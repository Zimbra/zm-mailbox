/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Server
 * Copyright (C) 2010, 2011, 2013, 2014, 2016 Synacor, Inc.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software Foundation,
 * version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 * ***** END LICENSE BLOCK *****
 */
options {    JDK_VERSION = "1.6";    STATIC = false;
    UNICODE_INPUT = true;
    IGNORE_CASE = true;
    ERROR_REPORTING = true;
                        
    SUPPORT_CLASS_VISIBILITY_PUBLIC = false;
}PARSER_BEGIN(Parser)package com.zimbra.cs.index.query.parser;

final class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
}PARSER_END(Parser)
<*> SKIP : {
    " " | "\t"
}

<*> TOKEN : {
    <LPAREN: "("> : DEFAULT
|   <RPAREN: ")"> : DEFAULT
}

<DEFAULT> TOKEN : {
    <AND: ("and" | "&&")>
|   <OR: ("or" | "||")>
|   <NOT: ("not" | "!")>
|   <PLUS: "+">
|   <MINUS: "-">
}

<DEFAULT, TEXT> TOKEN : {
    <TERM: <_TERM_START_CHAR> (<_TERM_CHAR>)*> : DEFAULT
|   <#_TERM_START_CHAR: (~["{", "}", " ", "\t", "\n", "\r", ":", "+", "-", "\"", "(", ")"] | <_ESCAPED_QUOTE>)>
|   <#_TERM_CHAR: (<_TERM_START_CHAR> | "-" | "+" | "@")>
|   <QUOTED_TERM: "\"" (<_ESCAPED_QUOTE> | ~["\n", "\""])* "\""> : DEFAULT
|   <#_ESCAPED_QUOTE: "\\\"">
|   <BRACED_TERM: "{" (~["}"])+ "}"> : DEFAULT
}

// Don't match operators after these tokens
<DEFAULT> TOKEN : {
    <CONTENT: "content:"> : TEXT
|   <SUBJECT: "subject:"> : TEXT
|   <MSGID: "msgid:"> : TEXT
|   <ENVTO: "envto:"> : TEXT
|   <ENVFROM: "envfrom:"> : TEXT
|   <CONTACT: "contact:"> : TEXT
|   <TO: "to:"> : TEXT
|   <FROM: "from:"> : TEXT
|   <CC: "cc:"> : TEXT
|   <TOFROM: "tofrom:"> : TEXT
|   <TOCC: "tocc:"> : TEXT
|   <FROMCC: "fromcc:"> : TEXT
|   <TOFROMCC: "tofromcc:"> : TEXT
|   <IN: "in:"> : TEXT
|   <UNDER: "under:"> : TEXT
|   <FILENAME: "filename:"> : TEXT
|   <TAG: "tag:"> : TEXT
|   <MESSAGE: "message:"> : TEXT
|   <MY: "my:"> : TEXT
|   <AUTHOR: "author:"> : TEXT
|   <TITLE: "title:"> : TEXT
|   <KEYWORDS: "keywords:"> : TEXT
|   <COMPANY: "company:"> : TEXT
|   <METADATA: "metadata:"> : TEXT
|   <FIELD: <_FIELD1> | <_FIELD2>> : TEXT
|   <#_FIELD1: "field" ("[" <TERM> "]")? ":">
|   <#_FIELD2: "#" <TERM> ":">
}

<DEFAULT> TOKEN : {    <DATE: "date:">
|   <MDATE: "mdate:">
|   <DAY: "day:">
|   <WEEK: "week:">
|   <MONTH: "month:">
|   <YEAR: "year:">
|   <AFTER: "after:">
|   <BEFORE: "before:">
|   <APPT_START: "appt-start:">
|   <APPT_END: "appt-end:">
|   <CONV_START: "conv-start:">
|   <CONV_END: "conv-end:">
|   <SIZE: "size:">
|   <BIGGER: "bigger:" | "larger:">
|   <SMALLER: "smaller:">
|   <CONV: "conv:"> : TEXT
|   <CONV_COUNT: "conv-count:">
|   <CONV_MINM: "conv-minm:">
|   <CONV_MAXM: "conv-maxm:">
|   <MODSEQ: "modseq:">
|   <PRIORITY: "priority:">
|   <IS: "is:">
|   <INID: "inid:">
|   <UNDERID: "underid:">
|   <HAS: "has:">
|   <TYPE: "type:">
|   <ATTACHMENT: "attachment:">
|   <ITEM: "item:">
|   <SORTBY: "sortby:">
|   <SORT: "sort:">
}
SimpleNode parse()       : {/*@bgen(jjtree) Root */
  SimpleNode jjtn000 = new SimpleNode(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}{/*@bgen(jjtree) Root */
    try {
/*@egen*/    Query() ["\r" | <EOF>]/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                             jjtn000.jjtSetLastToken(getToken(0));
                           }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}
private void Query() : {/*@bgen(jjtree) Query */
  SimpleNode jjtn000 = new SimpleNode(JJTQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) Query */
    try {
/*@egen*/
    [SortBy()] Clause() [SortBy()] ([Conjunction()] Clause() [SortBy()])*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

private void Clause() : {/*@bgen(jjtree) Clause */
  SimpleNode jjtn000 = new SimpleNode(JJTCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) Clause */
    try {
/*@egen*/
    [Modifier()]
    (        <LPAREN> Query() <RPAREN>
    |   TextClause()
    |   ItemClause()
    |   DateClause()
    |   DefaultClause()
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

private void DefaultClause() : {/*@bgen(jjtree) DefaultClause */
  SimpleNode jjtn000 = new SimpleNode(JJTDEFAULTCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) DefaultClause */
    try {
/*@egen*/
    <TERM> | <QUOTED_TERM>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/}

private void TextClause() : {/*@bgen(jjtree) TextClause */
  SimpleNode jjtn000 = new SimpleNode(JJTTEXTCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) TextClause */
    try {
/*@egen*/    TextField() TextTerm()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

private void ItemClause() : {/*@bgen(jjtree) ItemClause */
  SimpleNode jjtn000 = new SimpleNode(JJTITEMCLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) ItemClause */
    try {
/*@egen*/
    <ITEM> ItemTerm()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/}

private void DateClause() : {/*@bgen(jjtree) DateClause */
  SimpleNode jjtn000 = new SimpleNode(JJTDATECLAUSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) DateClause */
    try {
/*@egen*/    DateField() DateTerm()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

private void TextField()       : {
}
{
    <FIELD> | <MSGID> | <MODSEQ> | <TYPE> | <MY> | <IS> | <TAG> | <PRIORITY>
|   <FROM> | <TO> | <CC> | <ENVFROM> | <ENVTO>
|   <TOFROM> | <TOCC> | <FROMCC> | <TOFROMCC>
|   <SUBJECT> | <MESSAGE> | <CONTENT>
|   <IN> | <INID> | <UNDER> | <UNDERID>
|   <ATTACHMENT> | <HAS> | <FILENAME>
|   <CONTACT> | <AUTHOR> | <TITLE> | <KEYWORDS> | <COMPANY> | <METADATA>
|   <CONV> | <CONV_COUNT> | <CONV_MINM> | <CONV_MAXM>
|   <SIZE> | <BIGGER> | <SMALLER>
}

private void DateField()       : {
}
{    <DATE> | <MDATE> | <DAY> | <MONTH> | <WEEK> | <YEAR>
|   <AFTER> | <BEFORE> | <CONV_START> | <CONV_END> | <APPT_START> | <APPT_END>
}

private void Conjunction() : {/*@bgen(jjtree) Conjunction */
  SimpleNode jjtn000 = new SimpleNode(JJTCONJUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) Conjunction */
    try {
/*@egen*/
    <AND> | <OR>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

private void Modifier() : {/*@bgen(jjtree) Modifier */
  SimpleNode jjtn000 = new SimpleNode(JJTMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) Modifier */
    try {
/*@egen*/
    <PLUS> | <MINUS> | <NOT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

private void DateModifier() : {/*@bgen(jjtree) DateModifier */
  SimpleNode jjtn000 = new SimpleNode(JJTDATEMODIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) DateModifier */
    try {
/*@egen*/
    <NOT>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

private void SortBy() : {/*@bgen(jjtree) SortBy */
  SimpleNode jjtn000 = new SimpleNode(JJTSORTBY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) SortBy */
    try {
/*@egen*/
    (<SORTBY> | <SORT>) <TERM>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

private void TextTerm() : {/*@bgen(jjtree) TextTerm */
  SimpleNode jjtn000 = new SimpleNode(JJTTEXTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) TextTerm */
    try {
/*@egen*/
    (<LPAREN> [Modifier()] TextTerm() ([Conjunction()] [Modifier()] TextTerm())* <RPAREN>)
|   <TERM> | <QUOTED_TERM>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

/**
 * Allows {}'s, so these are legal: 'item:{1,2,3}', 'item:({1,2,3} or {4,5,6})'.
 */
private void ItemTerm() : {/*@bgen(jjtree) ItemTerm */
  SimpleNode jjtn000 = new SimpleNode(JJTITEMTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) ItemTerm */
    try {
/*@egen*/
    (<LPAREN> [Modifier()] ItemTerm() ([Conjunction()] [Modifier()] ItemTerm())* <RPAREN>)
|   <TERM> | <QUOTED_TERM>
|   <BRACED_TERM>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

/**
 * Allows starting - (minus) signs, and we don't want to interpret those as
 * a NOT, like we do in other cases.
 */
private void DateTerm() : {/*@bgen(jjtree) DateTerm */
  SimpleNode jjtn000 = new SimpleNode(JJTDATETERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/
}
{/*@bgen(jjtree) DateTerm */
    try {
/*@egen*/
    (<LPAREN> [DateModifier()] DateTerm() ([Conjunction()] [DateModifier()] DateTerm())* <RPAREN>)
|   [<MINUS> | <PLUS>] (<TERM> | <QUOTED_TERM>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}
