/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Server
 * Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software Foundation,
 * version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 * ***** END LICENSE BLOCK *****
 */
package com.zimbra.cs.account;

import static com.zimbra.common.account.ProvisioningConstants.FALSE;
import static com.zimbra.common.account.ProvisioningConstants.TRUE;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.zimbra.common.account.ZAttr;
import com.zimbra.common.account.ZAttrProvisioning;
import com.zimbra.common.util.ByteUtil;
import com.zimbra.common.util.StringUtil;
import com.zimbra.cs.ldap.LdapDateUtil;

/**
 * AUTO-GENERATED. DO NOT EDIT.
 *
 */

public abstract class ZAttrAccount  extends MailTarget {

    public ZAttrAccount(String name, String id, Map<String,Object> attrs, Map<String, Object> defaults, Provisioning prov) {
        super(name, id, attrs, defaults, prov);
    }

    ///// BEGIN-AUTO-GEN-REPLACE

    /**
     * RFC2256: ISO-3166 country 2-letter code
     *
     * @return c, or null if unset
     */
    @ZAttr(id=-1)
    public String getC() {
        return getAttr(Provisioning.A_c, null, true);
    }

    /**
     * RFC2256: ISO-3166 country 2-letter code
     *
     * @param c new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setC(String c) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_c, c);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: ISO-3166 country 2-letter code
     *
     * @param c new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setC(String c, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_c, c);
        return attrs;
    }

    /**
     * RFC2256: ISO-3166 country 2-letter code
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetC() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_c, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: ISO-3166 country 2-letter code
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetC(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_c, "");
        return attrs;
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @return cn, or null if unset
     */
    @ZAttr(id=-1)
    public String getCn() {
        return getAttr(Provisioning.A_cn, null, true);
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @param cn new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setCn(String cn) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_cn, cn);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @param cn new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setCn(String cn, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_cn, cn);
        return attrs;
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetCn() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_cn, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: common name(s) for which the entity is known by
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetCn(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_cn, "");
        return attrs;
    }

    /**
     * RFC1274: friendly country name
     *
     * @return co, or null if unset
     */
    @ZAttr(id=-1)
    public String getCo() {
        return getAttr(Provisioning.A_co, null, true);
    }

    /**
     * RFC1274: friendly country name
     *
     * @param co new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setCo(String co) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_co, co);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: friendly country name
     *
     * @param co new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setCo(String co, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_co, co);
        return attrs;
    }

    /**
     * RFC1274: friendly country name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetCo() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_co, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: friendly country name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetCo(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_co, "");
        return attrs;
    }

    /**
     * From Microsoft Schema
     *
     * @return company, or null if unset
     */
    @ZAttr(id=-1)
    public String getCompany() {
        return getAttr(Provisioning.A_company, null, true);
    }

    /**
     * From Microsoft Schema
     *
     * @param company new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setCompany(String company) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_company, company);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * From Microsoft Schema
     *
     * @param company new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setCompany(String company, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_company, company);
        return attrs;
    }

    /**
     * From Microsoft Schema
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetCompany() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_company, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * From Microsoft Schema
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetCompany(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_company, "");
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @return description, or empty array if unset
     */
    @ZAttr(id=-1)
    public String[] getDescription() {
        return getMultiAttr(Provisioning.A_description, true, true);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setDescription(String[] description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setDescription(String[] description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void addDescription(String description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> addDescription(String description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void removeDescription(String description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> removeDescription(String description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetDescription() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetDescription(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, "");
        return attrs;
    }

    /**
     * RFC2256: destination indicator
     *
     * @return destinationIndicator, or null if unset
     */
    @ZAttr(id=-1)
    public String getDestinationIndicator() {
        return getAttr(Provisioning.A_destinationIndicator, null, true);
    }

    /**
     * RFC2256: destination indicator
     *
     * @param destinationIndicator new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setDestinationIndicator(String destinationIndicator) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_destinationIndicator, destinationIndicator);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: destination indicator
     *
     * @param destinationIndicator new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setDestinationIndicator(String destinationIndicator, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_destinationIndicator, destinationIndicator);
        return attrs;
    }

    /**
     * RFC2256: destination indicator
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetDestinationIndicator() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_destinationIndicator, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: destination indicator
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetDestinationIndicator(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_destinationIndicator, "");
        return attrs;
    }

    /**
     * RFC2798: preferred name to be used when displaying entries
     *
     * @return displayName, or null if unset
     */
    @ZAttr(id=-1)
    public String getDisplayName() {
        return getAttr(Provisioning.A_displayName, null, true);
    }

    /**
     * RFC2798: preferred name to be used when displaying entries
     *
     * @param displayName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setDisplayName(String displayName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_displayName, displayName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2798: preferred name to be used when displaying entries
     *
     * @param displayName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setDisplayName(String displayName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_displayName, displayName);
        return attrs;
    }

    /**
     * RFC2798: preferred name to be used when displaying entries
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetDisplayName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_displayName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2798: preferred name to be used when displaying entries
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetDisplayName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_displayName, "");
        return attrs;
    }

    /**
     * RFC2256: Facsimile (Fax) Telephone Number
     *
     * @return facsimileTelephoneNumber, or null if unset
     */
    @ZAttr(id=-1)
    public String getFacsimileTelephoneNumber() {
        return getAttr(Provisioning.A_facsimileTelephoneNumber, null, true);
    }

    /**
     * RFC2256: Facsimile (Fax) Telephone Number
     *
     * @param facsimileTelephoneNumber new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setFacsimileTelephoneNumber(String facsimileTelephoneNumber) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_facsimileTelephoneNumber, facsimileTelephoneNumber);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Facsimile (Fax) Telephone Number
     *
     * @param facsimileTelephoneNumber new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setFacsimileTelephoneNumber(String facsimileTelephoneNumber, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_facsimileTelephoneNumber, facsimileTelephoneNumber);
        return attrs;
    }

    /**
     * RFC2256: Facsimile (Fax) Telephone Number
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetFacsimileTelephoneNumber() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_facsimileTelephoneNumber, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Facsimile (Fax) Telephone Number
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetFacsimileTelephoneNumber(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_facsimileTelephoneNumber, "");
        return attrs;
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @return givenName, or null if unset
     */
    @ZAttr(id=-1)
    public String getGivenName() {
        return getAttr(Provisioning.A_givenName, null, true);
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @param givenName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setGivenName(String givenName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_givenName, givenName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @param givenName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setGivenName(String givenName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_givenName, givenName);
        return attrs;
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetGivenName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_givenName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetGivenName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_givenName, "");
        return attrs;
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @return gn, or null if unset
     */
    @ZAttr(id=-1)
    public String getGn() {
        return getAttr(Provisioning.A_gn, null, true);
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @param gn new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setGn(String gn) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_gn, gn);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @param gn new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setGn(String gn, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_gn, gn);
        return attrs;
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetGn() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_gn, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: first name(s) for which the entity is known by
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetGn(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_gn, "");
        return attrs;
    }

    /**
     * RFC1274: home telephone number
     *
     * @return homePhone, or null if unset
     */
    @ZAttr(id=-1)
    public String getHomePhone() {
        return getAttr(Provisioning.A_homePhone, null, true);
    }

    /**
     * RFC1274: home telephone number
     *
     * @param homePhone new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setHomePhone(String homePhone) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_homePhone, homePhone);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: home telephone number
     *
     * @param homePhone new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setHomePhone(String homePhone, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_homePhone, homePhone);
        return attrs;
    }

    /**
     * RFC1274: home telephone number
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetHomePhone() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_homePhone, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: home telephone number
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetHomePhone(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_homePhone, "");
        return attrs;
    }

    /**
     * RFC2256: initials of some or all of names, but not the surname(s).
     *
     * @return initials, or null if unset
     */
    @ZAttr(id=-1)
    public String getInitials() {
        return getAttr(Provisioning.A_initials, null, true);
    }

    /**
     * RFC2256: initials of some or all of names, but not the surname(s).
     *
     * @param initials new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setInitials(String initials) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_initials, initials);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: initials of some or all of names, but not the surname(s).
     *
     * @param initials new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setInitials(String initials, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_initials, initials);
        return attrs;
    }

    /**
     * RFC2256: initials of some or all of names, but not the surname(s).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetInitials() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_initials, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: initials of some or all of names, but not the surname(s).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetInitials(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_initials, "");
        return attrs;
    }

    /**
     * RFC2256: international ISDN number
     *
     * @return internationaliSDNNumber, or null if unset
     */
    @ZAttr(id=-1)
    public String getInternationaliSDNNumber() {
        return getAttr(Provisioning.A_internationaliSDNNumber, null, true);
    }

    /**
     * RFC2256: international ISDN number
     *
     * @param internationaliSDNNumber new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setInternationaliSDNNumber(String internationaliSDNNumber) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_internationaliSDNNumber, internationaliSDNNumber);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: international ISDN number
     *
     * @param internationaliSDNNumber new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setInternationaliSDNNumber(String internationaliSDNNumber, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_internationaliSDNNumber, internationaliSDNNumber);
        return attrs;
    }

    /**
     * RFC2256: international ISDN number
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetInternationaliSDNNumber() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_internationaliSDNNumber, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: international ISDN number
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetInternationaliSDNNumber(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_internationaliSDNNumber, "");
        return attrs;
    }

    /**
     * RFC2256: locality which this object resides in
     *
     * @return l, or null if unset
     */
    @ZAttr(id=-1)
    public String getL() {
        return getAttr(Provisioning.A_l, null, true);
    }

    /**
     * RFC2256: locality which this object resides in
     *
     * @param l new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setL(String l) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_l, l);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: locality which this object resides in
     *
     * @param l new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setL(String l, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_l, l);
        return attrs;
    }

    /**
     * RFC2256: locality which this object resides in
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_l, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: locality which this object resides in
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_l, "");
        return attrs;
    }

    /**
     * RFC1274: RFC822 Mailbox
     *
     * @return mail, or null if unset
     */
    @ZAttr(id=-1)
    public String getMail() {
        return getAttr(Provisioning.A_mail, null, true);
    }

    /**
     * RFC1274: RFC822 Mailbox
     *
     * @param mail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setMail(String mail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_mail, mail);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: RFC822 Mailbox
     *
     * @param mail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setMail(String mail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_mail, mail);
        return attrs;
    }

    /**
     * RFC1274: RFC822 Mailbox
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetMail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_mail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: RFC822 Mailbox
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetMail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_mail, "");
        return attrs;
    }

    /**
     * RFC1274: mobile telephone number
     *
     * @return mobile, or null if unset
     */
    @ZAttr(id=-1)
    public String getMobile() {
        return getAttr(Provisioning.A_mobile, null, true);
    }

    /**
     * RFC1274: mobile telephone number
     *
     * @param mobile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setMobile(String mobile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_mobile, mobile);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: mobile telephone number
     *
     * @param mobile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setMobile(String mobile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_mobile, mobile);
        return attrs;
    }

    /**
     * RFC1274: mobile telephone number
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetMobile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_mobile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: mobile telephone number
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetMobile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_mobile, "");
        return attrs;
    }

    /**
     * RFC2256: organization this object belongs to
     *
     * @return o, or null if unset
     */
    @ZAttr(id=-1)
    public String getO() {
        return getAttr(Provisioning.A_o, null, true);
    }

    /**
     * RFC2256: organization this object belongs to
     *
     * @param o new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setO(String o) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_o, o);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: organization this object belongs to
     *
     * @param o new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setO(String o, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_o, o);
        return attrs;
    }

    /**
     * RFC2256: organization this object belongs to
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetO() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_o, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: organization this object belongs to
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetO(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_o, "");
        return attrs;
    }

    /**
     * RFC2256: organizational unit this object belongs to
     *
     * @return ou, or null if unset
     */
    @ZAttr(id=-1)
    public String getOu() {
        return getAttr(Provisioning.A_ou, null, true);
    }

    /**
     * RFC2256: organizational unit this object belongs to
     *
     * @param ou new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setOu(String ou) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_ou, ou);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: organizational unit this object belongs to
     *
     * @param ou new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setOu(String ou, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_ou, ou);
        return attrs;
    }

    /**
     * RFC2256: organizational unit this object belongs to
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetOu() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_ou, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: organizational unit this object belongs to
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetOu(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_ou, "");
        return attrs;
    }

    /**
     * RFC1274: pager telephone number
     *
     * @return pager, or null if unset
     */
    @ZAttr(id=-1)
    public String getPager() {
        return getAttr(Provisioning.A_pager, null, true);
    }

    /**
     * RFC1274: pager telephone number
     *
     * @param pager new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setPager(String pager) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_pager, pager);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: pager telephone number
     *
     * @param pager new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setPager(String pager, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_pager, pager);
        return attrs;
    }

    /**
     * RFC1274: pager telephone number
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetPager() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_pager, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: pager telephone number
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetPager(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_pager, "");
        return attrs;
    }

    /**
     * &#039;RFC2256: Physical Delivery Office Name
     *
     * @return physicalDeliveryOfficeName, or null if unset
     */
    @ZAttr(id=-1)
    public String getPhysicalDeliveryOfficeName() {
        return getAttr(Provisioning.A_physicalDeliveryOfficeName, null, true);
    }

    /**
     * &#039;RFC2256: Physical Delivery Office Name
     *
     * @param physicalDeliveryOfficeName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setPhysicalDeliveryOfficeName(String physicalDeliveryOfficeName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_physicalDeliveryOfficeName, physicalDeliveryOfficeName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * &#039;RFC2256: Physical Delivery Office Name
     *
     * @param physicalDeliveryOfficeName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setPhysicalDeliveryOfficeName(String physicalDeliveryOfficeName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_physicalDeliveryOfficeName, physicalDeliveryOfficeName);
        return attrs;
    }

    /**
     * &#039;RFC2256: Physical Delivery Office Name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetPhysicalDeliveryOfficeName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_physicalDeliveryOfficeName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * &#039;RFC2256: Physical Delivery Office Name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetPhysicalDeliveryOfficeName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_physicalDeliveryOfficeName, "");
        return attrs;
    }

    /**
     * RFC2256: Post Office Box
     *
     * @return postOfficeBox, or null if unset
     */
    @ZAttr(id=-1)
    public String getPostOfficeBox() {
        return getAttr(Provisioning.A_postOfficeBox, null, true);
    }

    /**
     * RFC2256: Post Office Box
     *
     * @param postOfficeBox new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setPostOfficeBox(String postOfficeBox) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postOfficeBox, postOfficeBox);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Post Office Box
     *
     * @param postOfficeBox new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setPostOfficeBox(String postOfficeBox, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postOfficeBox, postOfficeBox);
        return attrs;
    }

    /**
     * RFC2256: Post Office Box
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetPostOfficeBox() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postOfficeBox, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Post Office Box
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetPostOfficeBox(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postOfficeBox, "");
        return attrs;
    }

    /**
     * RFC2256: postal address
     *
     * @return postalAddress, or null if unset
     */
    @ZAttr(id=-1)
    public String getPostalAddress() {
        return getAttr(Provisioning.A_postalAddress, null, true);
    }

    /**
     * RFC2256: postal address
     *
     * @param postalAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setPostalAddress(String postalAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postalAddress, postalAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: postal address
     *
     * @param postalAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setPostalAddress(String postalAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postalAddress, postalAddress);
        return attrs;
    }

    /**
     * RFC2256: postal address
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetPostalAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postalAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: postal address
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetPostalAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postalAddress, "");
        return attrs;
    }

    /**
     * RFC2256: postal code
     *
     * @return postalCode, or null if unset
     */
    @ZAttr(id=-1)
    public String getPostalCode() {
        return getAttr(Provisioning.A_postalCode, null, true);
    }

    /**
     * RFC2256: postal code
     *
     * @param postalCode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setPostalCode(String postalCode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postalCode, postalCode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: postal code
     *
     * @param postalCode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setPostalCode(String postalCode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postalCode, postalCode);
        return attrs;
    }

    /**
     * RFC2256: postal code
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetPostalCode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postalCode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: postal code
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetPostalCode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_postalCode, "");
        return attrs;
    }

    /**
     * RFC2256: preferred delivery method
     *
     * @return preferredDeliveryMethod, or null if unset
     */
    @ZAttr(id=-1)
    public String getPreferredDeliveryMethod() {
        return getAttr(Provisioning.A_preferredDeliveryMethod, null, true);
    }

    /**
     * RFC2256: preferred delivery method
     *
     * @param preferredDeliveryMethod new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setPreferredDeliveryMethod(String preferredDeliveryMethod) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_preferredDeliveryMethod, preferredDeliveryMethod);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: preferred delivery method
     *
     * @param preferredDeliveryMethod new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setPreferredDeliveryMethod(String preferredDeliveryMethod, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_preferredDeliveryMethod, preferredDeliveryMethod);
        return attrs;
    }

    /**
     * RFC2256: preferred delivery method
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetPreferredDeliveryMethod() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_preferredDeliveryMethod, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: preferred delivery method
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetPreferredDeliveryMethod(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_preferredDeliveryMethod, "");
        return attrs;
    }

    /**
     * RFC2256: registered postal address
     *
     * @return registeredAddress, or null if unset
     */
    @ZAttr(id=-1)
    public String getRegisteredAddress() {
        return getAttr(Provisioning.A_registeredAddress, null, true);
    }

    /**
     * RFC2256: registered postal address
     *
     * @param registeredAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setRegisteredAddress(String registeredAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_registeredAddress, registeredAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: registered postal address
     *
     * @param registeredAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setRegisteredAddress(String registeredAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_registeredAddress, registeredAddress);
        return attrs;
    }

    /**
     * RFC2256: registered postal address
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetRegisteredAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_registeredAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: registered postal address
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetRegisteredAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_registeredAddress, "");
        return attrs;
    }

    /**
     * RFC2256: last (family) name(s) for which the entity is known by
     *
     * @return sn, or null if unset
     */
    @ZAttr(id=-1)
    public String getSn() {
        return getAttr(Provisioning.A_sn, null, true);
    }

    /**
     * RFC2256: last (family) name(s) for which the entity is known by
     *
     * @param sn new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setSn(String sn) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_sn, sn);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: last (family) name(s) for which the entity is known by
     *
     * @param sn new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setSn(String sn, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_sn, sn);
        return attrs;
    }

    /**
     * RFC2256: last (family) name(s) for which the entity is known by
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetSn() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_sn, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: last (family) name(s) for which the entity is known by
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetSn(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_sn, "");
        return attrs;
    }

    /**
     * RFC2256: state or province which this object resides in
     *
     * @return st, or null if unset
     */
    @ZAttr(id=-1)
    public String getSt() {
        return getAttr(Provisioning.A_st, null, true);
    }

    /**
     * RFC2256: state or province which this object resides in
     *
     * @param st new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setSt(String st) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_st, st);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: state or province which this object resides in
     *
     * @param st new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setSt(String st, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_st, st);
        return attrs;
    }

    /**
     * RFC2256: state or province which this object resides in
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetSt() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_st, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: state or province which this object resides in
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetSt(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_st, "");
        return attrs;
    }

    /**
     * RFC2256: street address of this object
     *
     * @return street, or null if unset
     */
    @ZAttr(id=-1)
    public String getStreet() {
        return getAttr(Provisioning.A_street, null, true);
    }

    /**
     * RFC2256: street address of this object
     *
     * @param street new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setStreet(String street) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_street, street);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: street address of this object
     *
     * @param street new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setStreet(String street, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_street, street);
        return attrs;
    }

    /**
     * RFC2256: street address of this object
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetStreet() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_street, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: street address of this object
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetStreet(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_street, "");
        return attrs;
    }

    /**
     * RFC2256: street address of this object
     *
     * @return streetAddress, or null if unset
     */
    @ZAttr(id=-1)
    public String getStreetAddress() {
        return getAttr(Provisioning.A_streetAddress, null, true);
    }

    /**
     * RFC2256: street address of this object
     *
     * @param streetAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setStreetAddress(String streetAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_streetAddress, streetAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: street address of this object
     *
     * @param streetAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setStreetAddress(String streetAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_streetAddress, streetAddress);
        return attrs;
    }

    /**
     * RFC2256: street address of this object
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetStreetAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_streetAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: street address of this object
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetStreetAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_streetAddress, "");
        return attrs;
    }

    /**
     * RFC2256: Telephone Number
     *
     * @return telephoneNumber, or null if unset
     */
    @ZAttr(id=-1)
    public String getTelephoneNumber() {
        return getAttr(Provisioning.A_telephoneNumber, null, true);
    }

    /**
     * RFC2256: Telephone Number
     *
     * @param telephoneNumber new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setTelephoneNumber(String telephoneNumber) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_telephoneNumber, telephoneNumber);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Telephone Number
     *
     * @param telephoneNumber new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setTelephoneNumber(String telephoneNumber, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_telephoneNumber, telephoneNumber);
        return attrs;
    }

    /**
     * RFC2256: Telephone Number
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetTelephoneNumber() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_telephoneNumber, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Telephone Number
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetTelephoneNumber(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_telephoneNumber, "");
        return attrs;
    }

    /**
     * RFC2256: Teletex Terminal Identifier
     *
     * @return teletexTerminalIdentifier, or null if unset
     */
    @ZAttr(id=-1)
    public String getTeletexTerminalIdentifier() {
        return getAttr(Provisioning.A_teletexTerminalIdentifier, null, true);
    }

    /**
     * RFC2256: Teletex Terminal Identifier
     *
     * @param teletexTerminalIdentifier new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setTeletexTerminalIdentifier(String teletexTerminalIdentifier) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_teletexTerminalIdentifier, teletexTerminalIdentifier);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Teletex Terminal Identifier
     *
     * @param teletexTerminalIdentifier new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setTeletexTerminalIdentifier(String teletexTerminalIdentifier, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_teletexTerminalIdentifier, teletexTerminalIdentifier);
        return attrs;
    }

    /**
     * RFC2256: Teletex Terminal Identifier
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetTeletexTerminalIdentifier() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_teletexTerminalIdentifier, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Teletex Terminal Identifier
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetTeletexTerminalIdentifier(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_teletexTerminalIdentifier, "");
        return attrs;
    }

    /**
     * RFC2256: Telex Number
     *
     * @return telexNumber, or null if unset
     */
    @ZAttr(id=-1)
    public String getTelexNumber() {
        return getAttr(Provisioning.A_telexNumber, null, true);
    }

    /**
     * RFC2256: Telex Number
     *
     * @param telexNumber new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setTelexNumber(String telexNumber) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_telexNumber, telexNumber);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Telex Number
     *
     * @param telexNumber new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setTelexNumber(String telexNumber, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_telexNumber, telexNumber);
        return attrs;
    }

    /**
     * RFC2256: Telex Number
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetTelexNumber() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_telexNumber, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: Telex Number
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetTelexNumber(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_telexNumber, "");
        return attrs;
    }

    /**
     * Account thumbnail photo
     *
     * @return thumbnailPhoto, or null if unset
     *
     * @since ZCS 8.8.7
     */
    @ZAttr(id=3021)
    public byte[] getThumbnailPhoto() {
        return getBinaryAttr(Provisioning.A_thumbnailPhoto, true);
    }

    /**
     * Account thumbnail photo
     *
     * @return thumbnailPhoto, or null if unset
     *
     * @since ZCS 8.8.7
     */
    @ZAttr(id=3021)
    public String getThumbnailPhotoAsString() {
        return getAttr(Provisioning.A_thumbnailPhoto, null, true);
    }

    /**
     * Account thumbnail photo
     *
     * @param thumbnailPhoto new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.7
     */
    @ZAttr(id=3021)
    public void setThumbnailPhoto(byte[] thumbnailPhoto) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_thumbnailPhoto, thumbnailPhoto==null ? "" : ByteUtil.encodeLDAPBase64(thumbnailPhoto));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account thumbnail photo
     *
     * @param thumbnailPhoto new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.7
     */
    @ZAttr(id=3021)
    public Map<String,Object> setThumbnailPhoto(byte[] thumbnailPhoto, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_thumbnailPhoto, thumbnailPhoto==null ? "" : ByteUtil.encodeLDAPBase64(thumbnailPhoto));
        return attrs;
    }

    /**
     * Account thumbnail photo
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.7
     */
    @ZAttr(id=3021)
    public void unsetThumbnailPhoto() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_thumbnailPhoto, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account thumbnail photo
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.7
     */
    @ZAttr(id=3021)
    public Map<String,Object> unsetThumbnailPhoto(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_thumbnailPhoto, "");
        return attrs;
    }

    /**
     * RFC2256: title associated with the entity
     *
     * @return title, or null if unset
     */
    @ZAttr(id=-1)
    public String getTitle() {
        return getAttr(Provisioning.A_title, null, true);
    }

    /**
     * RFC2256: title associated with the entity
     *
     * @param title new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setTitle(String title) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_title, title);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: title associated with the entity
     *
     * @param title new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setTitle(String title, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_title, title);
        return attrs;
    }

    /**
     * RFC2256: title associated with the entity
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetTitle() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_title, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: title associated with the entity
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetTitle(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_title, "");
        return attrs;
    }

    /**
     * RFC1274: user identifier
     *
     * @return uid, or null if unset
     */
    @ZAttr(id=-1)
    public String getUid() {
        return getAttr(Provisioning.A_uid, null, true);
    }

    /**
     * RFC1274: user identifier
     *
     * @param uid new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setUid(String uid) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_uid, uid);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: user identifier
     *
     * @param uid new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setUid(String uid, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_uid, uid);
        return attrs;
    }

    /**
     * RFC1274: user identifier
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetUid() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_uid, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC1274: user identifier
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetUid(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_uid, "");
        return attrs;
    }

    /**
     * RFC2256: X.509 user certificate
     *
     * @return userCertificate, or empty array if unset
     */
    @ZAttr(id=-1)
    public String[] getUserCertificateAsString() {
        return getMultiAttr(Provisioning.A_userCertificate, true, true);
    }

    /**
     * RFC2256: X.509 user certificate
     *
     * @param userCertificate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setUserCertificate(byte[] userCertificate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userCertificate, userCertificate==null ? "" : ByteUtil.encodeLDAPBase64(userCertificate));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: X.509 user certificate
     *
     * @param userCertificate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setUserCertificate(byte[] userCertificate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userCertificate, userCertificate==null ? "" : ByteUtil.encodeLDAPBase64(userCertificate));
        return attrs;
    }

    /**
     * RFC2256: X.509 user certificate
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetUserCertificate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userCertificate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: X.509 user certificate
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetUserCertificate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userCertificate, "");
        return attrs;
    }

    /**
     * RFC2256/2307: password of user. Stored encoded as SSHA (salted-SHA1)
     *
     * @return userPassword, or null if unset
     */
    @ZAttr(id=-1)
    public String getUserPassword() {
        return getAttr(Provisioning.A_userPassword, null, true);
    }

    /**
     * RFC2256/2307: password of user. Stored encoded as SSHA (salted-SHA1)
     *
     * @param userPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setUserPassword(String userPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userPassword, userPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256/2307: password of user. Stored encoded as SSHA (salted-SHA1)
     *
     * @param userPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setUserPassword(String userPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userPassword, userPassword);
        return attrs;
    }

    /**
     * RFC2256/2307: password of user. Stored encoded as SSHA (salted-SHA1)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetUserPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256/2307: password of user. Stored encoded as SSHA (salted-SHA1)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetUserPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userPassword, "");
        return attrs;
    }

    /**
     * RFC2798: PKCS#7 SignedData used to support S/MIME
     *
     * @return userSMIMECertificate, or empty array if unset
     */
    @ZAttr(id=-1)
    public String[] getUserSMIMECertificateAsString() {
        return getMultiAttr(Provisioning.A_userSMIMECertificate, true, true);
    }

    /**
     * RFC2798: PKCS#7 SignedData used to support S/MIME
     *
     * @param userSMIMECertificate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setUserSMIMECertificate(byte[] userSMIMECertificate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userSMIMECertificate, userSMIMECertificate==null ? "" : ByteUtil.encodeLDAPBase64(userSMIMECertificate));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2798: PKCS#7 SignedData used to support S/MIME
     *
     * @param userSMIMECertificate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setUserSMIMECertificate(byte[] userSMIMECertificate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userSMIMECertificate, userSMIMECertificate==null ? "" : ByteUtil.encodeLDAPBase64(userSMIMECertificate));
        return attrs;
    }

    /**
     * RFC2798: PKCS#7 SignedData used to support S/MIME
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetUserSMIMECertificate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userSMIMECertificate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2798: PKCS#7 SignedData used to support S/MIME
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetUserSMIMECertificate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_userSMIMECertificate, "");
        return attrs;
    }

    /**
     * RFC2256: X.121 Address
     *
     * @return x121Address, or null if unset
     */
    @ZAttr(id=-1)
    public String getX121Address() {
        return getAttr(Provisioning.A_x121Address, null, true);
    }

    /**
     * RFC2256: X.121 Address
     *
     * @param x121Address new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setX121Address(String x121Address) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_x121Address, x121Address);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: X.121 Address
     *
     * @param x121Address new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setX121Address(String x121Address, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_x121Address, x121Address);
        return attrs;
    }

    /**
     * RFC2256: X.121 Address
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetX121Address() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_x121Address, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: X.121 Address
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetX121Address(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_x121Address, "");
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @return zimbraACE, or empty array if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public String[] getACE() {
        return getMultiAttr(Provisioning.A_zimbraACE, true, true);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void setACE(String[] zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> setACE(String[] zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void addACE(String zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> addACE(String zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void removeACE(String zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> removeACE(String zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void unsetACE() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> unsetACE(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, "");
        return attrs;
    }

    /**
     * calendar user type - USER (default) or RESOURCE
     *
     * <p>Valid values: [USER, RESOURCE]
     *
     * @return zimbraAccountCalendarUserType, or null if unset and/or has invalid value
     */
    @ZAttr(id=313)
    public ZAttrProvisioning.AccountCalendarUserType getAccountCalendarUserType() {
        try { String v = getAttr(Provisioning.A_zimbraAccountCalendarUserType, true, true); return v == null ? null : ZAttrProvisioning.AccountCalendarUserType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * calendar user type - USER (default) or RESOURCE
     *
     * <p>Valid values: [USER, RESOURCE]
     *
     * @return zimbraAccountCalendarUserType, or null if unset
     */
    @ZAttr(id=313)
    public String getAccountCalendarUserTypeAsString() {
        return getAttr(Provisioning.A_zimbraAccountCalendarUserType, null, true);
    }

    /**
     * calendar user type - USER (default) or RESOURCE
     *
     * <p>Valid values: [USER, RESOURCE]
     *
     * @param zimbraAccountCalendarUserType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=313)
    public void setAccountCalendarUserType(ZAttrProvisioning.AccountCalendarUserType zimbraAccountCalendarUserType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountCalendarUserType, zimbraAccountCalendarUserType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar user type - USER (default) or RESOURCE
     *
     * <p>Valid values: [USER, RESOURCE]
     *
     * @param zimbraAccountCalendarUserType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=313)
    public Map<String,Object> setAccountCalendarUserType(ZAttrProvisioning.AccountCalendarUserType zimbraAccountCalendarUserType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountCalendarUserType, zimbraAccountCalendarUserType.toString());
        return attrs;
    }

    /**
     * calendar user type - USER (default) or RESOURCE
     *
     * <p>Valid values: [USER, RESOURCE]
     *
     * @param zimbraAccountCalendarUserType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=313)
    public void setAccountCalendarUserTypeAsString(String zimbraAccountCalendarUserType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountCalendarUserType, zimbraAccountCalendarUserType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar user type - USER (default) or RESOURCE
     *
     * <p>Valid values: [USER, RESOURCE]
     *
     * @param zimbraAccountCalendarUserType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=313)
    public Map<String,Object> setAccountCalendarUserTypeAsString(String zimbraAccountCalendarUserType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountCalendarUserType, zimbraAccountCalendarUserType);
        return attrs;
    }

    /**
     * calendar user type - USER (default) or RESOURCE
     *
     * <p>Valid values: [USER, RESOURCE]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=313)
    public void unsetAccountCalendarUserType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountCalendarUserType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar user type - USER (default) or RESOURCE
     *
     * <p>Valid values: [USER, RESOURCE]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=313)
    public Map<String,Object> unsetAccountCalendarUserType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountCalendarUserType, "");
        return attrs;
    }

    /**
     * account status. active - active lockout - no login until lockout
     * duration is over, mail delivery OK. locked - no login, mail delivery
     * OK. maintenance - no login, no delivery(lmtp server returns 4.x.x
     * Persistent Transient Failure). pending - no login, no delivery(lmtp
     * server returns 5.x.x Permanent Failure), Account behavior is like
     * closed, except that when the status is being set to pending, account
     * addresses are not removed from distribution lists. The use case is for
     * hosted. New account creation based on invites that are not completed
     * until user accepts TOS on account creation confirmation page. closed -
     * no login, no delivery(lmtp server returns 5.x.x Permanent Failure),
     * all addresses (account main email and all aliases) of the account are
     * removed from all distribution lists.
     *
     * <p>Valid values: [active, maintenance, locked, closed, lockout, pending]
     *
     * @return zimbraAccountStatus, or null if unset and/or has invalid value
     */
    @ZAttr(id=2)
    public ZAttrProvisioning.AccountStatus getAccountStatus() {
        try { String v = getAttr(Provisioning.A_zimbraAccountStatus, true, true); return v == null ? null : ZAttrProvisioning.AccountStatus.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * account status. active - active lockout - no login until lockout
     * duration is over, mail delivery OK. locked - no login, mail delivery
     * OK. maintenance - no login, no delivery(lmtp server returns 4.x.x
     * Persistent Transient Failure). pending - no login, no delivery(lmtp
     * server returns 5.x.x Permanent Failure), Account behavior is like
     * closed, except that when the status is being set to pending, account
     * addresses are not removed from distribution lists. The use case is for
     * hosted. New account creation based on invites that are not completed
     * until user accepts TOS on account creation confirmation page. closed -
     * no login, no delivery(lmtp server returns 5.x.x Permanent Failure),
     * all addresses (account main email and all aliases) of the account are
     * removed from all distribution lists.
     *
     * <p>Valid values: [active, maintenance, locked, closed, lockout, pending]
     *
     * @return zimbraAccountStatus, or null if unset
     */
    @ZAttr(id=2)
    public String getAccountStatusAsString() {
        return getAttr(Provisioning.A_zimbraAccountStatus, null, true);
    }

    /**
     * account status. active - active lockout - no login until lockout
     * duration is over, mail delivery OK. locked - no login, mail delivery
     * OK. maintenance - no login, no delivery(lmtp server returns 4.x.x
     * Persistent Transient Failure). pending - no login, no delivery(lmtp
     * server returns 5.x.x Permanent Failure), Account behavior is like
     * closed, except that when the status is being set to pending, account
     * addresses are not removed from distribution lists. The use case is for
     * hosted. New account creation based on invites that are not completed
     * until user accepts TOS on account creation confirmation page. closed -
     * no login, no delivery(lmtp server returns 5.x.x Permanent Failure),
     * all addresses (account main email and all aliases) of the account are
     * removed from all distribution lists.
     *
     * <p>Valid values: [active, maintenance, locked, closed, lockout, pending]
     *
     * @param zimbraAccountStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=2)
    public void setAccountStatus(ZAttrProvisioning.AccountStatus zimbraAccountStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountStatus, zimbraAccountStatus.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * account status. active - active lockout - no login until lockout
     * duration is over, mail delivery OK. locked - no login, mail delivery
     * OK. maintenance - no login, no delivery(lmtp server returns 4.x.x
     * Persistent Transient Failure). pending - no login, no delivery(lmtp
     * server returns 5.x.x Permanent Failure), Account behavior is like
     * closed, except that when the status is being set to pending, account
     * addresses are not removed from distribution lists. The use case is for
     * hosted. New account creation based on invites that are not completed
     * until user accepts TOS on account creation confirmation page. closed -
     * no login, no delivery(lmtp server returns 5.x.x Permanent Failure),
     * all addresses (account main email and all aliases) of the account are
     * removed from all distribution lists.
     *
     * <p>Valid values: [active, maintenance, locked, closed, lockout, pending]
     *
     * @param zimbraAccountStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=2)
    public Map<String,Object> setAccountStatus(ZAttrProvisioning.AccountStatus zimbraAccountStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountStatus, zimbraAccountStatus.toString());
        return attrs;
    }

    /**
     * account status. active - active lockout - no login until lockout
     * duration is over, mail delivery OK. locked - no login, mail delivery
     * OK. maintenance - no login, no delivery(lmtp server returns 4.x.x
     * Persistent Transient Failure). pending - no login, no delivery(lmtp
     * server returns 5.x.x Permanent Failure), Account behavior is like
     * closed, except that when the status is being set to pending, account
     * addresses are not removed from distribution lists. The use case is for
     * hosted. New account creation based on invites that are not completed
     * until user accepts TOS on account creation confirmation page. closed -
     * no login, no delivery(lmtp server returns 5.x.x Permanent Failure),
     * all addresses (account main email and all aliases) of the account are
     * removed from all distribution lists.
     *
     * <p>Valid values: [active, maintenance, locked, closed, lockout, pending]
     *
     * @param zimbraAccountStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=2)
    public void setAccountStatusAsString(String zimbraAccountStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountStatus, zimbraAccountStatus);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * account status. active - active lockout - no login until lockout
     * duration is over, mail delivery OK. locked - no login, mail delivery
     * OK. maintenance - no login, no delivery(lmtp server returns 4.x.x
     * Persistent Transient Failure). pending - no login, no delivery(lmtp
     * server returns 5.x.x Permanent Failure), Account behavior is like
     * closed, except that when the status is being set to pending, account
     * addresses are not removed from distribution lists. The use case is for
     * hosted. New account creation based on invites that are not completed
     * until user accepts TOS on account creation confirmation page. closed -
     * no login, no delivery(lmtp server returns 5.x.x Permanent Failure),
     * all addresses (account main email and all aliases) of the account are
     * removed from all distribution lists.
     *
     * <p>Valid values: [active, maintenance, locked, closed, lockout, pending]
     *
     * @param zimbraAccountStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=2)
    public Map<String,Object> setAccountStatusAsString(String zimbraAccountStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountStatus, zimbraAccountStatus);
        return attrs;
    }

    /**
     * account status. active - active lockout - no login until lockout
     * duration is over, mail delivery OK. locked - no login, mail delivery
     * OK. maintenance - no login, no delivery(lmtp server returns 4.x.x
     * Persistent Transient Failure). pending - no login, no delivery(lmtp
     * server returns 5.x.x Permanent Failure), Account behavior is like
     * closed, except that when the status is being set to pending, account
     * addresses are not removed from distribution lists. The use case is for
     * hosted. New account creation based on invites that are not completed
     * until user accepts TOS on account creation confirmation page. closed -
     * no login, no delivery(lmtp server returns 5.x.x Permanent Failure),
     * all addresses (account main email and all aliases) of the account are
     * removed from all distribution lists.
     *
     * <p>Valid values: [active, maintenance, locked, closed, lockout, pending]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=2)
    public void unsetAccountStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * account status. active - active lockout - no login until lockout
     * duration is over, mail delivery OK. locked - no login, mail delivery
     * OK. maintenance - no login, no delivery(lmtp server returns 4.x.x
     * Persistent Transient Failure). pending - no login, no delivery(lmtp
     * server returns 5.x.x Permanent Failure), Account behavior is like
     * closed, except that when the status is being set to pending, account
     * addresses are not removed from distribution lists. The use case is for
     * hosted. New account creation based on invites that are not completed
     * until user accepts TOS on account creation confirmation page. closed -
     * no login, no delivery(lmtp server returns 5.x.x Permanent Failure),
     * all addresses (account main email and all aliases) of the account are
     * removed from all distribution lists.
     *
     * <p>Valid values: [active, maintenance, locked, closed, lockout, pending]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=2)
    public Map<String,Object> unsetAccountStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountStatus, "");
        return attrs;
    }

    /**
     * lifetime of newly created admin auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getAdminAuthTokenLifetimeAsString to access value as a string.
     *
     * @see #getAdminAuthTokenLifetimeAsString()
     *
     * @return zimbraAdminAuthTokenLifetime in millseconds, or 43200000 (12h)  if unset
     */
    @ZAttr(id=109)
    public long getAdminAuthTokenLifetime() {
        return getTimeInterval(Provisioning.A_zimbraAdminAuthTokenLifetime, 43200000L, true);
    }

    /**
     * lifetime of newly created admin auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraAdminAuthTokenLifetime, or "12h" if unset
     */
    @ZAttr(id=109)
    public String getAdminAuthTokenLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraAdminAuthTokenLifetime, "12h", true);
    }

    /**
     * lifetime of newly created admin auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraAdminAuthTokenLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=109)
    public void setAdminAuthTokenLifetime(String zimbraAdminAuthTokenLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAuthTokenLifetime, zimbraAdminAuthTokenLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of newly created admin auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraAdminAuthTokenLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=109)
    public Map<String,Object> setAdminAuthTokenLifetime(String zimbraAdminAuthTokenLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAuthTokenLifetime, zimbraAdminAuthTokenLifetime);
        return attrs;
    }

    /**
     * lifetime of newly created admin auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=109)
    public void unsetAdminAuthTokenLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAuthTokenLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of newly created admin auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=109)
    public Map<String,Object> unsetAdminAuthTokenLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAuthTokenLifetime, "");
        return attrs;
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @return zimbraAdminConsoleUIComponents, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public String[] getAdminConsoleUIComponents() {
        return getMultiAttr(Provisioning.A_zimbraAdminConsoleUIComponents, true, true);
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @param zimbraAdminConsoleUIComponents new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public void setAdminConsoleUIComponents(String[] zimbraAdminConsoleUIComponents) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleUIComponents, zimbraAdminConsoleUIComponents);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @param zimbraAdminConsoleUIComponents new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public Map<String,Object> setAdminConsoleUIComponents(String[] zimbraAdminConsoleUIComponents, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleUIComponents, zimbraAdminConsoleUIComponents);
        return attrs;
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @param zimbraAdminConsoleUIComponents new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public void addAdminConsoleUIComponents(String zimbraAdminConsoleUIComponents) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAdminConsoleUIComponents, zimbraAdminConsoleUIComponents);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @param zimbraAdminConsoleUIComponents new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public Map<String,Object> addAdminConsoleUIComponents(String zimbraAdminConsoleUIComponents, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAdminConsoleUIComponents, zimbraAdminConsoleUIComponents);
        return attrs;
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @param zimbraAdminConsoleUIComponents existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public void removeAdminConsoleUIComponents(String zimbraAdminConsoleUIComponents) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAdminConsoleUIComponents, zimbraAdminConsoleUIComponents);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @param zimbraAdminConsoleUIComponents existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public Map<String,Object> removeAdminConsoleUIComponents(String zimbraAdminConsoleUIComponents, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAdminConsoleUIComponents, zimbraAdminConsoleUIComponents);
        return attrs;
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public void unsetAdminConsoleUIComponents() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleUIComponents, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * UI components available for the authed admin in admin console
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=761)
    public Map<String,Object> unsetAdminConsoleUIComponents(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleUIComponents, "");
        return attrs;
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied after the end user filter rule
     *
     * @return zimbraAdminOutgoingSieveScriptAfter, or null if unset
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2116)
    public String getAdminOutgoingSieveScriptAfter() {
        return getAttr(Provisioning.A_zimbraAdminOutgoingSieveScriptAfter, null, true);
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied after the end user filter rule
     *
     * @param zimbraAdminOutgoingSieveScriptAfter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2116)
    public void setAdminOutgoingSieveScriptAfter(String zimbraAdminOutgoingSieveScriptAfter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminOutgoingSieveScriptAfter, zimbraAdminOutgoingSieveScriptAfter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied after the end user filter rule
     *
     * @param zimbraAdminOutgoingSieveScriptAfter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2116)
    public Map<String,Object> setAdminOutgoingSieveScriptAfter(String zimbraAdminOutgoingSieveScriptAfter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminOutgoingSieveScriptAfter, zimbraAdminOutgoingSieveScriptAfter);
        return attrs;
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied after the end user filter rule
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2116)
    public void unsetAdminOutgoingSieveScriptAfter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminOutgoingSieveScriptAfter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied after the end user filter rule
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2116)
    public Map<String,Object> unsetAdminOutgoingSieveScriptAfter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminOutgoingSieveScriptAfter, "");
        return attrs;
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied before the end user filter rule
     *
     * @return zimbraAdminOutgoingSieveScriptBefore, or null if unset
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2115)
    public String getAdminOutgoingSieveScriptBefore() {
        return getAttr(Provisioning.A_zimbraAdminOutgoingSieveScriptBefore, null, true);
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied before the end user filter rule
     *
     * @param zimbraAdminOutgoingSieveScriptBefore new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2115)
    public void setAdminOutgoingSieveScriptBefore(String zimbraAdminOutgoingSieveScriptBefore) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminOutgoingSieveScriptBefore, zimbraAdminOutgoingSieveScriptBefore);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied before the end user filter rule
     *
     * @param zimbraAdminOutgoingSieveScriptBefore new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2115)
    public Map<String,Object> setAdminOutgoingSieveScriptBefore(String zimbraAdminOutgoingSieveScriptBefore, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminOutgoingSieveScriptBefore, zimbraAdminOutgoingSieveScriptBefore);
        return attrs;
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied before the end user filter rule
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2115)
    public void unsetAdminOutgoingSieveScriptBefore() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminOutgoingSieveScriptBefore, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * outgoing sieve script defined by admin (not able to edit and view from
     * the end user) applied before the end user filter rule
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2115)
    public Map<String,Object> unsetAdminOutgoingSieveScriptBefore(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminOutgoingSieveScriptBefore, "");
        return attrs;
    }

    /**
     * admin saved searches
     *
     * @return zimbraAdminSavedSearches, or empty array if unset
     */
    @ZAttr(id=446)
    public String[] getAdminSavedSearches() {
        return getMultiAttr(Provisioning.A_zimbraAdminSavedSearches, true, true);
    }

    /**
     * admin saved searches
     *
     * @param zimbraAdminSavedSearches new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=446)
    public void setAdminSavedSearches(String[] zimbraAdminSavedSearches) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSavedSearches, zimbraAdminSavedSearches);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin saved searches
     *
     * @param zimbraAdminSavedSearches new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=446)
    public Map<String,Object> setAdminSavedSearches(String[] zimbraAdminSavedSearches, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSavedSearches, zimbraAdminSavedSearches);
        return attrs;
    }

    /**
     * admin saved searches
     *
     * @param zimbraAdminSavedSearches new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=446)
    public void addAdminSavedSearches(String zimbraAdminSavedSearches) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAdminSavedSearches, zimbraAdminSavedSearches);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin saved searches
     *
     * @param zimbraAdminSavedSearches new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=446)
    public Map<String,Object> addAdminSavedSearches(String zimbraAdminSavedSearches, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAdminSavedSearches, zimbraAdminSavedSearches);
        return attrs;
    }

    /**
     * admin saved searches
     *
     * @param zimbraAdminSavedSearches existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=446)
    public void removeAdminSavedSearches(String zimbraAdminSavedSearches) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAdminSavedSearches, zimbraAdminSavedSearches);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin saved searches
     *
     * @param zimbraAdminSavedSearches existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=446)
    public Map<String,Object> removeAdminSavedSearches(String zimbraAdminSavedSearches, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAdminSavedSearches, zimbraAdminSavedSearches);
        return attrs;
    }

    /**
     * admin saved searches
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=446)
    public void unsetAdminSavedSearches() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSavedSearches, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin saved searches
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=446)
    public Map<String,Object> unsetAdminSavedSearches(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSavedSearches, "");
        return attrs;
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied after the end user filter rule
     *
     * @return zimbraAdminSieveScriptAfter, or null if unset
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2114)
    public String getAdminSieveScriptAfter() {
        return getAttr(Provisioning.A_zimbraAdminSieveScriptAfter, null, true);
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied after the end user filter rule
     *
     * @param zimbraAdminSieveScriptAfter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2114)
    public void setAdminSieveScriptAfter(String zimbraAdminSieveScriptAfter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveScriptAfter, zimbraAdminSieveScriptAfter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied after the end user filter rule
     *
     * @param zimbraAdminSieveScriptAfter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2114)
    public Map<String,Object> setAdminSieveScriptAfter(String zimbraAdminSieveScriptAfter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveScriptAfter, zimbraAdminSieveScriptAfter);
        return attrs;
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied after the end user filter rule
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2114)
    public void unsetAdminSieveScriptAfter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveScriptAfter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied after the end user filter rule
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2114)
    public Map<String,Object> unsetAdminSieveScriptAfter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveScriptAfter, "");
        return attrs;
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied before the end user filter rule
     *
     * @return zimbraAdminSieveScriptBefore, or null if unset
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2113)
    public String getAdminSieveScriptBefore() {
        return getAttr(Provisioning.A_zimbraAdminSieveScriptBefore, null, true);
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied before the end user filter rule
     *
     * @param zimbraAdminSieveScriptBefore new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2113)
    public void setAdminSieveScriptBefore(String zimbraAdminSieveScriptBefore) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveScriptBefore, zimbraAdminSieveScriptBefore);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied before the end user filter rule
     *
     * @param zimbraAdminSieveScriptBefore new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2113)
    public Map<String,Object> setAdminSieveScriptBefore(String zimbraAdminSieveScriptBefore, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveScriptBefore, zimbraAdminSieveScriptBefore);
        return attrs;
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied before the end user filter rule
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2113)
    public void unsetAdminSieveScriptBefore() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveScriptBefore, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sieve script defined by admin (not able to edit and view from the end
     * user) applied before the end user filter rule
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2113)
    public Map<String,Object> unsetAdminSieveScriptBefore(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveScriptBefore, "");
        return attrs;
    }

    /**
     * Whether this account can use any from address. Not changeable by
     * domain admin to allow arbitrary addresses
     *
     * @return zimbraAllowAnyFromAddress, or false if unset
     */
    @ZAttr(id=427)
    public boolean isAllowAnyFromAddress() {
        return getBooleanAttr(Provisioning.A_zimbraAllowAnyFromAddress, false, true);
    }

    /**
     * Whether this account can use any from address. Not changeable by
     * domain admin to allow arbitrary addresses
     *
     * @param zimbraAllowAnyFromAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=427)
    public void setAllowAnyFromAddress(boolean zimbraAllowAnyFromAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowAnyFromAddress, zimbraAllowAnyFromAddress ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether this account can use any from address. Not changeable by
     * domain admin to allow arbitrary addresses
     *
     * @param zimbraAllowAnyFromAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=427)
    public Map<String,Object> setAllowAnyFromAddress(boolean zimbraAllowAnyFromAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowAnyFromAddress, zimbraAllowAnyFromAddress ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether this account can use any from address. Not changeable by
     * domain admin to allow arbitrary addresses
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=427)
    public void unsetAllowAnyFromAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowAnyFromAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether this account can use any from address. Not changeable by
     * domain admin to allow arbitrary addresses
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=427)
    public Map<String,Object> unsetAllowAnyFromAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowAnyFromAddress, "");
        return attrs;
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @return zimbraAllowFromAddress, or empty array if unset
     */
    @ZAttr(id=428)
    public String[] getAllowFromAddress() {
        return getMultiAttr(Provisioning.A_zimbraAllowFromAddress, true, true);
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @param zimbraAllowFromAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=428)
    public void setAllowFromAddress(String[] zimbraAllowFromAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowFromAddress, zimbraAllowFromAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @param zimbraAllowFromAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=428)
    public Map<String,Object> setAllowFromAddress(String[] zimbraAllowFromAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowFromAddress, zimbraAllowFromAddress);
        return attrs;
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @param zimbraAllowFromAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=428)
    public void addAllowFromAddress(String zimbraAllowFromAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAllowFromAddress, zimbraAllowFromAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @param zimbraAllowFromAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=428)
    public Map<String,Object> addAllowFromAddress(String zimbraAllowFromAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAllowFromAddress, zimbraAllowFromAddress);
        return attrs;
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @param zimbraAllowFromAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=428)
    public void removeAllowFromAddress(String zimbraAllowFromAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAllowFromAddress, zimbraAllowFromAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @param zimbraAllowFromAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=428)
    public Map<String,Object> removeAllowFromAddress(String zimbraAllowFromAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAllowFromAddress, zimbraAllowFromAddress);
        return attrs;
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=428)
    public void unsetAllowFromAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowFromAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Addresses that this account is permitted to use in From: header on
     * sent messages. Only applicable when zimbraAllowAnyFromAddress is set
     * to false.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=428)
    public Map<String,Object> unsetAllowFromAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowFromAddress, "");
        return attrs;
    }

    /**
     * application-specific password
     *
     * @return zimbraAppSpecificPassword, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public String[] getAppSpecificPassword() {
        return getMultiAttr(Provisioning.A_zimbraAppSpecificPassword, true, true);
    }

    /**
     * application-specific password
     *
     * @param zimbraAppSpecificPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public void setAppSpecificPassword(String[] zimbraAppSpecificPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPassword, zimbraAppSpecificPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * application-specific password
     *
     * @param zimbraAppSpecificPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public Map<String,Object> setAppSpecificPassword(String[] zimbraAppSpecificPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPassword, zimbraAppSpecificPassword);
        return attrs;
    }

    /**
     * application-specific password
     *
     * @param zimbraAppSpecificPassword new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public void addAppSpecificPassword(String zimbraAppSpecificPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAppSpecificPassword, zimbraAppSpecificPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * application-specific password
     *
     * @param zimbraAppSpecificPassword new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public Map<String,Object> addAppSpecificPassword(String zimbraAppSpecificPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAppSpecificPassword, zimbraAppSpecificPassword);
        return attrs;
    }

    /**
     * application-specific password
     *
     * @param zimbraAppSpecificPassword existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public void removeAppSpecificPassword(String zimbraAppSpecificPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAppSpecificPassword, zimbraAppSpecificPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * application-specific password
     *
     * @param zimbraAppSpecificPassword existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public Map<String,Object> removeAppSpecificPassword(String zimbraAppSpecificPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAppSpecificPassword, zimbraAppSpecificPassword);
        return attrs;
    }

    /**
     * application-specific password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public void unsetAppSpecificPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * application-specific password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1836)
    public Map<String,Object> unsetAppSpecificPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPassword, "");
        return attrs;
    }

    /**
     * lifetime of app-specific passwords, or 0 for no expiry. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getAppSpecificPasswordDurationAsString to access value as a string.
     *
     * @see #getAppSpecificPasswordDurationAsString()
     *
     * @return zimbraAppSpecificPasswordDuration in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1839)
    public long getAppSpecificPasswordDuration() {
        return getTimeInterval(Provisioning.A_zimbraAppSpecificPasswordDuration, 0L, true);
    }

    /**
     * lifetime of app-specific passwords, or 0 for no expiry. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraAppSpecificPasswordDuration, or "0" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1839)
    public String getAppSpecificPasswordDurationAsString() {
        return getAttr(Provisioning.A_zimbraAppSpecificPasswordDuration, "0", true);
    }

    /**
     * lifetime of app-specific passwords, or 0 for no expiry. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAppSpecificPasswordDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1839)
    public void setAppSpecificPasswordDuration(String zimbraAppSpecificPasswordDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPasswordDuration, zimbraAppSpecificPasswordDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of app-specific passwords, or 0 for no expiry. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAppSpecificPasswordDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1839)
    public Map<String,Object> setAppSpecificPasswordDuration(String zimbraAppSpecificPasswordDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPasswordDuration, zimbraAppSpecificPasswordDuration);
        return attrs;
    }

    /**
     * lifetime of app-specific passwords, or 0 for no expiry. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1839)
    public void unsetAppSpecificPasswordDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPasswordDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of app-specific passwords, or 0 for no expiry. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1839)
    public Map<String,Object> unsetAppSpecificPasswordDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPasswordDuration, "");
        return attrs;
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @return zimbraArchiveAccount, or empty array if unset
     */
    @ZAttr(id=429)
    public String[] getArchiveAccount() {
        return getMultiAttr(Provisioning.A_zimbraArchiveAccount, true, true);
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @param zimbraArchiveAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=429)
    public void setArchiveAccount(String[] zimbraArchiveAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccount, zimbraArchiveAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @param zimbraArchiveAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=429)
    public Map<String,Object> setArchiveAccount(String[] zimbraArchiveAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccount, zimbraArchiveAccount);
        return attrs;
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @param zimbraArchiveAccount new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=429)
    public void addArchiveAccount(String zimbraArchiveAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraArchiveAccount, zimbraArchiveAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @param zimbraArchiveAccount new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=429)
    public Map<String,Object> addArchiveAccount(String zimbraArchiveAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraArchiveAccount, zimbraArchiveAccount);
        return attrs;
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @param zimbraArchiveAccount existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=429)
    public void removeArchiveAccount(String zimbraArchiveAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraArchiveAccount, zimbraArchiveAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @param zimbraArchiveAccount existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=429)
    public Map<String,Object> removeArchiveAccount(String zimbraArchiveAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraArchiveAccount, zimbraArchiveAccount);
        return attrs;
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=429)
    public void unsetArchiveAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mailboxes in which the current account in archived. Multi-value attr
     * with eg values { user-2006@example.com.archive,
     * user-2007@example.com.archive } that tells us that user@example.com
     * has been archived into those two mailboxes.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=429)
    public Map<String,Object> unsetArchiveAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccount, "");
        return attrs;
    }

    /**
     * An account or CoS setting that works with the name template that
     * allows you to dictate the date format used in the name template. This
     * is a Java SimpleDateFormat specifier. The default is an LDAP
     * generalized time format:
     *
     * @return zimbraArchiveAccountDateTemplate, or "yyyyMMdd" if unset
     */
    @ZAttr(id=432)
    public String getArchiveAccountDateTemplate() {
        return getAttr(Provisioning.A_zimbraArchiveAccountDateTemplate, "yyyyMMdd", true);
    }

    /**
     * An account or CoS setting that works with the name template that
     * allows you to dictate the date format used in the name template. This
     * is a Java SimpleDateFormat specifier. The default is an LDAP
     * generalized time format:
     *
     * @param zimbraArchiveAccountDateTemplate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=432)
    public void setArchiveAccountDateTemplate(String zimbraArchiveAccountDateTemplate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccountDateTemplate, zimbraArchiveAccountDateTemplate);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * An account or CoS setting that works with the name template that
     * allows you to dictate the date format used in the name template. This
     * is a Java SimpleDateFormat specifier. The default is an LDAP
     * generalized time format:
     *
     * @param zimbraArchiveAccountDateTemplate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=432)
    public Map<String,Object> setArchiveAccountDateTemplate(String zimbraArchiveAccountDateTemplate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccountDateTemplate, zimbraArchiveAccountDateTemplate);
        return attrs;
    }

    /**
     * An account or CoS setting that works with the name template that
     * allows you to dictate the date format used in the name template. This
     * is a Java SimpleDateFormat specifier. The default is an LDAP
     * generalized time format:
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=432)
    public void unsetArchiveAccountDateTemplate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccountDateTemplate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * An account or CoS setting that works with the name template that
     * allows you to dictate the date format used in the name template. This
     * is a Java SimpleDateFormat specifier. The default is an LDAP
     * generalized time format:
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=432)
    public Map<String,Object> unsetArchiveAccountDateTemplate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccountDateTemplate, "");
        return attrs;
    }

    /**
     * An account or CoS setting - typically only in CoS - that tells the
     * archiving system how to derive the archive mailbox name. ID, USER,
     * DATE, and DOMAIN are expanded.
     *
     * @return zimbraArchiveAccountNameTemplate, or "${USER}-${DATE}@${DOMAIN}.archive" if unset
     */
    @ZAttr(id=431)
    public String getArchiveAccountNameTemplate() {
        return getAttr(Provisioning.A_zimbraArchiveAccountNameTemplate, "${USER}-${DATE}@${DOMAIN}.archive", true);
    }

    /**
     * An account or CoS setting - typically only in CoS - that tells the
     * archiving system how to derive the archive mailbox name. ID, USER,
     * DATE, and DOMAIN are expanded.
     *
     * @param zimbraArchiveAccountNameTemplate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=431)
    public void setArchiveAccountNameTemplate(String zimbraArchiveAccountNameTemplate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccountNameTemplate, zimbraArchiveAccountNameTemplate);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * An account or CoS setting - typically only in CoS - that tells the
     * archiving system how to derive the archive mailbox name. ID, USER,
     * DATE, and DOMAIN are expanded.
     *
     * @param zimbraArchiveAccountNameTemplate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=431)
    public Map<String,Object> setArchiveAccountNameTemplate(String zimbraArchiveAccountNameTemplate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccountNameTemplate, zimbraArchiveAccountNameTemplate);
        return attrs;
    }

    /**
     * An account or CoS setting - typically only in CoS - that tells the
     * archiving system how to derive the archive mailbox name. ID, USER,
     * DATE, and DOMAIN are expanded.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=431)
    public void unsetArchiveAccountNameTemplate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccountNameTemplate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * An account or CoS setting - typically only in CoS - that tells the
     * archiving system how to derive the archive mailbox name. ID, USER,
     * DATE, and DOMAIN are expanded.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=431)
    public Map<String,Object> unsetArchiveAccountNameTemplate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveAccountNameTemplate, "");
        return attrs;
    }

    /**
     * whether account archiving is enabled
     *
     * @return zimbraArchiveEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public boolean isArchiveEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraArchiveEnabled, false, true);
    }

    /**
     * whether account archiving is enabled
     *
     * @param zimbraArchiveEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public void setArchiveEnabled(boolean zimbraArchiveEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveEnabled, zimbraArchiveEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether account archiving is enabled
     *
     * @param zimbraArchiveEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public Map<String,Object> setArchiveEnabled(boolean zimbraArchiveEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveEnabled, zimbraArchiveEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether account archiving is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public void unsetArchiveEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether account archiving is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public Map<String,Object> unsetArchiveEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveEnabled, "");
        return attrs;
    }

    /**
     * block all attachment downloading
     *
     * @return zimbraAttachmentsBlocked, or false if unset
     */
    @ZAttr(id=115)
    public boolean isAttachmentsBlocked() {
        return getBooleanAttr(Provisioning.A_zimbraAttachmentsBlocked, false, true);
    }

    /**
     * block all attachment downloading
     *
     * @param zimbraAttachmentsBlocked new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=115)
    public void setAttachmentsBlocked(boolean zimbraAttachmentsBlocked) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsBlocked, zimbraAttachmentsBlocked ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * block all attachment downloading
     *
     * @param zimbraAttachmentsBlocked new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=115)
    public Map<String,Object> setAttachmentsBlocked(boolean zimbraAttachmentsBlocked, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsBlocked, zimbraAttachmentsBlocked ? TRUE : FALSE);
        return attrs;
    }

    /**
     * block all attachment downloading
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=115)
    public void unsetAttachmentsBlocked() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsBlocked, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * block all attachment downloading
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=115)
    public Map<String,Object> unsetAttachmentsBlocked(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsBlocked, "");
        return attrs;
    }

    /**
     * whether or not to index attachments
     *
     * @return zimbraAttachmentsIndexingEnabled, or true if unset
     */
    @ZAttr(id=173)
    public boolean isAttachmentsIndexingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAttachmentsIndexingEnabled, true, true);
    }

    /**
     * whether or not to index attachments
     *
     * @param zimbraAttachmentsIndexingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=173)
    public void setAttachmentsIndexingEnabled(boolean zimbraAttachmentsIndexingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsIndexingEnabled, zimbraAttachmentsIndexingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to index attachments
     *
     * @param zimbraAttachmentsIndexingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=173)
    public Map<String,Object> setAttachmentsIndexingEnabled(boolean zimbraAttachmentsIndexingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsIndexingEnabled, zimbraAttachmentsIndexingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to index attachments
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=173)
    public void unsetAttachmentsIndexingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsIndexingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to index attachments
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=173)
    public Map<String,Object> unsetAttachmentsIndexingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsIndexingEnabled, "");
        return attrs;
    }

    /**
     * view all attachments in html only
     *
     * @return zimbraAttachmentsViewInHtmlOnly, or false if unset
     */
    @ZAttr(id=116)
    public boolean isAttachmentsViewInHtmlOnly() {
        return getBooleanAttr(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, false, true);
    }

    /**
     * view all attachments in html only
     *
     * @param zimbraAttachmentsViewInHtmlOnly new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=116)
    public void setAttachmentsViewInHtmlOnly(boolean zimbraAttachmentsViewInHtmlOnly) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, zimbraAttachmentsViewInHtmlOnly ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * view all attachments in html only
     *
     * @param zimbraAttachmentsViewInHtmlOnly new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=116)
    public Map<String,Object> setAttachmentsViewInHtmlOnly(boolean zimbraAttachmentsViewInHtmlOnly, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, zimbraAttachmentsViewInHtmlOnly ? TRUE : FALSE);
        return attrs;
    }

    /**
     * view all attachments in html only
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=116)
    public void unsetAttachmentsViewInHtmlOnly() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * view all attachments in html only
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=116)
    public Map<String,Object> unsetAttachmentsViewInHtmlOnly(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, "");
        return attrs;
    }

    /**
     * explicit mapping to an external LDAP dn for a given account
     *
     * @return zimbraAuthLdapExternalDn, or null if unset
     */
    @ZAttr(id=256)
    public String getAuthLdapExternalDn() {
        return getAttr(Provisioning.A_zimbraAuthLdapExternalDn, null, true);
    }

    /**
     * explicit mapping to an external LDAP dn for a given account
     *
     * @param zimbraAuthLdapExternalDn new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=256)
    public void setAuthLdapExternalDn(String zimbraAuthLdapExternalDn) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthLdapExternalDn, zimbraAuthLdapExternalDn);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * explicit mapping to an external LDAP dn for a given account
     *
     * @param zimbraAuthLdapExternalDn new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=256)
    public Map<String,Object> setAuthLdapExternalDn(String zimbraAuthLdapExternalDn, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthLdapExternalDn, zimbraAuthLdapExternalDn);
        return attrs;
    }

    /**
     * explicit mapping to an external LDAP dn for a given account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=256)
    public void unsetAuthLdapExternalDn() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthLdapExternalDn, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * explicit mapping to an external LDAP dn for a given account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=256)
    public Map<String,Object> unsetAuthLdapExternalDn(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthLdapExternalDn, "");
        return attrs;
    }

    /**
     * lifetime of newly created auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getAuthTokenLifetimeAsString to access value as a string.
     *
     * @see #getAuthTokenLifetimeAsString()
     *
     * @return zimbraAuthTokenLifetime in millseconds, or 172800000 (2d)  if unset
     */
    @ZAttr(id=108)
    public long getAuthTokenLifetime() {
        return getTimeInterval(Provisioning.A_zimbraAuthTokenLifetime, 172800000L, true);
    }

    /**
     * lifetime of newly created auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraAuthTokenLifetime, or "2d" if unset
     */
    @ZAttr(id=108)
    public String getAuthTokenLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraAuthTokenLifetime, "2d", true);
    }

    /**
     * lifetime of newly created auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraAuthTokenLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=108)
    public void setAuthTokenLifetime(String zimbraAuthTokenLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenLifetime, zimbraAuthTokenLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of newly created auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraAuthTokenLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=108)
    public Map<String,Object> setAuthTokenLifetime(String zimbraAuthTokenLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenLifetime, zimbraAuthTokenLifetime);
        return attrs;
    }

    /**
     * lifetime of newly created auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=108)
    public void unsetAuthTokenLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of newly created auth tokens. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=108)
    public Map<String,Object> unsetAuthTokenLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenLifetime, "");
        return attrs;
    }

    /**
     * if set, this value gets stored in the auth token and compared on every
     * request. Changing it will invalidate all outstanding auth tokens. It
     * also gets changed when an account password is changed.
     *
     * @return zimbraAuthTokenValidityValue, or -1 if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1044)
    public int getAuthTokenValidityValue() {
        return getIntAttr(Provisioning.A_zimbraAuthTokenValidityValue, -1, true);
    }

    /**
     * if set, this value gets stored in the auth token and compared on every
     * request. Changing it will invalidate all outstanding auth tokens. It
     * also gets changed when an account password is changed.
     *
     * @param zimbraAuthTokenValidityValue new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1044)
    public void setAuthTokenValidityValue(int zimbraAuthTokenValidityValue) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenValidityValue, Integer.toString(zimbraAuthTokenValidityValue));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if set, this value gets stored in the auth token and compared on every
     * request. Changing it will invalidate all outstanding auth tokens. It
     * also gets changed when an account password is changed.
     *
     * @param zimbraAuthTokenValidityValue new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1044)
    public Map<String,Object> setAuthTokenValidityValue(int zimbraAuthTokenValidityValue, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenValidityValue, Integer.toString(zimbraAuthTokenValidityValue));
        return attrs;
    }

    /**
     * if set, this value gets stored in the auth token and compared on every
     * request. Changing it will invalidate all outstanding auth tokens. It
     * also gets changed when an account password is changed.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1044)
    public void unsetAuthTokenValidityValue() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenValidityValue, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if set, this value gets stored in the auth token and compared on every
     * request. Changing it will invalidate all outstanding auth tokens. It
     * also gets changed when an account password is changed.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1044)
    public Map<String,Object> unsetAuthTokenValidityValue(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenValidityValue, "");
        return attrs;
    }

    /**
     * list of currently active auth tokens
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error on accessing ephemeral data
     *
     * @return zimbraAuthTokens, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1585)
    public String getAuthTokens(String dynamicComponent) throws com.zimbra.common.service.ServiceException {
        return getEphemeralAttr(Provisioning.A_zimbraAuthTokens, dynamicComponent).getValue(null);
    }

    /**
     * list of currently active auth tokens
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @param zimbraAuthTokens new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1585)
    public void addAuthTokens(String dynamicComponent, String zimbraAuthTokens, com.zimbra.cs.ephemeral.EphemeralInput.Expiration expiration) throws com.zimbra.common.service.ServiceException {
        modifyEphemeralAttr(Provisioning.A_zimbraAuthTokens, dynamicComponent, zimbraAuthTokens, true, expiration);
    }

    /**
     * list of currently active auth tokens
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @param zimbraAuthTokens existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1585)
    public void removeAuthTokens(String dynamicComponent, String zimbraAuthTokens) throws com.zimbra.common.service.ServiceException {
        deleteEphemeralAttr(Provisioning.A_zimbraAuthTokens, dynamicComponent, zimbraAuthTokens);
    }

    /**
     * list of currently active auth tokens
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1585)
    public boolean hasAuthTokens(String dynamicComponent) throws com.zimbra.common.service.ServiceException {
        return hasEphemeralAttr(Provisioning.A_zimbraAuthTokens, dynamicComponent);
    }

    /**
     * list of currently active auth tokens
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1585)
    public void purgeAuthTokens() throws com.zimbra.common.service.ServiceException {
        purgeEphemeralAttr(Provisioning.A_zimbraAuthTokens);
    }

    /**
     * Whether account should act as a service account to provide free busy
     * information to exchange servers for users in the domain.
     *
     * @return zimbraAvailabilityServiceProvider, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2072)
    public boolean isAvailabilityServiceProvider() {
        return getBooleanAttr(Provisioning.A_zimbraAvailabilityServiceProvider, false, true);
    }

    /**
     * Whether account should act as a service account to provide free busy
     * information to exchange servers for users in the domain.
     *
     * @param zimbraAvailabilityServiceProvider new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2072)
    public void setAvailabilityServiceProvider(boolean zimbraAvailabilityServiceProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailabilityServiceProvider, zimbraAvailabilityServiceProvider ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether account should act as a service account to provide free busy
     * information to exchange servers for users in the domain.
     *
     * @param zimbraAvailabilityServiceProvider new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2072)
    public Map<String,Object> setAvailabilityServiceProvider(boolean zimbraAvailabilityServiceProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailabilityServiceProvider, zimbraAvailabilityServiceProvider ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether account should act as a service account to provide free busy
     * information to exchange servers for users in the domain.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2072)
    public void unsetAvailabilityServiceProvider() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailabilityServiceProvider, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether account should act as a service account to provide free busy
     * information to exchange servers for users in the domain.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2072)
    public Map<String,Object> unsetAvailabilityServiceProvider(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailabilityServiceProvider, "");
        return attrs;
    }

    /**
     * Locales available for this account
     *
     * @return zimbraAvailableLocale, or empty array if unset
     */
    @ZAttr(id=487)
    public String[] getAvailableLocale() {
        return getMultiAttr(Provisioning.A_zimbraAvailableLocale, true, true);
    }

    /**
     * Locales available for this account
     *
     * @param zimbraAvailableLocale new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=487)
    public void setAvailableLocale(String[] zimbraAvailableLocale) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailableLocale, zimbraAvailableLocale);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Locales available for this account
     *
     * @param zimbraAvailableLocale new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=487)
    public Map<String,Object> setAvailableLocale(String[] zimbraAvailableLocale, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailableLocale, zimbraAvailableLocale);
        return attrs;
    }

    /**
     * Locales available for this account
     *
     * @param zimbraAvailableLocale new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=487)
    public void addAvailableLocale(String zimbraAvailableLocale) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAvailableLocale, zimbraAvailableLocale);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Locales available for this account
     *
     * @param zimbraAvailableLocale new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=487)
    public Map<String,Object> addAvailableLocale(String zimbraAvailableLocale, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAvailableLocale, zimbraAvailableLocale);
        return attrs;
    }

    /**
     * Locales available for this account
     *
     * @param zimbraAvailableLocale existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=487)
    public void removeAvailableLocale(String zimbraAvailableLocale) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAvailableLocale, zimbraAvailableLocale);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Locales available for this account
     *
     * @param zimbraAvailableLocale existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=487)
    public Map<String,Object> removeAvailableLocale(String zimbraAvailableLocale, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAvailableLocale, zimbraAvailableLocale);
        return attrs;
    }

    /**
     * Locales available for this account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=487)
    public void unsetAvailableLocale() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailableLocale, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Locales available for this account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=487)
    public Map<String,Object> unsetAvailableLocale(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailableLocale, "");
        return attrs;
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @return zimbraAvailableSkin, or empty array if unset
     */
    @ZAttr(id=364)
    public String[] getAvailableSkin() {
        return getMultiAttr(Provisioning.A_zimbraAvailableSkin, true, true);
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @param zimbraAvailableSkin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=364)
    public void setAvailableSkin(String[] zimbraAvailableSkin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailableSkin, zimbraAvailableSkin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @param zimbraAvailableSkin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=364)
    public Map<String,Object> setAvailableSkin(String[] zimbraAvailableSkin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailableSkin, zimbraAvailableSkin);
        return attrs;
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @param zimbraAvailableSkin new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=364)
    public void addAvailableSkin(String zimbraAvailableSkin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAvailableSkin, zimbraAvailableSkin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @param zimbraAvailableSkin new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=364)
    public Map<String,Object> addAvailableSkin(String zimbraAvailableSkin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAvailableSkin, zimbraAvailableSkin);
        return attrs;
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @param zimbraAvailableSkin existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=364)
    public void removeAvailableSkin(String zimbraAvailableSkin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAvailableSkin, zimbraAvailableSkin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @param zimbraAvailableSkin existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=364)
    public Map<String,Object> removeAvailableSkin(String zimbraAvailableSkin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAvailableSkin, zimbraAvailableSkin);
        return attrs;
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=364)
    public void unsetAvailableSkin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailableSkin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Skins available for this account. Fallback order is: 1. the normal
     * account/cos inheritance 2. if not set on account/cos, use the value on
     * the domain of the account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=364)
    public Map<String,Object> unsetAvailableSkin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAvailableSkin, "");
        return attrs;
    }

    /**
     * Batch size to use when indexing data
     *
     * @return zimbraBatchedIndexingSize, or 20 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=619)
    public int getBatchedIndexingSize() {
        return getIntAttr(Provisioning.A_zimbraBatchedIndexingSize, 20, true);
    }

    /**
     * Batch size to use when indexing data
     *
     * @param zimbraBatchedIndexingSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=619)
    public void setBatchedIndexingSize(int zimbraBatchedIndexingSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBatchedIndexingSize, Integer.toString(zimbraBatchedIndexingSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Batch size to use when indexing data
     *
     * @param zimbraBatchedIndexingSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=619)
    public Map<String,Object> setBatchedIndexingSize(int zimbraBatchedIndexingSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBatchedIndexingSize, Integer.toString(zimbraBatchedIndexingSize));
        return attrs;
    }

    /**
     * Batch size to use when indexing data
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=619)
    public void unsetBatchedIndexingSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBatchedIndexingSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Batch size to use when indexing data
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=619)
    public Map<String,Object> unsetBatchedIndexingSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBatchedIndexingSize, "");
        return attrs;
    }

    /**
     * COS zimbraID
     *
     * @return zimbraCOSId, or null if unset
     */
    @ZAttr(id=14)
    public String getCOSId() {
        return getAttr(Provisioning.A_zimbraCOSId, null, true);
    }

    /**
     * COS zimbraID
     *
     * @param zimbraCOSId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=14)
    public void setCOSId(String zimbraCOSId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCOSId, zimbraCOSId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * COS zimbraID
     *
     * @param zimbraCOSId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=14)
    public Map<String,Object> setCOSId(String zimbraCOSId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCOSId, zimbraCOSId);
        return attrs;
    }

    /**
     * COS zimbraID
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=14)
    public void unsetCOSId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCOSId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * COS zimbraID
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=14)
    public Map<String,Object> unsetCOSId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCOSId, "");
        return attrs;
    }

    /**
     * CalDAV shared folder cache duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getCalendarCalDavSharedFolderCacheDurationAsString to access value as a string.
     *
     * @see #getCalendarCalDavSharedFolderCacheDurationAsString()
     *
     * @return zimbraCalendarCalDavSharedFolderCacheDuration in millseconds, or 60000 (1m)  if unset
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=817)
    public long getCalendarCalDavSharedFolderCacheDuration() {
        return getTimeInterval(Provisioning.A_zimbraCalendarCalDavSharedFolderCacheDuration, 60000L, true);
    }

    /**
     * CalDAV shared folder cache duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraCalendarCalDavSharedFolderCacheDuration, or "1m" if unset
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=817)
    public String getCalendarCalDavSharedFolderCacheDurationAsString() {
        return getAttr(Provisioning.A_zimbraCalendarCalDavSharedFolderCacheDuration, "1m", true);
    }

    /**
     * CalDAV shared folder cache duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraCalendarCalDavSharedFolderCacheDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=817)
    public void setCalendarCalDavSharedFolderCacheDuration(String zimbraCalendarCalDavSharedFolderCacheDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSharedFolderCacheDuration, zimbraCalendarCalDavSharedFolderCacheDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CalDAV shared folder cache duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraCalendarCalDavSharedFolderCacheDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=817)
    public Map<String,Object> setCalendarCalDavSharedFolderCacheDuration(String zimbraCalendarCalDavSharedFolderCacheDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSharedFolderCacheDuration, zimbraCalendarCalDavSharedFolderCacheDuration);
        return attrs;
    }

    /**
     * CalDAV shared folder cache duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=817)
    public void unsetCalendarCalDavSharedFolderCacheDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSharedFolderCacheDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CalDAV shared folder cache duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=817)
    public Map<String,Object> unsetCalendarCalDavSharedFolderCacheDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSharedFolderCacheDuration, "");
        return attrs;
    }

    /**
     * see description of zimbraCalendarCalDavSyncStart. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getCalendarCalDavSyncEndAsString to access value as a string.
     *
     * @see #getCalendarCalDavSyncEndAsString()
     *
     * @return zimbraCalendarCalDavSyncEnd in millseconds, or -1 if unset
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=816)
    public long getCalendarCalDavSyncEnd() {
        return getTimeInterval(Provisioning.A_zimbraCalendarCalDavSyncEnd, -1L, true);
    }

    /**
     * see description of zimbraCalendarCalDavSyncStart. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraCalendarCalDavSyncEnd, or null if unset
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=816)
    public String getCalendarCalDavSyncEndAsString() {
        return getAttr(Provisioning.A_zimbraCalendarCalDavSyncEnd, null, true);
    }

    /**
     * see description of zimbraCalendarCalDavSyncStart. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraCalendarCalDavSyncEnd new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=816)
    public void setCalendarCalDavSyncEnd(String zimbraCalendarCalDavSyncEnd) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSyncEnd, zimbraCalendarCalDavSyncEnd);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * see description of zimbraCalendarCalDavSyncStart. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraCalendarCalDavSyncEnd new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=816)
    public Map<String,Object> setCalendarCalDavSyncEnd(String zimbraCalendarCalDavSyncEnd, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSyncEnd, zimbraCalendarCalDavSyncEnd);
        return attrs;
    }

    /**
     * see description of zimbraCalendarCalDavSyncStart. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=816)
    public void unsetCalendarCalDavSyncEnd() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSyncEnd, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * see description of zimbraCalendarCalDavSyncStart. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=816)
    public Map<String,Object> unsetCalendarCalDavSyncEnd(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSyncEnd, "");
        return attrs;
    }

    /**
     * zimbraCalendarCalDavSyncStart and zimbraCalendarCalDavSyncEnd limits
     * the window of appointment data available via CalDAV. for example when
     * zimbraCalendarCalDavSyncStart is set to 30 days, and
     * zimbraCalendarCalDavSyncEnd is set to 1 years, then the appointments
     * between (now - 30 days) and (now + 1 year) will be available via
     * CalDAV. When they are unset all the appointments are available via
     * CalDAV. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getCalendarCalDavSyncStartAsString to access value as a string.
     *
     * @see #getCalendarCalDavSyncStartAsString()
     *
     * @return zimbraCalendarCalDavSyncStart in millseconds, or -1 if unset
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=815)
    public long getCalendarCalDavSyncStart() {
        return getTimeInterval(Provisioning.A_zimbraCalendarCalDavSyncStart, -1L, true);
    }

    /**
     * zimbraCalendarCalDavSyncStart and zimbraCalendarCalDavSyncEnd limits
     * the window of appointment data available via CalDAV. for example when
     * zimbraCalendarCalDavSyncStart is set to 30 days, and
     * zimbraCalendarCalDavSyncEnd is set to 1 years, then the appointments
     * between (now - 30 days) and (now + 1 year) will be available via
     * CalDAV. When they are unset all the appointments are available via
     * CalDAV. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraCalendarCalDavSyncStart, or null if unset
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=815)
    public String getCalendarCalDavSyncStartAsString() {
        return getAttr(Provisioning.A_zimbraCalendarCalDavSyncStart, null, true);
    }

    /**
     * zimbraCalendarCalDavSyncStart and zimbraCalendarCalDavSyncEnd limits
     * the window of appointment data available via CalDAV. for example when
     * zimbraCalendarCalDavSyncStart is set to 30 days, and
     * zimbraCalendarCalDavSyncEnd is set to 1 years, then the appointments
     * between (now - 30 days) and (now + 1 year) will be available via
     * CalDAV. When they are unset all the appointments are available via
     * CalDAV. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraCalendarCalDavSyncStart new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=815)
    public void setCalendarCalDavSyncStart(String zimbraCalendarCalDavSyncStart) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSyncStart, zimbraCalendarCalDavSyncStart);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimbraCalendarCalDavSyncStart and zimbraCalendarCalDavSyncEnd limits
     * the window of appointment data available via CalDAV. for example when
     * zimbraCalendarCalDavSyncStart is set to 30 days, and
     * zimbraCalendarCalDavSyncEnd is set to 1 years, then the appointments
     * between (now - 30 days) and (now + 1 year) will be available via
     * CalDAV. When they are unset all the appointments are available via
     * CalDAV. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraCalendarCalDavSyncStart new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=815)
    public Map<String,Object> setCalendarCalDavSyncStart(String zimbraCalendarCalDavSyncStart, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSyncStart, zimbraCalendarCalDavSyncStart);
        return attrs;
    }

    /**
     * zimbraCalendarCalDavSyncStart and zimbraCalendarCalDavSyncEnd limits
     * the window of appointment data available via CalDAV. for example when
     * zimbraCalendarCalDavSyncStart is set to 30 days, and
     * zimbraCalendarCalDavSyncEnd is set to 1 years, then the appointments
     * between (now - 30 days) and (now + 1 year) will be available via
     * CalDAV. When they are unset all the appointments are available via
     * CalDAV. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=815)
    public void unsetCalendarCalDavSyncStart() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSyncStart, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimbraCalendarCalDavSyncStart and zimbraCalendarCalDavSyncEnd limits
     * the window of appointment data available via CalDAV. for example when
     * zimbraCalendarCalDavSyncStart is set to 30 days, and
     * zimbraCalendarCalDavSyncEnd is set to 1 years, then the appointments
     * between (now - 30 days) and (now + 1 year) will be available via
     * CalDAV. When they are unset all the appointments are available via
     * CalDAV. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=815)
    public Map<String,Object> unsetCalendarCalDavSyncStart(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavSyncStart, "");
        return attrs;
    }

    /**
     * whether to retain exception instances when the recurrence series is
     * changed to new time; set to FALSE for Exchange compatibility
     *
     * @return zimbraCalendarKeepExceptionsOnSeriesTimeChange, or false if unset
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1240)
    public boolean isCalendarKeepExceptionsOnSeriesTimeChange() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarKeepExceptionsOnSeriesTimeChange, false, true);
    }

    /**
     * whether to retain exception instances when the recurrence series is
     * changed to new time; set to FALSE for Exchange compatibility
     *
     * @param zimbraCalendarKeepExceptionsOnSeriesTimeChange new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1240)
    public void setCalendarKeepExceptionsOnSeriesTimeChange(boolean zimbraCalendarKeepExceptionsOnSeriesTimeChange) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarKeepExceptionsOnSeriesTimeChange, zimbraCalendarKeepExceptionsOnSeriesTimeChange ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to retain exception instances when the recurrence series is
     * changed to new time; set to FALSE for Exchange compatibility
     *
     * @param zimbraCalendarKeepExceptionsOnSeriesTimeChange new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1240)
    public Map<String,Object> setCalendarKeepExceptionsOnSeriesTimeChange(boolean zimbraCalendarKeepExceptionsOnSeriesTimeChange, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarKeepExceptionsOnSeriesTimeChange, zimbraCalendarKeepExceptionsOnSeriesTimeChange ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to retain exception instances when the recurrence series is
     * changed to new time; set to FALSE for Exchange compatibility
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1240)
    public void unsetCalendarKeepExceptionsOnSeriesTimeChange() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarKeepExceptionsOnSeriesTimeChange, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to retain exception instances when the recurrence series is
     * changed to new time; set to FALSE for Exchange compatibility
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1240)
    public Map<String,Object> unsetCalendarKeepExceptionsOnSeriesTimeChange(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarKeepExceptionsOnSeriesTimeChange, "");
        return attrs;
    }

    /**
     * list of disabled fields in calendar location web UI
     *
     * @return zimbraCalendarLocationDisabledFields, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1218)
    public String getCalendarLocationDisabledFields() {
        return getAttr(Provisioning.A_zimbraCalendarLocationDisabledFields, null, true);
    }

    /**
     * list of disabled fields in calendar location web UI
     *
     * @param zimbraCalendarLocationDisabledFields new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1218)
    public void setCalendarLocationDisabledFields(String zimbraCalendarLocationDisabledFields) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarLocationDisabledFields, zimbraCalendarLocationDisabledFields);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of disabled fields in calendar location web UI
     *
     * @param zimbraCalendarLocationDisabledFields new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1218)
    public Map<String,Object> setCalendarLocationDisabledFields(String zimbraCalendarLocationDisabledFields, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarLocationDisabledFields, zimbraCalendarLocationDisabledFields);
        return attrs;
    }

    /**
     * list of disabled fields in calendar location web UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1218)
    public void unsetCalendarLocationDisabledFields() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarLocationDisabledFields, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of disabled fields in calendar location web UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1218)
    public Map<String,Object> unsetCalendarLocationDisabledFields(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarLocationDisabledFields, "");
        return attrs;
    }

    /**
     * maximum number of revisions to keep for calendar items (appointments
     * and tasks). 0 means unlimited.
     *
     * @return zimbraCalendarMaxRevisions, or 1 if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=709)
    public int getCalendarMaxRevisions() {
        return getIntAttr(Provisioning.A_zimbraCalendarMaxRevisions, 1, true);
    }

    /**
     * maximum number of revisions to keep for calendar items (appointments
     * and tasks). 0 means unlimited.
     *
     * @param zimbraCalendarMaxRevisions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=709)
    public void setCalendarMaxRevisions(int zimbraCalendarMaxRevisions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxRevisions, Integer.toString(zimbraCalendarMaxRevisions));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of revisions to keep for calendar items (appointments
     * and tasks). 0 means unlimited.
     *
     * @param zimbraCalendarMaxRevisions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=709)
    public Map<String,Object> setCalendarMaxRevisions(int zimbraCalendarMaxRevisions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxRevisions, Integer.toString(zimbraCalendarMaxRevisions));
        return attrs;
    }

    /**
     * maximum number of revisions to keep for calendar items (appointments
     * and tasks). 0 means unlimited.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=709)
    public void unsetCalendarMaxRevisions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxRevisions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of revisions to keep for calendar items (appointments
     * and tasks). 0 means unlimited.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=709)
    public Map<String,Object> unsetCalendarMaxRevisions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarMaxRevisions, "");
        return attrs;
    }

    /**
     * email address identifying the default device for receiving reminders
     * for appointments and tasks
     *
     * @return zimbraCalendarReminderDeviceEmail, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1140)
    public String getCalendarReminderDeviceEmail() {
        return getAttr(Provisioning.A_zimbraCalendarReminderDeviceEmail, null, true);
    }

    /**
     * email address identifying the default device for receiving reminders
     * for appointments and tasks
     *
     * @param zimbraCalendarReminderDeviceEmail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1140)
    public void setCalendarReminderDeviceEmail(String zimbraCalendarReminderDeviceEmail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarReminderDeviceEmail, zimbraCalendarReminderDeviceEmail);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email address identifying the default device for receiving reminders
     * for appointments and tasks
     *
     * @param zimbraCalendarReminderDeviceEmail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1140)
    public Map<String,Object> setCalendarReminderDeviceEmail(String zimbraCalendarReminderDeviceEmail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarReminderDeviceEmail, zimbraCalendarReminderDeviceEmail);
        return attrs;
    }

    /**
     * email address identifying the default device for receiving reminders
     * for appointments and tasks
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1140)
    public void unsetCalendarReminderDeviceEmail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarReminderDeviceEmail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email address identifying the default device for receiving reminders
     * for appointments and tasks
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1140)
    public Map<String,Object> unsetCalendarReminderDeviceEmail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarReminderDeviceEmail, "");
        return attrs;
    }

    /**
     * whether calendar resources can be double booked
     *
     * @return zimbraCalendarResourceDoubleBookingAllowed, or true if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1087)
    public boolean isCalendarResourceDoubleBookingAllowed() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarResourceDoubleBookingAllowed, true, true);
    }

    /**
     * whether calendar resources can be double booked
     *
     * @param zimbraCalendarResourceDoubleBookingAllowed new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1087)
    public void setCalendarResourceDoubleBookingAllowed(boolean zimbraCalendarResourceDoubleBookingAllowed) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceDoubleBookingAllowed, zimbraCalendarResourceDoubleBookingAllowed ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether calendar resources can be double booked
     *
     * @param zimbraCalendarResourceDoubleBookingAllowed new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1087)
    public Map<String,Object> setCalendarResourceDoubleBookingAllowed(boolean zimbraCalendarResourceDoubleBookingAllowed, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceDoubleBookingAllowed, zimbraCalendarResourceDoubleBookingAllowed ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether calendar resources can be double booked
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1087)
    public void unsetCalendarResourceDoubleBookingAllowed() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceDoubleBookingAllowed, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether calendar resources can be double booked
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1087)
    public Map<String,Object> unsetCalendarResourceDoubleBookingAllowed(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceDoubleBookingAllowed, "");
        return attrs;
    }

    /**
     * whether to show Find Locations and Find Resources tabs for editing
     * appointments
     *
     * @return zimbraCalendarShowResourceTabs, or true if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1092)
    public boolean isCalendarShowResourceTabs() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarShowResourceTabs, true, true);
    }

    /**
     * whether to show Find Locations and Find Resources tabs for editing
     * appointments
     *
     * @param zimbraCalendarShowResourceTabs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1092)
    public void setCalendarShowResourceTabs(boolean zimbraCalendarShowResourceTabs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarShowResourceTabs, zimbraCalendarShowResourceTabs ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to show Find Locations and Find Resources tabs for editing
     * appointments
     *
     * @param zimbraCalendarShowResourceTabs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1092)
    public Map<String,Object> setCalendarShowResourceTabs(boolean zimbraCalendarShowResourceTabs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarShowResourceTabs, zimbraCalendarShowResourceTabs ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to show Find Locations and Find Resources tabs for editing
     * appointments
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1092)
    public void unsetCalendarShowResourceTabs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarShowResourceTabs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to show Find Locations and Find Resources tabs for editing
     * appointments
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1092)
    public Map<String,Object> unsetCalendarShowResourceTabs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarShowResourceTabs, "");
        return attrs;
    }

    /**
     * enable chat history saving
     *
     * @return zimbraChatHistoryEnabled, or true if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2103)
    public boolean isChatHistoryEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraChatHistoryEnabled, true, true);
    }

    /**
     * enable chat history saving
     *
     * @param zimbraChatHistoryEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2103)
    public void setChatHistoryEnabled(boolean zimbraChatHistoryEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatHistoryEnabled, zimbraChatHistoryEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable chat history saving
     *
     * @param zimbraChatHistoryEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2103)
    public Map<String,Object> setChatHistoryEnabled(boolean zimbraChatHistoryEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatHistoryEnabled, zimbraChatHistoryEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable chat history saving
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2103)
    public void unsetChatHistoryEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatHistoryEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable chat history saving
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2103)
    public Map<String,Object> unsetChatHistoryEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatHistoryEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @return zimbraChildAccount, or empty array if unset
     */
    @ZAttr(id=449)
    public String[] getChildAccount() {
        return getMultiAttr(Provisioning.A_zimbraChildAccount, true, true);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @param zimbraChildAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=449)
    public void setChildAccount(String[] zimbraChildAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChildAccount, zimbraChildAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @param zimbraChildAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=449)
    public Map<String,Object> setChildAccount(String[] zimbraChildAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChildAccount, zimbraChildAccount);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @param zimbraChildAccount new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=449)
    public void addChildAccount(String zimbraChildAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraChildAccount, zimbraChildAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @param zimbraChildAccount new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=449)
    public Map<String,Object> addChildAccount(String zimbraChildAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraChildAccount, zimbraChildAccount);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @param zimbraChildAccount existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=449)
    public void removeChildAccount(String zimbraChildAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraChildAccount, zimbraChildAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @param zimbraChildAccount existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=449)
    public Map<String,Object> removeChildAccount(String zimbraChildAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraChildAccount, zimbraChildAccount);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=449)
    public void unsetChildAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChildAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of child accounts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=449)
    public Map<String,Object> unsetChildAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChildAccount, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @return zimbraChildVisibleAccount, or empty array if unset
     */
    @ZAttr(id=450)
    public String[] getChildVisibleAccount() {
        return getMultiAttr(Provisioning.A_zimbraChildVisibleAccount, true, true);
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @param zimbraChildVisibleAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=450)
    public void setChildVisibleAccount(String[] zimbraChildVisibleAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChildVisibleAccount, zimbraChildVisibleAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @param zimbraChildVisibleAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=450)
    public Map<String,Object> setChildVisibleAccount(String[] zimbraChildVisibleAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChildVisibleAccount, zimbraChildVisibleAccount);
        return attrs;
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @param zimbraChildVisibleAccount new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=450)
    public void addChildVisibleAccount(String zimbraChildVisibleAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraChildVisibleAccount, zimbraChildVisibleAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @param zimbraChildVisibleAccount new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=450)
    public Map<String,Object> addChildVisibleAccount(String zimbraChildVisibleAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraChildVisibleAccount, zimbraChildVisibleAccount);
        return attrs;
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @param zimbraChildVisibleAccount existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=450)
    public void removeChildVisibleAccount(String zimbraChildVisibleAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraChildVisibleAccount, zimbraChildVisibleAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @param zimbraChildVisibleAccount existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=450)
    public Map<String,Object> removeChildVisibleAccount(String zimbraChildVisibleAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraChildVisibleAccount, zimbraChildVisibleAccount);
        return attrs;
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=450)
    public void unsetChildVisibleAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChildVisibleAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0.0. deprecated in favor of user-settable
     * attribute zimbraPrefChildVisibleAccount . Orig desc: zimbraId of
     * visible child accounts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=450)
    public Map<String,Object> unsetChildVisibleAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChildVisibleAccount, "");
        return attrs;
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @return zimbraCommunityAPIClientID, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public String getCommunityAPIClientID() {
        return getAttr(Provisioning.A_zimbraCommunityAPIClientID, null, true);
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @param zimbraCommunityAPIClientID new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public void setCommunityAPIClientID(String zimbraCommunityAPIClientID) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientID, zimbraCommunityAPIClientID);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @param zimbraCommunityAPIClientID new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public Map<String,Object> setCommunityAPIClientID(String zimbraCommunityAPIClientID, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientID, zimbraCommunityAPIClientID);
        return attrs;
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public void unsetCommunityAPIClientID() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientID, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public Map<String,Object> unsetCommunityAPIClientID(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientID, "");
        return attrs;
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @return zimbraCommunityAPIClientSecret, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public String getCommunityAPIClientSecret() {
        return getAttr(Provisioning.A_zimbraCommunityAPIClientSecret, null, true);
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @param zimbraCommunityAPIClientSecret new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public void setCommunityAPIClientSecret(String zimbraCommunityAPIClientSecret) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientSecret, zimbraCommunityAPIClientSecret);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @param zimbraCommunityAPIClientSecret new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public Map<String,Object> setCommunityAPIClientSecret(String zimbraCommunityAPIClientSecret, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientSecret, zimbraCommunityAPIClientSecret);
        return attrs;
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public void unsetCommunityAPIClientSecret() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientSecret, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public Map<String,Object> unsetCommunityAPIClientSecret(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientSecret, "");
        return attrs;
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @return zimbraCommunityBaseURL, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public String getCommunityBaseURL() {
        return getAttr(Provisioning.A_zimbraCommunityBaseURL, null, true);
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @param zimbraCommunityBaseURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public void setCommunityBaseURL(String zimbraCommunityBaseURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityBaseURL, zimbraCommunityBaseURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @param zimbraCommunityBaseURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public Map<String,Object> setCommunityBaseURL(String zimbraCommunityBaseURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityBaseURL, zimbraCommunityBaseURL);
        return attrs;
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public void unsetCommunityBaseURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityBaseURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public Map<String,Object> unsetCommunityBaseURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityBaseURL, "");
        return attrs;
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @return zimbraCommunityHomeURL, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public String getCommunityHomeURL() {
        return getAttr(Provisioning.A_zimbraCommunityHomeURL, null, true);
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @param zimbraCommunityHomeURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public void setCommunityHomeURL(String zimbraCommunityHomeURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityHomeURL, zimbraCommunityHomeURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @param zimbraCommunityHomeURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public Map<String,Object> setCommunityHomeURL(String zimbraCommunityHomeURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityHomeURL, zimbraCommunityHomeURL);
        return attrs;
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public void unsetCommunityHomeURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityHomeURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public Map<String,Object> unsetCommunityHomeURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityHomeURL, "");
        return attrs;
    }

    /**
     * User&#039;s ID in Zimbra Community. When user IDs between Zimbra
     * Collaboraiton and Zimbra Community are not synchronized use this
     * attrribute to store the user&#039;s Zimbra Community ID. In order for
     * this attribute to be used for SSO zimbraCommunityUsernameMapping has
     * to be set to zimbraCommunityID.
     *
     * @return zimbraCommunityID, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1644)
    public String getCommunityID() {
        return getAttr(Provisioning.A_zimbraCommunityID, null, true);
    }

    /**
     * User&#039;s ID in Zimbra Community. When user IDs between Zimbra
     * Collaboraiton and Zimbra Community are not synchronized use this
     * attrribute to store the user&#039;s Zimbra Community ID. In order for
     * this attribute to be used for SSO zimbraCommunityUsernameMapping has
     * to be set to zimbraCommunityID.
     *
     * @param zimbraCommunityID new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1644)
    public void setCommunityID(String zimbraCommunityID) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityID, zimbraCommunityID);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User&#039;s ID in Zimbra Community. When user IDs between Zimbra
     * Collaboraiton and Zimbra Community are not synchronized use this
     * attrribute to store the user&#039;s Zimbra Community ID. In order for
     * this attribute to be used for SSO zimbraCommunityUsernameMapping has
     * to be set to zimbraCommunityID.
     *
     * @param zimbraCommunityID new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1644)
    public Map<String,Object> setCommunityID(String zimbraCommunityID, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityID, zimbraCommunityID);
        return attrs;
    }

    /**
     * User&#039;s ID in Zimbra Community. When user IDs between Zimbra
     * Collaboraiton and Zimbra Community are not synchronized use this
     * attrribute to store the user&#039;s Zimbra Community ID. In order for
     * this attribute to be used for SSO zimbraCommunityUsernameMapping has
     * to be set to zimbraCommunityID.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1644)
    public void unsetCommunityID() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityID, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User&#039;s ID in Zimbra Community. When user IDs between Zimbra
     * Collaboraiton and Zimbra Community are not synchronized use this
     * attrribute to store the user&#039;s Zimbra Community ID. In order for
     * this attribute to be used for SSO zimbraCommunityUsernameMapping has
     * to be set to zimbraCommunityID.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1644)
    public Map<String,Object> unsetCommunityID(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityID, "");
        return attrs;
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @return zimbraCommunityUsernameMapping, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public String getCommunityUsernameMapping() {
        return getAttr(Provisioning.A_zimbraCommunityUsernameMapping, null, true);
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @param zimbraCommunityUsernameMapping new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public void setCommunityUsernameMapping(String zimbraCommunityUsernameMapping) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityUsernameMapping, zimbraCommunityUsernameMapping);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @param zimbraCommunityUsernameMapping new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public Map<String,Object> setCommunityUsernameMapping(String zimbraCommunityUsernameMapping, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityUsernameMapping, zimbraCommunityUsernameMapping);
        return attrs;
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public void unsetCommunityUsernameMapping() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityUsernameMapping, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public Map<String,Object> unsetCommunityUsernameMapping(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityUsernameMapping, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.7. deprecated in favor of
     * zimbraContactEmailFields, for bug 45475. Orig desc: Comma separates
     * list of attributes in contact object to search for email addresses
     * when generating auto-complete contact list. The same set of fields are
     * used for GAL contacts as well because LDAP attributes for GAL objects
     * are mapped to Contact compatible attributes via zimbraGalLdapAttrMap.
     *
     * @return zimbraContactAutoCompleteEmailFields, or "email,email2,email3,workEmail1,workEmail2,workEmail3" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=760)
    public String getContactAutoCompleteEmailFields() {
        return getAttr(Provisioning.A_zimbraContactAutoCompleteEmailFields, "email,email2,email3,workEmail1,workEmail2,workEmail3", true);
    }

    /**
     * Deprecated since: 6.0.7. deprecated in favor of
     * zimbraContactEmailFields, for bug 45475. Orig desc: Comma separates
     * list of attributes in contact object to search for email addresses
     * when generating auto-complete contact list. The same set of fields are
     * used for GAL contacts as well because LDAP attributes for GAL objects
     * are mapped to Contact compatible attributes via zimbraGalLdapAttrMap.
     *
     * @param zimbraContactAutoCompleteEmailFields new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=760)
    public void setContactAutoCompleteEmailFields(String zimbraContactAutoCompleteEmailFields) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactAutoCompleteEmailFields, zimbraContactAutoCompleteEmailFields);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.7. deprecated in favor of
     * zimbraContactEmailFields, for bug 45475. Orig desc: Comma separates
     * list of attributes in contact object to search for email addresses
     * when generating auto-complete contact list. The same set of fields are
     * used for GAL contacts as well because LDAP attributes for GAL objects
     * are mapped to Contact compatible attributes via zimbraGalLdapAttrMap.
     *
     * @param zimbraContactAutoCompleteEmailFields new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=760)
    public Map<String,Object> setContactAutoCompleteEmailFields(String zimbraContactAutoCompleteEmailFields, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactAutoCompleteEmailFields, zimbraContactAutoCompleteEmailFields);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.7. deprecated in favor of
     * zimbraContactEmailFields, for bug 45475. Orig desc: Comma separates
     * list of attributes in contact object to search for email addresses
     * when generating auto-complete contact list. The same set of fields are
     * used for GAL contacts as well because LDAP attributes for GAL objects
     * are mapped to Contact compatible attributes via zimbraGalLdapAttrMap.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=760)
    public void unsetContactAutoCompleteEmailFields() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactAutoCompleteEmailFields, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.7. deprecated in favor of
     * zimbraContactEmailFields, for bug 45475. Orig desc: Comma separates
     * list of attributes in contact object to search for email addresses
     * when generating auto-complete contact list. The same set of fields are
     * used for GAL contacts as well because LDAP attributes for GAL objects
     * are mapped to Contact compatible attributes via zimbraGalLdapAttrMap.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=760)
    public Map<String,Object> unsetContactAutoCompleteEmailFields(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactAutoCompleteEmailFields, "");
        return attrs;
    }

    /**
     * maximum number of contact entries to return from an auto complete
     *
     * @return zimbraContactAutoCompleteMaxResults, or 20 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=827)
    public int getContactAutoCompleteMaxResults() {
        return getIntAttr(Provisioning.A_zimbraContactAutoCompleteMaxResults, 20, true);
    }

    /**
     * maximum number of contact entries to return from an auto complete
     *
     * @param zimbraContactAutoCompleteMaxResults new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=827)
    public void setContactAutoCompleteMaxResults(int zimbraContactAutoCompleteMaxResults) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactAutoCompleteMaxResults, Integer.toString(zimbraContactAutoCompleteMaxResults));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of contact entries to return from an auto complete
     *
     * @param zimbraContactAutoCompleteMaxResults new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=827)
    public Map<String,Object> setContactAutoCompleteMaxResults(int zimbraContactAutoCompleteMaxResults, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactAutoCompleteMaxResults, Integer.toString(zimbraContactAutoCompleteMaxResults));
        return attrs;
    }

    /**
     * maximum number of contact entries to return from an auto complete
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=827)
    public void unsetContactAutoCompleteMaxResults() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactAutoCompleteMaxResults, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of contact entries to return from an auto complete
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=827)
    public Map<String,Object> unsetContactAutoCompleteMaxResults(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactAutoCompleteMaxResults, "");
        return attrs;
    }

    /**
     * Comma separates list of attributes in contact object to search for
     * email addresses when generating auto-complete contact list. The same
     * set of fields are used for GAL contacts as well because LDAP
     * attributes for GAL objects are mapped to Contact compatible attributes
     * via zimbraGalLdapAttrMap.
     *
     * @return zimbraContactEmailFields, or "email,email2,email3,email4,email5,email6,email7,email8,email9,email10,workEmail1,workEmail2,workEmail3" if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1088)
    public String getContactEmailFields() {
        return getAttr(Provisioning.A_zimbraContactEmailFields, "email,email2,email3,email4,email5,email6,email7,email8,email9,email10,workEmail1,workEmail2,workEmail3", true);
    }

    /**
     * Comma separates list of attributes in contact object to search for
     * email addresses when generating auto-complete contact list. The same
     * set of fields are used for GAL contacts as well because LDAP
     * attributes for GAL objects are mapped to Contact compatible attributes
     * via zimbraGalLdapAttrMap.
     *
     * @param zimbraContactEmailFields new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1088)
    public void setContactEmailFields(String zimbraContactEmailFields) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactEmailFields, zimbraContactEmailFields);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Comma separates list of attributes in contact object to search for
     * email addresses when generating auto-complete contact list. The same
     * set of fields are used for GAL contacts as well because LDAP
     * attributes for GAL objects are mapped to Contact compatible attributes
     * via zimbraGalLdapAttrMap.
     *
     * @param zimbraContactEmailFields new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1088)
    public Map<String,Object> setContactEmailFields(String zimbraContactEmailFields, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactEmailFields, zimbraContactEmailFields);
        return attrs;
    }

    /**
     * Comma separates list of attributes in contact object to search for
     * email addresses when generating auto-complete contact list. The same
     * set of fields are used for GAL contacts as well because LDAP
     * attributes for GAL objects are mapped to Contact compatible attributes
     * via zimbraGalLdapAttrMap.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1088)
    public void unsetContactEmailFields() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactEmailFields, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Comma separates list of attributes in contact object to search for
     * email addresses when generating auto-complete contact list. The same
     * set of fields are used for GAL contacts as well because LDAP
     * attributes for GAL objects are mapped to Contact compatible attributes
     * via zimbraGalLdapAttrMap.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1088)
    public Map<String,Object> unsetContactEmailFields(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactEmailFields, "");
        return attrs;
    }

    /**
     * Maximum number of contacts allowed in mailbox. 0 means no limit.
     *
     * @return zimbraContactMaxNumEntries, or 10000 if unset
     */
    @ZAttr(id=107)
    public int getContactMaxNumEntries() {
        return getIntAttr(Provisioning.A_zimbraContactMaxNumEntries, 10000, true);
    }

    /**
     * Maximum number of contacts allowed in mailbox. 0 means no limit.
     *
     * @param zimbraContactMaxNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=107)
    public void setContactMaxNumEntries(int zimbraContactMaxNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactMaxNumEntries, Integer.toString(zimbraContactMaxNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of contacts allowed in mailbox. 0 means no limit.
     *
     * @param zimbraContactMaxNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=107)
    public Map<String,Object> setContactMaxNumEntries(int zimbraContactMaxNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactMaxNumEntries, Integer.toString(zimbraContactMaxNumEntries));
        return attrs;
    }

    /**
     * Maximum number of contacts allowed in mailbox. 0 means no limit.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=107)
    public void unsetContactMaxNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactMaxNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of contacts allowed in mailbox. 0 means no limit.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=107)
    public Map<String,Object> unsetContactMaxNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactMaxNumEntries, "");
        return attrs;
    }

    /**
     * Size of the contact ranking table. Ranking table is used to keep track
     * of most heavily used contacts in outgoing email. Contacts in the
     * ranking table are given the priority when generating the auto-complete
     * contact list.
     *
     * @return zimbraContactRankingTableSize, or 200 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=758)
    public int getContactRankingTableSize() {
        return getIntAttr(Provisioning.A_zimbraContactRankingTableSize, 200, true);
    }

    /**
     * Size of the contact ranking table. Ranking table is used to keep track
     * of most heavily used contacts in outgoing email. Contacts in the
     * ranking table are given the priority when generating the auto-complete
     * contact list.
     *
     * @param zimbraContactRankingTableSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=758)
    public void setContactRankingTableSize(int zimbraContactRankingTableSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableSize, Integer.toString(zimbraContactRankingTableSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of the contact ranking table. Ranking table is used to keep track
     * of most heavily used contacts in outgoing email. Contacts in the
     * ranking table are given the priority when generating the auto-complete
     * contact list.
     *
     * @param zimbraContactRankingTableSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=758)
    public Map<String,Object> setContactRankingTableSize(int zimbraContactRankingTableSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableSize, Integer.toString(zimbraContactRankingTableSize));
        return attrs;
    }

    /**
     * Size of the contact ranking table. Ranking table is used to keep track
     * of most heavily used contacts in outgoing email. Contacts in the
     * ranking table are given the priority when generating the auto-complete
     * contact list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=758)
    public void unsetContactRankingTableSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Size of the contact ranking table. Ranking table is used to keep track
     * of most heavily used contacts in outgoing email. Contacts in the
     * ranking table are given the priority when generating the auto-complete
     * contact list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=758)
    public Map<String,Object> unsetContactRankingTableSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableSize, "");
        return attrs;
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @return zimbraConverterHints, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public String[] getConverterHints() {
        return getMultiAttr(Provisioning.A_zimbraConverterHints, true, true);
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @param zimbraConverterHints new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public void setConverterHints(String[] zimbraConverterHints) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConverterHints, zimbraConverterHints);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @param zimbraConverterHints new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public Map<String,Object> setConverterHints(String[] zimbraConverterHints, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConverterHints, zimbraConverterHints);
        return attrs;
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @param zimbraConverterHints new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public void addConverterHints(String zimbraConverterHints) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConverterHints, zimbraConverterHints);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @param zimbraConverterHints new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public Map<String,Object> addConverterHints(String zimbraConverterHints, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConverterHints, zimbraConverterHints);
        return attrs;
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @param zimbraConverterHints existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public void removeConverterHints(String zimbraConverterHints) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConverterHints, zimbraConverterHints);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @param zimbraConverterHints existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public Map<String,Object> removeConverterHints(String zimbraConverterHints, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConverterHints, zimbraConverterHints);
        return attrs;
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public void unsetConverterHints() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConverterHints, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allows converter hints to be supplied on the COS level. Can be used to
     * enable or disable some converters
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1441)
    public Map<String,Object> unsetConverterHints(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConverterHints, "");
        return attrs;
    }

    /**
     * time object was created
     *
     * <p>Use getCreateTimestampAsString to access value as a string.
     *
     * @see #getCreateTimestampAsString()
     *
     * @return zimbraCreateTimestamp as Date, null if unset or unable to parse
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Date getCreateTimestamp() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraCreateTimestamp, null, true);
    }

    /**
     * time object was created
     *
     * @return zimbraCreateTimestamp, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public String getCreateTimestampAsString() {
        return getAttr(Provisioning.A_zimbraCreateTimestamp, null, true);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void setCreateTimestamp(Date zimbraCreateTimestamp) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraCreateTimestamp));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> setCreateTimestamp(Date zimbraCreateTimestamp, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraCreateTimestamp));
        return attrs;
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void setCreateTimestampAsString(String zimbraCreateTimestamp) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> setCreateTimestampAsString(String zimbraCreateTimestamp, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp);
        return attrs;
    }

    /**
     * time object was created
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void unsetCreateTimestamp() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> unsetCreateTimestamp(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, "");
        return attrs;
    }

    /**
     * List of data associated with CSRF token for an account. The data
     * format is CSRF token data:Auth token Key crumb:Auth Token Key
     * expiration
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error on accessing ephemeral data
     *
     * @return zimbraCsrfTokenData, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1629)
    public String getCsrfTokenData(String dynamicComponent) throws com.zimbra.common.service.ServiceException {
        return getEphemeralAttr(Provisioning.A_zimbraCsrfTokenData, dynamicComponent).getValue(null);
    }

    /**
     * List of data associated with CSRF token for an account. The data
     * format is CSRF token data:Auth token Key crumb:Auth Token Key
     * expiration
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @param zimbraCsrfTokenData new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1629)
    public void addCsrfTokenData(String dynamicComponent, String zimbraCsrfTokenData, com.zimbra.cs.ephemeral.EphemeralInput.Expiration expiration) throws com.zimbra.common.service.ServiceException {
        modifyEphemeralAttr(Provisioning.A_zimbraCsrfTokenData, dynamicComponent, zimbraCsrfTokenData, true, expiration);
    }

    /**
     * List of data associated with CSRF token for an account. The data
     * format is CSRF token data:Auth token Key crumb:Auth Token Key
     * expiration
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @param zimbraCsrfTokenData existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1629)
    public void removeCsrfTokenData(String dynamicComponent, String zimbraCsrfTokenData) throws com.zimbra.common.service.ServiceException {
        deleteEphemeralAttr(Provisioning.A_zimbraCsrfTokenData, dynamicComponent, zimbraCsrfTokenData);
    }

    /**
     * List of data associated with CSRF token for an account. The data
     * format is CSRF token data:Auth token Key crumb:Auth Token Key
     * expiration
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1629)
    public boolean hasCsrfTokenData(String dynamicComponent) throws com.zimbra.common.service.ServiceException {
        return hasEphemeralAttr(Provisioning.A_zimbraCsrfTokenData, dynamicComponent);
    }

    /**
     * List of data associated with CSRF token for an account. The data
     * format is CSRF token data:Auth token Key crumb:Auth Token Key
     * expiration
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1629)
    public void purgeCsrfTokenData() throws com.zimbra.common.service.ServiceException {
        purgeEphemeralAttr(Provisioning.A_zimbraCsrfTokenData);
    }

    /**
     * set to 1 or 3 to specify customer care account tier level
     *
     * @return zimbraCustomerCareTier, or -1 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=605)
    public int getCustomerCareTier() {
        return getIntAttr(Provisioning.A_zimbraCustomerCareTier, -1, true);
    }

    /**
     * set to 1 or 3 to specify customer care account tier level
     *
     * @param zimbraCustomerCareTier new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=605)
    public void setCustomerCareTier(int zimbraCustomerCareTier) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCustomerCareTier, Integer.toString(zimbraCustomerCareTier));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to 1 or 3 to specify customer care account tier level
     *
     * @param zimbraCustomerCareTier new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=605)
    public Map<String,Object> setCustomerCareTier(int zimbraCustomerCareTier, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCustomerCareTier, Integer.toString(zimbraCustomerCareTier));
        return attrs;
    }

    /**
     * set to 1 or 3 to specify customer care account tier level
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=605)
    public void unsetCustomerCareTier() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCustomerCareTier, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to 1 or 3 to specify customer care account tier level
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=605)
    public Map<String,Object> unsetCustomerCareTier(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCustomerCareTier, "");
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Caldav data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDataSourceCaldavPollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourceCaldavPollingIntervalAsString()
     *
     * @return zimbraDataSourceCaldavPollingInterval in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=788)
    public long getDataSourceCaldavPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourceCaldavPollingInterval, -1L, true);
    }

    /**
     * The time interval between automated data imports for a Caldav data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDataSourceCaldavPollingInterval, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=788)
    public String getDataSourceCaldavPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceCaldavPollingInterval, null, true);
    }

    /**
     * The time interval between automated data imports for a Caldav data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceCaldavPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=788)
    public void setDataSourceCaldavPollingInterval(String zimbraDataSourceCaldavPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceCaldavPollingInterval, zimbraDataSourceCaldavPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Caldav data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceCaldavPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=788)
    public Map<String,Object> setDataSourceCaldavPollingInterval(String zimbraDataSourceCaldavPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceCaldavPollingInterval, zimbraDataSourceCaldavPollingInterval);
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Caldav data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=788)
    public void unsetDataSourceCaldavPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceCaldavPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Caldav data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=788)
    public Map<String,Object> unsetDataSourceCaldavPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceCaldavPollingInterval, "");
        return attrs;
    }

    /**
     * The time interval between automated data imports for a remote calendar
     * data source. If explicitly set to 0, the data source will not be
     * scheduled for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDataSourceCalendarPollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourceCalendarPollingIntervalAsString()
     *
     * @return zimbraDataSourceCalendarPollingInterval in millseconds, or 43200000 (12h)  if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=819)
    public long getDataSourceCalendarPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourceCalendarPollingInterval, 43200000L, true);
    }

    /**
     * The time interval between automated data imports for a remote calendar
     * data source. If explicitly set to 0, the data source will not be
     * scheduled for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDataSourceCalendarPollingInterval, or "12h" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=819)
    public String getDataSourceCalendarPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceCalendarPollingInterval, "12h", true);
    }

    /**
     * The time interval between automated data imports for a remote calendar
     * data source. If explicitly set to 0, the data source will not be
     * scheduled for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceCalendarPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=819)
    public void setDataSourceCalendarPollingInterval(String zimbraDataSourceCalendarPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceCalendarPollingInterval, zimbraDataSourceCalendarPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a remote calendar
     * data source. If explicitly set to 0, the data source will not be
     * scheduled for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceCalendarPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=819)
    public Map<String,Object> setDataSourceCalendarPollingInterval(String zimbraDataSourceCalendarPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceCalendarPollingInterval, zimbraDataSourceCalendarPollingInterval);
        return attrs;
    }

    /**
     * The time interval between automated data imports for a remote calendar
     * data source. If explicitly set to 0, the data source will not be
     * scheduled for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=819)
    public void unsetDataSourceCalendarPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceCalendarPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a remote calendar
     * data source. If explicitly set to 0, the data source will not be
     * scheduled for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=819)
    public Map<String,Object> unsetDataSourceCalendarPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceCalendarPollingInterval, "");
        return attrs;
    }

    /**
     * The time interval between automated data imports for a GAL data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDataSourceGalPollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourceGalPollingIntervalAsString()
     *
     * @return zimbraDataSourceGalPollingInterval in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=826)
    public long getDataSourceGalPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourceGalPollingInterval, -1L, true);
    }

    /**
     * The time interval between automated data imports for a GAL data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDataSourceGalPollingInterval, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=826)
    public String getDataSourceGalPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceGalPollingInterval, null, true);
    }

    /**
     * The time interval between automated data imports for a GAL data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceGalPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=826)
    public void setDataSourceGalPollingInterval(String zimbraDataSourceGalPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceGalPollingInterval, zimbraDataSourceGalPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a GAL data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceGalPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=826)
    public Map<String,Object> setDataSourceGalPollingInterval(String zimbraDataSourceGalPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceGalPollingInterval, zimbraDataSourceGalPollingInterval);
        return attrs;
    }

    /**
     * The time interval between automated data imports for a GAL data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=826)
    public void unsetDataSourceGalPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceGalPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a GAL data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=826)
    public Map<String,Object> unsetDataSourceGalPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceGalPollingInterval, "");
        return attrs;
    }

    /**
     * The time interval between automated data imports for an Imap data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDataSourceImapPollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourceImapPollingIntervalAsString()
     *
     * @return zimbraDataSourceImapPollingInterval in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=768)
    public long getDataSourceImapPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourceImapPollingInterval, -1L, true);
    }

    /**
     * The time interval between automated data imports for an Imap data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDataSourceImapPollingInterval, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=768)
    public String getDataSourceImapPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceImapPollingInterval, null, true);
    }

    /**
     * The time interval between automated data imports for an Imap data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceImapPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=768)
    public void setDataSourceImapPollingInterval(String zimbraDataSourceImapPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceImapPollingInterval, zimbraDataSourceImapPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for an Imap data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceImapPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=768)
    public Map<String,Object> setDataSourceImapPollingInterval(String zimbraDataSourceImapPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceImapPollingInterval, zimbraDataSourceImapPollingInterval);
        return attrs;
    }

    /**
     * The time interval between automated data imports for an Imap data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=768)
    public void unsetDataSourceImapPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceImapPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for an Imap data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=768)
    public Map<String,Object> unsetDataSourceImapPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceImapPollingInterval, "");
        return attrs;
    }

    /**
     * whether to invoke data imports for all data sources owned by an
     * account after successful user login from the login page
     *
     * @return zimbraDataSourceImportOnLogin, or false if unset
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1418)
    public boolean isDataSourceImportOnLogin() {
        return getBooleanAttr(Provisioning.A_zimbraDataSourceImportOnLogin, false, true);
    }

    /**
     * whether to invoke data imports for all data sources owned by an
     * account after successful user login from the login page
     *
     * @param zimbraDataSourceImportOnLogin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1418)
    public void setDataSourceImportOnLogin(boolean zimbraDataSourceImportOnLogin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceImportOnLogin, zimbraDataSourceImportOnLogin ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to invoke data imports for all data sources owned by an
     * account after successful user login from the login page
     *
     * @param zimbraDataSourceImportOnLogin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1418)
    public Map<String,Object> setDataSourceImportOnLogin(boolean zimbraDataSourceImportOnLogin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceImportOnLogin, zimbraDataSourceImportOnLogin ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to invoke data imports for all data sources owned by an
     * account after successful user login from the login page
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1418)
    public void unsetDataSourceImportOnLogin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceImportOnLogin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to invoke data imports for all data sources owned by an
     * account after successful user login from the login page
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1418)
    public Map<String,Object> unsetDataSourceImportOnLogin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceImportOnLogin, "");
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Live data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDataSourceLivePollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourceLivePollingIntervalAsString()
     *
     * @return zimbraDataSourceLivePollingInterval in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=769)
    public long getDataSourceLivePollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourceLivePollingInterval, -1L, true);
    }

    /**
     * The time interval between automated data imports for a Live data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDataSourceLivePollingInterval, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=769)
    public String getDataSourceLivePollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceLivePollingInterval, null, true);
    }

    /**
     * The time interval between automated data imports for a Live data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceLivePollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=769)
    public void setDataSourceLivePollingInterval(String zimbraDataSourceLivePollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceLivePollingInterval, zimbraDataSourceLivePollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Live data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceLivePollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=769)
    public Map<String,Object> setDataSourceLivePollingInterval(String zimbraDataSourceLivePollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceLivePollingInterval, zimbraDataSourceLivePollingInterval);
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Live data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=769)
    public void unsetDataSourceLivePollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceLivePollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Live data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=769)
    public Map<String,Object> unsetDataSourceLivePollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceLivePollingInterval, "");
        return attrs;
    }

    /**
     * Maximum number of data sources allowed on an account
     *
     * @return zimbraDataSourceMaxNumEntries, or 20 if unset
     */
    @ZAttr(id=426)
    public int getDataSourceMaxNumEntries() {
        return getIntAttr(Provisioning.A_zimbraDataSourceMaxNumEntries, 20, true);
    }

    /**
     * Maximum number of data sources allowed on an account
     *
     * @param zimbraDataSourceMaxNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=426)
    public void setDataSourceMaxNumEntries(int zimbraDataSourceMaxNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceMaxNumEntries, Integer.toString(zimbraDataSourceMaxNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of data sources allowed on an account
     *
     * @param zimbraDataSourceMaxNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=426)
    public Map<String,Object> setDataSourceMaxNumEntries(int zimbraDataSourceMaxNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceMaxNumEntries, Integer.toString(zimbraDataSourceMaxNumEntries));
        return attrs;
    }

    /**
     * Maximum number of data sources allowed on an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=426)
    public void unsetDataSourceMaxNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceMaxNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of data sources allowed on an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=426)
    public Map<String,Object> unsetDataSourceMaxNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceMaxNumEntries, "");
        return attrs;
    }

    /**
     * Shortest allowed duration for zimbraDataSourcePollingInterval.. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getDataSourceMinPollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourceMinPollingIntervalAsString()
     *
     * @return zimbraDataSourceMinPollingInterval in millseconds, or 60000 (1m)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=525)
    public long getDataSourceMinPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourceMinPollingInterval, 60000L, true);
    }

    /**
     * Shortest allowed duration for zimbraDataSourcePollingInterval.. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraDataSourceMinPollingInterval, or "1m" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=525)
    public String getDataSourceMinPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceMinPollingInterval, "1m", true);
    }

    /**
     * Shortest allowed duration for zimbraDataSourcePollingInterval.. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraDataSourceMinPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=525)
    public void setDataSourceMinPollingInterval(String zimbraDataSourceMinPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceMinPollingInterval, zimbraDataSourceMinPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shortest allowed duration for zimbraDataSourcePollingInterval.. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraDataSourceMinPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=525)
    public Map<String,Object> setDataSourceMinPollingInterval(String zimbraDataSourceMinPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceMinPollingInterval, zimbraDataSourceMinPollingInterval);
        return attrs;
    }

    /**
     * Shortest allowed duration for zimbraDataSourcePollingInterval.. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=525)
    public void unsetDataSourceMinPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceMinPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shortest allowed duration for zimbraDataSourcePollingInterval.. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=525)
    public Map<String,Object> unsetDataSourceMinPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceMinPollingInterval, "");
        return attrs;
    }

    /**
     * Prior to 6.0.0: The time interval between automated data imports for a
     * data source, or all data sources owned by an account. If unset or 0,
     * the data source will not be scheduled for automated polling. Since
     * 6.0.0: Deprecated on account/cos since 6.0.0. Values on account/cos
     * are migrated to protocol specific
     * zimbraDataSource{proto}PollingInterval attributes. 1. if
     * zimbraDataSourcePollingInterval is set on data source, use it 2.
     * otherwise use the zimbraDataSource{Proto}PollingInterval on
     * account/cos 3. if zimbraDataSource{Proto}PollingInterval is not set on
     * account/cos, use the attribute&#039;s default if one is specified. See
     * individual attribute descriptions for defaults. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getDataSourcePollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourcePollingIntervalAsString()
     *
     * @return zimbraDataSourcePollingInterval in millseconds, or -1 if unset
     */
    @ZAttr(id=455)
    public long getDataSourcePollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourcePollingInterval, -1L, true);
    }

    /**
     * Prior to 6.0.0: The time interval between automated data imports for a
     * data source, or all data sources owned by an account. If unset or 0,
     * the data source will not be scheduled for automated polling. Since
     * 6.0.0: Deprecated on account/cos since 6.0.0. Values on account/cos
     * are migrated to protocol specific
     * zimbraDataSource{proto}PollingInterval attributes. 1. if
     * zimbraDataSourcePollingInterval is set on data source, use it 2.
     * otherwise use the zimbraDataSource{Proto}PollingInterval on
     * account/cos 3. if zimbraDataSource{Proto}PollingInterval is not set on
     * account/cos, use the attribute&#039;s default if one is specified. See
     * individual attribute descriptions for defaults. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraDataSourcePollingInterval, or null if unset
     */
    @ZAttr(id=455)
    public String getDataSourcePollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourcePollingInterval, null, true);
    }

    /**
     * Prior to 6.0.0: The time interval between automated data imports for a
     * data source, or all data sources owned by an account. If unset or 0,
     * the data source will not be scheduled for automated polling. Since
     * 6.0.0: Deprecated on account/cos since 6.0.0. Values on account/cos
     * are migrated to protocol specific
     * zimbraDataSource{proto}PollingInterval attributes. 1. if
     * zimbraDataSourcePollingInterval is set on data source, use it 2.
     * otherwise use the zimbraDataSource{Proto}PollingInterval on
     * account/cos 3. if zimbraDataSource{Proto}PollingInterval is not set on
     * account/cos, use the attribute&#039;s default if one is specified. See
     * individual attribute descriptions for defaults. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraDataSourcePollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=455)
    public void setDataSourcePollingInterval(String zimbraDataSourcePollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourcePollingInterval, zimbraDataSourcePollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prior to 6.0.0: The time interval between automated data imports for a
     * data source, or all data sources owned by an account. If unset or 0,
     * the data source will not be scheduled for automated polling. Since
     * 6.0.0: Deprecated on account/cos since 6.0.0. Values on account/cos
     * are migrated to protocol specific
     * zimbraDataSource{proto}PollingInterval attributes. 1. if
     * zimbraDataSourcePollingInterval is set on data source, use it 2.
     * otherwise use the zimbraDataSource{Proto}PollingInterval on
     * account/cos 3. if zimbraDataSource{Proto}PollingInterval is not set on
     * account/cos, use the attribute&#039;s default if one is specified. See
     * individual attribute descriptions for defaults. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraDataSourcePollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=455)
    public Map<String,Object> setDataSourcePollingInterval(String zimbraDataSourcePollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourcePollingInterval, zimbraDataSourcePollingInterval);
        return attrs;
    }

    /**
     * Prior to 6.0.0: The time interval between automated data imports for a
     * data source, or all data sources owned by an account. If unset or 0,
     * the data source will not be scheduled for automated polling. Since
     * 6.0.0: Deprecated on account/cos since 6.0.0. Values on account/cos
     * are migrated to protocol specific
     * zimbraDataSource{proto}PollingInterval attributes. 1. if
     * zimbraDataSourcePollingInterval is set on data source, use it 2.
     * otherwise use the zimbraDataSource{Proto}PollingInterval on
     * account/cos 3. if zimbraDataSource{Proto}PollingInterval is not set on
     * account/cos, use the attribute&#039;s default if one is specified. See
     * individual attribute descriptions for defaults. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=455)
    public void unsetDataSourcePollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourcePollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prior to 6.0.0: The time interval between automated data imports for a
     * data source, or all data sources owned by an account. If unset or 0,
     * the data source will not be scheduled for automated polling. Since
     * 6.0.0: Deprecated on account/cos since 6.0.0. Values on account/cos
     * are migrated to protocol specific
     * zimbraDataSource{proto}PollingInterval attributes. 1. if
     * zimbraDataSourcePollingInterval is set on data source, use it 2.
     * otherwise use the zimbraDataSource{Proto}PollingInterval on
     * account/cos 3. if zimbraDataSource{Proto}PollingInterval is not set on
     * account/cos, use the attribute&#039;s default if one is specified. See
     * individual attribute descriptions for defaults. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=455)
    public Map<String,Object> unsetDataSourcePollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourcePollingInterval, "");
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Pop3 data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDataSourcePop3PollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourcePop3PollingIntervalAsString()
     *
     * @return zimbraDataSourcePop3PollingInterval in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=767)
    public long getDataSourcePop3PollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourcePop3PollingInterval, -1L, true);
    }

    /**
     * The time interval between automated data imports for a Pop3 data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDataSourcePop3PollingInterval, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=767)
    public String getDataSourcePop3PollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourcePop3PollingInterval, null, true);
    }

    /**
     * The time interval between automated data imports for a Pop3 data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourcePop3PollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=767)
    public void setDataSourcePop3PollingInterval(String zimbraDataSourcePop3PollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourcePop3PollingInterval, zimbraDataSourcePop3PollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Pop3 data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourcePop3PollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=767)
    public Map<String,Object> setDataSourcePop3PollingInterval(String zimbraDataSourcePop3PollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourcePop3PollingInterval, zimbraDataSourcePop3PollingInterval);
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Pop3 data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=767)
    public void unsetDataSourcePop3PollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourcePop3PollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Pop3 data
     * source. If unset or 0, the data source will not be scheduled for
     * automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=767)
    public Map<String,Object> unsetDataSourcePop3PollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourcePop3PollingInterval, "");
        return attrs;
    }

    /**
     * Quota allotted to each data source
     *
     * @return zimbraDataSourceQuota, or 0 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2015)
    public long getDataSourceQuota() {
        return getLongAttr(Provisioning.A_zimbraDataSourceQuota, 0L, true);
    }

    /**
     * Quota allotted to each data source
     *
     * @param zimbraDataSourceQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2015)
    public void setDataSourceQuota(long zimbraDataSourceQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceQuota, Long.toString(zimbraDataSourceQuota));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Quota allotted to each data source
     *
     * @param zimbraDataSourceQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2015)
    public Map<String,Object> setDataSourceQuota(long zimbraDataSourceQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceQuota, Long.toString(zimbraDataSourceQuota));
        return attrs;
    }

    /**
     * Quota allotted to each data source
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2015)
    public void unsetDataSourceQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Quota allotted to each data source
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2015)
    public Map<String,Object> unsetDataSourceQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceQuota, "");
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Rss data
     * source. If explicitly set to 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDataSourceRssPollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourceRssPollingIntervalAsString()
     *
     * @return zimbraDataSourceRssPollingInterval in millseconds, or 43200000 (12h)  if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=770)
    public long getDataSourceRssPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourceRssPollingInterval, 43200000L, true);
    }

    /**
     * The time interval between automated data imports for a Rss data
     * source. If explicitly set to 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDataSourceRssPollingInterval, or "12h" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=770)
    public String getDataSourceRssPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceRssPollingInterval, "12h", true);
    }

    /**
     * The time interval between automated data imports for a Rss data
     * source. If explicitly set to 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceRssPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=770)
    public void setDataSourceRssPollingInterval(String zimbraDataSourceRssPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceRssPollingInterval, zimbraDataSourceRssPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Rss data
     * source. If explicitly set to 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceRssPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=770)
    public Map<String,Object> setDataSourceRssPollingInterval(String zimbraDataSourceRssPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceRssPollingInterval, zimbraDataSourceRssPollingInterval);
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Rss data
     * source. If explicitly set to 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=770)
    public void unsetDataSourceRssPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceRssPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Rss data
     * source. If explicitly set to 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=770)
    public Map<String,Object> unsetDataSourceRssPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceRssPollingInterval, "");
        return attrs;
    }

    /**
     * Quota allotted to all data sources
     *
     * @return zimbraDataSourceTotalQuota, or 0 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2016)
    public long getDataSourceTotalQuota() {
        return getLongAttr(Provisioning.A_zimbraDataSourceTotalQuota, 0L, true);
    }

    /**
     * Quota allotted to all data sources
     *
     * @param zimbraDataSourceTotalQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2016)
    public void setDataSourceTotalQuota(long zimbraDataSourceTotalQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceTotalQuota, Long.toString(zimbraDataSourceTotalQuota));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Quota allotted to all data sources
     *
     * @param zimbraDataSourceTotalQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2016)
    public Map<String,Object> setDataSourceTotalQuota(long zimbraDataSourceTotalQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceTotalQuota, Long.toString(zimbraDataSourceTotalQuota));
        return attrs;
    }

    /**
     * Quota allotted to all data sources
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2016)
    public void unsetDataSourceTotalQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceTotalQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Quota allotted to all data sources
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2016)
    public Map<String,Object> unsetDataSourceTotalQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceTotalQuota, "");
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Yahoo address
     * book data source. If unset or 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDataSourceYabPollingIntervalAsString to access value as a string.
     *
     * @see #getDataSourceYabPollingIntervalAsString()
     *
     * @return zimbraDataSourceYabPollingInterval in millseconds, or -1 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=789)
    public long getDataSourceYabPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraDataSourceYabPollingInterval, -1L, true);
    }

    /**
     * The time interval between automated data imports for a Yahoo address
     * book data source. If unset or 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDataSourceYabPollingInterval, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=789)
    public String getDataSourceYabPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceYabPollingInterval, null, true);
    }

    /**
     * The time interval between automated data imports for a Yahoo address
     * book data source. If unset or 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceYabPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=789)
    public void setDataSourceYabPollingInterval(String zimbraDataSourceYabPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceYabPollingInterval, zimbraDataSourceYabPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Yahoo address
     * book data source. If unset or 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDataSourceYabPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=789)
    public Map<String,Object> setDataSourceYabPollingInterval(String zimbraDataSourceYabPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceYabPollingInterval, zimbraDataSourceYabPollingInterval);
        return attrs;
    }

    /**
     * The time interval between automated data imports for a Yahoo address
     * book data source. If unset or 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=789)
    public void unsetDataSourceYabPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceYabPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The time interval between automated data imports for a Yahoo address
     * book data source. If unset or 0, the data source will not be scheduled
     * for automated polling. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=789)
    public Map<String,Object> unsetDataSourceYabPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceYabPollingInterval, "");
        return attrs;
    }

    /**
     * For selective enabling of debug logging
     *
     * @return zimbraDebugInfo, or empty array if unset
     */
    @ZAttr(id=365)
    public String[] getDebugInfo() {
        return getMultiAttr(Provisioning.A_zimbraDebugInfo, true, true);
    }

    /**
     * For selective enabling of debug logging
     *
     * @param zimbraDebugInfo new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=365)
    public void setDebugInfo(String[] zimbraDebugInfo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDebugInfo, zimbraDebugInfo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For selective enabling of debug logging
     *
     * @param zimbraDebugInfo new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=365)
    public Map<String,Object> setDebugInfo(String[] zimbraDebugInfo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDebugInfo, zimbraDebugInfo);
        return attrs;
    }

    /**
     * For selective enabling of debug logging
     *
     * @param zimbraDebugInfo new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=365)
    public void addDebugInfo(String zimbraDebugInfo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDebugInfo, zimbraDebugInfo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For selective enabling of debug logging
     *
     * @param zimbraDebugInfo new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=365)
    public Map<String,Object> addDebugInfo(String zimbraDebugInfo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDebugInfo, zimbraDebugInfo);
        return attrs;
    }

    /**
     * For selective enabling of debug logging
     *
     * @param zimbraDebugInfo existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=365)
    public void removeDebugInfo(String zimbraDebugInfo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDebugInfo, zimbraDebugInfo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For selective enabling of debug logging
     *
     * @param zimbraDebugInfo existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=365)
    public Map<String,Object> removeDebugInfo(String zimbraDebugInfo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDebugInfo, zimbraDebugInfo);
        return attrs;
    }

    /**
     * For selective enabling of debug logging
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=365)
    public void unsetDebugInfo() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDebugInfo, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For selective enabling of debug logging
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=365)
    public Map<String,Object> unsetDebugInfo(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDebugInfo, "");
        return attrs;
    }

    /**
     * Default flags on folder. These are set when a new folder is created,
     * has no effect on existing folders. Possible values are: * -
     * \Subscribed b - \ExcludeFB # - \Checked i - \NoInherit y - \SyncFolder
     * ~ - \Sync o - \Noinferiors g - \Global
     *
     * @return zimbraDefaultFolderFlags, or null if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1210)
    public String getDefaultFolderFlags() {
        return getAttr(Provisioning.A_zimbraDefaultFolderFlags, null, true);
    }

    /**
     * Default flags on folder. These are set when a new folder is created,
     * has no effect on existing folders. Possible values are: * -
     * \Subscribed b - \ExcludeFB # - \Checked i - \NoInherit y - \SyncFolder
     * ~ - \Sync o - \Noinferiors g - \Global
     *
     * @param zimbraDefaultFolderFlags new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1210)
    public void setDefaultFolderFlags(String zimbraDefaultFolderFlags) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultFolderFlags, zimbraDefaultFolderFlags);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default flags on folder. These are set when a new folder is created,
     * has no effect on existing folders. Possible values are: * -
     * \Subscribed b - \ExcludeFB # - \Checked i - \NoInherit y - \SyncFolder
     * ~ - \Sync o - \Noinferiors g - \Global
     *
     * @param zimbraDefaultFolderFlags new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1210)
    public Map<String,Object> setDefaultFolderFlags(String zimbraDefaultFolderFlags, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultFolderFlags, zimbraDefaultFolderFlags);
        return attrs;
    }

    /**
     * Default flags on folder. These are set when a new folder is created,
     * has no effect on existing folders. Possible values are: * -
     * \Subscribed b - \ExcludeFB # - \Checked i - \NoInherit y - \SyncFolder
     * ~ - \Sync o - \Noinferiors g - \Global
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1210)
    public void unsetDefaultFolderFlags() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultFolderFlags, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default flags on folder. These are set when a new folder is created,
     * has no effect on existing folders. Possible values are: * -
     * \Subscribed b - \ExcludeFB # - \Checked i - \NoInherit y - \SyncFolder
     * ~ - \Sync o - \Noinferiors g - \Global
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1210)
    public Map<String,Object> unsetDefaultFolderFlags(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultFolderFlags, "");
        return attrs;
    }

    /**
     * allowed passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDeviceAllowedPasscodeLockoutDuration, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1397)
    public String[] getDeviceAllowedPasscodeLockoutDurationAsString() {
        String[] value = getMultiAttr(Provisioning.A_zimbraDeviceAllowedPasscodeLockoutDuration, true, true); return value.length > 0 ? value : new String[] {"1m","2m","5m","10m","30m"};
    }

    /**
     * allowed passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDeviceAllowedPasscodeLockoutDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1397)
    public void setDeviceAllowedPasscodeLockoutDuration(String[] zimbraDeviceAllowedPasscodeLockoutDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceAllowedPasscodeLockoutDuration, zimbraDeviceAllowedPasscodeLockoutDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * allowed passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDeviceAllowedPasscodeLockoutDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1397)
    public Map<String,Object> setDeviceAllowedPasscodeLockoutDuration(String[] zimbraDeviceAllowedPasscodeLockoutDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceAllowedPasscodeLockoutDuration, zimbraDeviceAllowedPasscodeLockoutDuration);
        return attrs;
    }

    /**
     * allowed passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1397)
    public void unsetDeviceAllowedPasscodeLockoutDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceAllowedPasscodeLockoutDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * allowed passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1397)
    public Map<String,Object> unsetDeviceAllowedPasscodeLockoutDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceAllowedPasscodeLockoutDuration, "");
        return attrs;
    }

    /**
     * Regex to be matched for preventing devices from soft deletion of out
     * of range calendar items. Suppose device is set to sync calendar item
     * of 2 months range then server will ONLY send softdelete for out of
     * range (expired) calendar items, if device id DOES NOT match to the
     * regex provided.
     *
     * @return zimbraDeviceCalendarSoftDeleteExcludePattern, or null if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1450)
    public String getDeviceCalendarSoftDeleteExcludePattern() {
        return getAttr(Provisioning.A_zimbraDeviceCalendarSoftDeleteExcludePattern, null, true);
    }

    /**
     * Regex to be matched for preventing devices from soft deletion of out
     * of range calendar items. Suppose device is set to sync calendar item
     * of 2 months range then server will ONLY send softdelete for out of
     * range (expired) calendar items, if device id DOES NOT match to the
     * regex provided.
     *
     * @param zimbraDeviceCalendarSoftDeleteExcludePattern new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1450)
    public void setDeviceCalendarSoftDeleteExcludePattern(String zimbraDeviceCalendarSoftDeleteExcludePattern) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceCalendarSoftDeleteExcludePattern, zimbraDeviceCalendarSoftDeleteExcludePattern);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Regex to be matched for preventing devices from soft deletion of out
     * of range calendar items. Suppose device is set to sync calendar item
     * of 2 months range then server will ONLY send softdelete for out of
     * range (expired) calendar items, if device id DOES NOT match to the
     * regex provided.
     *
     * @param zimbraDeviceCalendarSoftDeleteExcludePattern new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1450)
    public Map<String,Object> setDeviceCalendarSoftDeleteExcludePattern(String zimbraDeviceCalendarSoftDeleteExcludePattern, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceCalendarSoftDeleteExcludePattern, zimbraDeviceCalendarSoftDeleteExcludePattern);
        return attrs;
    }

    /**
     * Regex to be matched for preventing devices from soft deletion of out
     * of range calendar items. Suppose device is set to sync calendar item
     * of 2 months range then server will ONLY send softdelete for out of
     * range (expired) calendar items, if device id DOES NOT match to the
     * regex provided.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1450)
    public void unsetDeviceCalendarSoftDeleteExcludePattern() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceCalendarSoftDeleteExcludePattern, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Regex to be matched for preventing devices from soft deletion of out
     * of range calendar items. Suppose device is set to sync calendar item
     * of 2 months range then server will ONLY send softdelete for out of
     * range (expired) calendar items, if device id DOES NOT match to the
     * regex provided.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1450)
    public Map<String,Object> unsetDeviceCalendarSoftDeleteExcludePattern(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceCalendarSoftDeleteExcludePattern, "");
        return attrs;
    }

    /**
     * Whether OpenWith feature is enabled on devices.
     *
     * @return zimbraDeviceFileOpenWithEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1400)
    public boolean isDeviceFileOpenWithEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraDeviceFileOpenWithEnabled, true, true);
    }

    /**
     * Whether OpenWith feature is enabled on devices.
     *
     * @param zimbraDeviceFileOpenWithEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1400)
    public void setDeviceFileOpenWithEnabled(boolean zimbraDeviceFileOpenWithEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceFileOpenWithEnabled, zimbraDeviceFileOpenWithEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether OpenWith feature is enabled on devices.
     *
     * @param zimbraDeviceFileOpenWithEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1400)
    public Map<String,Object> setDeviceFileOpenWithEnabled(boolean zimbraDeviceFileOpenWithEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceFileOpenWithEnabled, zimbraDeviceFileOpenWithEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether OpenWith feature is enabled on devices.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1400)
    public void unsetDeviceFileOpenWithEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceFileOpenWithEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether OpenWith feature is enabled on devices.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1400)
    public Map<String,Object> unsetDeviceFileOpenWithEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceFileOpenWithEnabled, "");
        return attrs;
    }

    /**
     * For native apps - whether to lock device when inactive.
     *
     * @return zimbraDeviceLockWhenInactive, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1399)
    public boolean isDeviceLockWhenInactive() {
        return getBooleanAttr(Provisioning.A_zimbraDeviceLockWhenInactive, false, true);
    }

    /**
     * For native apps - whether to lock device when inactive.
     *
     * @param zimbraDeviceLockWhenInactive new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1399)
    public void setDeviceLockWhenInactive(boolean zimbraDeviceLockWhenInactive) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceLockWhenInactive, zimbraDeviceLockWhenInactive ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For native apps - whether to lock device when inactive.
     *
     * @param zimbraDeviceLockWhenInactive new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1399)
    public Map<String,Object> setDeviceLockWhenInactive(boolean zimbraDeviceLockWhenInactive, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceLockWhenInactive, zimbraDeviceLockWhenInactive ? TRUE : FALSE);
        return attrs;
    }

    /**
     * For native apps - whether to lock device when inactive.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1399)
    public void unsetDeviceLockWhenInactive() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceLockWhenInactive, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For native apps - whether to lock device when inactive.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1399)
    public Map<String,Object> unsetDeviceLockWhenInactive(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceLockWhenInactive, "");
        return attrs;
    }

    /**
     * Whether offline reading of documents on device is allowed
     *
     * @return zimbraDeviceOfflineCacheEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1412)
    public boolean isDeviceOfflineCacheEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraDeviceOfflineCacheEnabled, false, true);
    }

    /**
     * Whether offline reading of documents on device is allowed
     *
     * @param zimbraDeviceOfflineCacheEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1412)
    public void setDeviceOfflineCacheEnabled(boolean zimbraDeviceOfflineCacheEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceOfflineCacheEnabled, zimbraDeviceOfflineCacheEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether offline reading of documents on device is allowed
     *
     * @param zimbraDeviceOfflineCacheEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1412)
    public Map<String,Object> setDeviceOfflineCacheEnabled(boolean zimbraDeviceOfflineCacheEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceOfflineCacheEnabled, zimbraDeviceOfflineCacheEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether offline reading of documents on device is allowed
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1412)
    public void unsetDeviceOfflineCacheEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceOfflineCacheEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether offline reading of documents on device is allowed
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1412)
    public Map<String,Object> unsetDeviceOfflineCacheEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDeviceOfflineCacheEnabled, "");
        return attrs;
    }

    /**
     * Whether device is password protected in native apps
     *
     * @return zimbraDevicePasscodeEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1396)
    public boolean isDevicePasscodeEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraDevicePasscodeEnabled, false, true);
    }

    /**
     * Whether device is password protected in native apps
     *
     * @param zimbraDevicePasscodeEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1396)
    public void setDevicePasscodeEnabled(boolean zimbraDevicePasscodeEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDevicePasscodeEnabled, zimbraDevicePasscodeEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether device is password protected in native apps
     *
     * @param zimbraDevicePasscodeEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1396)
    public Map<String,Object> setDevicePasscodeEnabled(boolean zimbraDevicePasscodeEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDevicePasscodeEnabled, zimbraDevicePasscodeEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether device is password protected in native apps
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1396)
    public void unsetDevicePasscodeEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDevicePasscodeEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether device is password protected in native apps
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1396)
    public Map<String,Object> unsetDevicePasscodeEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDevicePasscodeEnabled, "");
        return attrs;
    }

    /**
     * passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getDevicePasscodeLockoutDurationAsString to access value as a string.
     *
     * @see #getDevicePasscodeLockoutDurationAsString()
     *
     * @return zimbraDevicePasscodeLockoutDuration in millseconds, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1398)
    public long getDevicePasscodeLockoutDuration() {
        return getTimeInterval(Provisioning.A_zimbraDevicePasscodeLockoutDuration, -1L, true);
    }

    /**
     * passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraDevicePasscodeLockoutDuration, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1398)
    public String getDevicePasscodeLockoutDurationAsString() {
        return getAttr(Provisioning.A_zimbraDevicePasscodeLockoutDuration, null, true);
    }

    /**
     * passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDevicePasscodeLockoutDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1398)
    public void setDevicePasscodeLockoutDuration(String zimbraDevicePasscodeLockoutDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDevicePasscodeLockoutDuration, zimbraDevicePasscodeLockoutDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraDevicePasscodeLockoutDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1398)
    public Map<String,Object> setDevicePasscodeLockoutDuration(String zimbraDevicePasscodeLockoutDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDevicePasscodeLockoutDuration, zimbraDevicePasscodeLockoutDuration);
        return attrs;
    }

    /**
     * passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1398)
    public void unsetDevicePasscodeLockoutDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDevicePasscodeLockoutDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * passcode lockout duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1398)
    public Map<String,Object> unsetDevicePasscodeLockoutDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDevicePasscodeLockoutDuration, "");
        return attrs;
    }

    /**
     * Whether conversations are allowed to span multiple accounts. Every
     * time this attribute is changed, new messages that continue existing
     * conversation threads in imported accounts will no longer thread with
     * those conversations, and will instead start new ones.
     *
     * @return zimbraDisableCrossAccountConversationThreading, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2048)
    public boolean isDisableCrossAccountConversationThreading() {
        return getBooleanAttr(Provisioning.A_zimbraDisableCrossAccountConversationThreading, true, true);
    }

    /**
     * Whether conversations are allowed to span multiple accounts. Every
     * time this attribute is changed, new messages that continue existing
     * conversation threads in imported accounts will no longer thread with
     * those conversations, and will instead start new ones.
     *
     * @param zimbraDisableCrossAccountConversationThreading new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2048)
    public void setDisableCrossAccountConversationThreading(boolean zimbraDisableCrossAccountConversationThreading) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDisableCrossAccountConversationThreading, zimbraDisableCrossAccountConversationThreading ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether conversations are allowed to span multiple accounts. Every
     * time this attribute is changed, new messages that continue existing
     * conversation threads in imported accounts will no longer thread with
     * those conversations, and will instead start new ones.
     *
     * @param zimbraDisableCrossAccountConversationThreading new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2048)
    public Map<String,Object> setDisableCrossAccountConversationThreading(boolean zimbraDisableCrossAccountConversationThreading, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDisableCrossAccountConversationThreading, zimbraDisableCrossAccountConversationThreading ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether conversations are allowed to span multiple accounts. Every
     * time this attribute is changed, new messages that continue existing
     * conversation threads in imported accounts will no longer thread with
     * those conversations, and will instead start new ones.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2048)
    public void unsetDisableCrossAccountConversationThreading() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDisableCrossAccountConversationThreading, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether conversations are allowed to span multiple accounts. Every
     * time this attribute is changed, new messages that continue existing
     * conversation threads in imported accounts will no longer thread with
     * those conversations, and will instead start new ones.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2048)
    public Map<String,Object> unsetDisableCrossAccountConversationThreading(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDisableCrossAccountConversationThreading, "");
        return attrs;
    }

    /**
     * maximum amount of mail quota a domain admin can set on a user
     *
     * @return zimbraDomainAdminMaxMailQuota, or -1 if unset
     */
    @ZAttr(id=398)
    public long getDomainAdminMaxMailQuota() {
        return getLongAttr(Provisioning.A_zimbraDomainAdminMaxMailQuota, -1L, true);
    }

    /**
     * maximum amount of mail quota a domain admin can set on a user
     *
     * @param zimbraDomainAdminMaxMailQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=398)
    public void setDomainAdminMaxMailQuota(long zimbraDomainAdminMaxMailQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAdminMaxMailQuota, Long.toString(zimbraDomainAdminMaxMailQuota));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum amount of mail quota a domain admin can set on a user
     *
     * @param zimbraDomainAdminMaxMailQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=398)
    public Map<String,Object> setDomainAdminMaxMailQuota(long zimbraDomainAdminMaxMailQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAdminMaxMailQuota, Long.toString(zimbraDomainAdminMaxMailQuota));
        return attrs;
    }

    /**
     * maximum amount of mail quota a domain admin can set on a user
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=398)
    public void unsetDomainAdminMaxMailQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAdminMaxMailQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum amount of mail quota a domain admin can set on a user
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=398)
    public Map<String,Object> unsetDomainAdminMaxMailQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAdminMaxMailQuota, "");
        return attrs;
    }

    /**
     * enable/disable dumpster
     *
     * @return zimbraDumpsterEnabled, or false if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1128)
    public boolean isDumpsterEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraDumpsterEnabled, false, true);
    }

    /**
     * enable/disable dumpster
     *
     * @param zimbraDumpsterEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1128)
    public void setDumpsterEnabled(boolean zimbraDumpsterEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterEnabled, zimbraDumpsterEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable/disable dumpster
     *
     * @param zimbraDumpsterEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1128)
    public Map<String,Object> setDumpsterEnabled(boolean zimbraDumpsterEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterEnabled, zimbraDumpsterEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable/disable dumpster
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1128)
    public void unsetDumpsterEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable/disable dumpster
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1128)
    public Map<String,Object> unsetDumpsterEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterEnabled, "");
        return attrs;
    }

    /**
     * disables purging from dumpster when set to FALSE
     *
     * @return zimbraDumpsterPurgeEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1315)
    public boolean isDumpsterPurgeEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraDumpsterPurgeEnabled, true, true);
    }

    /**
     * disables purging from dumpster when set to FALSE
     *
     * @param zimbraDumpsterPurgeEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1315)
    public void setDumpsterPurgeEnabled(boolean zimbraDumpsterPurgeEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterPurgeEnabled, zimbraDumpsterPurgeEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disables purging from dumpster when set to FALSE
     *
     * @param zimbraDumpsterPurgeEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1315)
    public Map<String,Object> setDumpsterPurgeEnabled(boolean zimbraDumpsterPurgeEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterPurgeEnabled, zimbraDumpsterPurgeEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * disables purging from dumpster when set to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1315)
    public void unsetDumpsterPurgeEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterPurgeEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disables purging from dumpster when set to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1315)
    public Map<String,Object> unsetDumpsterPurgeEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterPurgeEnabled, "");
        return attrs;
    }

    /**
     * limits how much of a dumpster data is viewable by the end user, based
     * on the age since being put in dumpster. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getDumpsterUserVisibleAgeAsString to access value as a string.
     *
     * @see #getDumpsterUserVisibleAgeAsString()
     *
     * @return zimbraDumpsterUserVisibleAge in millseconds, or 2592000000 (30d)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1314)
    public long getDumpsterUserVisibleAge() {
        return getTimeInterval(Provisioning.A_zimbraDumpsterUserVisibleAge, 2592000000L, true);
    }

    /**
     * limits how much of a dumpster data is viewable by the end user, based
     * on the age since being put in dumpster. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraDumpsterUserVisibleAge, or "30d" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1314)
    public String getDumpsterUserVisibleAgeAsString() {
        return getAttr(Provisioning.A_zimbraDumpsterUserVisibleAge, "30d", true);
    }

    /**
     * limits how much of a dumpster data is viewable by the end user, based
     * on the age since being put in dumpster. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraDumpsterUserVisibleAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1314)
    public void setDumpsterUserVisibleAge(String zimbraDumpsterUserVisibleAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterUserVisibleAge, zimbraDumpsterUserVisibleAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * limits how much of a dumpster data is viewable by the end user, based
     * on the age since being put in dumpster. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraDumpsterUserVisibleAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1314)
    public Map<String,Object> setDumpsterUserVisibleAge(String zimbraDumpsterUserVisibleAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterUserVisibleAge, zimbraDumpsterUserVisibleAge);
        return attrs;
    }

    /**
     * limits how much of a dumpster data is viewable by the end user, based
     * on the age since being put in dumpster. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1314)
    public void unsetDumpsterUserVisibleAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterUserVisibleAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * limits how much of a dumpster data is viewable by the end user, based
     * on the age since being put in dumpster. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1314)
    public Map<String,Object> unsetDumpsterUserVisibleAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDumpsterUserVisibleAge, "");
        return attrs;
    }

    /**
     * Indicates the account should be excluded from Crossmailbox searchers.
     *
     * @return zimbraExcludeFromCMBSearch, or false if unset
     */
    @ZAttr(id=501)
    public boolean isExcludeFromCMBSearch() {
        return getBooleanAttr(Provisioning.A_zimbraExcludeFromCMBSearch, false, true);
    }

    /**
     * Indicates the account should be excluded from Crossmailbox searchers.
     *
     * @param zimbraExcludeFromCMBSearch new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=501)
    public void setExcludeFromCMBSearch(boolean zimbraExcludeFromCMBSearch) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExcludeFromCMBSearch, zimbraExcludeFromCMBSearch ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the account should be excluded from Crossmailbox searchers.
     *
     * @param zimbraExcludeFromCMBSearch new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=501)
    public Map<String,Object> setExcludeFromCMBSearch(boolean zimbraExcludeFromCMBSearch, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExcludeFromCMBSearch, zimbraExcludeFromCMBSearch ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Indicates the account should be excluded from Crossmailbox searchers.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=501)
    public void unsetExcludeFromCMBSearch() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExcludeFromCMBSearch, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the account should be excluded from Crossmailbox searchers.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=501)
    public Map<String,Object> unsetExcludeFromCMBSearch(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExcludeFromCMBSearch, "");
        return attrs;
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @return zimbraExportMaxDays, or 0 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public int getExportMaxDays() {
        return getIntAttr(Provisioning.A_zimbraExportMaxDays, 0, true);
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @param zimbraExportMaxDays new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public void setExportMaxDays(int zimbraExportMaxDays) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExportMaxDays, Integer.toString(zimbraExportMaxDays));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @param zimbraExportMaxDays new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public Map<String,Object> setExportMaxDays(int zimbraExportMaxDays, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExportMaxDays, Integer.toString(zimbraExportMaxDays));
        return attrs;
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public void unsetExportMaxDays() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExportMaxDays, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public Map<String,Object> unsetExportMaxDays(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExportMaxDays, "");
        return attrs;
    }

    /**
     * Time when external virtual account was last automatically disabled by
     * the system. Applicable only when zimbraIsExternalVirtualAccount on the
     * account is set to TRUE.
     *
     * <p>Use getExternalAccountDisabledTimeAsString to access value as a string.
     *
     * @see #getExternalAccountDisabledTimeAsString()
     *
     * @return zimbraExternalAccountDisabledTime as Date, null if unset or unable to parse
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1371)
    public Date getExternalAccountDisabledTime() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraExternalAccountDisabledTime, null, true);
    }

    /**
     * Time when external virtual account was last automatically disabled by
     * the system. Applicable only when zimbraIsExternalVirtualAccount on the
     * account is set to TRUE.
     *
     * @return zimbraExternalAccountDisabledTime, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1371)
    public String getExternalAccountDisabledTimeAsString() {
        return getAttr(Provisioning.A_zimbraExternalAccountDisabledTime, null, true);
    }

    /**
     * Time when external virtual account was last automatically disabled by
     * the system. Applicable only when zimbraIsExternalVirtualAccount on the
     * account is set to TRUE.
     *
     * @param zimbraExternalAccountDisabledTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1371)
    public void setExternalAccountDisabledTime(Date zimbraExternalAccountDisabledTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountDisabledTime, zimbraExternalAccountDisabledTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraExternalAccountDisabledTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time when external virtual account was last automatically disabled by
     * the system. Applicable only when zimbraIsExternalVirtualAccount on the
     * account is set to TRUE.
     *
     * @param zimbraExternalAccountDisabledTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1371)
    public Map<String,Object> setExternalAccountDisabledTime(Date zimbraExternalAccountDisabledTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountDisabledTime, zimbraExternalAccountDisabledTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraExternalAccountDisabledTime));
        return attrs;
    }

    /**
     * Time when external virtual account was last automatically disabled by
     * the system. Applicable only when zimbraIsExternalVirtualAccount on the
     * account is set to TRUE.
     *
     * @param zimbraExternalAccountDisabledTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1371)
    public void setExternalAccountDisabledTimeAsString(String zimbraExternalAccountDisabledTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountDisabledTime, zimbraExternalAccountDisabledTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time when external virtual account was last automatically disabled by
     * the system. Applicable only when zimbraIsExternalVirtualAccount on the
     * account is set to TRUE.
     *
     * @param zimbraExternalAccountDisabledTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1371)
    public Map<String,Object> setExternalAccountDisabledTimeAsString(String zimbraExternalAccountDisabledTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountDisabledTime, zimbraExternalAccountDisabledTime);
        return attrs;
    }

    /**
     * Time when external virtual account was last automatically disabled by
     * the system. Applicable only when zimbraIsExternalVirtualAccount on the
     * account is set to TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1371)
    public void unsetExternalAccountDisabledTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountDisabledTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time when external virtual account was last automatically disabled by
     * the system. Applicable only when zimbraIsExternalVirtualAccount on the
     * account is set to TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1371)
    public Map<String,Object> unsetExternalAccountDisabledTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountDisabledTime, "");
        return attrs;
    }

    /**
     * Duration after the last time the external virtual account was
     * automatically disabled by the system after which the external virtual
     * account would be automatically deleted. Value of 0 indicates that the
     * external virtual account should never be automatically deleted.
     * Applicable only when zimbraIsExternalVirtualAccount on the account is
     * set to TRUE. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getExternalAccountLifetimeAfterDisabledAsString to access value as a string.
     *
     * @see #getExternalAccountLifetimeAfterDisabledAsString()
     *
     * @return zimbraExternalAccountLifetimeAfterDisabled in millseconds, or 2592000000 (30d)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1372)
    public long getExternalAccountLifetimeAfterDisabled() {
        return getTimeInterval(Provisioning.A_zimbraExternalAccountLifetimeAfterDisabled, 2592000000L, true);
    }

    /**
     * Duration after the last time the external virtual account was
     * automatically disabled by the system after which the external virtual
     * account would be automatically deleted. Value of 0 indicates that the
     * external virtual account should never be automatically deleted.
     * Applicable only when zimbraIsExternalVirtualAccount on the account is
     * set to TRUE. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraExternalAccountLifetimeAfterDisabled, or "30d" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1372)
    public String getExternalAccountLifetimeAfterDisabledAsString() {
        return getAttr(Provisioning.A_zimbraExternalAccountLifetimeAfterDisabled, "30d", true);
    }

    /**
     * Duration after the last time the external virtual account was
     * automatically disabled by the system after which the external virtual
     * account would be automatically deleted. Value of 0 indicates that the
     * external virtual account should never be automatically deleted.
     * Applicable only when zimbraIsExternalVirtualAccount on the account is
     * set to TRUE. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraExternalAccountLifetimeAfterDisabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1372)
    public void setExternalAccountLifetimeAfterDisabled(String zimbraExternalAccountLifetimeAfterDisabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountLifetimeAfterDisabled, zimbraExternalAccountLifetimeAfterDisabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Duration after the last time the external virtual account was
     * automatically disabled by the system after which the external virtual
     * account would be automatically deleted. Value of 0 indicates that the
     * external virtual account should never be automatically deleted.
     * Applicable only when zimbraIsExternalVirtualAccount on the account is
     * set to TRUE. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraExternalAccountLifetimeAfterDisabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1372)
    public Map<String,Object> setExternalAccountLifetimeAfterDisabled(String zimbraExternalAccountLifetimeAfterDisabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountLifetimeAfterDisabled, zimbraExternalAccountLifetimeAfterDisabled);
        return attrs;
    }

    /**
     * Duration after the last time the external virtual account was
     * automatically disabled by the system after which the external virtual
     * account would be automatically deleted. Value of 0 indicates that the
     * external virtual account should never be automatically deleted.
     * Applicable only when zimbraIsExternalVirtualAccount on the account is
     * set to TRUE. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1372)
    public void unsetExternalAccountLifetimeAfterDisabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountLifetimeAfterDisabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Duration after the last time the external virtual account was
     * automatically disabled by the system after which the external virtual
     * account would be automatically deleted. Value of 0 indicates that the
     * external virtual account should never be automatically deleted.
     * Applicable only when zimbraIsExternalVirtualAccount on the account is
     * set to TRUE. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1372)
    public Map<String,Object> unsetExternalAccountLifetimeAfterDisabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountLifetimeAfterDisabled, "");
        return attrs;
    }

    /**
     * external imap hostname
     *
     * @return zimbraExternalImapHostname, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=786)
    public String getExternalImapHostname() {
        return getAttr(Provisioning.A_zimbraExternalImapHostname, null, true);
    }

    /**
     * external imap hostname
     *
     * @param zimbraExternalImapHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=786)
    public void setExternalImapHostname(String zimbraExternalImapHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapHostname, zimbraExternalImapHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap hostname
     *
     * @param zimbraExternalImapHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=786)
    public Map<String,Object> setExternalImapHostname(String zimbraExternalImapHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapHostname, zimbraExternalImapHostname);
        return attrs;
    }

    /**
     * external imap hostname
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=786)
    public void unsetExternalImapHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap hostname
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=786)
    public Map<String,Object> unsetExternalImapHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapHostname, "");
        return attrs;
    }

    /**
     * external imap port
     *
     * <p>Use getExternalImapPortAsString to access value as a string.
     *
     * @see #getExternalImapPortAsString()
     *
     * @return zimbraExternalImapPort, or -1 if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=782)
    public int getExternalImapPort() {
        return getIntAttr(Provisioning.A_zimbraExternalImapPort, -1, true);
    }

    /**
     * external imap port
     *
     * @return zimbraExternalImapPort, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=782)
    public String getExternalImapPortAsString() {
        return getAttr(Provisioning.A_zimbraExternalImapPort, null, true);
    }

    /**
     * external imap port
     *
     * @param zimbraExternalImapPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=782)
    public void setExternalImapPort(int zimbraExternalImapPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapPort, Integer.toString(zimbraExternalImapPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap port
     *
     * @param zimbraExternalImapPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=782)
    public Map<String,Object> setExternalImapPort(int zimbraExternalImapPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapPort, Integer.toString(zimbraExternalImapPort));
        return attrs;
    }

    /**
     * external imap port
     *
     * @param zimbraExternalImapPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=782)
    public void setExternalImapPortAsString(String zimbraExternalImapPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapPort, zimbraExternalImapPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap port
     *
     * @param zimbraExternalImapPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=782)
    public Map<String,Object> setExternalImapPortAsString(String zimbraExternalImapPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapPort, zimbraExternalImapPort);
        return attrs;
    }

    /**
     * external imap port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=782)
    public void unsetExternalImapPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=782)
    public Map<String,Object> unsetExternalImapPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapPort, "");
        return attrs;
    }

    /**
     * external imap SSL hostname
     *
     * @return zimbraExternalImapSSLHostname, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=787)
    public String getExternalImapSSLHostname() {
        return getAttr(Provisioning.A_zimbraExternalImapSSLHostname, null, true);
    }

    /**
     * external imap SSL hostname
     *
     * @param zimbraExternalImapSSLHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=787)
    public void setExternalImapSSLHostname(String zimbraExternalImapSSLHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLHostname, zimbraExternalImapSSLHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap SSL hostname
     *
     * @param zimbraExternalImapSSLHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=787)
    public Map<String,Object> setExternalImapSSLHostname(String zimbraExternalImapSSLHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLHostname, zimbraExternalImapSSLHostname);
        return attrs;
    }

    /**
     * external imap SSL hostname
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=787)
    public void unsetExternalImapSSLHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap SSL hostname
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=787)
    public Map<String,Object> unsetExternalImapSSLHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLHostname, "");
        return attrs;
    }

    /**
     * external imap SSL port
     *
     * <p>Use getExternalImapSSLPortAsString to access value as a string.
     *
     * @see #getExternalImapSSLPortAsString()
     *
     * @return zimbraExternalImapSSLPort, or -1 if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=783)
    public int getExternalImapSSLPort() {
        return getIntAttr(Provisioning.A_zimbraExternalImapSSLPort, -1, true);
    }

    /**
     * external imap SSL port
     *
     * @return zimbraExternalImapSSLPort, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=783)
    public String getExternalImapSSLPortAsString() {
        return getAttr(Provisioning.A_zimbraExternalImapSSLPort, null, true);
    }

    /**
     * external imap SSL port
     *
     * @param zimbraExternalImapSSLPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=783)
    public void setExternalImapSSLPort(int zimbraExternalImapSSLPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLPort, Integer.toString(zimbraExternalImapSSLPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap SSL port
     *
     * @param zimbraExternalImapSSLPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=783)
    public Map<String,Object> setExternalImapSSLPort(int zimbraExternalImapSSLPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLPort, Integer.toString(zimbraExternalImapSSLPort));
        return attrs;
    }

    /**
     * external imap SSL port
     *
     * @param zimbraExternalImapSSLPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=783)
    public void setExternalImapSSLPortAsString(String zimbraExternalImapSSLPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLPort, zimbraExternalImapSSLPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap SSL port
     *
     * @param zimbraExternalImapSSLPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=783)
    public Map<String,Object> setExternalImapSSLPortAsString(String zimbraExternalImapSSLPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLPort, zimbraExternalImapSSLPort);
        return attrs;
    }

    /**
     * external imap SSL port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=783)
    public void unsetExternalImapSSLPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external imap SSL port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=783)
    public Map<String,Object> unsetExternalImapSSLPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalImapSSLPort, "");
        return attrs;
    }

    /**
     * external pop3 hostname
     *
     * @return zimbraExternalPop3Hostname, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=784)
    public String getExternalPop3Hostname() {
        return getAttr(Provisioning.A_zimbraExternalPop3Hostname, null, true);
    }

    /**
     * external pop3 hostname
     *
     * @param zimbraExternalPop3Hostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=784)
    public void setExternalPop3Hostname(String zimbraExternalPop3Hostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Hostname, zimbraExternalPop3Hostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 hostname
     *
     * @param zimbraExternalPop3Hostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=784)
    public Map<String,Object> setExternalPop3Hostname(String zimbraExternalPop3Hostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Hostname, zimbraExternalPop3Hostname);
        return attrs;
    }

    /**
     * external pop3 hostname
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=784)
    public void unsetExternalPop3Hostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Hostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 hostname
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=784)
    public Map<String,Object> unsetExternalPop3Hostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Hostname, "");
        return attrs;
    }

    /**
     * external pop3 port
     *
     * <p>Use getExternalPop3PortAsString to access value as a string.
     *
     * @see #getExternalPop3PortAsString()
     *
     * @return zimbraExternalPop3Port, or -1 if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=780)
    public int getExternalPop3Port() {
        return getIntAttr(Provisioning.A_zimbraExternalPop3Port, -1, true);
    }

    /**
     * external pop3 port
     *
     * @return zimbraExternalPop3Port, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=780)
    public String getExternalPop3PortAsString() {
        return getAttr(Provisioning.A_zimbraExternalPop3Port, null, true);
    }

    /**
     * external pop3 port
     *
     * @param zimbraExternalPop3Port new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=780)
    public void setExternalPop3Port(int zimbraExternalPop3Port) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Port, Integer.toString(zimbraExternalPop3Port));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 port
     *
     * @param zimbraExternalPop3Port new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=780)
    public Map<String,Object> setExternalPop3Port(int zimbraExternalPop3Port, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Port, Integer.toString(zimbraExternalPop3Port));
        return attrs;
    }

    /**
     * external pop3 port
     *
     * @param zimbraExternalPop3Port new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=780)
    public void setExternalPop3PortAsString(String zimbraExternalPop3Port) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Port, zimbraExternalPop3Port);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 port
     *
     * @param zimbraExternalPop3Port new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=780)
    public Map<String,Object> setExternalPop3PortAsString(String zimbraExternalPop3Port, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Port, zimbraExternalPop3Port);
        return attrs;
    }

    /**
     * external pop3 port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=780)
    public void unsetExternalPop3Port() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Port, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=780)
    public Map<String,Object> unsetExternalPop3Port(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3Port, "");
        return attrs;
    }

    /**
     * external pop3 SSL hostname
     *
     * @return zimbraExternalPop3SSLHostname, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=785)
    public String getExternalPop3SSLHostname() {
        return getAttr(Provisioning.A_zimbraExternalPop3SSLHostname, null, true);
    }

    /**
     * external pop3 SSL hostname
     *
     * @param zimbraExternalPop3SSLHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=785)
    public void setExternalPop3SSLHostname(String zimbraExternalPop3SSLHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLHostname, zimbraExternalPop3SSLHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 SSL hostname
     *
     * @param zimbraExternalPop3SSLHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=785)
    public Map<String,Object> setExternalPop3SSLHostname(String zimbraExternalPop3SSLHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLHostname, zimbraExternalPop3SSLHostname);
        return attrs;
    }

    /**
     * external pop3 SSL hostname
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=785)
    public void unsetExternalPop3SSLHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 SSL hostname
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=785)
    public Map<String,Object> unsetExternalPop3SSLHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLHostname, "");
        return attrs;
    }

    /**
     * external pop3 SSL port
     *
     * <p>Use getExternalPop3SSLPortAsString to access value as a string.
     *
     * @see #getExternalPop3SSLPortAsString()
     *
     * @return zimbraExternalPop3SSLPort, or -1 if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=781)
    public int getExternalPop3SSLPort() {
        return getIntAttr(Provisioning.A_zimbraExternalPop3SSLPort, -1, true);
    }

    /**
     * external pop3 SSL port
     *
     * @return zimbraExternalPop3SSLPort, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=781)
    public String getExternalPop3SSLPortAsString() {
        return getAttr(Provisioning.A_zimbraExternalPop3SSLPort, null, true);
    }

    /**
     * external pop3 SSL port
     *
     * @param zimbraExternalPop3SSLPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=781)
    public void setExternalPop3SSLPort(int zimbraExternalPop3SSLPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLPort, Integer.toString(zimbraExternalPop3SSLPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 SSL port
     *
     * @param zimbraExternalPop3SSLPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=781)
    public Map<String,Object> setExternalPop3SSLPort(int zimbraExternalPop3SSLPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLPort, Integer.toString(zimbraExternalPop3SSLPort));
        return attrs;
    }

    /**
     * external pop3 SSL port
     *
     * @param zimbraExternalPop3SSLPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=781)
    public void setExternalPop3SSLPortAsString(String zimbraExternalPop3SSLPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLPort, zimbraExternalPop3SSLPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 SSL port
     *
     * @param zimbraExternalPop3SSLPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=781)
    public Map<String,Object> setExternalPop3SSLPortAsString(String zimbraExternalPop3SSLPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLPort, zimbraExternalPop3SSLPort);
        return attrs;
    }

    /**
     * external pop3 SSL port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=781)
    public void unsetExternalPop3SSLPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external pop3 SSL port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=781)
    public Map<String,Object> unsetExternalPop3SSLPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalPop3SSLPort, "");
        return attrs;
    }

    /**
     * whether checking against zimbraExternalShareWhitelistDomain for
     * external user sharing is enabled
     *
     * @return zimbraExternalShareDomainWhitelistEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1264)
    public boolean isExternalShareDomainWhitelistEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraExternalShareDomainWhitelistEnabled, false, true);
    }

    /**
     * whether checking against zimbraExternalShareWhitelistDomain for
     * external user sharing is enabled
     *
     * @param zimbraExternalShareDomainWhitelistEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1264)
    public void setExternalShareDomainWhitelistEnabled(boolean zimbraExternalShareDomainWhitelistEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareDomainWhitelistEnabled, zimbraExternalShareDomainWhitelistEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether checking against zimbraExternalShareWhitelistDomain for
     * external user sharing is enabled
     *
     * @param zimbraExternalShareDomainWhitelistEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1264)
    public Map<String,Object> setExternalShareDomainWhitelistEnabled(boolean zimbraExternalShareDomainWhitelistEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareDomainWhitelistEnabled, zimbraExternalShareDomainWhitelistEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether checking against zimbraExternalShareWhitelistDomain for
     * external user sharing is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1264)
    public void unsetExternalShareDomainWhitelistEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareDomainWhitelistEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether checking against zimbraExternalShareWhitelistDomain for
     * external user sharing is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1264)
    public Map<String,Object> unsetExternalShareDomainWhitelistEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareDomainWhitelistEnabled, "");
        return attrs;
    }

    /**
     * Maximum allowed lifetime of shares to external users. A value of 0
     * indicates that there&#039;s no limit on an external share&#039;s
     * lifetime. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getExternalShareLifetimeAsString to access value as a string.
     *
     * @see #getExternalShareLifetimeAsString()
     *
     * @return zimbraExternalShareLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1260)
    public long getExternalShareLifetime() {
        return getTimeInterval(Provisioning.A_zimbraExternalShareLifetime, 0L, true);
    }

    /**
     * Maximum allowed lifetime of shares to external users. A value of 0
     * indicates that there&#039;s no limit on an external share&#039;s
     * lifetime. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraExternalShareLifetime, or "0" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1260)
    public String getExternalShareLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraExternalShareLifetime, "0", true);
    }

    /**
     * Maximum allowed lifetime of shares to external users. A value of 0
     * indicates that there&#039;s no limit on an external share&#039;s
     * lifetime. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraExternalShareLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1260)
    public void setExternalShareLifetime(String zimbraExternalShareLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareLifetime, zimbraExternalShareLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of shares to external users. A value of 0
     * indicates that there&#039;s no limit on an external share&#039;s
     * lifetime. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraExternalShareLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1260)
    public Map<String,Object> setExternalShareLifetime(String zimbraExternalShareLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareLifetime, zimbraExternalShareLifetime);
        return attrs;
    }

    /**
     * Maximum allowed lifetime of shares to external users. A value of 0
     * indicates that there&#039;s no limit on an external share&#039;s
     * lifetime. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1260)
    public void unsetExternalShareLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of shares to external users. A value of 0
     * indicates that there&#039;s no limit on an external share&#039;s
     * lifetime. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1260)
    public Map<String,Object> unsetExternalShareLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareLifetime, "");
        return attrs;
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @return zimbraExternalShareWhitelistDomain, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public String[] getExternalShareWhitelistDomain() {
        return getMultiAttr(Provisioning.A_zimbraExternalShareWhitelistDomain, true, true);
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @param zimbraExternalShareWhitelistDomain new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public void setExternalShareWhitelistDomain(String[] zimbraExternalShareWhitelistDomain) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareWhitelistDomain, zimbraExternalShareWhitelistDomain);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @param zimbraExternalShareWhitelistDomain new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public Map<String,Object> setExternalShareWhitelistDomain(String[] zimbraExternalShareWhitelistDomain, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareWhitelistDomain, zimbraExternalShareWhitelistDomain);
        return attrs;
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @param zimbraExternalShareWhitelistDomain new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public void addExternalShareWhitelistDomain(String zimbraExternalShareWhitelistDomain) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraExternalShareWhitelistDomain, zimbraExternalShareWhitelistDomain);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @param zimbraExternalShareWhitelistDomain new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public Map<String,Object> addExternalShareWhitelistDomain(String zimbraExternalShareWhitelistDomain, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraExternalShareWhitelistDomain, zimbraExternalShareWhitelistDomain);
        return attrs;
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @param zimbraExternalShareWhitelistDomain existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public void removeExternalShareWhitelistDomain(String zimbraExternalShareWhitelistDomain) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraExternalShareWhitelistDomain, zimbraExternalShareWhitelistDomain);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @param zimbraExternalShareWhitelistDomain existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public Map<String,Object> removeExternalShareWhitelistDomain(String zimbraExternalShareWhitelistDomain, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraExternalShareWhitelistDomain, zimbraExternalShareWhitelistDomain);
        return attrs;
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public void unsetExternalShareWhitelistDomain() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareWhitelistDomain, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of external domains that users can share files and folders with
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1263)
    public Map<String,Object> unsetExternalShareWhitelistDomain(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareWhitelistDomain, "");
        return attrs;
    }

    /**
     * switch for turning external user sharing on/off
     *
     * @return zimbraExternalSharingEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1261)
    public boolean isExternalSharingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraExternalSharingEnabled, true, true);
    }

    /**
     * switch for turning external user sharing on/off
     *
     * @param zimbraExternalSharingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1261)
    public void setExternalSharingEnabled(boolean zimbraExternalSharingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalSharingEnabled, zimbraExternalSharingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * switch for turning external user sharing on/off
     *
     * @param zimbraExternalSharingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1261)
    public Map<String,Object> setExternalSharingEnabled(boolean zimbraExternalSharingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalSharingEnabled, zimbraExternalSharingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * switch for turning external user sharing on/off
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1261)
    public void unsetExternalSharingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalSharingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * switch for turning external user sharing on/off
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1261)
    public Map<String,Object> unsetExternalSharingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalSharingEnabled, "");
        return attrs;
    }

    /**
     * External email address of an external user. Applicable only when
     * zimbraIsExternalVirtualAccount is set to TRUE.
     *
     * @return zimbraExternalUserMailAddress, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1244)
    public String getExternalUserMailAddress() {
        return getAttr(Provisioning.A_zimbraExternalUserMailAddress, null, true);
    }

    /**
     * External email address of an external user. Applicable only when
     * zimbraIsExternalVirtualAccount is set to TRUE.
     *
     * @param zimbraExternalUserMailAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1244)
    public void setExternalUserMailAddress(String zimbraExternalUserMailAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalUserMailAddress, zimbraExternalUserMailAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * External email address of an external user. Applicable only when
     * zimbraIsExternalVirtualAccount is set to TRUE.
     *
     * @param zimbraExternalUserMailAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1244)
    public Map<String,Object> setExternalUserMailAddress(String zimbraExternalUserMailAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalUserMailAddress, zimbraExternalUserMailAddress);
        return attrs;
    }

    /**
     * External email address of an external user. Applicable only when
     * zimbraIsExternalVirtualAccount is set to TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1244)
    public void unsetExternalUserMailAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalUserMailAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * External email address of an external user. Applicable only when
     * zimbraIsExternalVirtualAccount is set to TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1244)
    public Map<String,Object> unsetExternalUserMailAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalUserMailAddress, "");
        return attrs;
    }

    /**
     * RFC822 email address under verification for an account
     *
     * @return zimbraFeatureAddressUnderVerification, or null if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2128)
    public String getFeatureAddressUnderVerification() {
        return getAttr(Provisioning.A_zimbraFeatureAddressUnderVerification, null, true);
    }

    /**
     * RFC822 email address under verification for an account
     *
     * @param zimbraFeatureAddressUnderVerification new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2128)
    public void setFeatureAddressUnderVerification(String zimbraFeatureAddressUnderVerification) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressUnderVerification, zimbraFeatureAddressUnderVerification);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address under verification for an account
     *
     * @param zimbraFeatureAddressUnderVerification new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2128)
    public Map<String,Object> setFeatureAddressUnderVerification(String zimbraFeatureAddressUnderVerification, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressUnderVerification, zimbraFeatureAddressUnderVerification);
        return attrs;
    }

    /**
     * RFC822 email address under verification for an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2128)
    public void unsetFeatureAddressUnderVerification() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressUnderVerification, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address under verification for an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2128)
    public Map<String,Object> unsetFeatureAddressUnderVerification(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressUnderVerification, "");
        return attrs;
    }

    /**
     * Enable end-user email address verification
     *
     * @return zimbraFeatureAddressVerificationEnabled, or false if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2126)
    public boolean isFeatureAddressVerificationEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureAddressVerificationEnabled, false, true);
    }

    /**
     * Enable end-user email address verification
     *
     * @param zimbraFeatureAddressVerificationEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2126)
    public void setFeatureAddressVerificationEnabled(boolean zimbraFeatureAddressVerificationEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationEnabled, zimbraFeatureAddressVerificationEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable end-user email address verification
     *
     * @param zimbraFeatureAddressVerificationEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2126)
    public Map<String,Object> setFeatureAddressVerificationEnabled(boolean zimbraFeatureAddressVerificationEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationEnabled, zimbraFeatureAddressVerificationEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Enable end-user email address verification
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2126)
    public void unsetFeatureAddressVerificationEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable end-user email address verification
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2126)
    public Map<String,Object> unsetFeatureAddressVerificationEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationEnabled, "");
        return attrs;
    }

    /**
     * Expiry time for end-user email address verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFeatureAddressVerificationExpiryAsString to access value as a string.
     *
     * @see #getFeatureAddressVerificationExpiryAsString()
     *
     * @return zimbraFeatureAddressVerificationExpiry in millseconds, or 86400000 (1d)  if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2127)
    public long getFeatureAddressVerificationExpiry() {
        return getTimeInterval(Provisioning.A_zimbraFeatureAddressVerificationExpiry, 86400000L, true);
    }

    /**
     * Expiry time for end-user email address verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFeatureAddressVerificationExpiry, or "1d" if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2127)
    public String getFeatureAddressVerificationExpiryAsString() {
        return getAttr(Provisioning.A_zimbraFeatureAddressVerificationExpiry, "1d", true);
    }

    /**
     * Expiry time for end-user email address verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFeatureAddressVerificationExpiry new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2127)
    public void setFeatureAddressVerificationExpiry(String zimbraFeatureAddressVerificationExpiry) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationExpiry, zimbraFeatureAddressVerificationExpiry);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Expiry time for end-user email address verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFeatureAddressVerificationExpiry new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2127)
    public Map<String,Object> setFeatureAddressVerificationExpiry(String zimbraFeatureAddressVerificationExpiry, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationExpiry, zimbraFeatureAddressVerificationExpiry);
        return attrs;
    }

    /**
     * Expiry time for end-user email address verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2127)
    public void unsetFeatureAddressVerificationExpiry() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationExpiry, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Expiry time for end-user email address verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2127)
    public Map<String,Object> unsetFeatureAddressVerificationExpiry(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationExpiry, "");
        return attrs;
    }

    /**
     * End-user email address verification status
     *
     * <p>Valid values: [verified, pending, failed, expired]
     *
     * @return zimbraFeatureAddressVerificationStatus, or null if unset and/or has invalid value
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2129)
    public ZAttrProvisioning.FeatureAddressVerificationStatus getFeatureAddressVerificationStatus() {
        try { String v = getAttr(Provisioning.A_zimbraFeatureAddressVerificationStatus, true, true); return v == null ? null : ZAttrProvisioning.FeatureAddressVerificationStatus.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * End-user email address verification status
     *
     * <p>Valid values: [verified, pending, failed, expired]
     *
     * @return zimbraFeatureAddressVerificationStatus, or null if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2129)
    public String getFeatureAddressVerificationStatusAsString() {
        return getAttr(Provisioning.A_zimbraFeatureAddressVerificationStatus, null, true);
    }

    /**
     * End-user email address verification status
     *
     * <p>Valid values: [verified, pending, failed, expired]
     *
     * @param zimbraFeatureAddressVerificationStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2129)
    public void setFeatureAddressVerificationStatus(ZAttrProvisioning.FeatureAddressVerificationStatus zimbraFeatureAddressVerificationStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationStatus, zimbraFeatureAddressVerificationStatus.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * End-user email address verification status
     *
     * <p>Valid values: [verified, pending, failed, expired]
     *
     * @param zimbraFeatureAddressVerificationStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2129)
    public Map<String,Object> setFeatureAddressVerificationStatus(ZAttrProvisioning.FeatureAddressVerificationStatus zimbraFeatureAddressVerificationStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationStatus, zimbraFeatureAddressVerificationStatus.toString());
        return attrs;
    }

    /**
     * End-user email address verification status
     *
     * <p>Valid values: [verified, pending, failed, expired]
     *
     * @param zimbraFeatureAddressVerificationStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2129)
    public void setFeatureAddressVerificationStatusAsString(String zimbraFeatureAddressVerificationStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationStatus, zimbraFeatureAddressVerificationStatus);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * End-user email address verification status
     *
     * <p>Valid values: [verified, pending, failed, expired]
     *
     * @param zimbraFeatureAddressVerificationStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2129)
    public Map<String,Object> setFeatureAddressVerificationStatusAsString(String zimbraFeatureAddressVerificationStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationStatus, zimbraFeatureAddressVerificationStatus);
        return attrs;
    }

    /**
     * End-user email address verification status
     *
     * <p>Valid values: [verified, pending, failed, expired]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2129)
    public void unsetFeatureAddressVerificationStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * End-user email address verification status
     *
     * <p>Valid values: [verified, pending, failed, expired]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2129)
    public Map<String,Object> unsetFeatureAddressVerificationStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAddressVerificationStatus, "");
        return attrs;
    }

    /**
     * whether email features and tabs are enabled in the web client if
     * accessed from the admin console
     *
     * @return zimbraFeatureAdminMailEnabled, or true if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1170)
    public boolean isFeatureAdminMailEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureAdminMailEnabled, true, true);
    }

    /**
     * whether email features and tabs are enabled in the web client if
     * accessed from the admin console
     *
     * @param zimbraFeatureAdminMailEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1170)
    public void setFeatureAdminMailEnabled(boolean zimbraFeatureAdminMailEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdminMailEnabled, zimbraFeatureAdminMailEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether email features and tabs are enabled in the web client if
     * accessed from the admin console
     *
     * @param zimbraFeatureAdminMailEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1170)
    public Map<String,Object> setFeatureAdminMailEnabled(boolean zimbraFeatureAdminMailEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdminMailEnabled, zimbraFeatureAdminMailEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether email features and tabs are enabled in the web client if
     * accessed from the admin console
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1170)
    public void unsetFeatureAdminMailEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdminMailEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether email features and tabs are enabled in the web client if
     * accessed from the admin console
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1170)
    public Map<String,Object> unsetFeatureAdminMailEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdminMailEnabled, "");
        return attrs;
    }

    /**
     * Whether email related configuration categories in Preference tab are
     * enabled in the web client even if the zimbraFeatureAdminMailEnabled is
     * set to FALSE (Email tab is disabled), and accessed from the admin
     * console. If the zimbraFeatureAdminMailEnabled is TRUE, this key is
     * ignored.
     *
     * @return zimbraFeatureAdminPreferencesEnabled, or false if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1686)
    public boolean isFeatureAdminPreferencesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureAdminPreferencesEnabled, false, true);
    }

    /**
     * Whether email related configuration categories in Preference tab are
     * enabled in the web client even if the zimbraFeatureAdminMailEnabled is
     * set to FALSE (Email tab is disabled), and accessed from the admin
     * console. If the zimbraFeatureAdminMailEnabled is TRUE, this key is
     * ignored.
     *
     * @param zimbraFeatureAdminPreferencesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1686)
    public void setFeatureAdminPreferencesEnabled(boolean zimbraFeatureAdminPreferencesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdminPreferencesEnabled, zimbraFeatureAdminPreferencesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether email related configuration categories in Preference tab are
     * enabled in the web client even if the zimbraFeatureAdminMailEnabled is
     * set to FALSE (Email tab is disabled), and accessed from the admin
     * console. If the zimbraFeatureAdminMailEnabled is TRUE, this key is
     * ignored.
     *
     * @param zimbraFeatureAdminPreferencesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1686)
    public Map<String,Object> setFeatureAdminPreferencesEnabled(boolean zimbraFeatureAdminPreferencesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdminPreferencesEnabled, zimbraFeatureAdminPreferencesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether email related configuration categories in Preference tab are
     * enabled in the web client even if the zimbraFeatureAdminMailEnabled is
     * set to FALSE (Email tab is disabled), and accessed from the admin
     * console. If the zimbraFeatureAdminMailEnabled is TRUE, this key is
     * ignored.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1686)
    public void unsetFeatureAdminPreferencesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdminPreferencesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether email related configuration categories in Preference tab are
     * enabled in the web client even if the zimbraFeatureAdminMailEnabled is
     * set to FALSE (Email tab is disabled), and accessed from the admin
     * console. If the zimbraFeatureAdminMailEnabled is TRUE, this key is
     * ignored.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1686)
    public Map<String,Object> unsetFeatureAdminPreferencesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdminPreferencesEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Deprecated as of bug 56924. Orig desc:
     * advanced search button enabled
     *
     * @return zimbraFeatureAdvancedSearchEnabled, or true if unset
     */
    @ZAttr(id=138)
    public boolean isFeatureAdvancedSearchEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureAdvancedSearchEnabled, true, true);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated as of bug 56924. Orig desc:
     * advanced search button enabled
     *
     * @param zimbraFeatureAdvancedSearchEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=138)
    public void setFeatureAdvancedSearchEnabled(boolean zimbraFeatureAdvancedSearchEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdvancedSearchEnabled, zimbraFeatureAdvancedSearchEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated as of bug 56924. Orig desc:
     * advanced search button enabled
     *
     * @param zimbraFeatureAdvancedSearchEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=138)
    public Map<String,Object> setFeatureAdvancedSearchEnabled(boolean zimbraFeatureAdvancedSearchEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdvancedSearchEnabled, zimbraFeatureAdvancedSearchEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Deprecated as of bug 56924. Orig desc:
     * advanced search button enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=138)
    public void unsetFeatureAdvancedSearchEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdvancedSearchEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated as of bug 56924. Orig desc:
     * advanced search button enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=138)
    public Map<String,Object> unsetFeatureAdvancedSearchEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAdvancedSearchEnabled, "");
        return attrs;
    }

    /**
     * whether or not to enable rerouting spam messages to Junk folder in
     * ZCS, exposing Junk folder and actions in the web UI, and exposing Junk
     * folder to IMAP clients.
     *
     * @return zimbraFeatureAntispamEnabled, or true if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1168)
    public boolean isFeatureAntispamEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureAntispamEnabled, true, true);
    }

    /**
     * whether or not to enable rerouting spam messages to Junk folder in
     * ZCS, exposing Junk folder and actions in the web UI, and exposing Junk
     * folder to IMAP clients.
     *
     * @param zimbraFeatureAntispamEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1168)
    public void setFeatureAntispamEnabled(boolean zimbraFeatureAntispamEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAntispamEnabled, zimbraFeatureAntispamEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to enable rerouting spam messages to Junk folder in
     * ZCS, exposing Junk folder and actions in the web UI, and exposing Junk
     * folder to IMAP clients.
     *
     * @param zimbraFeatureAntispamEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1168)
    public Map<String,Object> setFeatureAntispamEnabled(boolean zimbraFeatureAntispamEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAntispamEnabled, zimbraFeatureAntispamEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to enable rerouting spam messages to Junk folder in
     * ZCS, exposing Junk folder and actions in the web UI, and exposing Junk
     * folder to IMAP clients.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1168)
    public void unsetFeatureAntispamEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAntispamEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to enable rerouting spam messages to Junk folder in
     * ZCS, exposing Junk folder and actions in the web UI, and exposing Junk
     * folder to IMAP clients.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1168)
    public Map<String,Object> unsetFeatureAntispamEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAntispamEnabled, "");
        return attrs;
    }

    /**
     * Whether app-specific passwords are enabled when two-factor auth is
     * enabled. If TRUE, the port specified by zimbraMtaAuthPort must be
     * accessible by the MTA.
     *
     * @return zimbraFeatureAppSpecificPasswordsEnabled, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1907)
    public boolean isFeatureAppSpecificPasswordsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureAppSpecificPasswordsEnabled, true, true);
    }

    /**
     * Whether app-specific passwords are enabled when two-factor auth is
     * enabled. If TRUE, the port specified by zimbraMtaAuthPort must be
     * accessible by the MTA.
     *
     * @param zimbraFeatureAppSpecificPasswordsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1907)
    public void setFeatureAppSpecificPasswordsEnabled(boolean zimbraFeatureAppSpecificPasswordsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAppSpecificPasswordsEnabled, zimbraFeatureAppSpecificPasswordsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether app-specific passwords are enabled when two-factor auth is
     * enabled. If TRUE, the port specified by zimbraMtaAuthPort must be
     * accessible by the MTA.
     *
     * @param zimbraFeatureAppSpecificPasswordsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1907)
    public Map<String,Object> setFeatureAppSpecificPasswordsEnabled(boolean zimbraFeatureAppSpecificPasswordsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAppSpecificPasswordsEnabled, zimbraFeatureAppSpecificPasswordsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether app-specific passwords are enabled when two-factor auth is
     * enabled. If TRUE, the port specified by zimbraMtaAuthPort must be
     * accessible by the MTA.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1907)
    public void unsetFeatureAppSpecificPasswordsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAppSpecificPasswordsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether app-specific passwords are enabled when two-factor auth is
     * enabled. If TRUE, the port specified by zimbraMtaAuthPort must be
     * accessible by the MTA.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1907)
    public Map<String,Object> unsetFeatureAppSpecificPasswordsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureAppSpecificPasswordsEnabled, "");
        return attrs;
    }

    /**
     * Docs features enabled in briefcase
     *
     * @return zimbraFeatureBriefcaseDocsEnabled, or true if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1055)
    public boolean isFeatureBriefcaseDocsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureBriefcaseDocsEnabled, true, true);
    }

    /**
     * Docs features enabled in briefcase
     *
     * @param zimbraFeatureBriefcaseDocsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1055)
    public void setFeatureBriefcaseDocsEnabled(boolean zimbraFeatureBriefcaseDocsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseDocsEnabled, zimbraFeatureBriefcaseDocsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Docs features enabled in briefcase
     *
     * @param zimbraFeatureBriefcaseDocsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1055)
    public Map<String,Object> setFeatureBriefcaseDocsEnabled(boolean zimbraFeatureBriefcaseDocsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseDocsEnabled, zimbraFeatureBriefcaseDocsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Docs features enabled in briefcase
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1055)
    public void unsetFeatureBriefcaseDocsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseDocsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Docs features enabled in briefcase
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1055)
    public Map<String,Object> unsetFeatureBriefcaseDocsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseDocsEnabled, "");
        return attrs;
    }

    /**
     * Slides features enabled in briefcase
     *
     * @return zimbraFeatureBriefcaseSlidesEnabled, or false if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1054)
    public boolean isFeatureBriefcaseSlidesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureBriefcaseSlidesEnabled, false, true);
    }

    /**
     * Slides features enabled in briefcase
     *
     * @param zimbraFeatureBriefcaseSlidesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1054)
    public void setFeatureBriefcaseSlidesEnabled(boolean zimbraFeatureBriefcaseSlidesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseSlidesEnabled, zimbraFeatureBriefcaseSlidesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Slides features enabled in briefcase
     *
     * @param zimbraFeatureBriefcaseSlidesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1054)
    public Map<String,Object> setFeatureBriefcaseSlidesEnabled(boolean zimbraFeatureBriefcaseSlidesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseSlidesEnabled, zimbraFeatureBriefcaseSlidesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Slides features enabled in briefcase
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1054)
    public void unsetFeatureBriefcaseSlidesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseSlidesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Slides features enabled in briefcase
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1054)
    public Map<String,Object> unsetFeatureBriefcaseSlidesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseSlidesEnabled, "");
        return attrs;
    }

    /**
     * Spreadsheet features enabled in briefcase
     *
     * @return zimbraFeatureBriefcaseSpreadsheetEnabled, or false if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1053)
    public boolean isFeatureBriefcaseSpreadsheetEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureBriefcaseSpreadsheetEnabled, false, true);
    }

    /**
     * Spreadsheet features enabled in briefcase
     *
     * @param zimbraFeatureBriefcaseSpreadsheetEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1053)
    public void setFeatureBriefcaseSpreadsheetEnabled(boolean zimbraFeatureBriefcaseSpreadsheetEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseSpreadsheetEnabled, zimbraFeatureBriefcaseSpreadsheetEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Spreadsheet features enabled in briefcase
     *
     * @param zimbraFeatureBriefcaseSpreadsheetEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1053)
    public Map<String,Object> setFeatureBriefcaseSpreadsheetEnabled(boolean zimbraFeatureBriefcaseSpreadsheetEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseSpreadsheetEnabled, zimbraFeatureBriefcaseSpreadsheetEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Spreadsheet features enabled in briefcase
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1053)
    public void unsetFeatureBriefcaseSpreadsheetEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseSpreadsheetEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Spreadsheet features enabled in briefcase
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1053)
    public Map<String,Object> unsetFeatureBriefcaseSpreadsheetEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcaseSpreadsheetEnabled, "");
        return attrs;
    }

    /**
     * whether to allow use of briefcase feature
     *
     * @return zimbraFeatureBriefcasesEnabled, or true if unset
     */
    @ZAttr(id=498)
    public boolean isFeatureBriefcasesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureBriefcasesEnabled, true, true);
    }

    /**
     * whether to allow use of briefcase feature
     *
     * @param zimbraFeatureBriefcasesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=498)
    public void setFeatureBriefcasesEnabled(boolean zimbraFeatureBriefcasesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcasesEnabled, zimbraFeatureBriefcasesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of briefcase feature
     *
     * @param zimbraFeatureBriefcasesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=498)
    public Map<String,Object> setFeatureBriefcasesEnabled(boolean zimbraFeatureBriefcasesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcasesEnabled, zimbraFeatureBriefcasesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow use of briefcase feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=498)
    public void unsetFeatureBriefcasesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcasesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of briefcase feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=498)
    public Map<String,Object> unsetFeatureBriefcasesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureBriefcasesEnabled, "");
        return attrs;
    }

    /**
     * calendar features
     *
     * @return zimbraFeatureCalendarEnabled, or true if unset
     */
    @ZAttr(id=136)
    public boolean isFeatureCalendarEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureCalendarEnabled, true, true);
    }

    /**
     * calendar features
     *
     * @param zimbraFeatureCalendarEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=136)
    public void setFeatureCalendarEnabled(boolean zimbraFeatureCalendarEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarEnabled, zimbraFeatureCalendarEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar features
     *
     * @param zimbraFeatureCalendarEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=136)
    public Map<String,Object> setFeatureCalendarEnabled(boolean zimbraFeatureCalendarEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarEnabled, zimbraFeatureCalendarEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * calendar features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=136)
    public void unsetFeatureCalendarEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=136)
    public Map<String,Object> unsetFeatureCalendarEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarEnabled, "");
        return attrs;
    }

    /**
     * whether receiving reminders on the designated device for appointments
     * and tasks is enabled
     *
     * @return zimbraFeatureCalendarReminderDeviceEmailEnabled, or false if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1150)
    public boolean isFeatureCalendarReminderDeviceEmailEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureCalendarReminderDeviceEmailEnabled, false, true);
    }

    /**
     * whether receiving reminders on the designated device for appointments
     * and tasks is enabled
     *
     * @param zimbraFeatureCalendarReminderDeviceEmailEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1150)
    public void setFeatureCalendarReminderDeviceEmailEnabled(boolean zimbraFeatureCalendarReminderDeviceEmailEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarReminderDeviceEmailEnabled, zimbraFeatureCalendarReminderDeviceEmailEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether receiving reminders on the designated device for appointments
     * and tasks is enabled
     *
     * @param zimbraFeatureCalendarReminderDeviceEmailEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1150)
    public Map<String,Object> setFeatureCalendarReminderDeviceEmailEnabled(boolean zimbraFeatureCalendarReminderDeviceEmailEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarReminderDeviceEmailEnabled, zimbraFeatureCalendarReminderDeviceEmailEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether receiving reminders on the designated device for appointments
     * and tasks is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1150)
    public void unsetFeatureCalendarReminderDeviceEmailEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarReminderDeviceEmailEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether receiving reminders on the designated device for appointments
     * and tasks is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1150)
    public Map<String,Object> unsetFeatureCalendarReminderDeviceEmailEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarReminderDeviceEmailEnabled, "");
        return attrs;
    }

    /**
     * calendar upsell enabled
     *
     * @return zimbraFeatureCalendarUpsellEnabled, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=531)
    public boolean isFeatureCalendarUpsellEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureCalendarUpsellEnabled, false, true);
    }

    /**
     * calendar upsell enabled
     *
     * @param zimbraFeatureCalendarUpsellEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=531)
    public void setFeatureCalendarUpsellEnabled(boolean zimbraFeatureCalendarUpsellEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarUpsellEnabled, zimbraFeatureCalendarUpsellEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar upsell enabled
     *
     * @param zimbraFeatureCalendarUpsellEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=531)
    public Map<String,Object> setFeatureCalendarUpsellEnabled(boolean zimbraFeatureCalendarUpsellEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarUpsellEnabled, zimbraFeatureCalendarUpsellEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * calendar upsell enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=531)
    public void unsetFeatureCalendarUpsellEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarUpsellEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar upsell enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=531)
    public Map<String,Object> unsetFeatureCalendarUpsellEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarUpsellEnabled, "");
        return attrs;
    }

    /**
     * calendar upsell URL
     *
     * @return zimbraFeatureCalendarUpsellURL, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=532)
    public String getFeatureCalendarUpsellURL() {
        return getAttr(Provisioning.A_zimbraFeatureCalendarUpsellURL, null, true);
    }

    /**
     * calendar upsell URL
     *
     * @param zimbraFeatureCalendarUpsellURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=532)
    public void setFeatureCalendarUpsellURL(String zimbraFeatureCalendarUpsellURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarUpsellURL, zimbraFeatureCalendarUpsellURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar upsell URL
     *
     * @param zimbraFeatureCalendarUpsellURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=532)
    public Map<String,Object> setFeatureCalendarUpsellURL(String zimbraFeatureCalendarUpsellURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarUpsellURL, zimbraFeatureCalendarUpsellURL);
        return attrs;
    }

    /**
     * calendar upsell URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=532)
    public void unsetFeatureCalendarUpsellURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarUpsellURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar upsell URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=532)
    public Map<String,Object> unsetFeatureCalendarUpsellURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCalendarUpsellURL, "");
        return attrs;
    }

    /**
     * password changing
     *
     * @return zimbraFeatureChangePasswordEnabled, or true if unset
     */
    @ZAttr(id=141)
    public boolean isFeatureChangePasswordEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureChangePasswordEnabled, true, true);
    }

    /**
     * password changing
     *
     * @param zimbraFeatureChangePasswordEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=141)
    public void setFeatureChangePasswordEnabled(boolean zimbraFeatureChangePasswordEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureChangePasswordEnabled, zimbraFeatureChangePasswordEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * password changing
     *
     * @param zimbraFeatureChangePasswordEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=141)
    public Map<String,Object> setFeatureChangePasswordEnabled(boolean zimbraFeatureChangePasswordEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureChangePasswordEnabled, zimbraFeatureChangePasswordEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * password changing
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=141)
    public void unsetFeatureChangePasswordEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureChangePasswordEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * password changing
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=141)
    public Map<String,Object> unsetFeatureChangePasswordEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureChangePasswordEnabled, "");
        return attrs;
    }

    /**
     * Whether to enable chat feature
     *
     * @return zimbraFeatureChatEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2052)
    public boolean isFeatureChatEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureChatEnabled, false, true);
    }

    /**
     * Whether to enable chat feature
     *
     * @param zimbraFeatureChatEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2052)
    public void setFeatureChatEnabled(boolean zimbraFeatureChatEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureChatEnabled, zimbraFeatureChatEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable chat feature
     *
     * @param zimbraFeatureChatEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2052)
    public Map<String,Object> setFeatureChatEnabled(boolean zimbraFeatureChatEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureChatEnabled, zimbraFeatureChatEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable chat feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2052)
    public void unsetFeatureChatEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureChatEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable chat feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2052)
    public Map<String,Object> unsetFeatureChatEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureChatEnabled, "");
        return attrs;
    }

    /**
     * whether or not compose messages in a new windows is allowed
     *
     * @return zimbraFeatureComposeInNewWindowEnabled, or true if unset
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=584)
    public boolean isFeatureComposeInNewWindowEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureComposeInNewWindowEnabled, true, true);
    }

    /**
     * whether or not compose messages in a new windows is allowed
     *
     * @param zimbraFeatureComposeInNewWindowEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=584)
    public void setFeatureComposeInNewWindowEnabled(boolean zimbraFeatureComposeInNewWindowEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureComposeInNewWindowEnabled, zimbraFeatureComposeInNewWindowEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not compose messages in a new windows is allowed
     *
     * @param zimbraFeatureComposeInNewWindowEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=584)
    public Map<String,Object> setFeatureComposeInNewWindowEnabled(boolean zimbraFeatureComposeInNewWindowEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureComposeInNewWindowEnabled, zimbraFeatureComposeInNewWindowEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not compose messages in a new windows is allowed
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=584)
    public void unsetFeatureComposeInNewWindowEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureComposeInNewWindowEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not compose messages in a new windows is allowed
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=584)
    public Map<String,Object> unsetFeatureComposeInNewWindowEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureComposeInNewWindowEnabled, "");
        return attrs;
    }

    /**
     * whether a confirmation page should be display after an operation is
     * done in the UI
     *
     * @return zimbraFeatureConfirmationPageEnabled, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=806)
    public boolean isFeatureConfirmationPageEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureConfirmationPageEnabled, false, true);
    }

    /**
     * whether a confirmation page should be display after an operation is
     * done in the UI
     *
     * @param zimbraFeatureConfirmationPageEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=806)
    public void setFeatureConfirmationPageEnabled(boolean zimbraFeatureConfirmationPageEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureConfirmationPageEnabled, zimbraFeatureConfirmationPageEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether a confirmation page should be display after an operation is
     * done in the UI
     *
     * @param zimbraFeatureConfirmationPageEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=806)
    public Map<String,Object> setFeatureConfirmationPageEnabled(boolean zimbraFeatureConfirmationPageEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureConfirmationPageEnabled, zimbraFeatureConfirmationPageEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether a confirmation page should be display after an operation is
     * done in the UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=806)
    public void unsetFeatureConfirmationPageEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureConfirmationPageEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether a confirmation page should be display after an operation is
     * done in the UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=806)
    public Map<String,Object> unsetFeatureConfirmationPageEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureConfirmationPageEnabled, "");
        return attrs;
    }

    /**
     * Enable contact backup feature
     *
     * @return zimbraFeatureContactBackupEnabled, or false if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2131)
    public boolean isFeatureContactBackupEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureContactBackupEnabled, false, true);
    }

    /**
     * Enable contact backup feature
     *
     * @param zimbraFeatureContactBackupEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2131)
    public void setFeatureContactBackupEnabled(boolean zimbraFeatureContactBackupEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupEnabled, zimbraFeatureContactBackupEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable contact backup feature
     *
     * @param zimbraFeatureContactBackupEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2131)
    public Map<String,Object> setFeatureContactBackupEnabled(boolean zimbraFeatureContactBackupEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupEnabled, zimbraFeatureContactBackupEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Enable contact backup feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2131)
    public void unsetFeatureContactBackupEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable contact backup feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2131)
    public Map<String,Object> unsetFeatureContactBackupEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupEnabled, "");
        return attrs;
    }

    /**
     * whether detailed contact search UI is enabled
     *
     * @return zimbraFeatureContactsDetailedSearchEnabled, or false if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1164)
    public boolean isFeatureContactsDetailedSearchEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureContactsDetailedSearchEnabled, false, true);
    }

    /**
     * whether detailed contact search UI is enabled
     *
     * @param zimbraFeatureContactsDetailedSearchEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1164)
    public void setFeatureContactsDetailedSearchEnabled(boolean zimbraFeatureContactsDetailedSearchEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsDetailedSearchEnabled, zimbraFeatureContactsDetailedSearchEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether detailed contact search UI is enabled
     *
     * @param zimbraFeatureContactsDetailedSearchEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1164)
    public Map<String,Object> setFeatureContactsDetailedSearchEnabled(boolean zimbraFeatureContactsDetailedSearchEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsDetailedSearchEnabled, zimbraFeatureContactsDetailedSearchEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether detailed contact search UI is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1164)
    public void unsetFeatureContactsDetailedSearchEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsDetailedSearchEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether detailed contact search UI is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1164)
    public Map<String,Object> unsetFeatureContactsDetailedSearchEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsDetailedSearchEnabled, "");
        return attrs;
    }

    /**
     * contact features
     *
     * @return zimbraFeatureContactsEnabled, or true if unset
     */
    @ZAttr(id=135)
    public boolean isFeatureContactsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureContactsEnabled, true, true);
    }

    /**
     * contact features
     *
     * @param zimbraFeatureContactsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=135)
    public void setFeatureContactsEnabled(boolean zimbraFeatureContactsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsEnabled, zimbraFeatureContactsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * contact features
     *
     * @param zimbraFeatureContactsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=135)
    public Map<String,Object> setFeatureContactsEnabled(boolean zimbraFeatureContactsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsEnabled, zimbraFeatureContactsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * contact features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=135)
    public void unsetFeatureContactsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * contact features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=135)
    public Map<String,Object> unsetFeatureContactsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsEnabled, "");
        return attrs;
    }

    /**
     * address book upsell enabled
     *
     * @return zimbraFeatureContactsUpsellEnabled, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=529)
    public boolean isFeatureContactsUpsellEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureContactsUpsellEnabled, false, true);
    }

    /**
     * address book upsell enabled
     *
     * @param zimbraFeatureContactsUpsellEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=529)
    public void setFeatureContactsUpsellEnabled(boolean zimbraFeatureContactsUpsellEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsUpsellEnabled, zimbraFeatureContactsUpsellEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * address book upsell enabled
     *
     * @param zimbraFeatureContactsUpsellEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=529)
    public Map<String,Object> setFeatureContactsUpsellEnabled(boolean zimbraFeatureContactsUpsellEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsUpsellEnabled, zimbraFeatureContactsUpsellEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * address book upsell enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=529)
    public void unsetFeatureContactsUpsellEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsUpsellEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * address book upsell enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=529)
    public Map<String,Object> unsetFeatureContactsUpsellEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsUpsellEnabled, "");
        return attrs;
    }

    /**
     * address book upsell URL
     *
     * @return zimbraFeatureContactsUpsellURL, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=530)
    public String getFeatureContactsUpsellURL() {
        return getAttr(Provisioning.A_zimbraFeatureContactsUpsellURL, null, true);
    }

    /**
     * address book upsell URL
     *
     * @param zimbraFeatureContactsUpsellURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=530)
    public void setFeatureContactsUpsellURL(String zimbraFeatureContactsUpsellURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsUpsellURL, zimbraFeatureContactsUpsellURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * address book upsell URL
     *
     * @param zimbraFeatureContactsUpsellURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=530)
    public Map<String,Object> setFeatureContactsUpsellURL(String zimbraFeatureContactsUpsellURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsUpsellURL, zimbraFeatureContactsUpsellURL);
        return attrs;
    }

    /**
     * address book upsell URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=530)
    public void unsetFeatureContactsUpsellURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsUpsellURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * address book upsell URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=530)
    public Map<String,Object> unsetFeatureContactsUpsellURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactsUpsellURL, "");
        return attrs;
    }

    /**
     * conversations
     *
     * @return zimbraFeatureConversationsEnabled, or true if unset
     */
    @ZAttr(id=140)
    public boolean isFeatureConversationsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureConversationsEnabled, true, true);
    }

    /**
     * conversations
     *
     * @param zimbraFeatureConversationsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=140)
    public void setFeatureConversationsEnabled(boolean zimbraFeatureConversationsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureConversationsEnabled, zimbraFeatureConversationsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * conversations
     *
     * @param zimbraFeatureConversationsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=140)
    public Map<String,Object> setFeatureConversationsEnabled(boolean zimbraFeatureConversationsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureConversationsEnabled, zimbraFeatureConversationsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * conversations
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=140)
    public void unsetFeatureConversationsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureConversationsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * conversations
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=140)
    public Map<String,Object> unsetFeatureConversationsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureConversationsEnabled, "");
        return attrs;
    }

    /**
     * whether Crocodoc feature is enabled in the web client
     *
     * @return zimbraFeatureCrocodocEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1381)
    public boolean isFeatureCrocodocEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureCrocodocEnabled, false, true);
    }

    /**
     * whether Crocodoc feature is enabled in the web client
     *
     * @param zimbraFeatureCrocodocEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1381)
    public void setFeatureCrocodocEnabled(boolean zimbraFeatureCrocodocEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCrocodocEnabled, zimbraFeatureCrocodocEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether Crocodoc feature is enabled in the web client
     *
     * @param zimbraFeatureCrocodocEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1381)
    public Map<String,Object> setFeatureCrocodocEnabled(boolean zimbraFeatureCrocodocEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCrocodocEnabled, zimbraFeatureCrocodocEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether Crocodoc feature is enabled in the web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1381)
    public void unsetFeatureCrocodocEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCrocodocEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether Crocodoc feature is enabled in the web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1381)
    public Map<String,Object> unsetFeatureCrocodocEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureCrocodocEnabled, "");
        return attrs;
    }

    /**
     * Whether data source purging is enabled
     *
     * @return zimbraFeatureDataSourcePurgingEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2014)
    public boolean isFeatureDataSourcePurgingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureDataSourcePurgingEnabled, false, true);
    }

    /**
     * Whether data source purging is enabled
     *
     * @param zimbraFeatureDataSourcePurgingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2014)
    public void setFeatureDataSourcePurgingEnabled(boolean zimbraFeatureDataSourcePurgingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDataSourcePurgingEnabled, zimbraFeatureDataSourcePurgingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether data source purging is enabled
     *
     * @param zimbraFeatureDataSourcePurgingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2014)
    public Map<String,Object> setFeatureDataSourcePurgingEnabled(boolean zimbraFeatureDataSourcePurgingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDataSourcePurgingEnabled, zimbraFeatureDataSourcePurgingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether data source purging is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2014)
    public void unsetFeatureDataSourcePurgingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDataSourcePurgingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether data source purging is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2014)
    public Map<String,Object> unsetFeatureDataSourcePurgingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDataSourcePurgingEnabled, "");
        return attrs;
    }

    /**
     * enable end-user mail discarding defined in mail filters features
     *
     * @return zimbraFeatureDiscardInFiltersEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=773)
    public boolean isFeatureDiscardInFiltersEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureDiscardInFiltersEnabled, true, true);
    }

    /**
     * enable end-user mail discarding defined in mail filters features
     *
     * @param zimbraFeatureDiscardInFiltersEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=773)
    public void setFeatureDiscardInFiltersEnabled(boolean zimbraFeatureDiscardInFiltersEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDiscardInFiltersEnabled, zimbraFeatureDiscardInFiltersEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable end-user mail discarding defined in mail filters features
     *
     * @param zimbraFeatureDiscardInFiltersEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=773)
    public Map<String,Object> setFeatureDiscardInFiltersEnabled(boolean zimbraFeatureDiscardInFiltersEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDiscardInFiltersEnabled, zimbraFeatureDiscardInFiltersEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable end-user mail discarding defined in mail filters features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=773)
    public void unsetFeatureDiscardInFiltersEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDiscardInFiltersEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable end-user mail discarding defined in mail filters features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=773)
    public Map<String,Object> unsetFeatureDiscardInFiltersEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDiscardInFiltersEnabled, "");
        return attrs;
    }

    /**
     * whether expanding distribution list members feature is enabled
     *
     * @return zimbraFeatureDistributionListExpandMembersEnabled, or true if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1134)
    public boolean isFeatureDistributionListExpandMembersEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureDistributionListExpandMembersEnabled, true, true);
    }

    /**
     * whether expanding distribution list members feature is enabled
     *
     * @param zimbraFeatureDistributionListExpandMembersEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1134)
    public void setFeatureDistributionListExpandMembersEnabled(boolean zimbraFeatureDistributionListExpandMembersEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListExpandMembersEnabled, zimbraFeatureDistributionListExpandMembersEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether expanding distribution list members feature is enabled
     *
     * @param zimbraFeatureDistributionListExpandMembersEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1134)
    public Map<String,Object> setFeatureDistributionListExpandMembersEnabled(boolean zimbraFeatureDistributionListExpandMembersEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListExpandMembersEnabled, zimbraFeatureDistributionListExpandMembersEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether expanding distribution list members feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1134)
    public void unsetFeatureDistributionListExpandMembersEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListExpandMembersEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether expanding distribution list members feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1134)
    public Map<String,Object> unsetFeatureDistributionListExpandMembersEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListExpandMembersEnabled, "");
        return attrs;
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @return zimbraFeatureDistributionListFolderEnabled, or true if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public boolean isFeatureDistributionListFolderEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, true, true);
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @param zimbraFeatureDistributionListFolderEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public void setFeatureDistributionListFolderEnabled(boolean zimbraFeatureDistributionListFolderEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, zimbraFeatureDistributionListFolderEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @param zimbraFeatureDistributionListFolderEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public Map<String,Object> setFeatureDistributionListFolderEnabled(boolean zimbraFeatureDistributionListFolderEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, zimbraFeatureDistributionListFolderEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public void unsetFeatureDistributionListFolderEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public Map<String,Object> unsetFeatureDistributionListFolderEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, "");
        return attrs;
    }

    /**
     * Whether to allow a user to access EWS service
     *
     * @return zimbraFeatureEwsEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1574)
    public boolean isFeatureEwsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureEwsEnabled, false, true);
    }

    /**
     * Whether to allow a user to access EWS service
     *
     * @param zimbraFeatureEwsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1574)
    public void setFeatureEwsEnabled(boolean zimbraFeatureEwsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureEwsEnabled, zimbraFeatureEwsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access EWS service
     *
     * @param zimbraFeatureEwsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1574)
    public Map<String,Object> setFeatureEwsEnabled(boolean zimbraFeatureEwsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureEwsEnabled, zimbraFeatureEwsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow a user to access EWS service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1574)
    public void unsetFeatureEwsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureEwsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access EWS service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1574)
    public Map<String,Object> unsetFeatureEwsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureEwsEnabled, "");
        return attrs;
    }

    /**
     * whether export folder feature is enabled
     *
     * @return zimbraFeatureExportFolderEnabled, or true if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1185)
    public boolean isFeatureExportFolderEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureExportFolderEnabled, true, true);
    }

    /**
     * whether export folder feature is enabled
     *
     * @param zimbraFeatureExportFolderEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1185)
    public void setFeatureExportFolderEnabled(boolean zimbraFeatureExportFolderEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureExportFolderEnabled, zimbraFeatureExportFolderEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether export folder feature is enabled
     *
     * @param zimbraFeatureExportFolderEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1185)
    public Map<String,Object> setFeatureExportFolderEnabled(boolean zimbraFeatureExportFolderEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureExportFolderEnabled, zimbraFeatureExportFolderEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether export folder feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1185)
    public void unsetFeatureExportFolderEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureExportFolderEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether export folder feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1185)
    public Map<String,Object> unsetFeatureExportFolderEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureExportFolderEnabled, "");
        return attrs;
    }

    /**
     * whether external feedback feature is enabled
     *
     * @return zimbraFeatureExternalFeedbackEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1373)
    public boolean isFeatureExternalFeedbackEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureExternalFeedbackEnabled, false, true);
    }

    /**
     * whether external feedback feature is enabled
     *
     * @param zimbraFeatureExternalFeedbackEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1373)
    public void setFeatureExternalFeedbackEnabled(boolean zimbraFeatureExternalFeedbackEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureExternalFeedbackEnabled, zimbraFeatureExternalFeedbackEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether external feedback feature is enabled
     *
     * @param zimbraFeatureExternalFeedbackEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1373)
    public Map<String,Object> setFeatureExternalFeedbackEnabled(boolean zimbraFeatureExternalFeedbackEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureExternalFeedbackEnabled, zimbraFeatureExternalFeedbackEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether external feedback feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1373)
    public void unsetFeatureExternalFeedbackEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureExternalFeedbackEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether external feedback feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1373)
    public Map<String,Object> unsetFeatureExternalFeedbackEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureExternalFeedbackEnabled, "");
        return attrs;
    }

    /**
     * filter prefs enabled
     *
     * @return zimbraFeatureFiltersEnabled, or true if unset
     */
    @ZAttr(id=143)
    public boolean isFeatureFiltersEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureFiltersEnabled, true, true);
    }

    /**
     * filter prefs enabled
     *
     * @param zimbraFeatureFiltersEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=143)
    public void setFeatureFiltersEnabled(boolean zimbraFeatureFiltersEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFiltersEnabled, zimbraFeatureFiltersEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * filter prefs enabled
     *
     * @param zimbraFeatureFiltersEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=143)
    public Map<String,Object> setFeatureFiltersEnabled(boolean zimbraFeatureFiltersEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFiltersEnabled, zimbraFeatureFiltersEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * filter prefs enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=143)
    public void unsetFeatureFiltersEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFiltersEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * filter prefs enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=143)
    public Map<String,Object> unsetFeatureFiltersEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFiltersEnabled, "");
        return attrs;
    }

    /**
     * whether to allow use of flagging feature
     *
     * @return zimbraFeatureFlaggingEnabled, or true if unset
     */
    @ZAttr(id=499)
    public boolean isFeatureFlaggingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureFlaggingEnabled, true, true);
    }

    /**
     * whether to allow use of flagging feature
     *
     * @param zimbraFeatureFlaggingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=499)
    public void setFeatureFlaggingEnabled(boolean zimbraFeatureFlaggingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFlaggingEnabled, zimbraFeatureFlaggingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of flagging feature
     *
     * @param zimbraFeatureFlaggingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=499)
    public Map<String,Object> setFeatureFlaggingEnabled(boolean zimbraFeatureFlaggingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFlaggingEnabled, zimbraFeatureFlaggingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow use of flagging feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=499)
    public void unsetFeatureFlaggingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFlaggingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of flagging feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=499)
    public Map<String,Object> unsetFeatureFlaggingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFlaggingEnabled, "");
        return attrs;
    }

    /**
     * whether free busy view is enabled in the web UI
     *
     * @return zimbraFeatureFreeBusyViewEnabled, or false if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1143)
    public boolean isFeatureFreeBusyViewEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureFreeBusyViewEnabled, false, true);
    }

    /**
     * whether free busy view is enabled in the web UI
     *
     * @param zimbraFeatureFreeBusyViewEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1143)
    public void setFeatureFreeBusyViewEnabled(boolean zimbraFeatureFreeBusyViewEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFreeBusyViewEnabled, zimbraFeatureFreeBusyViewEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether free busy view is enabled in the web UI
     *
     * @param zimbraFeatureFreeBusyViewEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1143)
    public Map<String,Object> setFeatureFreeBusyViewEnabled(boolean zimbraFeatureFreeBusyViewEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFreeBusyViewEnabled, zimbraFeatureFreeBusyViewEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether free busy view is enabled in the web UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1143)
    public void unsetFeatureFreeBusyViewEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFreeBusyViewEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether free busy view is enabled in the web UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1143)
    public Map<String,Object> unsetFeatureFreeBusyViewEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFreeBusyViewEnabled, "");
        return attrs;
    }

    /**
     * whether to display from address control in user preferences
     *
     * @return zimbraFeatureFromDisplayEnabled, or true if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1455)
    public boolean isFeatureFromDisplayEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureFromDisplayEnabled, true, true);
    }

    /**
     * whether to display from address control in user preferences
     *
     * @param zimbraFeatureFromDisplayEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1455)
    public void setFeatureFromDisplayEnabled(boolean zimbraFeatureFromDisplayEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFromDisplayEnabled, zimbraFeatureFromDisplayEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display from address control in user preferences
     *
     * @param zimbraFeatureFromDisplayEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1455)
    public Map<String,Object> setFeatureFromDisplayEnabled(boolean zimbraFeatureFromDisplayEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFromDisplayEnabled, zimbraFeatureFromDisplayEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to display from address control in user preferences
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1455)
    public void unsetFeatureFromDisplayEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFromDisplayEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display from address control in user preferences
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1455)
    public Map<String,Object> unsetFeatureFromDisplayEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureFromDisplayEnabled, "");
        return attrs;
    }

    /**
     * enable auto-completion from the GAL, zimbraFeatureGalEnabled also has
     * to be enabled for the auto-completion feature
     *
     * @return zimbraFeatureGalAutoCompleteEnabled, or true if unset
     */
    @ZAttr(id=359)
    public boolean isFeatureGalAutoCompleteEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureGalAutoCompleteEnabled, true, true);
    }

    /**
     * enable auto-completion from the GAL, zimbraFeatureGalEnabled also has
     * to be enabled for the auto-completion feature
     *
     * @param zimbraFeatureGalAutoCompleteEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=359)
    public void setFeatureGalAutoCompleteEnabled(boolean zimbraFeatureGalAutoCompleteEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalAutoCompleteEnabled, zimbraFeatureGalAutoCompleteEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable auto-completion from the GAL, zimbraFeatureGalEnabled also has
     * to be enabled for the auto-completion feature
     *
     * @param zimbraFeatureGalAutoCompleteEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=359)
    public Map<String,Object> setFeatureGalAutoCompleteEnabled(boolean zimbraFeatureGalAutoCompleteEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalAutoCompleteEnabled, zimbraFeatureGalAutoCompleteEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable auto-completion from the GAL, zimbraFeatureGalEnabled also has
     * to be enabled for the auto-completion feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=359)
    public void unsetFeatureGalAutoCompleteEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalAutoCompleteEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable auto-completion from the GAL, zimbraFeatureGalEnabled also has
     * to be enabled for the auto-completion feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=359)
    public Map<String,Object> unsetFeatureGalAutoCompleteEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalAutoCompleteEnabled, "");
        return attrs;
    }

    /**
     * whether GAL features are enabled
     *
     * @return zimbraFeatureGalEnabled, or true if unset
     */
    @ZAttr(id=149)
    public boolean isFeatureGalEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureGalEnabled, true, true);
    }

    /**
     * whether GAL features are enabled
     *
     * @param zimbraFeatureGalEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=149)
    public void setFeatureGalEnabled(boolean zimbraFeatureGalEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalEnabled, zimbraFeatureGalEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether GAL features are enabled
     *
     * @param zimbraFeatureGalEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=149)
    public Map<String,Object> setFeatureGalEnabled(boolean zimbraFeatureGalEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalEnabled, zimbraFeatureGalEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether GAL features are enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=149)
    public void unsetFeatureGalEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether GAL features are enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=149)
    public Map<String,Object> unsetFeatureGalEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalEnabled, "");
        return attrs;
    }

    /**
     * whether GAL sync feature is enabled
     *
     * @return zimbraFeatureGalSyncEnabled, or true if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=711)
    public boolean isFeatureGalSyncEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureGalSyncEnabled, true, true);
    }

    /**
     * whether GAL sync feature is enabled
     *
     * @param zimbraFeatureGalSyncEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=711)
    public void setFeatureGalSyncEnabled(boolean zimbraFeatureGalSyncEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalSyncEnabled, zimbraFeatureGalSyncEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether GAL sync feature is enabled
     *
     * @param zimbraFeatureGalSyncEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=711)
    public Map<String,Object> setFeatureGalSyncEnabled(boolean zimbraFeatureGalSyncEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalSyncEnabled, zimbraFeatureGalSyncEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether GAL sync feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=711)
    public void unsetFeatureGalSyncEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalSyncEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether GAL sync feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=711)
    public Map<String,Object> unsetFeatureGalSyncEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGalSyncEnabled, "");
        return attrs;
    }

    /**
     * group calendar features. if set to FALSE, calendar works as a personal
     * calendar and attendees and scheduling etc are turned off in web UI
     *
     * @return zimbraFeatureGroupCalendarEnabled, or true if unset
     */
    @ZAttr(id=481)
    public boolean isFeatureGroupCalendarEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureGroupCalendarEnabled, true, true);
    }

    /**
     * group calendar features. if set to FALSE, calendar works as a personal
     * calendar and attendees and scheduling etc are turned off in web UI
     *
     * @param zimbraFeatureGroupCalendarEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=481)
    public void setFeatureGroupCalendarEnabled(boolean zimbraFeatureGroupCalendarEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGroupCalendarEnabled, zimbraFeatureGroupCalendarEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * group calendar features. if set to FALSE, calendar works as a personal
     * calendar and attendees and scheduling etc are turned off in web UI
     *
     * @param zimbraFeatureGroupCalendarEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=481)
    public Map<String,Object> setFeatureGroupCalendarEnabled(boolean zimbraFeatureGroupCalendarEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGroupCalendarEnabled, zimbraFeatureGroupCalendarEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * group calendar features. if set to FALSE, calendar works as a personal
     * calendar and attendees and scheduling etc are turned off in web UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=481)
    public void unsetFeatureGroupCalendarEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGroupCalendarEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * group calendar features. if set to FALSE, calendar works as a personal
     * calendar and attendees and scheduling etc are turned off in web UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=481)
    public Map<String,Object> unsetFeatureGroupCalendarEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureGroupCalendarEnabled, "");
        return attrs;
    }

    /**
     * enabled html composing
     *
     * @return zimbraFeatureHtmlComposeEnabled, or true if unset
     */
    @ZAttr(id=219)
    public boolean isFeatureHtmlComposeEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureHtmlComposeEnabled, true, true);
    }

    /**
     * enabled html composing
     *
     * @param zimbraFeatureHtmlComposeEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=219)
    public void setFeatureHtmlComposeEnabled(boolean zimbraFeatureHtmlComposeEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureHtmlComposeEnabled, zimbraFeatureHtmlComposeEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enabled html composing
     *
     * @param zimbraFeatureHtmlComposeEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=219)
    public Map<String,Object> setFeatureHtmlComposeEnabled(boolean zimbraFeatureHtmlComposeEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureHtmlComposeEnabled, zimbraFeatureHtmlComposeEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enabled html composing
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=219)
    public void unsetFeatureHtmlComposeEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureHtmlComposeEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enabled html composing
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=219)
    public Map<String,Object> unsetFeatureHtmlComposeEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureHtmlComposeEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. deprecated in favor of
     * zimbraFeatureChatEnabled. Orig desc: IM features
     *
     * @return zimbraFeatureIMEnabled, or false if unset
     */
    @ZAttr(id=305)
    public boolean isFeatureIMEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureIMEnabled, false, true);
    }

    /**
     * Deprecated since: 8.7.0. deprecated in favor of
     * zimbraFeatureChatEnabled. Orig desc: IM features
     *
     * @param zimbraFeatureIMEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=305)
    public void setFeatureIMEnabled(boolean zimbraFeatureIMEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureIMEnabled, zimbraFeatureIMEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. deprecated in favor of
     * zimbraFeatureChatEnabled. Orig desc: IM features
     *
     * @param zimbraFeatureIMEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=305)
    public Map<String,Object> setFeatureIMEnabled(boolean zimbraFeatureIMEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureIMEnabled, zimbraFeatureIMEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. deprecated in favor of
     * zimbraFeatureChatEnabled. Orig desc: IM features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=305)
    public void unsetFeatureIMEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureIMEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. deprecated in favor of
     * zimbraFeatureChatEnabled. Orig desc: IM features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=305)
    public Map<String,Object> unsetFeatureIMEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureIMEnabled, "");
        return attrs;
    }

    /**
     * whether to allow use of identities feature
     *
     * @return zimbraFeatureIdentitiesEnabled, or true if unset
     */
    @ZAttr(id=415)
    public boolean isFeatureIdentitiesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureIdentitiesEnabled, true, true);
    }

    /**
     * whether to allow use of identities feature
     *
     * @param zimbraFeatureIdentitiesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=415)
    public void setFeatureIdentitiesEnabled(boolean zimbraFeatureIdentitiesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureIdentitiesEnabled, zimbraFeatureIdentitiesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of identities feature
     *
     * @param zimbraFeatureIdentitiesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=415)
    public Map<String,Object> setFeatureIdentitiesEnabled(boolean zimbraFeatureIdentitiesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureIdentitiesEnabled, zimbraFeatureIdentitiesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow use of identities feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=415)
    public void unsetFeatureIdentitiesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureIdentitiesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of identities feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=415)
    public Map<String,Object> unsetFeatureIdentitiesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureIdentitiesEnabled, "");
        return attrs;
    }

    /**
     * whether user is allowed to retrieve mail from an external IMAP data
     * source
     *
     * @return zimbraFeatureImapDataSourceEnabled, or true if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=568)
    public boolean isFeatureImapDataSourceEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureImapDataSourceEnabled, true, true);
    }

    /**
     * whether user is allowed to retrieve mail from an external IMAP data
     * source
     *
     * @param zimbraFeatureImapDataSourceEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=568)
    public void setFeatureImapDataSourceEnabled(boolean zimbraFeatureImapDataSourceEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImapDataSourceEnabled, zimbraFeatureImapDataSourceEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether user is allowed to retrieve mail from an external IMAP data
     * source
     *
     * @param zimbraFeatureImapDataSourceEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=568)
    public Map<String,Object> setFeatureImapDataSourceEnabled(boolean zimbraFeatureImapDataSourceEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImapDataSourceEnabled, zimbraFeatureImapDataSourceEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether user is allowed to retrieve mail from an external IMAP data
     * source
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=568)
    public void unsetFeatureImapDataSourceEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImapDataSourceEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether user is allowed to retrieve mail from an external IMAP data
     * source
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=568)
    public Map<String,Object> unsetFeatureImapDataSourceEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImapDataSourceEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 7.1.0. deprecated in favor of
     * zimbraFeatureImportFolderEnabled and zimbraFeatureExportFolderEnabled
     * for bug 53745. Orig desc: whether import export folder feature is
     * enabled
     *
     * @return zimbraFeatureImportExportFolderEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=750)
    public boolean isFeatureImportExportFolderEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureImportExportFolderEnabled, true, true);
    }

    /**
     * Deprecated since: 7.1.0. deprecated in favor of
     * zimbraFeatureImportFolderEnabled and zimbraFeatureExportFolderEnabled
     * for bug 53745. Orig desc: whether import export folder feature is
     * enabled
     *
     * @param zimbraFeatureImportExportFolderEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=750)
    public void setFeatureImportExportFolderEnabled(boolean zimbraFeatureImportExportFolderEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImportExportFolderEnabled, zimbraFeatureImportExportFolderEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 7.1.0. deprecated in favor of
     * zimbraFeatureImportFolderEnabled and zimbraFeatureExportFolderEnabled
     * for bug 53745. Orig desc: whether import export folder feature is
     * enabled
     *
     * @param zimbraFeatureImportExportFolderEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=750)
    public Map<String,Object> setFeatureImportExportFolderEnabled(boolean zimbraFeatureImportExportFolderEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImportExportFolderEnabled, zimbraFeatureImportExportFolderEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 7.1.0. deprecated in favor of
     * zimbraFeatureImportFolderEnabled and zimbraFeatureExportFolderEnabled
     * for bug 53745. Orig desc: whether import export folder feature is
     * enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=750)
    public void unsetFeatureImportExportFolderEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImportExportFolderEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 7.1.0. deprecated in favor of
     * zimbraFeatureImportFolderEnabled and zimbraFeatureExportFolderEnabled
     * for bug 53745. Orig desc: whether import export folder feature is
     * enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=750)
    public Map<String,Object> unsetFeatureImportExportFolderEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImportExportFolderEnabled, "");
        return attrs;
    }

    /**
     * whether import folder feature is enabled
     *
     * @return zimbraFeatureImportFolderEnabled, or true if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1184)
    public boolean isFeatureImportFolderEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureImportFolderEnabled, true, true);
    }

    /**
     * whether import folder feature is enabled
     *
     * @param zimbraFeatureImportFolderEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1184)
    public void setFeatureImportFolderEnabled(boolean zimbraFeatureImportFolderEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImportFolderEnabled, zimbraFeatureImportFolderEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether import folder feature is enabled
     *
     * @param zimbraFeatureImportFolderEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1184)
    public Map<String,Object> setFeatureImportFolderEnabled(boolean zimbraFeatureImportFolderEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImportFolderEnabled, zimbraFeatureImportFolderEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether import folder feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1184)
    public void unsetFeatureImportFolderEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImportFolderEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether import folder feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1184)
    public Map<String,Object> unsetFeatureImportFolderEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureImportFolderEnabled, "");
        return attrs;
    }

    /**
     * preference to set initial search
     *
     * @return zimbraFeatureInitialSearchPreferenceEnabled, or true if unset
     */
    @ZAttr(id=142)
    public boolean isFeatureInitialSearchPreferenceEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureInitialSearchPreferenceEnabled, true, true);
    }

    /**
     * preference to set initial search
     *
     * @param zimbraFeatureInitialSearchPreferenceEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=142)
    public void setFeatureInitialSearchPreferenceEnabled(boolean zimbraFeatureInitialSearchPreferenceEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureInitialSearchPreferenceEnabled, zimbraFeatureInitialSearchPreferenceEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * preference to set initial search
     *
     * @param zimbraFeatureInitialSearchPreferenceEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=142)
    public Map<String,Object> setFeatureInitialSearchPreferenceEnabled(boolean zimbraFeatureInitialSearchPreferenceEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureInitialSearchPreferenceEnabled, zimbraFeatureInitialSearchPreferenceEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * preference to set initial search
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=142)
    public void unsetFeatureInitialSearchPreferenceEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureInitialSearchPreferenceEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * preference to set initial search
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=142)
    public Map<String,Object> unsetFeatureInitialSearchPreferenceEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureInitialSearchPreferenceEnabled, "");
        return attrs;
    }

    /**
     * Enable instant notifications
     *
     * @return zimbraFeatureInstantNotify, or true if unset
     */
    @ZAttr(id=521)
    public boolean isFeatureInstantNotify() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureInstantNotify, true, true);
    }

    /**
     * Enable instant notifications
     *
     * @param zimbraFeatureInstantNotify new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=521)
    public void setFeatureInstantNotify(boolean zimbraFeatureInstantNotify) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureInstantNotify, zimbraFeatureInstantNotify ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable instant notifications
     *
     * @param zimbraFeatureInstantNotify new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=521)
    public Map<String,Object> setFeatureInstantNotify(boolean zimbraFeatureInstantNotify, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureInstantNotify, zimbraFeatureInstantNotify ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Enable instant notifications
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=521)
    public void unsetFeatureInstantNotify() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureInstantNotify, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable instant notifications
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=521)
    public Map<String,Object> unsetFeatureInstantNotify(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureInstantNotify, "");
        return attrs;
    }

    /**
     * enable/disable MAPI (Microsoft Outlook) Connector
     *
     * @return zimbraFeatureMAPIConnectorEnabled, or true if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1127)
    public boolean isFeatureMAPIConnectorEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMAPIConnectorEnabled, true, true);
    }

    /**
     * enable/disable MAPI (Microsoft Outlook) Connector
     *
     * @param zimbraFeatureMAPIConnectorEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1127)
    public void setFeatureMAPIConnectorEnabled(boolean zimbraFeatureMAPIConnectorEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMAPIConnectorEnabled, zimbraFeatureMAPIConnectorEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable/disable MAPI (Microsoft Outlook) Connector
     *
     * @param zimbraFeatureMAPIConnectorEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1127)
    public Map<String,Object> setFeatureMAPIConnectorEnabled(boolean zimbraFeatureMAPIConnectorEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMAPIConnectorEnabled, zimbraFeatureMAPIConnectorEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable/disable MAPI (Microsoft Outlook) Connector
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1127)
    public void unsetFeatureMAPIConnectorEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMAPIConnectorEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable/disable MAPI (Microsoft Outlook) Connector
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1127)
    public Map<String,Object> unsetFeatureMAPIConnectorEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMAPIConnectorEnabled, "");
        return attrs;
    }

    /**
     * email features enabled
     *
     * @return zimbraFeatureMailEnabled, or true if unset
     */
    @ZAttr(id=489)
    public boolean isFeatureMailEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMailEnabled, true, true);
    }

    /**
     * email features enabled
     *
     * @param zimbraFeatureMailEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=489)
    public void setFeatureMailEnabled(boolean zimbraFeatureMailEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailEnabled, zimbraFeatureMailEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email features enabled
     *
     * @param zimbraFeatureMailEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=489)
    public Map<String,Object> setFeatureMailEnabled(boolean zimbraFeatureMailEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailEnabled, zimbraFeatureMailEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * email features enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=489)
    public void unsetFeatureMailEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email features enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=489)
    public Map<String,Object> unsetFeatureMailEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailEnabled, "");
        return attrs;
    }

    /**
     * enable end-user mail forwarding features
     *
     * @return zimbraFeatureMailForwardingEnabled, or true if unset
     */
    @ZAttr(id=342)
    public boolean isFeatureMailForwardingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMailForwardingEnabled, true, true);
    }

    /**
     * enable end-user mail forwarding features
     *
     * @param zimbraFeatureMailForwardingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=342)
    public void setFeatureMailForwardingEnabled(boolean zimbraFeatureMailForwardingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailForwardingEnabled, zimbraFeatureMailForwardingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable end-user mail forwarding features
     *
     * @param zimbraFeatureMailForwardingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=342)
    public Map<String,Object> setFeatureMailForwardingEnabled(boolean zimbraFeatureMailForwardingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailForwardingEnabled, zimbraFeatureMailForwardingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable end-user mail forwarding features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=342)
    public void unsetFeatureMailForwardingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailForwardingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable end-user mail forwarding features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=342)
    public Map<String,Object> unsetFeatureMailForwardingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailForwardingEnabled, "");
        return attrs;
    }

    /**
     * enable end-user mail forwarding defined in mail filters features
     *
     * @return zimbraFeatureMailForwardingInFiltersEnabled, or true if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=704)
    public boolean isFeatureMailForwardingInFiltersEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMailForwardingInFiltersEnabled, true, true);
    }

    /**
     * enable end-user mail forwarding defined in mail filters features
     *
     * @param zimbraFeatureMailForwardingInFiltersEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=704)
    public void setFeatureMailForwardingInFiltersEnabled(boolean zimbraFeatureMailForwardingInFiltersEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailForwardingInFiltersEnabled, zimbraFeatureMailForwardingInFiltersEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable end-user mail forwarding defined in mail filters features
     *
     * @param zimbraFeatureMailForwardingInFiltersEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=704)
    public Map<String,Object> setFeatureMailForwardingInFiltersEnabled(boolean zimbraFeatureMailForwardingInFiltersEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailForwardingInFiltersEnabled, zimbraFeatureMailForwardingInFiltersEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable end-user mail forwarding defined in mail filters features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=704)
    public void unsetFeatureMailForwardingInFiltersEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailForwardingInFiltersEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable end-user mail forwarding defined in mail filters features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=704)
    public Map<String,Object> unsetFeatureMailForwardingInFiltersEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailForwardingInFiltersEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. done via skin template overrides. Orig desc:
     * whether user is allowed to set mail polling interval
     *
     * @return zimbraFeatureMailPollingIntervalPreferenceEnabled, or true if unset
     */
    @ZAttr(id=441)
    public boolean isFeatureMailPollingIntervalPreferenceEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMailPollingIntervalPreferenceEnabled, true, true);
    }

    /**
     * Deprecated since: 5.0. done via skin template overrides. Orig desc:
     * whether user is allowed to set mail polling interval
     *
     * @param zimbraFeatureMailPollingIntervalPreferenceEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=441)
    public void setFeatureMailPollingIntervalPreferenceEnabled(boolean zimbraFeatureMailPollingIntervalPreferenceEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailPollingIntervalPreferenceEnabled, zimbraFeatureMailPollingIntervalPreferenceEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. done via skin template overrides. Orig desc:
     * whether user is allowed to set mail polling interval
     *
     * @param zimbraFeatureMailPollingIntervalPreferenceEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=441)
    public Map<String,Object> setFeatureMailPollingIntervalPreferenceEnabled(boolean zimbraFeatureMailPollingIntervalPreferenceEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailPollingIntervalPreferenceEnabled, zimbraFeatureMailPollingIntervalPreferenceEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. done via skin template overrides. Orig desc:
     * whether user is allowed to set mail polling interval
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=441)
    public void unsetFeatureMailPollingIntervalPreferenceEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailPollingIntervalPreferenceEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. done via skin template overrides. Orig desc:
     * whether user is allowed to set mail polling interval
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=441)
    public Map<String,Object> unsetFeatureMailPollingIntervalPreferenceEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailPollingIntervalPreferenceEnabled, "");
        return attrs;
    }

    /**
     * mail priority feature
     *
     * @return zimbraFeatureMailPriorityEnabled, or true if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=566)
    public boolean isFeatureMailPriorityEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMailPriorityEnabled, true, true);
    }

    /**
     * mail priority feature
     *
     * @param zimbraFeatureMailPriorityEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=566)
    public void setFeatureMailPriorityEnabled(boolean zimbraFeatureMailPriorityEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailPriorityEnabled, zimbraFeatureMailPriorityEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail priority feature
     *
     * @param zimbraFeatureMailPriorityEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=566)
    public Map<String,Object> setFeatureMailPriorityEnabled(boolean zimbraFeatureMailPriorityEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailPriorityEnabled, zimbraFeatureMailPriorityEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * mail priority feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=566)
    public void unsetFeatureMailPriorityEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailPriorityEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail priority feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=566)
    public Map<String,Object> unsetFeatureMailPriorityEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailPriorityEnabled, "");
        return attrs;
    }

    /**
     * whether the send later feature is enabled
     *
     * @return zimbraFeatureMailSendLaterEnabled, or false if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1137)
    public boolean isFeatureMailSendLaterEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMailSendLaterEnabled, false, true);
    }

    /**
     * whether the send later feature is enabled
     *
     * @param zimbraFeatureMailSendLaterEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1137)
    public void setFeatureMailSendLaterEnabled(boolean zimbraFeatureMailSendLaterEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailSendLaterEnabled, zimbraFeatureMailSendLaterEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the send later feature is enabled
     *
     * @param zimbraFeatureMailSendLaterEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1137)
    public Map<String,Object> setFeatureMailSendLaterEnabled(boolean zimbraFeatureMailSendLaterEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailSendLaterEnabled, zimbraFeatureMailSendLaterEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether the send later feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1137)
    public void unsetFeatureMailSendLaterEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailSendLaterEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the send later feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1137)
    public Map<String,Object> unsetFeatureMailSendLaterEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailSendLaterEnabled, "");
        return attrs;
    }

    /**
     * email upsell enabled
     *
     * @return zimbraFeatureMailUpsellEnabled, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=527)
    public boolean isFeatureMailUpsellEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMailUpsellEnabled, false, true);
    }

    /**
     * email upsell enabled
     *
     * @param zimbraFeatureMailUpsellEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=527)
    public void setFeatureMailUpsellEnabled(boolean zimbraFeatureMailUpsellEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailUpsellEnabled, zimbraFeatureMailUpsellEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email upsell enabled
     *
     * @param zimbraFeatureMailUpsellEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=527)
    public Map<String,Object> setFeatureMailUpsellEnabled(boolean zimbraFeatureMailUpsellEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailUpsellEnabled, zimbraFeatureMailUpsellEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * email upsell enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=527)
    public void unsetFeatureMailUpsellEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailUpsellEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email upsell enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=527)
    public Map<String,Object> unsetFeatureMailUpsellEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailUpsellEnabled, "");
        return attrs;
    }

    /**
     * email upsell URL
     *
     * @return zimbraFeatureMailUpsellURL, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=528)
    public String getFeatureMailUpsellURL() {
        return getAttr(Provisioning.A_zimbraFeatureMailUpsellURL, null, true);
    }

    /**
     * email upsell URL
     *
     * @param zimbraFeatureMailUpsellURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=528)
    public void setFeatureMailUpsellURL(String zimbraFeatureMailUpsellURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailUpsellURL, zimbraFeatureMailUpsellURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email upsell URL
     *
     * @param zimbraFeatureMailUpsellURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=528)
    public Map<String,Object> setFeatureMailUpsellURL(String zimbraFeatureMailUpsellURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailUpsellURL, zimbraFeatureMailUpsellURL);
        return attrs;
    }

    /**
     * email upsell URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=528)
    public void unsetFeatureMailUpsellURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailUpsellURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email upsell URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=528)
    public Map<String,Object> unsetFeatureMailUpsellURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMailUpsellURL, "");
        return attrs;
    }

    /**
     * whether to allow end user to publish and remove S/MIME certificates to
     * their GAL entry in the web UI
     *
     * @return zimbraFeatureManageSMIMECertificateEnabled, or false if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1183)
    public boolean isFeatureManageSMIMECertificateEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureManageSMIMECertificateEnabled, false, true);
    }

    /**
     * whether to allow end user to publish and remove S/MIME certificates to
     * their GAL entry in the web UI
     *
     * @param zimbraFeatureManageSMIMECertificateEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1183)
    public void setFeatureManageSMIMECertificateEnabled(boolean zimbraFeatureManageSMIMECertificateEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureManageSMIMECertificateEnabled, zimbraFeatureManageSMIMECertificateEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow end user to publish and remove S/MIME certificates to
     * their GAL entry in the web UI
     *
     * @param zimbraFeatureManageSMIMECertificateEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1183)
    public Map<String,Object> setFeatureManageSMIMECertificateEnabled(boolean zimbraFeatureManageSMIMECertificateEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureManageSMIMECertificateEnabled, zimbraFeatureManageSMIMECertificateEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow end user to publish and remove S/MIME certificates to
     * their GAL entry in the web UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1183)
    public void unsetFeatureManageSMIMECertificateEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureManageSMIMECertificateEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow end user to publish and remove S/MIME certificates to
     * their GAL entry in the web UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1183)
    public Map<String,Object> unsetFeatureManageSMIMECertificateEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureManageSMIMECertificateEnabled, "");
        return attrs;
    }

    /**
     * enable end-user to manage zimlets
     *
     * @return zimbraFeatureManageZimlets, or true if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1051)
    public boolean isFeatureManageZimlets() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureManageZimlets, true, true);
    }

    /**
     * enable end-user to manage zimlets
     *
     * @param zimbraFeatureManageZimlets new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1051)
    public void setFeatureManageZimlets(boolean zimbraFeatureManageZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureManageZimlets, zimbraFeatureManageZimlets ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable end-user to manage zimlets
     *
     * @param zimbraFeatureManageZimlets new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1051)
    public Map<String,Object> setFeatureManageZimlets(boolean zimbraFeatureManageZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureManageZimlets, zimbraFeatureManageZimlets ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable end-user to manage zimlets
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1051)
    public void unsetFeatureManageZimlets() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureManageZimlets, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable end-user to manage zimlets
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1051)
    public Map<String,Object> unsetFeatureManageZimlets(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureManageZimlets, "");
        return attrs;
    }

    /**
     * Mark messages sent to a forwarding address as read
     *
     * @return zimbraFeatureMarkMailForwardedAsRead, or false if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2123)
    public boolean isFeatureMarkMailForwardedAsRead() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMarkMailForwardedAsRead, false, true);
    }

    /**
     * Mark messages sent to a forwarding address as read
     *
     * @param zimbraFeatureMarkMailForwardedAsRead new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2123)
    public void setFeatureMarkMailForwardedAsRead(boolean zimbraFeatureMarkMailForwardedAsRead) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMarkMailForwardedAsRead, zimbraFeatureMarkMailForwardedAsRead ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mark messages sent to a forwarding address as read
     *
     * @param zimbraFeatureMarkMailForwardedAsRead new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2123)
    public Map<String,Object> setFeatureMarkMailForwardedAsRead(boolean zimbraFeatureMarkMailForwardedAsRead, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMarkMailForwardedAsRead, zimbraFeatureMarkMailForwardedAsRead ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Mark messages sent to a forwarding address as read
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2123)
    public void unsetFeatureMarkMailForwardedAsRead() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMarkMailForwardedAsRead, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mark messages sent to a forwarding address as read
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2123)
    public Map<String,Object> unsetFeatureMarkMailForwardedAsRead(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMarkMailForwardedAsRead, "");
        return attrs;
    }

    /**
     * Whether to allow a user to access Zimbra mobile App
     *
     * @return zimbraFeatureMobileAppEnabled, or false if unset
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3083)
    public boolean isFeatureMobileAppEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMobileAppEnabled, false, true);
    }

    /**
     * Whether to allow a user to access Zimbra mobile App
     *
     * @param zimbraFeatureMobileAppEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3083)
    public void setFeatureMobileAppEnabled(boolean zimbraFeatureMobileAppEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileAppEnabled, zimbraFeatureMobileAppEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access Zimbra mobile App
     *
     * @param zimbraFeatureMobileAppEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3083)
    public Map<String,Object> setFeatureMobileAppEnabled(boolean zimbraFeatureMobileAppEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileAppEnabled, zimbraFeatureMobileAppEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow a user to access Zimbra mobile App
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3083)
    public void unsetFeatureMobileAppEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileAppEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access Zimbra mobile App
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3083)
    public Map<String,Object> unsetFeatureMobileAppEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileAppEnabled, "");
        return attrs;
    }

    /**
     * Whether to enable Zimbra Mobile Gateway feature
     *
     * @return zimbraFeatureMobileGatewayEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2063)
    public boolean isFeatureMobileGatewayEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMobileGatewayEnabled, false, true);
    }

    /**
     * Whether to enable Zimbra Mobile Gateway feature
     *
     * @param zimbraFeatureMobileGatewayEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2063)
    public void setFeatureMobileGatewayEnabled(boolean zimbraFeatureMobileGatewayEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileGatewayEnabled, zimbraFeatureMobileGatewayEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable Zimbra Mobile Gateway feature
     *
     * @param zimbraFeatureMobileGatewayEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2063)
    public Map<String,Object> setFeatureMobileGatewayEnabled(boolean zimbraFeatureMobileGatewayEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileGatewayEnabled, zimbraFeatureMobileGatewayEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable Zimbra Mobile Gateway feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2063)
    public void unsetFeatureMobileGatewayEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileGatewayEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable Zimbra Mobile Gateway feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2063)
    public Map<String,Object> unsetFeatureMobileGatewayEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileGatewayEnabled, "");
        return attrs;
    }

    /**
     * whether to enforce mobile policy
     *
     * @return zimbraFeatureMobilePolicyEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=833)
    public boolean isFeatureMobilePolicyEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMobilePolicyEnabled, true, true);
    }

    /**
     * whether to enforce mobile policy
     *
     * @param zimbraFeatureMobilePolicyEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=833)
    public void setFeatureMobilePolicyEnabled(boolean zimbraFeatureMobilePolicyEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobilePolicyEnabled, zimbraFeatureMobilePolicyEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enforce mobile policy
     *
     * @param zimbraFeatureMobilePolicyEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=833)
    public Map<String,Object> setFeatureMobilePolicyEnabled(boolean zimbraFeatureMobilePolicyEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobilePolicyEnabled, zimbraFeatureMobilePolicyEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to enforce mobile policy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=833)
    public void unsetFeatureMobilePolicyEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobilePolicyEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enforce mobile policy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=833)
    public Map<String,Object> unsetFeatureMobilePolicyEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobilePolicyEnabled, "");
        return attrs;
    }

    /**
     * whether to permit mobile sync
     *
     * @return zimbraFeatureMobileSyncEnabled, or false if unset
     */
    @ZAttr(id=347)
    public boolean isFeatureMobileSyncEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureMobileSyncEnabled, false, true);
    }

    /**
     * whether to permit mobile sync
     *
     * @param zimbraFeatureMobileSyncEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=347)
    public void setFeatureMobileSyncEnabled(boolean zimbraFeatureMobileSyncEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileSyncEnabled, zimbraFeatureMobileSyncEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to permit mobile sync
     *
     * @param zimbraFeatureMobileSyncEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=347)
    public Map<String,Object> setFeatureMobileSyncEnabled(boolean zimbraFeatureMobileSyncEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileSyncEnabled, zimbraFeatureMobileSyncEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to permit mobile sync
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=347)
    public void unsetFeatureMobileSyncEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileSyncEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to permit mobile sync
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=347)
    public Map<String,Object> unsetFeatureMobileSyncEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureMobileSyncEnabled, "");
        return attrs;
    }

    /**
     * Whether to allow a user to access Zimbra modern desktop
     *
     * @return zimbraFeatureModernDesktopEnabled, or false if unset
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3082)
    public boolean isFeatureModernDesktopEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureModernDesktopEnabled, false, true);
    }

    /**
     * Whether to allow a user to access Zimbra modern desktop
     *
     * @param zimbraFeatureModernDesktopEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3082)
    public void setFeatureModernDesktopEnabled(boolean zimbraFeatureModernDesktopEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureModernDesktopEnabled, zimbraFeatureModernDesktopEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access Zimbra modern desktop
     *
     * @param zimbraFeatureModernDesktopEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3082)
    public Map<String,Object> setFeatureModernDesktopEnabled(boolean zimbraFeatureModernDesktopEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureModernDesktopEnabled, zimbraFeatureModernDesktopEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow a user to access Zimbra modern desktop
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3082)
    public void unsetFeatureModernDesktopEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureModernDesktopEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access Zimbra modern desktop
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3082)
    public Map<String,Object> unsetFeatureModernDesktopEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureModernDesktopEnabled, "");
        return attrs;
    }

    /**
     * Whether user can create address books
     *
     * @return zimbraFeatureNewAddrBookEnabled, or true if unset
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=631)
    public boolean isFeatureNewAddrBookEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureNewAddrBookEnabled, true, true);
    }

    /**
     * Whether user can create address books
     *
     * @param zimbraFeatureNewAddrBookEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=631)
    public void setFeatureNewAddrBookEnabled(boolean zimbraFeatureNewAddrBookEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNewAddrBookEnabled, zimbraFeatureNewAddrBookEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether user can create address books
     *
     * @param zimbraFeatureNewAddrBookEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=631)
    public Map<String,Object> setFeatureNewAddrBookEnabled(boolean zimbraFeatureNewAddrBookEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNewAddrBookEnabled, zimbraFeatureNewAddrBookEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether user can create address books
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=631)
    public void unsetFeatureNewAddrBookEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNewAddrBookEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether user can create address books
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=631)
    public Map<String,Object> unsetFeatureNewAddrBookEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNewAddrBookEnabled, "");
        return attrs;
    }

    /**
     * Whether new mail notification feature should be allowed for this
     * account or in this cos
     *
     * @return zimbraFeatureNewMailNotificationEnabled, or true if unset
     */
    @ZAttr(id=367)
    public boolean isFeatureNewMailNotificationEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureNewMailNotificationEnabled, true, true);
    }

    /**
     * Whether new mail notification feature should be allowed for this
     * account or in this cos
     *
     * @param zimbraFeatureNewMailNotificationEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=367)
    public void setFeatureNewMailNotificationEnabled(boolean zimbraFeatureNewMailNotificationEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNewMailNotificationEnabled, zimbraFeatureNewMailNotificationEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether new mail notification feature should be allowed for this
     * account or in this cos
     *
     * @param zimbraFeatureNewMailNotificationEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=367)
    public Map<String,Object> setFeatureNewMailNotificationEnabled(boolean zimbraFeatureNewMailNotificationEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNewMailNotificationEnabled, zimbraFeatureNewMailNotificationEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether new mail notification feature should be allowed for this
     * account or in this cos
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=367)
    public void unsetFeatureNewMailNotificationEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNewMailNotificationEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether new mail notification feature should be allowed for this
     * account or in this cos
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=367)
    public Map<String,Object> unsetFeatureNewMailNotificationEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNewMailNotificationEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 7.0.0. Deprecated per bugs 50465, 56201. Orig desc:
     * Whether notebook feature should be allowed for this account or in this
     * cos
     *
     * @return zimbraFeatureNotebookEnabled, or false if unset
     */
    @ZAttr(id=356)
    public boolean isFeatureNotebookEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureNotebookEnabled, false, true);
    }

    /**
     * Deprecated since: 7.0.0. Deprecated per bugs 50465, 56201. Orig desc:
     * Whether notebook feature should be allowed for this account or in this
     * cos
     *
     * @param zimbraFeatureNotebookEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=356)
    public void setFeatureNotebookEnabled(boolean zimbraFeatureNotebookEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNotebookEnabled, zimbraFeatureNotebookEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 7.0.0. Deprecated per bugs 50465, 56201. Orig desc:
     * Whether notebook feature should be allowed for this account or in this
     * cos
     *
     * @param zimbraFeatureNotebookEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=356)
    public Map<String,Object> setFeatureNotebookEnabled(boolean zimbraFeatureNotebookEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNotebookEnabled, zimbraFeatureNotebookEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 7.0.0. Deprecated per bugs 50465, 56201. Orig desc:
     * Whether notebook feature should be allowed for this account or in this
     * cos
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=356)
    public void unsetFeatureNotebookEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNotebookEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 7.0.0. Deprecated per bugs 50465, 56201. Orig desc:
     * Whether notebook feature should be allowed for this account or in this
     * cos
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=356)
    public Map<String,Object> unsetFeatureNotebookEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureNotebookEnabled, "");
        return attrs;
    }

    /**
     * whether or not open a new msg/conv in a new windows is allowed
     *
     * @return zimbraFeatureOpenMailInNewWindowEnabled, or true if unset
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=585)
    public boolean isFeatureOpenMailInNewWindowEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureOpenMailInNewWindowEnabled, true, true);
    }

    /**
     * whether or not open a new msg/conv in a new windows is allowed
     *
     * @param zimbraFeatureOpenMailInNewWindowEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=585)
    public void setFeatureOpenMailInNewWindowEnabled(boolean zimbraFeatureOpenMailInNewWindowEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOpenMailInNewWindowEnabled, zimbraFeatureOpenMailInNewWindowEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not open a new msg/conv in a new windows is allowed
     *
     * @param zimbraFeatureOpenMailInNewWindowEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=585)
    public Map<String,Object> setFeatureOpenMailInNewWindowEnabled(boolean zimbraFeatureOpenMailInNewWindowEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOpenMailInNewWindowEnabled, zimbraFeatureOpenMailInNewWindowEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not open a new msg/conv in a new windows is allowed
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=585)
    public void unsetFeatureOpenMailInNewWindowEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOpenMailInNewWindowEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not open a new msg/conv in a new windows is allowed
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=585)
    public Map<String,Object> unsetFeatureOpenMailInNewWindowEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOpenMailInNewWindowEnabled, "");
        return attrs;
    }

    /**
     * whether an account can modify its zimbraPref* attributes
     *
     * @return zimbraFeatureOptionsEnabled, or true if unset
     */
    @ZAttr(id=451)
    public boolean isFeatureOptionsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureOptionsEnabled, true, true);
    }

    /**
     * whether an account can modify its zimbraPref* attributes
     *
     * @param zimbraFeatureOptionsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=451)
    public void setFeatureOptionsEnabled(boolean zimbraFeatureOptionsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOptionsEnabled, zimbraFeatureOptionsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether an account can modify its zimbraPref* attributes
     *
     * @param zimbraFeatureOptionsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=451)
    public Map<String,Object> setFeatureOptionsEnabled(boolean zimbraFeatureOptionsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOptionsEnabled, zimbraFeatureOptionsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether an account can modify its zimbraPref* attributes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=451)
    public void unsetFeatureOptionsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOptionsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether an account can modify its zimbraPref* attributes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=451)
    public Map<String,Object> unsetFeatureOptionsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOptionsEnabled, "");
        return attrs;
    }

    /**
     * Whether out of office reply feature should be allowed for this account
     * or in this cos
     *
     * @return zimbraFeatureOutOfOfficeReplyEnabled, or true if unset
     */
    @ZAttr(id=366)
    public boolean isFeatureOutOfOfficeReplyEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureOutOfOfficeReplyEnabled, true, true);
    }

    /**
     * Whether out of office reply feature should be allowed for this account
     * or in this cos
     *
     * @param zimbraFeatureOutOfOfficeReplyEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=366)
    public void setFeatureOutOfOfficeReplyEnabled(boolean zimbraFeatureOutOfOfficeReplyEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOutOfOfficeReplyEnabled, zimbraFeatureOutOfOfficeReplyEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether out of office reply feature should be allowed for this account
     * or in this cos
     *
     * @param zimbraFeatureOutOfOfficeReplyEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=366)
    public Map<String,Object> setFeatureOutOfOfficeReplyEnabled(boolean zimbraFeatureOutOfOfficeReplyEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOutOfOfficeReplyEnabled, zimbraFeatureOutOfOfficeReplyEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether out of office reply feature should be allowed for this account
     * or in this cos
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=366)
    public void unsetFeatureOutOfOfficeReplyEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOutOfOfficeReplyEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether out of office reply feature should be allowed for this account
     * or in this cos
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=366)
    public Map<String,Object> unsetFeatureOutOfOfficeReplyEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureOutOfOfficeReplyEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 56924. Orig desc: whether
     * people search feature is enabled
     *
     * @return zimbraFeaturePeopleSearchEnabled, or true if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1109)
    public boolean isFeaturePeopleSearchEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeaturePeopleSearchEnabled, true, true);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 56924. Orig desc: whether
     * people search feature is enabled
     *
     * @param zimbraFeaturePeopleSearchEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1109)
    public void setFeaturePeopleSearchEnabled(boolean zimbraFeaturePeopleSearchEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePeopleSearchEnabled, zimbraFeaturePeopleSearchEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 56924. Orig desc: whether
     * people search feature is enabled
     *
     * @param zimbraFeaturePeopleSearchEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1109)
    public Map<String,Object> setFeaturePeopleSearchEnabled(boolean zimbraFeaturePeopleSearchEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePeopleSearchEnabled, zimbraFeaturePeopleSearchEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 56924. Orig desc: whether
     * people search feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1109)
    public void unsetFeaturePeopleSearchEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePeopleSearchEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 56924. Orig desc: whether
     * people search feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1109)
    public Map<String,Object> unsetFeaturePeopleSearchEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePeopleSearchEnabled, "");
        return attrs;
    }

    /**
     * whether user is allowed to retrieve mail from an external POP3 data
     * source
     *
     * @return zimbraFeaturePop3DataSourceEnabled, or true if unset
     */
    @ZAttr(id=416)
    public boolean isFeaturePop3DataSourceEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeaturePop3DataSourceEnabled, true, true);
    }

    /**
     * whether user is allowed to retrieve mail from an external POP3 data
     * source
     *
     * @param zimbraFeaturePop3DataSourceEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=416)
    public void setFeaturePop3DataSourceEnabled(boolean zimbraFeaturePop3DataSourceEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePop3DataSourceEnabled, zimbraFeaturePop3DataSourceEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether user is allowed to retrieve mail from an external POP3 data
     * source
     *
     * @param zimbraFeaturePop3DataSourceEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=416)
    public Map<String,Object> setFeaturePop3DataSourceEnabled(boolean zimbraFeaturePop3DataSourceEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePop3DataSourceEnabled, zimbraFeaturePop3DataSourceEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether user is allowed to retrieve mail from an external POP3 data
     * source
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=416)
    public void unsetFeaturePop3DataSourceEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePop3DataSourceEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether user is allowed to retrieve mail from an external POP3 data
     * source
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=416)
    public Map<String,Object> unsetFeaturePop3DataSourceEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePop3DataSourceEnabled, "");
        return attrs;
    }

    /**
     * portal features
     *
     * @return zimbraFeaturePortalEnabled, or false if unset
     */
    @ZAttr(id=447)
    public boolean isFeaturePortalEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeaturePortalEnabled, false, true);
    }

    /**
     * portal features
     *
     * @param zimbraFeaturePortalEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=447)
    public void setFeaturePortalEnabled(boolean zimbraFeaturePortalEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePortalEnabled, zimbraFeaturePortalEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * portal features
     *
     * @param zimbraFeaturePortalEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=447)
    public Map<String,Object> setFeaturePortalEnabled(boolean zimbraFeaturePortalEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePortalEnabled, zimbraFeaturePortalEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * portal features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=447)
    public void unsetFeaturePortalEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePortalEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * portal features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=447)
    public Map<String,Object> unsetFeaturePortalEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePortalEnabled, "");
        return attrs;
    }

    /**
     * whether priority inbox feature is enabled
     *
     * @return zimbraFeaturePriorityInboxEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1271)
    public boolean isFeaturePriorityInboxEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeaturePriorityInboxEnabled, true, true);
    }

    /**
     * whether priority inbox feature is enabled
     *
     * @param zimbraFeaturePriorityInboxEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1271)
    public void setFeaturePriorityInboxEnabled(boolean zimbraFeaturePriorityInboxEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePriorityInboxEnabled, zimbraFeaturePriorityInboxEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether priority inbox feature is enabled
     *
     * @param zimbraFeaturePriorityInboxEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1271)
    public Map<String,Object> setFeaturePriorityInboxEnabled(boolean zimbraFeaturePriorityInboxEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePriorityInboxEnabled, zimbraFeaturePriorityInboxEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether priority inbox feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1271)
    public void unsetFeaturePriorityInboxEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePriorityInboxEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether priority inbox feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1271)
    public Map<String,Object> unsetFeaturePriorityInboxEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeaturePriorityInboxEnabled, "");
        return attrs;
    }

    /**
     * whether the web UI shows UI elements related to read receipts
     *
     * @return zimbraFeatureReadReceiptsEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=821)
    public boolean isFeatureReadReceiptsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureReadReceiptsEnabled, true, true);
    }

    /**
     * whether the web UI shows UI elements related to read receipts
     *
     * @param zimbraFeatureReadReceiptsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=821)
    public void setFeatureReadReceiptsEnabled(boolean zimbraFeatureReadReceiptsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureReadReceiptsEnabled, zimbraFeatureReadReceiptsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the web UI shows UI elements related to read receipts
     *
     * @param zimbraFeatureReadReceiptsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=821)
    public Map<String,Object> setFeatureReadReceiptsEnabled(boolean zimbraFeatureReadReceiptsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureReadReceiptsEnabled, zimbraFeatureReadReceiptsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether the web UI shows UI elements related to read receipts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=821)
    public void unsetFeatureReadReceiptsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureReadReceiptsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the web UI shows UI elements related to read receipts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=821)
    public Map<String,Object> unsetFeatureReadReceiptsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureReadReceiptsEnabled, "");
        return attrs;
    }

    /**
     * status of password reset feature
     *
     * <p>Valid values: [enabled, suspended, disabled]
     *
     * @return zimbraFeatureResetPasswordStatus, or ZAttrProvisioning.FeatureResetPasswordStatus.disabled if unset and/or has invalid value
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2134)
    public ZAttrProvisioning.FeatureResetPasswordStatus getFeatureResetPasswordStatus() {
        try { String v = getAttr(Provisioning.A_zimbraFeatureResetPasswordStatus, true, true); return v == null ? ZAttrProvisioning.FeatureResetPasswordStatus.disabled : ZAttrProvisioning.FeatureResetPasswordStatus.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.FeatureResetPasswordStatus.disabled; }
    }

    /**
     * status of password reset feature
     *
     * <p>Valid values: [enabled, suspended, disabled]
     *
     * @return zimbraFeatureResetPasswordStatus, or "disabled" if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2134)
    public String getFeatureResetPasswordStatusAsString() {
        return getAttr(Provisioning.A_zimbraFeatureResetPasswordStatus, "disabled", true);
    }

    /**
     * status of password reset feature
     *
     * <p>Valid values: [enabled, suspended, disabled]
     *
     * @param zimbraFeatureResetPasswordStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2134)
    public void setFeatureResetPasswordStatus(ZAttrProvisioning.FeatureResetPasswordStatus zimbraFeatureResetPasswordStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordStatus, zimbraFeatureResetPasswordStatus.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * status of password reset feature
     *
     * <p>Valid values: [enabled, suspended, disabled]
     *
     * @param zimbraFeatureResetPasswordStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2134)
    public Map<String,Object> setFeatureResetPasswordStatus(ZAttrProvisioning.FeatureResetPasswordStatus zimbraFeatureResetPasswordStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordStatus, zimbraFeatureResetPasswordStatus.toString());
        return attrs;
    }

    /**
     * status of password reset feature
     *
     * <p>Valid values: [enabled, suspended, disabled]
     *
     * @param zimbraFeatureResetPasswordStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2134)
    public void setFeatureResetPasswordStatusAsString(String zimbraFeatureResetPasswordStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordStatus, zimbraFeatureResetPasswordStatus);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * status of password reset feature
     *
     * <p>Valid values: [enabled, suspended, disabled]
     *
     * @param zimbraFeatureResetPasswordStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2134)
    public Map<String,Object> setFeatureResetPasswordStatusAsString(String zimbraFeatureResetPasswordStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordStatus, zimbraFeatureResetPasswordStatus);
        return attrs;
    }

    /**
     * status of password reset feature
     *
     * <p>Valid values: [enabled, suspended, disabled]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2134)
    public void unsetFeatureResetPasswordStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * status of password reset feature
     *
     * <p>Valid values: [enabled, suspended, disabled]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2134)
    public Map<String,Object> unsetFeatureResetPasswordStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordStatus, "");
        return attrs;
    }

    /**
     * time for which reset password feature is suspended. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFeatureResetPasswordSuspensionTimeAsString to access value as a string.
     *
     * @see #getFeatureResetPasswordSuspensionTimeAsString()
     *
     * @return zimbraFeatureResetPasswordSuspensionTime in millseconds, or 86400000 (1d)  if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2142)
    public long getFeatureResetPasswordSuspensionTime() {
        return getTimeInterval(Provisioning.A_zimbraFeatureResetPasswordSuspensionTime, 86400000L, true);
    }

    /**
     * time for which reset password feature is suspended. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFeatureResetPasswordSuspensionTime, or "1d" if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2142)
    public String getFeatureResetPasswordSuspensionTimeAsString() {
        return getAttr(Provisioning.A_zimbraFeatureResetPasswordSuspensionTime, "1d", true);
    }

    /**
     * time for which reset password feature is suspended. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFeatureResetPasswordSuspensionTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2142)
    public void setFeatureResetPasswordSuspensionTime(String zimbraFeatureResetPasswordSuspensionTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordSuspensionTime, zimbraFeatureResetPasswordSuspensionTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time for which reset password feature is suspended. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFeatureResetPasswordSuspensionTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2142)
    public Map<String,Object> setFeatureResetPasswordSuspensionTime(String zimbraFeatureResetPasswordSuspensionTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordSuspensionTime, zimbraFeatureResetPasswordSuspensionTime);
        return attrs;
    }

    /**
     * time for which reset password feature is suspended. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2142)
    public void unsetFeatureResetPasswordSuspensionTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordSuspensionTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time for which reset password feature is suspended. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2142)
    public Map<String,Object> unsetFeatureResetPasswordSuspensionTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureResetPasswordSuspensionTime, "");
        return attrs;
    }

    /**
     * whether S/MIME feature is enabled. Note: SMIME is a Network feature,
     * this attribute is effective only if SMIME is permitted by license.
     *
     * @return zimbraFeatureSMIMEEnabled, or false if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1186)
    public boolean isFeatureSMIMEEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureSMIMEEnabled, false, true);
    }

    /**
     * whether S/MIME feature is enabled. Note: SMIME is a Network feature,
     * this attribute is effective only if SMIME is permitted by license.
     *
     * @param zimbraFeatureSMIMEEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1186)
    public void setFeatureSMIMEEnabled(boolean zimbraFeatureSMIMEEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSMIMEEnabled, zimbraFeatureSMIMEEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether S/MIME feature is enabled. Note: SMIME is a Network feature,
     * this attribute is effective only if SMIME is permitted by license.
     *
     * @param zimbraFeatureSMIMEEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1186)
    public Map<String,Object> setFeatureSMIMEEnabled(boolean zimbraFeatureSMIMEEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSMIMEEnabled, zimbraFeatureSMIMEEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether S/MIME feature is enabled. Note: SMIME is a Network feature,
     * this attribute is effective only if SMIME is permitted by license.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1186)
    public void unsetFeatureSMIMEEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSMIMEEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether S/MIME feature is enabled. Note: SMIME is a Network feature,
     * this attribute is effective only if SMIME is permitted by license.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1186)
    public Map<String,Object> unsetFeatureSMIMEEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSMIMEEnabled, "");
        return attrs;
    }

    /**
     * saved search feature
     *
     * @return zimbraFeatureSavedSearchesEnabled, or true if unset
     */
    @ZAttr(id=139)
    public boolean isFeatureSavedSearchesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureSavedSearchesEnabled, true, true);
    }

    /**
     * saved search feature
     *
     * @param zimbraFeatureSavedSearchesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=139)
    public void setFeatureSavedSearchesEnabled(boolean zimbraFeatureSavedSearchesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSavedSearchesEnabled, zimbraFeatureSavedSearchesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * saved search feature
     *
     * @param zimbraFeatureSavedSearchesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=139)
    public Map<String,Object> setFeatureSavedSearchesEnabled(boolean zimbraFeatureSavedSearchesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSavedSearchesEnabled, zimbraFeatureSavedSearchesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * saved search feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=139)
    public void unsetFeatureSavedSearchesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSavedSearchesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * saved search feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=139)
    public Map<String,Object> unsetFeatureSavedSearchesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSavedSearchesEnabled, "");
        return attrs;
    }

    /**
     * enabled sharing
     *
     * @return zimbraFeatureSharingEnabled, or true if unset
     */
    @ZAttr(id=335)
    public boolean isFeatureSharingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureSharingEnabled, true, true);
    }

    /**
     * enabled sharing
     *
     * @param zimbraFeatureSharingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=335)
    public void setFeatureSharingEnabled(boolean zimbraFeatureSharingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSharingEnabled, zimbraFeatureSharingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enabled sharing
     *
     * @param zimbraFeatureSharingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=335)
    public Map<String,Object> setFeatureSharingEnabled(boolean zimbraFeatureSharingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSharingEnabled, zimbraFeatureSharingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enabled sharing
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=335)
    public void unsetFeatureSharingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSharingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enabled sharing
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=335)
    public Map<String,Object> unsetFeatureSharingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSharingEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated. Orig desc: keyboard shortcuts
     * aliases features
     *
     * @return zimbraFeatureShortcutAliasesEnabled, or true if unset
     */
    @ZAttr(id=452)
    public boolean isFeatureShortcutAliasesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureShortcutAliasesEnabled, true, true);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated. Orig desc: keyboard shortcuts
     * aliases features
     *
     * @param zimbraFeatureShortcutAliasesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=452)
    public void setFeatureShortcutAliasesEnabled(boolean zimbraFeatureShortcutAliasesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureShortcutAliasesEnabled, zimbraFeatureShortcutAliasesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated. Orig desc: keyboard shortcuts
     * aliases features
     *
     * @param zimbraFeatureShortcutAliasesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=452)
    public Map<String,Object> setFeatureShortcutAliasesEnabled(boolean zimbraFeatureShortcutAliasesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureShortcutAliasesEnabled, zimbraFeatureShortcutAliasesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated. Orig desc: keyboard shortcuts
     * aliases features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=452)
    public void unsetFeatureShortcutAliasesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureShortcutAliasesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated. Orig desc: keyboard shortcuts
     * aliases features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=452)
    public Map<String,Object> unsetFeatureShortcutAliasesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureShortcutAliasesEnabled, "");
        return attrs;
    }

    /**
     * whether to allow use of signature feature
     *
     * @return zimbraFeatureSignaturesEnabled, or true if unset
     */
    @ZAttr(id=494)
    public boolean isFeatureSignaturesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureSignaturesEnabled, true, true);
    }

    /**
     * whether to allow use of signature feature
     *
     * @param zimbraFeatureSignaturesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=494)
    public void setFeatureSignaturesEnabled(boolean zimbraFeatureSignaturesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSignaturesEnabled, zimbraFeatureSignaturesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of signature feature
     *
     * @param zimbraFeatureSignaturesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=494)
    public Map<String,Object> setFeatureSignaturesEnabled(boolean zimbraFeatureSignaturesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSignaturesEnabled, zimbraFeatureSignaturesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow use of signature feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=494)
    public void unsetFeatureSignaturesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSignaturesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of signature feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=494)
    public Map<String,Object> unsetFeatureSignaturesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSignaturesEnabled, "");
        return attrs;
    }

    /**
     * Whether changing skin is allowed for this account or in this cos
     *
     * @return zimbraFeatureSkinChangeEnabled, or true if unset
     */
    @ZAttr(id=354)
    public boolean isFeatureSkinChangeEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureSkinChangeEnabled, true, true);
    }

    /**
     * Whether changing skin is allowed for this account or in this cos
     *
     * @param zimbraFeatureSkinChangeEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=354)
    public void setFeatureSkinChangeEnabled(boolean zimbraFeatureSkinChangeEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSkinChangeEnabled, zimbraFeatureSkinChangeEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether changing skin is allowed for this account or in this cos
     *
     * @param zimbraFeatureSkinChangeEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=354)
    public Map<String,Object> setFeatureSkinChangeEnabled(boolean zimbraFeatureSkinChangeEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSkinChangeEnabled, zimbraFeatureSkinChangeEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether changing skin is allowed for this account or in this cos
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=354)
    public void unsetFeatureSkinChangeEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSkinChangeEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether changing skin is allowed for this account or in this cos
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=354)
    public Map<String,Object> unsetFeatureSkinChangeEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSkinChangeEnabled, "");
        return attrs;
    }

    /**
     * internal social features
     *
     * @return zimbraFeatureSocialEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1490)
    public boolean isFeatureSocialEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureSocialEnabled, false, true);
    }

    /**
     * internal social features
     *
     * @param zimbraFeatureSocialEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1490)
    public void setFeatureSocialEnabled(boolean zimbraFeatureSocialEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialEnabled, zimbraFeatureSocialEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * internal social features
     *
     * @param zimbraFeatureSocialEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1490)
    public Map<String,Object> setFeatureSocialEnabled(boolean zimbraFeatureSocialEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialEnabled, zimbraFeatureSocialEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * internal social features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1490)
    public void unsetFeatureSocialEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * internal social features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1490)
    public Map<String,Object> unsetFeatureSocialEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialEnabled, "");
        return attrs;
    }

    /**
     * external social features
     *
     * @return zimbraFeatureSocialExternalEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1491)
    public boolean isFeatureSocialExternalEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureSocialExternalEnabled, false, true);
    }

    /**
     * external social features
     *
     * @param zimbraFeatureSocialExternalEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1491)
    public void setFeatureSocialExternalEnabled(boolean zimbraFeatureSocialExternalEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialExternalEnabled, zimbraFeatureSocialExternalEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external social features
     *
     * @param zimbraFeatureSocialExternalEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1491)
    public Map<String,Object> setFeatureSocialExternalEnabled(boolean zimbraFeatureSocialExternalEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialExternalEnabled, zimbraFeatureSocialExternalEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * external social features
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1491)
    public void unsetFeatureSocialExternalEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialExternalEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external social features
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1491)
    public Map<String,Object> unsetFeatureSocialExternalEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialExternalEnabled, "");
        return attrs;
    }

    /**
     * external social URL
     *
     * @return zimbraFeatureSocialExternalURL, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1492)
    public String getFeatureSocialExternalURL() {
        return getAttr(Provisioning.A_zimbraFeatureSocialExternalURL, null, true);
    }

    /**
     * external social URL
     *
     * @param zimbraFeatureSocialExternalURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1492)
    public void setFeatureSocialExternalURL(String zimbraFeatureSocialExternalURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialExternalURL, zimbraFeatureSocialExternalURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external social URL
     *
     * @param zimbraFeatureSocialExternalURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1492)
    public Map<String,Object> setFeatureSocialExternalURL(String zimbraFeatureSocialExternalURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialExternalURL, zimbraFeatureSocialExternalURL);
        return attrs;
    }

    /**
     * external social URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1492)
    public void unsetFeatureSocialExternalURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialExternalURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external social URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1492)
    public Map<String,Object> unsetFeatureSocialExternalURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialExternalURL, "");
        return attrs;
    }

    /**
     * message social filters enabled in the web client UI
     *
     * <p>Valid values: [SocialCast, LinkedIn, Twitter, Facebook]
     *
     * @return zimbraFeatureSocialFiltersEnabled, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1272)
    public String[] getFeatureSocialFiltersEnabledAsString() {
        String[] value = getMultiAttr(Provisioning.A_zimbraFeatureSocialFiltersEnabled, true, true); return value.length > 0 ? value : new String[] {"SocialCast","LinkedIn","Twitter","Facebook"};
    }

    /**
     * message social filters enabled in the web client UI
     *
     * <p>Valid values: [SocialCast, LinkedIn, Twitter, Facebook]
     *
     * @param zimbraFeatureSocialFiltersEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1272)
    public void setFeatureSocialFiltersEnabled(ZAttrProvisioning.FeatureSocialFiltersEnabled zimbraFeatureSocialFiltersEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialFiltersEnabled, zimbraFeatureSocialFiltersEnabled.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * message social filters enabled in the web client UI
     *
     * <p>Valid values: [SocialCast, LinkedIn, Twitter, Facebook]
     *
     * @param zimbraFeatureSocialFiltersEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1272)
    public Map<String,Object> setFeatureSocialFiltersEnabled(ZAttrProvisioning.FeatureSocialFiltersEnabled zimbraFeatureSocialFiltersEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialFiltersEnabled, zimbraFeatureSocialFiltersEnabled.toString());
        return attrs;
    }

    /**
     * message social filters enabled in the web client UI
     *
     * <p>Valid values: [SocialCast, LinkedIn, Twitter, Facebook]
     *
     * @param zimbraFeatureSocialFiltersEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1272)
    public void setFeatureSocialFiltersEnabledAsString(String[] zimbraFeatureSocialFiltersEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialFiltersEnabled, zimbraFeatureSocialFiltersEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * message social filters enabled in the web client UI
     *
     * <p>Valid values: [SocialCast, LinkedIn, Twitter, Facebook]
     *
     * @param zimbraFeatureSocialFiltersEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1272)
    public Map<String,Object> setFeatureSocialFiltersEnabledAsString(String[] zimbraFeatureSocialFiltersEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialFiltersEnabled, zimbraFeatureSocialFiltersEnabled);
        return attrs;
    }

    /**
     * message social filters enabled in the web client UI
     *
     * <p>Valid values: [SocialCast, LinkedIn, Twitter, Facebook]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1272)
    public void unsetFeatureSocialFiltersEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialFiltersEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * message social filters enabled in the web client UI
     *
     * <p>Valid values: [SocialCast, LinkedIn, Twitter, Facebook]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1272)
    public Map<String,Object> unsetFeatureSocialFiltersEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialFiltersEnabled, "");
        return attrs;
    }

    /**
     * social tab name
     *
     * @return zimbraFeatureSocialName, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1625)
    public String getFeatureSocialName() {
        return getAttr(Provisioning.A_zimbraFeatureSocialName, null, true);
    }

    /**
     * social tab name
     *
     * @param zimbraFeatureSocialName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1625)
    public void setFeatureSocialName(String zimbraFeatureSocialName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialName, zimbraFeatureSocialName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * social tab name
     *
     * @param zimbraFeatureSocialName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1625)
    public Map<String,Object> setFeatureSocialName(String zimbraFeatureSocialName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialName, zimbraFeatureSocialName);
        return attrs;
    }

    /**
     * social tab name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1625)
    public void unsetFeatureSocialName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * social tab name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1625)
    public Map<String,Object> unsetFeatureSocialName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialName, "");
        return attrs;
    }

    /**
     * whether Socialcast integration is enabled in the web client
     *
     * @return zimbraFeatureSocialcastEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1388)
    public boolean isFeatureSocialcastEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureSocialcastEnabled, false, true);
    }

    /**
     * whether Socialcast integration is enabled in the web client
     *
     * @param zimbraFeatureSocialcastEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1388)
    public void setFeatureSocialcastEnabled(boolean zimbraFeatureSocialcastEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialcastEnabled, zimbraFeatureSocialcastEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether Socialcast integration is enabled in the web client
     *
     * @param zimbraFeatureSocialcastEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1388)
    public Map<String,Object> setFeatureSocialcastEnabled(boolean zimbraFeatureSocialcastEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialcastEnabled, zimbraFeatureSocialcastEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether Socialcast integration is enabled in the web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1388)
    public void unsetFeatureSocialcastEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialcastEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether Socialcast integration is enabled in the web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1388)
    public Map<String,Object> unsetFeatureSocialcastEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureSocialcastEnabled, "");
        return attrs;
    }

    /**
     * tagging feature
     *
     * @return zimbraFeatureTaggingEnabled, or true if unset
     */
    @ZAttr(id=137)
    public boolean isFeatureTaggingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureTaggingEnabled, true, true);
    }

    /**
     * tagging feature
     *
     * @param zimbraFeatureTaggingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=137)
    public void setFeatureTaggingEnabled(boolean zimbraFeatureTaggingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTaggingEnabled, zimbraFeatureTaggingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * tagging feature
     *
     * @param zimbraFeatureTaggingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=137)
    public Map<String,Object> setFeatureTaggingEnabled(boolean zimbraFeatureTaggingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTaggingEnabled, zimbraFeatureTaggingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * tagging feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=137)
    public void unsetFeatureTaggingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTaggingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * tagging feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=137)
    public Map<String,Object> unsetFeatureTaggingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTaggingEnabled, "");
        return attrs;
    }

    /**
     * whether to allow use of tasks feature
     *
     * @return zimbraFeatureTasksEnabled, or true if unset
     */
    @ZAttr(id=436)
    public boolean isFeatureTasksEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureTasksEnabled, true, true);
    }

    /**
     * whether to allow use of tasks feature
     *
     * @param zimbraFeatureTasksEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=436)
    public void setFeatureTasksEnabled(boolean zimbraFeatureTasksEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTasksEnabled, zimbraFeatureTasksEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of tasks feature
     *
     * @param zimbraFeatureTasksEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=436)
    public Map<String,Object> setFeatureTasksEnabled(boolean zimbraFeatureTasksEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTasksEnabled, zimbraFeatureTasksEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow use of tasks feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=436)
    public void unsetFeatureTasksEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTasksEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow use of tasks feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=436)
    public Map<String,Object> unsetFeatureTasksEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTasksEnabled, "");
        return attrs;
    }

    /**
     * Whether to allow a user to access touch client. Note: touch client is
     * a Network feature, this attribute is effective only if touch client is
     * permitted by license.
     *
     * @return zimbraFeatureTouchClientEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1636)
    public boolean isFeatureTouchClientEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureTouchClientEnabled, false, true);
    }

    /**
     * Whether to allow a user to access touch client. Note: touch client is
     * a Network feature, this attribute is effective only if touch client is
     * permitted by license.
     *
     * @param zimbraFeatureTouchClientEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1636)
    public void setFeatureTouchClientEnabled(boolean zimbraFeatureTouchClientEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTouchClientEnabled, zimbraFeatureTouchClientEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access touch client. Note: touch client is
     * a Network feature, this attribute is effective only if touch client is
     * permitted by license.
     *
     * @param zimbraFeatureTouchClientEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1636)
    public Map<String,Object> setFeatureTouchClientEnabled(boolean zimbraFeatureTouchClientEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTouchClientEnabled, zimbraFeatureTouchClientEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow a user to access touch client. Note: touch client is
     * a Network feature, this attribute is effective only if touch client is
     * permitted by license.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1636)
    public void unsetFeatureTouchClientEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTouchClientEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access touch client. Note: touch client is
     * a Network feature, this attribute is effective only if touch client is
     * permitted by license.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1636)
    public Map<String,Object> unsetFeatureTouchClientEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTouchClientEnabled, "");
        return attrs;
    }

    /**
     * Whether the option of specifying trusted devices when using two-factor
     * authentication is available on the account
     *
     * @return zimbraFeatureTrustedDevicesEnabled, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2054)
    public boolean isFeatureTrustedDevicesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureTrustedDevicesEnabled, true, true);
    }

    /**
     * Whether the option of specifying trusted devices when using two-factor
     * authentication is available on the account
     *
     * @param zimbraFeatureTrustedDevicesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2054)
    public void setFeatureTrustedDevicesEnabled(boolean zimbraFeatureTrustedDevicesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTrustedDevicesEnabled, zimbraFeatureTrustedDevicesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the option of specifying trusted devices when using two-factor
     * authentication is available on the account
     *
     * @param zimbraFeatureTrustedDevicesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2054)
    public Map<String,Object> setFeatureTrustedDevicesEnabled(boolean zimbraFeatureTrustedDevicesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTrustedDevicesEnabled, zimbraFeatureTrustedDevicesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether the option of specifying trusted devices when using two-factor
     * authentication is available on the account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2054)
    public void unsetFeatureTrustedDevicesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTrustedDevicesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the option of specifying trusted devices when using two-factor
     * authentication is available on the account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2054)
    public Map<String,Object> unsetFeatureTrustedDevicesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTrustedDevicesEnabled, "");
        return attrs;
    }

    /**
     * Whether the option of enabling two-factor authentication is available
     * on the account
     *
     * @return zimbraFeatureTwoFactorAuthAvailable, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2050)
    public boolean isFeatureTwoFactorAuthAvailable() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureTwoFactorAuthAvailable, false, true);
    }

    /**
     * Whether the option of enabling two-factor authentication is available
     * on the account
     *
     * @param zimbraFeatureTwoFactorAuthAvailable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2050)
    public void setFeatureTwoFactorAuthAvailable(boolean zimbraFeatureTwoFactorAuthAvailable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTwoFactorAuthAvailable, zimbraFeatureTwoFactorAuthAvailable ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the option of enabling two-factor authentication is available
     * on the account
     *
     * @param zimbraFeatureTwoFactorAuthAvailable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2050)
    public Map<String,Object> setFeatureTwoFactorAuthAvailable(boolean zimbraFeatureTwoFactorAuthAvailable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTwoFactorAuthAvailable, zimbraFeatureTwoFactorAuthAvailable ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether the option of enabling two-factor authentication is available
     * on the account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2050)
    public void unsetFeatureTwoFactorAuthAvailable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTwoFactorAuthAvailable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the option of enabling two-factor authentication is available
     * on the account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2050)
    public Map<String,Object> unsetFeatureTwoFactorAuthAvailable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTwoFactorAuthAvailable, "");
        return attrs;
    }

    /**
     * whether two-factor authentication is required
     *
     * @return zimbraFeatureTwoFactorAuthRequired, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1820)
    public boolean isFeatureTwoFactorAuthRequired() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureTwoFactorAuthRequired, false, true);
    }

    /**
     * whether two-factor authentication is required
     *
     * @param zimbraFeatureTwoFactorAuthRequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1820)
    public void setFeatureTwoFactorAuthRequired(boolean zimbraFeatureTwoFactorAuthRequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTwoFactorAuthRequired, zimbraFeatureTwoFactorAuthRequired ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether two-factor authentication is required
     *
     * @param zimbraFeatureTwoFactorAuthRequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1820)
    public Map<String,Object> setFeatureTwoFactorAuthRequired(boolean zimbraFeatureTwoFactorAuthRequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTwoFactorAuthRequired, zimbraFeatureTwoFactorAuthRequired ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether two-factor authentication is required
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1820)
    public void unsetFeatureTwoFactorAuthRequired() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTwoFactorAuthRequired, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether two-factor authentication is required
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1820)
    public Map<String,Object> unsetFeatureTwoFactorAuthRequired(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureTwoFactorAuthRequired, "");
        return attrs;
    }

    /**
     * option to view attachments in html
     *
     * @return zimbraFeatureViewInHtmlEnabled, or false if unset
     */
    @ZAttr(id=312)
    public boolean isFeatureViewInHtmlEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureViewInHtmlEnabled, false, true);
    }

    /**
     * option to view attachments in html
     *
     * @param zimbraFeatureViewInHtmlEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=312)
    public void setFeatureViewInHtmlEnabled(boolean zimbraFeatureViewInHtmlEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureViewInHtmlEnabled, zimbraFeatureViewInHtmlEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * option to view attachments in html
     *
     * @param zimbraFeatureViewInHtmlEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=312)
    public Map<String,Object> setFeatureViewInHtmlEnabled(boolean zimbraFeatureViewInHtmlEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureViewInHtmlEnabled, zimbraFeatureViewInHtmlEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * option to view attachments in html
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=312)
    public void unsetFeatureViewInHtmlEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureViewInHtmlEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * option to view attachments in html
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=312)
    public Map<String,Object> unsetFeatureViewInHtmlEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureViewInHtmlEnabled, "");
        return attrs;
    }

    /**
     * whether or not changing voicemail pin is enabled
     *
     * @return zimbraFeatureVoiceChangePinEnabled, or true if unset
     *
     * @since ZCS 5.0.19
     */
    @ZAttr(id=1050)
    public boolean isFeatureVoiceChangePinEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureVoiceChangePinEnabled, true, true);
    }

    /**
     * whether or not changing voicemail pin is enabled
     *
     * @param zimbraFeatureVoiceChangePinEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.19
     */
    @ZAttr(id=1050)
    public void setFeatureVoiceChangePinEnabled(boolean zimbraFeatureVoiceChangePinEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceChangePinEnabled, zimbraFeatureVoiceChangePinEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not changing voicemail pin is enabled
     *
     * @param zimbraFeatureVoiceChangePinEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.19
     */
    @ZAttr(id=1050)
    public Map<String,Object> setFeatureVoiceChangePinEnabled(boolean zimbraFeatureVoiceChangePinEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceChangePinEnabled, zimbraFeatureVoiceChangePinEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not changing voicemail pin is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.19
     */
    @ZAttr(id=1050)
    public void unsetFeatureVoiceChangePinEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceChangePinEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not changing voicemail pin is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.19
     */
    @ZAttr(id=1050)
    public Map<String,Object> unsetFeatureVoiceChangePinEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceChangePinEnabled, "");
        return attrs;
    }

    /**
     * Voicemail features enabled
     *
     * @return zimbraFeatureVoiceEnabled, or false if unset
     */
    @ZAttr(id=445)
    public boolean isFeatureVoiceEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureVoiceEnabled, false, true);
    }

    /**
     * Voicemail features enabled
     *
     * @param zimbraFeatureVoiceEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=445)
    public void setFeatureVoiceEnabled(boolean zimbraFeatureVoiceEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceEnabled, zimbraFeatureVoiceEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Voicemail features enabled
     *
     * @param zimbraFeatureVoiceEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=445)
    public Map<String,Object> setFeatureVoiceEnabled(boolean zimbraFeatureVoiceEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceEnabled, zimbraFeatureVoiceEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Voicemail features enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=445)
    public void unsetFeatureVoiceEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Voicemail features enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=445)
    public Map<String,Object> unsetFeatureVoiceEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceEnabled, "");
        return attrs;
    }

    /**
     * voice upsell enabled
     *
     * @return zimbraFeatureVoiceUpsellEnabled, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=533)
    public boolean isFeatureVoiceUpsellEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureVoiceUpsellEnabled, false, true);
    }

    /**
     * voice upsell enabled
     *
     * @param zimbraFeatureVoiceUpsellEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=533)
    public void setFeatureVoiceUpsellEnabled(boolean zimbraFeatureVoiceUpsellEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceUpsellEnabled, zimbraFeatureVoiceUpsellEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * voice upsell enabled
     *
     * @param zimbraFeatureVoiceUpsellEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=533)
    public Map<String,Object> setFeatureVoiceUpsellEnabled(boolean zimbraFeatureVoiceUpsellEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceUpsellEnabled, zimbraFeatureVoiceUpsellEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * voice upsell enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=533)
    public void unsetFeatureVoiceUpsellEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceUpsellEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * voice upsell enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=533)
    public Map<String,Object> unsetFeatureVoiceUpsellEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceUpsellEnabled, "");
        return attrs;
    }

    /**
     * voice upsell URL
     *
     * @return zimbraFeatureVoiceUpsellURL, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=534)
    public String getFeatureVoiceUpsellURL() {
        return getAttr(Provisioning.A_zimbraFeatureVoiceUpsellURL, null, true);
    }

    /**
     * voice upsell URL
     *
     * @param zimbraFeatureVoiceUpsellURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=534)
    public void setFeatureVoiceUpsellURL(String zimbraFeatureVoiceUpsellURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceUpsellURL, zimbraFeatureVoiceUpsellURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * voice upsell URL
     *
     * @param zimbraFeatureVoiceUpsellURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=534)
    public Map<String,Object> setFeatureVoiceUpsellURL(String zimbraFeatureVoiceUpsellURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceUpsellURL, zimbraFeatureVoiceUpsellURL);
        return attrs;
    }

    /**
     * voice upsell URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=534)
    public void unsetFeatureVoiceUpsellURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceUpsellURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * voice upsell URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=534)
    public Map<String,Object> unsetFeatureVoiceUpsellURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureVoiceUpsellURL, "");
        return attrs;
    }

    /**
     * whether to use Web Client feature
     *
     * @return zimbraFeatureWebClientEnabled, or true if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3088)
    public boolean isFeatureWebClientEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureWebClientEnabled, true, true);
    }

    /**
     * whether to use Web Client feature
     *
     * @param zimbraFeatureWebClientEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3088)
    public void setFeatureWebClientEnabled(boolean zimbraFeatureWebClientEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebClientEnabled, zimbraFeatureWebClientEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to use Web Client feature
     *
     * @param zimbraFeatureWebClientEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3088)
    public Map<String,Object> setFeatureWebClientEnabled(boolean zimbraFeatureWebClientEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebClientEnabled, zimbraFeatureWebClientEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to use Web Client feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3088)
    public void unsetFeatureWebClientEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebClientEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to use Web Client feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3088)
    public Map<String,Object> unsetFeatureWebClientEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebClientEnabled, "");
        return attrs;
    }

    /**
     * admin setting to enable/disable the web client offline access feature
     *
     * @return zimbraFeatureWebClientOfflineAccessEnabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1611)
    public boolean isFeatureWebClientOfflineAccessEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureWebClientOfflineAccessEnabled, true, true);
    }

    /**
     * admin setting to enable/disable the web client offline access feature
     *
     * @param zimbraFeatureWebClientOfflineAccessEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1611)
    public void setFeatureWebClientOfflineAccessEnabled(boolean zimbraFeatureWebClientOfflineAccessEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebClientOfflineAccessEnabled, zimbraFeatureWebClientOfflineAccessEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin setting to enable/disable the web client offline access feature
     *
     * @param zimbraFeatureWebClientOfflineAccessEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1611)
    public Map<String,Object> setFeatureWebClientOfflineAccessEnabled(boolean zimbraFeatureWebClientOfflineAccessEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebClientOfflineAccessEnabled, zimbraFeatureWebClientOfflineAccessEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * admin setting to enable/disable the web client offline access feature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1611)
    public void unsetFeatureWebClientOfflineAccessEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebClientOfflineAccessEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin setting to enable/disable the web client offline access feature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1611)
    public Map<String,Object> unsetFeatureWebClientOfflineAccessEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebClientOfflineAccessEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40170. Orig desc:
     * whether web search feature is enabled
     *
     * @return zimbraFeatureWebSearchEnabled, or true if unset
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=602)
    public boolean isFeatureWebSearchEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureWebSearchEnabled, true, true);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40170. Orig desc:
     * whether web search feature is enabled
     *
     * @param zimbraFeatureWebSearchEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=602)
    public void setFeatureWebSearchEnabled(boolean zimbraFeatureWebSearchEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebSearchEnabled, zimbraFeatureWebSearchEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40170. Orig desc:
     * whether web search feature is enabled
     *
     * @param zimbraFeatureWebSearchEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=602)
    public Map<String,Object> setFeatureWebSearchEnabled(boolean zimbraFeatureWebSearchEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebSearchEnabled, zimbraFeatureWebSearchEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40170. Orig desc:
     * whether web search feature is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=602)
    public void unsetFeatureWebSearchEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebSearchEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40170. Orig desc:
     * whether web search feature is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=602)
    public Map<String,Object> unsetFeatureWebSearchEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureWebSearchEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.9.0. deprecated with attribute
     * zimbraFeatureModernDesktopEnabled. Orig desc: Whether to allow a user
     * to access Zimbra X desktop
     *
     * @return zimbraFeatureZXDesktopEnabled, or false if unset
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3080)
    public boolean isFeatureZXDesktopEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureZXDesktopEnabled, false, true);
    }

    /**
     * Deprecated since: 8.9.0. deprecated with attribute
     * zimbraFeatureModernDesktopEnabled. Orig desc: Whether to allow a user
     * to access Zimbra X desktop
     *
     * @param zimbraFeatureZXDesktopEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3080)
    public void setFeatureZXDesktopEnabled(boolean zimbraFeatureZXDesktopEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZXDesktopEnabled, zimbraFeatureZXDesktopEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.9.0. deprecated with attribute
     * zimbraFeatureModernDesktopEnabled. Orig desc: Whether to allow a user
     * to access Zimbra X desktop
     *
     * @param zimbraFeatureZXDesktopEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3080)
    public Map<String,Object> setFeatureZXDesktopEnabled(boolean zimbraFeatureZXDesktopEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZXDesktopEnabled, zimbraFeatureZXDesktopEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.9.0. deprecated with attribute
     * zimbraFeatureModernDesktopEnabled. Orig desc: Whether to allow a user
     * to access Zimbra X desktop
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3080)
    public void unsetFeatureZXDesktopEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZXDesktopEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.9.0. deprecated with attribute
     * zimbraFeatureModernDesktopEnabled. Orig desc: Whether to allow a user
     * to access Zimbra X desktop
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3080)
    public Map<String,Object> unsetFeatureZXDesktopEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZXDesktopEnabled, "");
        return attrs;
    }

    /**
     * Whether to allow a user to access Zimbra X web client
     *
     * @return zimbraFeatureZXWebEnabled, or false if unset
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3079)
    public boolean isFeatureZXWebEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureZXWebEnabled, false, true);
    }

    /**
     * Whether to allow a user to access Zimbra X web client
     *
     * @param zimbraFeatureZXWebEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3079)
    public void setFeatureZXWebEnabled(boolean zimbraFeatureZXWebEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZXWebEnabled, zimbraFeatureZXWebEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access Zimbra X web client
     *
     * @param zimbraFeatureZXWebEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3079)
    public Map<String,Object> setFeatureZXWebEnabled(boolean zimbraFeatureZXWebEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZXWebEnabled, zimbraFeatureZXWebEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow a user to access Zimbra X web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3079)
    public void unsetFeatureZXWebEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZXWebEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow a user to access Zimbra X web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.9.0
     */
    @ZAttr(id=3079)
    public Map<String,Object> unsetFeatureZXWebEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZXWebEnabled, "");
        return attrs;
    }

    /**
     * Zimbra Assistant enabled
     *
     * @return zimbraFeatureZimbraAssistantEnabled, or true if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=544)
    public boolean isFeatureZimbraAssistantEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureZimbraAssistantEnabled, true, true);
    }

    /**
     * Zimbra Assistant enabled
     *
     * @param zimbraFeatureZimbraAssistantEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=544)
    public void setFeatureZimbraAssistantEnabled(boolean zimbraFeatureZimbraAssistantEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZimbraAssistantEnabled, zimbraFeatureZimbraAssistantEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra Assistant enabled
     *
     * @param zimbraFeatureZimbraAssistantEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=544)
    public Map<String,Object> setFeatureZimbraAssistantEnabled(boolean zimbraFeatureZimbraAssistantEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZimbraAssistantEnabled, zimbraFeatureZimbraAssistantEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Zimbra Assistant enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=544)
    public void unsetFeatureZimbraAssistantEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZimbraAssistantEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra Assistant enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=544)
    public Map<String,Object> unsetFeatureZimbraAssistantEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureZimbraAssistantEnabled, "");
        return attrs;
    }

    /**
     * whether crash reporting is enabled in the Android client
     *
     * @return zimbraFileAndroidCrashReportingEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1385)
    public boolean isFileAndroidCrashReportingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFileAndroidCrashReportingEnabled, true, true);
    }

    /**
     * whether crash reporting is enabled in the Android client
     *
     * @param zimbraFileAndroidCrashReportingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1385)
    public void setFileAndroidCrashReportingEnabled(boolean zimbraFileAndroidCrashReportingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileAndroidCrashReportingEnabled, zimbraFileAndroidCrashReportingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether crash reporting is enabled in the Android client
     *
     * @param zimbraFileAndroidCrashReportingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1385)
    public Map<String,Object> setFileAndroidCrashReportingEnabled(boolean zimbraFileAndroidCrashReportingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileAndroidCrashReportingEnabled, zimbraFileAndroidCrashReportingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether crash reporting is enabled in the Android client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1385)
    public void unsetFileAndroidCrashReportingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileAndroidCrashReportingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether crash reporting is enabled in the Android client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1385)
    public Map<String,Object> unsetFileAndroidCrashReportingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileAndroidCrashReportingEnabled, "");
        return attrs;
    }

    /**
     * template for constructing the body of a file deletion warning message
     *
     * @return zimbraFileDeletionNotificationBody, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1313)
    public String getFileDeletionNotificationBody() {
        return getAttr(Provisioning.A_zimbraFileDeletionNotificationBody, null, true);
    }

    /**
     * template for constructing the body of a file deletion warning message
     *
     * @param zimbraFileDeletionNotificationBody new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1313)
    public void setFileDeletionNotificationBody(String zimbraFileDeletionNotificationBody) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileDeletionNotificationBody, zimbraFileDeletionNotificationBody);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template for constructing the body of a file deletion warning message
     *
     * @param zimbraFileDeletionNotificationBody new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1313)
    public Map<String,Object> setFileDeletionNotificationBody(String zimbraFileDeletionNotificationBody, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileDeletionNotificationBody, zimbraFileDeletionNotificationBody);
        return attrs;
    }

    /**
     * template for constructing the body of a file deletion warning message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1313)
    public void unsetFileDeletionNotificationBody() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileDeletionNotificationBody, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template for constructing the body of a file deletion warning message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1313)
    public Map<String,Object> unsetFileDeletionNotificationBody(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileDeletionNotificationBody, "");
        return attrs;
    }

    /**
     * template for constructing the subject of a file deletion warning
     * message
     *
     * @return zimbraFileDeletionNotificationSubject, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1312)
    public String getFileDeletionNotificationSubject() {
        return getAttr(Provisioning.A_zimbraFileDeletionNotificationSubject, null, true);
    }

    /**
     * template for constructing the subject of a file deletion warning
     * message
     *
     * @param zimbraFileDeletionNotificationSubject new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1312)
    public void setFileDeletionNotificationSubject(String zimbraFileDeletionNotificationSubject) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileDeletionNotificationSubject, zimbraFileDeletionNotificationSubject);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template for constructing the subject of a file deletion warning
     * message
     *
     * @param zimbraFileDeletionNotificationSubject new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1312)
    public Map<String,Object> setFileDeletionNotificationSubject(String zimbraFileDeletionNotificationSubject, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileDeletionNotificationSubject, zimbraFileDeletionNotificationSubject);
        return attrs;
    }

    /**
     * template for constructing the subject of a file deletion warning
     * message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1312)
    public void unsetFileDeletionNotificationSubject() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileDeletionNotificationSubject, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template for constructing the subject of a file deletion warning
     * message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1312)
    public Map<String,Object> unsetFileDeletionNotificationSubject(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileDeletionNotificationSubject, "");
        return attrs;
    }

    /**
     * template for constructing the body of a file expiration warning
     * message
     *
     * @return zimbraFileExpirationWarningBody, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1311)
    public String getFileExpirationWarningBody() {
        return getAttr(Provisioning.A_zimbraFileExpirationWarningBody, null, true);
    }

    /**
     * template for constructing the body of a file expiration warning
     * message
     *
     * @param zimbraFileExpirationWarningBody new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1311)
    public void setFileExpirationWarningBody(String zimbraFileExpirationWarningBody) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningBody, zimbraFileExpirationWarningBody);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template for constructing the body of a file expiration warning
     * message
     *
     * @param zimbraFileExpirationWarningBody new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1311)
    public Map<String,Object> setFileExpirationWarningBody(String zimbraFileExpirationWarningBody, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningBody, zimbraFileExpirationWarningBody);
        return attrs;
    }

    /**
     * template for constructing the body of a file expiration warning
     * message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1311)
    public void unsetFileExpirationWarningBody() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningBody, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template for constructing the body of a file expiration warning
     * message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1311)
    public Map<String,Object> unsetFileExpirationWarningBody(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningBody, "");
        return attrs;
    }

    /**
     * template for constructing the subject of a file expiration warning
     * message
     *
     * @return zimbraFileExpirationWarningSubject, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1310)
    public String getFileExpirationWarningSubject() {
        return getAttr(Provisioning.A_zimbraFileExpirationWarningSubject, null, true);
    }

    /**
     * template for constructing the subject of a file expiration warning
     * message
     *
     * @param zimbraFileExpirationWarningSubject new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1310)
    public void setFileExpirationWarningSubject(String zimbraFileExpirationWarningSubject) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningSubject, zimbraFileExpirationWarningSubject);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template for constructing the subject of a file expiration warning
     * message
     *
     * @param zimbraFileExpirationWarningSubject new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1310)
    public Map<String,Object> setFileExpirationWarningSubject(String zimbraFileExpirationWarningSubject, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningSubject, zimbraFileExpirationWarningSubject);
        return attrs;
    }

    /**
     * template for constructing the subject of a file expiration warning
     * message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1310)
    public void unsetFileExpirationWarningSubject() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningSubject, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template for constructing the subject of a file expiration warning
     * message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1310)
    public Map<String,Object> unsetFileExpirationWarningSubject(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningSubject, "");
        return attrs;
    }

    /**
     * Period of inactivity after which file owner receives a deletion
     * warning email. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getFileExpirationWarningThresholdAsString to access value as a string.
     *
     * @see #getFileExpirationWarningThresholdAsString()
     *
     * @return zimbraFileExpirationWarningThreshold in millseconds, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1308)
    public long getFileExpirationWarningThreshold() {
        return getTimeInterval(Provisioning.A_zimbraFileExpirationWarningThreshold, -1L, true);
    }

    /**
     * Period of inactivity after which file owner receives a deletion
     * warning email. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraFileExpirationWarningThreshold, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1308)
    public String getFileExpirationWarningThresholdAsString() {
        return getAttr(Provisioning.A_zimbraFileExpirationWarningThreshold, null, true);
    }

    /**
     * Period of inactivity after which file owner receives a deletion
     * warning email. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraFileExpirationWarningThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1308)
    public void setFileExpirationWarningThreshold(String zimbraFileExpirationWarningThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningThreshold, zimbraFileExpirationWarningThreshold);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Period of inactivity after which file owner receives a deletion
     * warning email. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraFileExpirationWarningThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1308)
    public Map<String,Object> setFileExpirationWarningThreshold(String zimbraFileExpirationWarningThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningThreshold, zimbraFileExpirationWarningThreshold);
        return attrs;
    }

    /**
     * Period of inactivity after which file owner receives a deletion
     * warning email. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1308)
    public void unsetFileExpirationWarningThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Period of inactivity after which file owner receives a deletion
     * warning email. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1308)
    public Map<String,Object> unsetFileExpirationWarningThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExpirationWarningThreshold, "");
        return attrs;
    }

    /**
     * Maximum allowed lifetime of file shares to external users. A value of
     * 0 indicates that there&#039;s no limit on an external file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getFileExternalShareLifetimeAsString to access value as a string.
     *
     * @see #getFileExternalShareLifetimeAsString()
     *
     * @return zimbraFileExternalShareLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1363)
    public long getFileExternalShareLifetime() {
        return getTimeInterval(Provisioning.A_zimbraFileExternalShareLifetime, 0L, true);
    }

    /**
     * Maximum allowed lifetime of file shares to external users. A value of
     * 0 indicates that there&#039;s no limit on an external file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraFileExternalShareLifetime, or "0" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1363)
    public String getFileExternalShareLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraFileExternalShareLifetime, "0", true);
    }

    /**
     * Maximum allowed lifetime of file shares to external users. A value of
     * 0 indicates that there&#039;s no limit on an external file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraFileExternalShareLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1363)
    public void setFileExternalShareLifetime(String zimbraFileExternalShareLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExternalShareLifetime, zimbraFileExternalShareLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of file shares to external users. A value of
     * 0 indicates that there&#039;s no limit on an external file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraFileExternalShareLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1363)
    public Map<String,Object> setFileExternalShareLifetime(String zimbraFileExternalShareLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExternalShareLifetime, zimbraFileExternalShareLifetime);
        return attrs;
    }

    /**
     * Maximum allowed lifetime of file shares to external users. A value of
     * 0 indicates that there&#039;s no limit on an external file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1363)
    public void unsetFileExternalShareLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExternalShareLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of file shares to external users. A value of
     * 0 indicates that there&#039;s no limit on an external file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1363)
    public Map<String,Object> unsetFileExternalShareLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileExternalShareLifetime, "");
        return attrs;
    }

    /**
     * whether crash reporting is enabled in the IOS client
     *
     * @return zimbraFileIOSCrashReportingEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1390)
    public boolean isFileIOSCrashReportingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFileIOSCrashReportingEnabled, true, true);
    }

    /**
     * whether crash reporting is enabled in the IOS client
     *
     * @param zimbraFileIOSCrashReportingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1390)
    public void setFileIOSCrashReportingEnabled(boolean zimbraFileIOSCrashReportingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileIOSCrashReportingEnabled, zimbraFileIOSCrashReportingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether crash reporting is enabled in the IOS client
     *
     * @param zimbraFileIOSCrashReportingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1390)
    public Map<String,Object> setFileIOSCrashReportingEnabled(boolean zimbraFileIOSCrashReportingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileIOSCrashReportingEnabled, zimbraFileIOSCrashReportingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether crash reporting is enabled in the IOS client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1390)
    public void unsetFileIOSCrashReportingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileIOSCrashReportingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether crash reporting is enabled in the IOS client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1390)
    public Map<String,Object> unsetFileIOSCrashReportingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileIOSCrashReportingEnabled, "");
        return attrs;
    }

    /**
     * Period of inactivity after which a file gets deleted. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFileLifetimeAsString to access value as a string.
     *
     * @see #getFileLifetimeAsString()
     *
     * @return zimbraFileLifetime in millseconds, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1309)
    public long getFileLifetime() {
        return getTimeInterval(Provisioning.A_zimbraFileLifetime, -1L, true);
    }

    /**
     * Period of inactivity after which a file gets deleted. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFileLifetime, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1309)
    public String getFileLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraFileLifetime, null, true);
    }

    /**
     * Period of inactivity after which a file gets deleted. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFileLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1309)
    public void setFileLifetime(String zimbraFileLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileLifetime, zimbraFileLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Period of inactivity after which a file gets deleted. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFileLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1309)
    public Map<String,Object> setFileLifetime(String zimbraFileLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileLifetime, zimbraFileLifetime);
        return attrs;
    }

    /**
     * Period of inactivity after which a file gets deleted. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1309)
    public void unsetFileLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Period of inactivity after which a file gets deleted. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1309)
    public Map<String,Object> unsetFileLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileLifetime, "");
        return attrs;
    }

    /**
     * Maximum size in bytes for file preview in web client
     *
     * @return zimbraFilePreviewMaxSize, or 20971520 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1442)
    public long getFilePreviewMaxSize() {
        return getLongAttr(Provisioning.A_zimbraFilePreviewMaxSize, 20971520L, true);
    }

    /**
     * Maximum size in bytes for file preview in web client
     *
     * @param zimbraFilePreviewMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1442)
    public void setFilePreviewMaxSize(long zimbraFilePreviewMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilePreviewMaxSize, Long.toString(zimbraFilePreviewMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for file preview in web client
     *
     * @param zimbraFilePreviewMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1442)
    public Map<String,Object> setFilePreviewMaxSize(long zimbraFilePreviewMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilePreviewMaxSize, Long.toString(zimbraFilePreviewMaxSize));
        return attrs;
    }

    /**
     * Maximum size in bytes for file preview in web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1442)
    public void unsetFilePreviewMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilePreviewMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for file preview in web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1442)
    public Map<String,Object> unsetFilePreviewMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilePreviewMaxSize, "");
        return attrs;
    }

    /**
     * Maximum allowed lifetime of public file shares. A value of 0 indicates
     * that there&#039;s no limit on a public file share&#039;s lifetime. .
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFilePublicShareLifetimeAsString to access value as a string.
     *
     * @see #getFilePublicShareLifetimeAsString()
     *
     * @return zimbraFilePublicShareLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1364)
    public long getFilePublicShareLifetime() {
        return getTimeInterval(Provisioning.A_zimbraFilePublicShareLifetime, 0L, true);
    }

    /**
     * Maximum allowed lifetime of public file shares. A value of 0 indicates
     * that there&#039;s no limit on a public file share&#039;s lifetime. .
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFilePublicShareLifetime, or "0" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1364)
    public String getFilePublicShareLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraFilePublicShareLifetime, "0", true);
    }

    /**
     * Maximum allowed lifetime of public file shares. A value of 0 indicates
     * that there&#039;s no limit on a public file share&#039;s lifetime. .
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFilePublicShareLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1364)
    public void setFilePublicShareLifetime(String zimbraFilePublicShareLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilePublicShareLifetime, zimbraFilePublicShareLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of public file shares. A value of 0 indicates
     * that there&#039;s no limit on a public file share&#039;s lifetime. .
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFilePublicShareLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1364)
    public Map<String,Object> setFilePublicShareLifetime(String zimbraFilePublicShareLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilePublicShareLifetime, zimbraFilePublicShareLifetime);
        return attrs;
    }

    /**
     * Maximum allowed lifetime of public file shares. A value of 0 indicates
     * that there&#039;s no limit on a public file share&#039;s lifetime. .
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1364)
    public void unsetFilePublicShareLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilePublicShareLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of public file shares. A value of 0 indicates
     * that there&#039;s no limit on a public file share&#039;s lifetime. .
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1364)
    public Map<String,Object> unsetFilePublicShareLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilePublicShareLifetime, "");
        return attrs;
    }

    /**
     * Maximum allowed lifetime of file shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getFileShareLifetimeAsString to access value as a string.
     *
     * @see #getFileShareLifetimeAsString()
     *
     * @return zimbraFileShareLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1362)
    public long getFileShareLifetime() {
        return getTimeInterval(Provisioning.A_zimbraFileShareLifetime, 0L, true);
    }

    /**
     * Maximum allowed lifetime of file shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraFileShareLifetime, or "0" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1362)
    public String getFileShareLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraFileShareLifetime, "0", true);
    }

    /**
     * Maximum allowed lifetime of file shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraFileShareLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1362)
    public void setFileShareLifetime(String zimbraFileShareLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileShareLifetime, zimbraFileShareLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of file shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraFileShareLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1362)
    public Map<String,Object> setFileShareLifetime(String zimbraFileShareLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileShareLifetime, zimbraFileShareLifetime);
        return attrs;
    }

    /**
     * Maximum allowed lifetime of file shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1362)
    public void unsetFileShareLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileShareLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of file shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal file
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1362)
    public Map<String,Object> unsetFileShareLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileShareLifetime, "");
        return attrs;
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @return zimbraFileUploadMaxSizePerFile, or 2147483648 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public long getFileUploadMaxSizePerFile() {
        return getLongAttr(Provisioning.A_zimbraFileUploadMaxSizePerFile, 2147483648L, true);
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @param zimbraFileUploadMaxSizePerFile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public void setFileUploadMaxSizePerFile(long zimbraFileUploadMaxSizePerFile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSizePerFile, Long.toString(zimbraFileUploadMaxSizePerFile));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @param zimbraFileUploadMaxSizePerFile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public Map<String,Object> setFileUploadMaxSizePerFile(long zimbraFileUploadMaxSizePerFile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSizePerFile, Long.toString(zimbraFileUploadMaxSizePerFile));
        return attrs;
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public void unsetFileUploadMaxSizePerFile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSizePerFile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public Map<String,Object> unsetFileUploadMaxSizePerFile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSizePerFile, "");
        return attrs;
    }

    /**
     * how long a file version is kept around. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getFileVersionLifetimeAsString to access value as a string.
     *
     * @see #getFileVersionLifetimeAsString()
     *
     * @return zimbraFileVersionLifetime in millseconds, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1325)
    public long getFileVersionLifetime() {
        return getTimeInterval(Provisioning.A_zimbraFileVersionLifetime, -1L, true);
    }

    /**
     * how long a file version is kept around. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraFileVersionLifetime, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1325)
    public String getFileVersionLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraFileVersionLifetime, null, true);
    }

    /**
     * how long a file version is kept around. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraFileVersionLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1325)
    public void setFileVersionLifetime(String zimbraFileVersionLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileVersionLifetime, zimbraFileVersionLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how long a file version is kept around. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraFileVersionLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1325)
    public Map<String,Object> setFileVersionLifetime(String zimbraFileVersionLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileVersionLifetime, zimbraFileVersionLifetime);
        return attrs;
    }

    /**
     * how long a file version is kept around. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1325)
    public void unsetFileVersionLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileVersionLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how long a file version is kept around. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1325)
    public Map<String,Object> unsetFileVersionLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileVersionLifetime, "");
        return attrs;
    }

    /**
     * whether file versioning is enabled
     *
     * @return zimbraFileVersioningEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1324)
    public boolean isFileVersioningEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFileVersioningEnabled, false, true);
    }

    /**
     * whether file versioning is enabled
     *
     * @param zimbraFileVersioningEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1324)
    public void setFileVersioningEnabled(boolean zimbraFileVersioningEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileVersioningEnabled, zimbraFileVersioningEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether file versioning is enabled
     *
     * @param zimbraFileVersioningEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1324)
    public Map<String,Object> setFileVersioningEnabled(boolean zimbraFileVersioningEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileVersioningEnabled, zimbraFileVersioningEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether file versioning is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1324)
    public void unsetFileVersioningEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileVersioningEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether file versioning is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1324)
    public Map<String,Object> unsetFileVersioningEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileVersioningEnabled, "");
        return attrs;
    }

    /**
     * Maximum number of messages that can be processed in a single
     * ApplyFilterRules operation.
     *
     * @return zimbraFilterBatchSize, or 10000 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1158)
    public int getFilterBatchSize() {
        return getIntAttr(Provisioning.A_zimbraFilterBatchSize, 10000, true);
    }

    /**
     * Maximum number of messages that can be processed in a single
     * ApplyFilterRules operation.
     *
     * @param zimbraFilterBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1158)
    public void setFilterBatchSize(int zimbraFilterBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterBatchSize, Integer.toString(zimbraFilterBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages that can be processed in a single
     * ApplyFilterRules operation.
     *
     * @param zimbraFilterBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1158)
    public Map<String,Object> setFilterBatchSize(int zimbraFilterBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterBatchSize, Integer.toString(zimbraFilterBatchSize));
        return attrs;
    }

    /**
     * Maximum number of messages that can be processed in a single
     * ApplyFilterRules operation.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1158)
    public void unsetFilterBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages that can be processed in a single
     * ApplyFilterRules operation.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1158)
    public Map<String,Object> unsetFilterBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterBatchSize, "");
        return attrs;
    }

    /**
     * The amount of time to sleep between every two messages during
     * ApplyFilterRules. Increasing this value will even out server load at
     * the expense of slowing down the operation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getFilterSleepIntervalAsString to access value as a string.
     *
     * @see #getFilterSleepIntervalAsString()
     *
     * @return zimbraFilterSleepInterval in millseconds, or 1 (1ms)  if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1159)
    public long getFilterSleepInterval() {
        return getTimeInterval(Provisioning.A_zimbraFilterSleepInterval, 1L, true);
    }

    /**
     * The amount of time to sleep between every two messages during
     * ApplyFilterRules. Increasing this value will even out server load at
     * the expense of slowing down the operation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraFilterSleepInterval, or "1ms" if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1159)
    public String getFilterSleepIntervalAsString() {
        return getAttr(Provisioning.A_zimbraFilterSleepInterval, "1ms", true);
    }

    /**
     * The amount of time to sleep between every two messages during
     * ApplyFilterRules. Increasing this value will even out server load at
     * the expense of slowing down the operation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraFilterSleepInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1159)
    public void setFilterSleepInterval(String zimbraFilterSleepInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterSleepInterval, zimbraFilterSleepInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The amount of time to sleep between every two messages during
     * ApplyFilterRules. Increasing this value will even out server load at
     * the expense of slowing down the operation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraFilterSleepInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1159)
    public Map<String,Object> setFilterSleepInterval(String zimbraFilterSleepInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterSleepInterval, zimbraFilterSleepInterval);
        return attrs;
    }

    /**
     * The amount of time to sleep between every two messages during
     * ApplyFilterRules. Increasing this value will even out server load at
     * the expense of slowing down the operation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1159)
    public void unsetFilterSleepInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterSleepInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The amount of time to sleep between every two messages during
     * ApplyFilterRules. Increasing this value will even out server load at
     * the expense of slowing down the operation. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1159)
    public Map<String,Object> unsetFilterSleepInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFilterSleepInterval, "");
        return attrs;
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @return zimbraForceClearCookies, or false if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public boolean isForceClearCookies() {
        return getBooleanAttr(Provisioning.A_zimbraForceClearCookies, false, true);
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @param zimbraForceClearCookies new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public void setForceClearCookies(boolean zimbraForceClearCookies) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForceClearCookies, zimbraForceClearCookies ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @param zimbraForceClearCookies new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public Map<String,Object> setForceClearCookies(boolean zimbraForceClearCookies, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForceClearCookies, zimbraForceClearCookies ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public void unsetForceClearCookies() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForceClearCookies, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public Map<String,Object> unsetForceClearCookies(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForceClearCookies, "");
        return attrs;
    }

    /**
     * mapping to foreign principal identifier
     *
     * @return zimbraForeignPrincipal, or empty array if unset
     */
    @ZAttr(id=295)
    public String[] getForeignPrincipal() {
        return getMultiAttr(Provisioning.A_zimbraForeignPrincipal, true, true);
    }

    /**
     * mapping to foreign principal identifier
     *
     * @param zimbraForeignPrincipal new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=295)
    public void setForeignPrincipal(String[] zimbraForeignPrincipal) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForeignPrincipal, zimbraForeignPrincipal);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mapping to foreign principal identifier
     *
     * @param zimbraForeignPrincipal new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=295)
    public Map<String,Object> setForeignPrincipal(String[] zimbraForeignPrincipal, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForeignPrincipal, zimbraForeignPrincipal);
        return attrs;
    }

    /**
     * mapping to foreign principal identifier
     *
     * @param zimbraForeignPrincipal new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=295)
    public void addForeignPrincipal(String zimbraForeignPrincipal) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraForeignPrincipal, zimbraForeignPrincipal);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mapping to foreign principal identifier
     *
     * @param zimbraForeignPrincipal new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=295)
    public Map<String,Object> addForeignPrincipal(String zimbraForeignPrincipal, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraForeignPrincipal, zimbraForeignPrincipal);
        return attrs;
    }

    /**
     * mapping to foreign principal identifier
     *
     * @param zimbraForeignPrincipal existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=295)
    public void removeForeignPrincipal(String zimbraForeignPrincipal) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraForeignPrincipal, zimbraForeignPrincipal);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mapping to foreign principal identifier
     *
     * @param zimbraForeignPrincipal existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=295)
    public Map<String,Object> removeForeignPrincipal(String zimbraForeignPrincipal, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraForeignPrincipal, zimbraForeignPrincipal);
        return attrs;
    }

    /**
     * mapping to foreign principal identifier
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=295)
    public void unsetForeignPrincipal() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForeignPrincipal, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mapping to foreign principal identifier
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=295)
    public Map<String,Object> unsetForeignPrincipal(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForeignPrincipal, "");
        return attrs;
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @return zimbraFreebusyExchangeAuthPassword, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public String getFreebusyExchangeAuthPassword() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeAuthPassword, null, true);
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeAuthPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public void setFreebusyExchangeAuthPassword(String zimbraFreebusyExchangeAuthPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthPassword, zimbraFreebusyExchangeAuthPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeAuthPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public Map<String,Object> setFreebusyExchangeAuthPassword(String zimbraFreebusyExchangeAuthPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthPassword, zimbraFreebusyExchangeAuthPassword);
        return attrs;
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public void unsetFreebusyExchangeAuthPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public Map<String,Object> unsetFreebusyExchangeAuthPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthPassword, "");
        return attrs;
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @return zimbraFreebusyExchangeAuthScheme, or null if unset and/or has invalid value
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public ZAttrProvisioning.FreebusyExchangeAuthScheme getFreebusyExchangeAuthScheme() {
        try { String v = getAttr(Provisioning.A_zimbraFreebusyExchangeAuthScheme, true, true); return v == null ? null : ZAttrProvisioning.FreebusyExchangeAuthScheme.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @return zimbraFreebusyExchangeAuthScheme, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public String getFreebusyExchangeAuthSchemeAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeAuthScheme, null, true);
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param zimbraFreebusyExchangeAuthScheme new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public void setFreebusyExchangeAuthScheme(ZAttrProvisioning.FreebusyExchangeAuthScheme zimbraFreebusyExchangeAuthScheme) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, zimbraFreebusyExchangeAuthScheme.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param zimbraFreebusyExchangeAuthScheme new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public Map<String,Object> setFreebusyExchangeAuthScheme(ZAttrProvisioning.FreebusyExchangeAuthScheme zimbraFreebusyExchangeAuthScheme, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, zimbraFreebusyExchangeAuthScheme.toString());
        return attrs;
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param zimbraFreebusyExchangeAuthScheme new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public void setFreebusyExchangeAuthSchemeAsString(String zimbraFreebusyExchangeAuthScheme) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, zimbraFreebusyExchangeAuthScheme);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param zimbraFreebusyExchangeAuthScheme new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public Map<String,Object> setFreebusyExchangeAuthSchemeAsString(String zimbraFreebusyExchangeAuthScheme, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, zimbraFreebusyExchangeAuthScheme);
        return attrs;
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public void unsetFreebusyExchangeAuthScheme() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public Map<String,Object> unsetFreebusyExchangeAuthScheme(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, "");
        return attrs;
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @return zimbraFreebusyExchangeAuthUsername, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public String getFreebusyExchangeAuthUsername() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeAuthUsername, null, true);
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeAuthUsername new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public void setFreebusyExchangeAuthUsername(String zimbraFreebusyExchangeAuthUsername) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthUsername, zimbraFreebusyExchangeAuthUsername);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeAuthUsername new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public Map<String,Object> setFreebusyExchangeAuthUsername(String zimbraFreebusyExchangeAuthUsername, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthUsername, zimbraFreebusyExchangeAuthUsername);
        return attrs;
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public void unsetFreebusyExchangeAuthUsername() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthUsername, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public Map<String,Object> unsetFreebusyExchangeAuthUsername(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthUsername, "");
        return attrs;
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFreebusyExchangeCachedIntervalAsString to access value as a string.
     *
     * @see #getFreebusyExchangeCachedIntervalAsString()
     *
     * @return zimbraFreebusyExchangeCachedInterval in millseconds, or -1 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public long getFreebusyExchangeCachedInterval() {
        return getTimeInterval(Provisioning.A_zimbraFreebusyExchangeCachedInterval, -1L, true);
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFreebusyExchangeCachedInterval, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public String getFreebusyExchangeCachedIntervalAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeCachedInterval, null, true);
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFreebusyExchangeCachedInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public void setFreebusyExchangeCachedInterval(String zimbraFreebusyExchangeCachedInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedInterval, zimbraFreebusyExchangeCachedInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFreebusyExchangeCachedInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public Map<String,Object> setFreebusyExchangeCachedInterval(String zimbraFreebusyExchangeCachedInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedInterval, zimbraFreebusyExchangeCachedInterval);
        return attrs;
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public void unsetFreebusyExchangeCachedInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public Map<String,Object> unsetFreebusyExchangeCachedInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedInterval, "");
        return attrs;
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFreebusyExchangeCachedIntervalStartAsString to access value as a string.
     *
     * @see #getFreebusyExchangeCachedIntervalStartAsString()
     *
     * @return zimbraFreebusyExchangeCachedIntervalStart in millseconds, or -1 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public long getFreebusyExchangeCachedIntervalStart() {
        return getTimeInterval(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, -1L, true);
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFreebusyExchangeCachedIntervalStart, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public String getFreebusyExchangeCachedIntervalStartAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, null, true);
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFreebusyExchangeCachedIntervalStart new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public void setFreebusyExchangeCachedIntervalStart(String zimbraFreebusyExchangeCachedIntervalStart) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, zimbraFreebusyExchangeCachedIntervalStart);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFreebusyExchangeCachedIntervalStart new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public Map<String,Object> setFreebusyExchangeCachedIntervalStart(String zimbraFreebusyExchangeCachedIntervalStart, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, zimbraFreebusyExchangeCachedIntervalStart);
        return attrs;
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public void unsetFreebusyExchangeCachedIntervalStart() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public Map<String,Object> unsetFreebusyExchangeCachedIntervalStart(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, "");
        return attrs;
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @return zimbraFreebusyExchangeURL, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public String getFreebusyExchangeURL() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeURL, null, true);
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public void setFreebusyExchangeURL(String zimbraFreebusyExchangeURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeURL, zimbraFreebusyExchangeURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public Map<String,Object> setFreebusyExchangeURL(String zimbraFreebusyExchangeURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeURL, zimbraFreebusyExchangeURL);
        return attrs;
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public void unsetFreebusyExchangeURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public Map<String,Object> unsetFreebusyExchangeURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeURL, "");
        return attrs;
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @return zimbraFreebusyExchangeUserOrg, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public String getFreebusyExchangeUserOrg() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeUserOrg, null, true);
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @param zimbraFreebusyExchangeUserOrg new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public void setFreebusyExchangeUserOrg(String zimbraFreebusyExchangeUserOrg) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeUserOrg, zimbraFreebusyExchangeUserOrg);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @param zimbraFreebusyExchangeUserOrg new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public Map<String,Object> setFreebusyExchangeUserOrg(String zimbraFreebusyExchangeUserOrg, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeUserOrg, zimbraFreebusyExchangeUserOrg);
        return attrs;
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public void unsetFreebusyExchangeUserOrg() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeUserOrg, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public Map<String,Object> unsetFreebusyExchangeUserOrg(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeUserOrg, "");
        return attrs;
    }

    /**
     * when set to TRUE, free/busy for the account is not calculated from
     * local mailbox.
     *
     * @return zimbraFreebusyLocalMailboxNotActive, or false if unset
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=752)
    public boolean isFreebusyLocalMailboxNotActive() {
        return getBooleanAttr(Provisioning.A_zimbraFreebusyLocalMailboxNotActive, false, true);
    }

    /**
     * when set to TRUE, free/busy for the account is not calculated from
     * local mailbox.
     *
     * @param zimbraFreebusyLocalMailboxNotActive new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=752)
    public void setFreebusyLocalMailboxNotActive(boolean zimbraFreebusyLocalMailboxNotActive) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyLocalMailboxNotActive, zimbraFreebusyLocalMailboxNotActive ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * when set to TRUE, free/busy for the account is not calculated from
     * local mailbox.
     *
     * @param zimbraFreebusyLocalMailboxNotActive new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=752)
    public Map<String,Object> setFreebusyLocalMailboxNotActive(boolean zimbraFreebusyLocalMailboxNotActive, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyLocalMailboxNotActive, zimbraFreebusyLocalMailboxNotActive ? TRUE : FALSE);
        return attrs;
    }

    /**
     * when set to TRUE, free/busy for the account is not calculated from
     * local mailbox.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=752)
    public void unsetFreebusyLocalMailboxNotActive() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyLocalMailboxNotActive, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * when set to TRUE, free/busy for the account is not calculated from
     * local mailbox.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=752)
    public Map<String,Object> unsetFreebusyLocalMailboxNotActive(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyLocalMailboxNotActive, "");
        return attrs;
    }

    /**
     * whether to use gal sync account for autocomplete
     *
     * @return zimbraGalSyncAccountBasedAutoCompleteEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1027)
    public boolean isGalSyncAccountBasedAutoCompleteEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraGalSyncAccountBasedAutoCompleteEnabled, true, true);
    }

    /**
     * whether to use gal sync account for autocomplete
     *
     * @param zimbraGalSyncAccountBasedAutoCompleteEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1027)
    public void setGalSyncAccountBasedAutoCompleteEnabled(boolean zimbraGalSyncAccountBasedAutoCompleteEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncAccountBasedAutoCompleteEnabled, zimbraGalSyncAccountBasedAutoCompleteEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to use gal sync account for autocomplete
     *
     * @param zimbraGalSyncAccountBasedAutoCompleteEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1027)
    public Map<String,Object> setGalSyncAccountBasedAutoCompleteEnabled(boolean zimbraGalSyncAccountBasedAutoCompleteEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncAccountBasedAutoCompleteEnabled, zimbraGalSyncAccountBasedAutoCompleteEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to use gal sync account for autocomplete
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1027)
    public void unsetGalSyncAccountBasedAutoCompleteEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncAccountBasedAutoCompleteEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to use gal sync account for autocomplete
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1027)
    public Map<String,Object> unsetGalSyncAccountBasedAutoCompleteEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncAccountBasedAutoCompleteEnabled, "");
        return attrs;
    }

    /**
     * seniority index of the group or group member which will determine the
     * sorting order in the hierarchical address book
     *
     * @return zimbraHABSeniorityIndex, or -1 if unset
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3071)
    public int getHABSeniorityIndex() {
        return getIntAttr(Provisioning.A_zimbraHABSeniorityIndex, -1, true);
    }

    /**
     * seniority index of the group or group member which will determine the
     * sorting order in the hierarchical address book
     *
     * @param zimbraHABSeniorityIndex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3071)
    public void setHABSeniorityIndex(int zimbraHABSeniorityIndex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHABSeniorityIndex, Integer.toString(zimbraHABSeniorityIndex));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * seniority index of the group or group member which will determine the
     * sorting order in the hierarchical address book
     *
     * @param zimbraHABSeniorityIndex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3071)
    public Map<String,Object> setHABSeniorityIndex(int zimbraHABSeniorityIndex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHABSeniorityIndex, Integer.toString(zimbraHABSeniorityIndex));
        return attrs;
    }

    /**
     * seniority index of the group or group member which will determine the
     * sorting order in the hierarchical address book
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3071)
    public void unsetHABSeniorityIndex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHABSeniorityIndex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * seniority index of the group or group member which will determine the
     * sorting order in the hierarchical address book
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3071)
    public Map<String,Object> unsetHABSeniorityIndex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHABSeniorityIndex, "");
        return attrs;
    }

    /**
     * hide entry in Global Address List
     *
     * @return zimbraHideInGal, or false if unset
     */
    @ZAttr(id=353)
    public boolean isHideInGal() {
        return getBooleanAttr(Provisioning.A_zimbraHideInGal, false, true);
    }

    /**
     * hide entry in Global Address List
     *
     * @param zimbraHideInGal new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=353)
    public void setHideInGal(boolean zimbraHideInGal) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHideInGal, zimbraHideInGal ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * hide entry in Global Address List
     *
     * @param zimbraHideInGal new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=353)
    public Map<String,Object> setHideInGal(boolean zimbraHideInGal, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHideInGal, zimbraHideInGal ? TRUE : FALSE);
        return attrs;
    }

    /**
     * hide entry in Global Address List
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=353)
    public void unsetHideInGal() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHideInGal, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * hide entry in Global Address List
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=353)
    public Map<String,Object> unsetHideInGal(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHideInGal, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @return zimbraIMAvailableInteropGateways, or empty array if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public String[] getIMAvailableInteropGateways() {
        return getMultiAttr(Provisioning.A_zimbraIMAvailableInteropGateways, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @param zimbraIMAvailableInteropGateways new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public void setIMAvailableInteropGateways(String[] zimbraIMAvailableInteropGateways) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMAvailableInteropGateways, zimbraIMAvailableInteropGateways);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @param zimbraIMAvailableInteropGateways new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public Map<String,Object> setIMAvailableInteropGateways(String[] zimbraIMAvailableInteropGateways, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMAvailableInteropGateways, zimbraIMAvailableInteropGateways);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @param zimbraIMAvailableInteropGateways new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public void addIMAvailableInteropGateways(String zimbraIMAvailableInteropGateways) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraIMAvailableInteropGateways, zimbraIMAvailableInteropGateways);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @param zimbraIMAvailableInteropGateways new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public Map<String,Object> addIMAvailableInteropGateways(String zimbraIMAvailableInteropGateways, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraIMAvailableInteropGateways, zimbraIMAvailableInteropGateways);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @param zimbraIMAvailableInteropGateways existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public void removeIMAvailableInteropGateways(String zimbraIMAvailableInteropGateways) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraIMAvailableInteropGateways, zimbraIMAvailableInteropGateways);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @param zimbraIMAvailableInteropGateways existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public Map<String,Object> removeIMAvailableInteropGateways(String zimbraIMAvailableInteropGateways, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraIMAvailableInteropGateways, zimbraIMAvailableInteropGateways);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public void unsetIMAvailableInteropGateways() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMAvailableInteropGateways, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * available IM interop gateways
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=571)
    public Map<String,Object> unsetIMAvailableInteropGateways(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMAvailableInteropGateways, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40069. Orig desc: IM
     * service
     *
     * <p>Valid values: [zimbra, yahoo]
     *
     * @return zimbraIMService, or ZAttrProvisioning.IMService.zimbra if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=762)
    public ZAttrProvisioning.IMService getIMService() {
        try { String v = getAttr(Provisioning.A_zimbraIMService, true, true); return v == null ? ZAttrProvisioning.IMService.zimbra : ZAttrProvisioning.IMService.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.IMService.zimbra; }
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40069. Orig desc: IM
     * service
     *
     * <p>Valid values: [zimbra, yahoo]
     *
     * @return zimbraIMService, or "zimbra" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=762)
    public String getIMServiceAsString() {
        return getAttr(Provisioning.A_zimbraIMService, "zimbra", true);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40069. Orig desc: IM
     * service
     *
     * <p>Valid values: [zimbra, yahoo]
     *
     * @param zimbraIMService new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=762)
    public void setIMService(ZAttrProvisioning.IMService zimbraIMService) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMService, zimbraIMService.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40069. Orig desc: IM
     * service
     *
     * <p>Valid values: [zimbra, yahoo]
     *
     * @param zimbraIMService new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=762)
    public Map<String,Object> setIMService(ZAttrProvisioning.IMService zimbraIMService, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMService, zimbraIMService.toString());
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40069. Orig desc: IM
     * service
     *
     * <p>Valid values: [zimbra, yahoo]
     *
     * @param zimbraIMService new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=762)
    public void setIMServiceAsString(String zimbraIMService) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMService, zimbraIMService);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40069. Orig desc: IM
     * service
     *
     * <p>Valid values: [zimbra, yahoo]
     *
     * @param zimbraIMService new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=762)
    public Map<String,Object> setIMServiceAsString(String zimbraIMService, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMService, zimbraIMService);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40069. Orig desc: IM
     * service
     *
     * <p>Valid values: [zimbra, yahoo]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=762)
    public void unsetIMService() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMService, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_GA. deprecated per bug 40069. Orig desc: IM
     * service
     *
     * <p>Valid values: [zimbra, yahoo]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=762)
    public Map<String,Object> unsetIMService(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIMService, "");
        return attrs;
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @return zimbraId, or null if unset
     */
    @ZAttr(id=1)
    public String getId() {
        return getAttr(Provisioning.A_zimbraId, null, true);
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @param zimbraId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=1)
    public void setId(String zimbraId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraId, zimbraId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @param zimbraId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=1)
    public Map<String,Object> setId(String zimbraId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraId, zimbraId);
        return attrs;
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=1)
    public void unsetId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra Systems Unique ID
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=1)
    public Map<String,Object> unsetId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraId, "");
        return attrs;
    }

    /**
     * maximum number of identities allowed on an account
     *
     * @return zimbraIdentityMaxNumEntries, or 20 if unset
     */
    @ZAttr(id=414)
    public int getIdentityMaxNumEntries() {
        return getIntAttr(Provisioning.A_zimbraIdentityMaxNumEntries, 20, true);
    }

    /**
     * maximum number of identities allowed on an account
     *
     * @param zimbraIdentityMaxNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=414)
    public void setIdentityMaxNumEntries(int zimbraIdentityMaxNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIdentityMaxNumEntries, Integer.toString(zimbraIdentityMaxNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of identities allowed on an account
     *
     * @param zimbraIdentityMaxNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=414)
    public Map<String,Object> setIdentityMaxNumEntries(int zimbraIdentityMaxNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIdentityMaxNumEntries, Integer.toString(zimbraIdentityMaxNumEntries));
        return attrs;
    }

    /**
     * maximum number of identities allowed on an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=414)
    public void unsetIdentityMaxNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIdentityMaxNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of identities allowed on an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=414)
    public Map<String,Object> unsetIdentityMaxNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIdentityMaxNumEntries, "");
        return attrs;
    }

    /**
     * whether IMAP is enabled for an account
     *
     * @return zimbraImapEnabled, or true if unset
     */
    @ZAttr(id=174)
    public boolean isImapEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraImapEnabled, true, true);
    }

    /**
     * whether IMAP is enabled for an account
     *
     * @param zimbraImapEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=174)
    public void setImapEnabled(boolean zimbraImapEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnabled, zimbraImapEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP is enabled for an account
     *
     * @param zimbraImapEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=174)
    public Map<String,Object> setImapEnabled(boolean zimbraImapEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnabled, zimbraImapEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether IMAP is enabled for an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=174)
    public void unsetImapEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP is enabled for an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=174)
    public Map<String,Object> unsetImapEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapEnabled, "");
        return attrs;
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @return zimbraInterceptAddress, or empty array if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public String[] getInterceptAddress() {
        return getMultiAttr(Provisioning.A_zimbraInterceptAddress, true, true);
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @param zimbraInterceptAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public void setInterceptAddress(String[] zimbraInterceptAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptAddress, zimbraInterceptAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @param zimbraInterceptAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public Map<String,Object> setInterceptAddress(String[] zimbraInterceptAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptAddress, zimbraInterceptAddress);
        return attrs;
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @param zimbraInterceptAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public void addInterceptAddress(String zimbraInterceptAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraInterceptAddress, zimbraInterceptAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @param zimbraInterceptAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public Map<String,Object> addInterceptAddress(String zimbraInterceptAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraInterceptAddress, zimbraInterceptAddress);
        return attrs;
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @param zimbraInterceptAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public void removeInterceptAddress(String zimbraInterceptAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraInterceptAddress, zimbraInterceptAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @param zimbraInterceptAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public Map<String,Object> removeInterceptAddress(String zimbraInterceptAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraInterceptAddress, zimbraInterceptAddress);
        return attrs;
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public void unsetInterceptAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The address to which legal intercept messages will be sent.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=614)
    public Map<String,Object> unsetInterceptAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptAddress, "");
        return attrs;
    }

    /**
     * Template used to construct the body of a legal intercept message.
     *
     * @return zimbraInterceptBody, or "Intercepted message for ${ACCOUNT_ADDRESS}.${NEWLINE}Operation=${OPERATION}, folder=${FOLDER_NAME}, folder ID=${FOLDER_ID}." if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=618)
    public String getInterceptBody() {
        return getAttr(Provisioning.A_zimbraInterceptBody, "Intercepted message for ${ACCOUNT_ADDRESS}.${NEWLINE}Operation=${OPERATION}, folder=${FOLDER_NAME}, folder ID=${FOLDER_ID}.", true);
    }

    /**
     * Template used to construct the body of a legal intercept message.
     *
     * @param zimbraInterceptBody new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=618)
    public void setInterceptBody(String zimbraInterceptBody) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptBody, zimbraInterceptBody);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the body of a legal intercept message.
     *
     * @param zimbraInterceptBody new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=618)
    public Map<String,Object> setInterceptBody(String zimbraInterceptBody, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptBody, zimbraInterceptBody);
        return attrs;
    }

    /**
     * Template used to construct the body of a legal intercept message.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=618)
    public void unsetInterceptBody() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptBody, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the body of a legal intercept message.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=618)
    public Map<String,Object> unsetInterceptBody(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptBody, "");
        return attrs;
    }

    /**
     * Template used to construct the sender of a legal intercept message.
     *
     * @return zimbraInterceptFrom, or "Postmaster <postmaster@${ACCOUNT_DOMAIN}>" if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=616)
    public String getInterceptFrom() {
        return getAttr(Provisioning.A_zimbraInterceptFrom, "Postmaster <postmaster@${ACCOUNT_DOMAIN}>", true);
    }

    /**
     * Template used to construct the sender of a legal intercept message.
     *
     * @param zimbraInterceptFrom new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=616)
    public void setInterceptFrom(String zimbraInterceptFrom) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptFrom, zimbraInterceptFrom);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the sender of a legal intercept message.
     *
     * @param zimbraInterceptFrom new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=616)
    public Map<String,Object> setInterceptFrom(String zimbraInterceptFrom, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptFrom, zimbraInterceptFrom);
        return attrs;
    }

    /**
     * Template used to construct the sender of a legal intercept message.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=616)
    public void unsetInterceptFrom() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptFrom, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the sender of a legal intercept message.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=616)
    public Map<String,Object> unsetInterceptFrom(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptFrom, "");
        return attrs;
    }

    /**
     * Specifies whether legal intercept messages should contain the entire
     * original message or just the headers.
     *
     * @return zimbraInterceptSendHeadersOnly, or false if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=615)
    public boolean isInterceptSendHeadersOnly() {
        return getBooleanAttr(Provisioning.A_zimbraInterceptSendHeadersOnly, false, true);
    }

    /**
     * Specifies whether legal intercept messages should contain the entire
     * original message or just the headers.
     *
     * @param zimbraInterceptSendHeadersOnly new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=615)
    public void setInterceptSendHeadersOnly(boolean zimbraInterceptSendHeadersOnly) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptSendHeadersOnly, zimbraInterceptSendHeadersOnly ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies whether legal intercept messages should contain the entire
     * original message or just the headers.
     *
     * @param zimbraInterceptSendHeadersOnly new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=615)
    public Map<String,Object> setInterceptSendHeadersOnly(boolean zimbraInterceptSendHeadersOnly, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptSendHeadersOnly, zimbraInterceptSendHeadersOnly ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Specifies whether legal intercept messages should contain the entire
     * original message or just the headers.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=615)
    public void unsetInterceptSendHeadersOnly() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptSendHeadersOnly, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies whether legal intercept messages should contain the entire
     * original message or just the headers.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=615)
    public Map<String,Object> unsetInterceptSendHeadersOnly(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptSendHeadersOnly, "");
        return attrs;
    }

    /**
     * Template used to construct the subject of a legal intercept message.
     *
     * @return zimbraInterceptSubject, or "Intercepted message for ${ACCOUNT_ADDRESS}: ${MESSAGE_SUBJECT}" if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=617)
    public String getInterceptSubject() {
        return getAttr(Provisioning.A_zimbraInterceptSubject, "Intercepted message for ${ACCOUNT_ADDRESS}: ${MESSAGE_SUBJECT}", true);
    }

    /**
     * Template used to construct the subject of a legal intercept message.
     *
     * @param zimbraInterceptSubject new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=617)
    public void setInterceptSubject(String zimbraInterceptSubject) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptSubject, zimbraInterceptSubject);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the subject of a legal intercept message.
     *
     * @param zimbraInterceptSubject new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=617)
    public Map<String,Object> setInterceptSubject(String zimbraInterceptSubject, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptSubject, zimbraInterceptSubject);
        return attrs;
    }

    /**
     * Template used to construct the subject of a legal intercept message.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=617)
    public void unsetInterceptSubject() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptSubject, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the subject of a legal intercept message.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=617)
    public Map<String,Object> unsetInterceptSubject(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInterceptSubject, "");
        return attrs;
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @return zimbraInternalSendersDomain, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public String[] getInternalSendersDomain() {
        return getMultiAttr(Provisioning.A_zimbraInternalSendersDomain, true, true);
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @param zimbraInternalSendersDomain new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public void setInternalSendersDomain(String[] zimbraInternalSendersDomain) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInternalSendersDomain, zimbraInternalSendersDomain);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @param zimbraInternalSendersDomain new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public Map<String,Object> setInternalSendersDomain(String[] zimbraInternalSendersDomain, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInternalSendersDomain, zimbraInternalSendersDomain);
        return attrs;
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @param zimbraInternalSendersDomain new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public void addInternalSendersDomain(String zimbraInternalSendersDomain) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraInternalSendersDomain, zimbraInternalSendersDomain);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @param zimbraInternalSendersDomain new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public Map<String,Object> addInternalSendersDomain(String zimbraInternalSendersDomain, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraInternalSendersDomain, zimbraInternalSendersDomain);
        return attrs;
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @param zimbraInternalSendersDomain existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public void removeInternalSendersDomain(String zimbraInternalSendersDomain) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraInternalSendersDomain, zimbraInternalSendersDomain);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @param zimbraInternalSendersDomain existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public Map<String,Object> removeInternalSendersDomain(String zimbraInternalSendersDomain, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraInternalSendersDomain, zimbraInternalSendersDomain);
        return attrs;
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public void unsetInternalSendersDomain() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInternalSendersDomain, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * additional domains considered as internal w.r.t. recipient
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1319)
    public Map<String,Object> unsetInternalSendersDomain(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInternalSendersDomain, "");
        return attrs;
    }

    /**
     * list of invalid jwt
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error on accessing ephemeral data
     *
     * @return zimbraInvalidJWTokens, or empty array if unset
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=2133)
    public String getInvalidJWTokens(String dynamicComponent) throws com.zimbra.common.service.ServiceException {
        return getEphemeralAttr(Provisioning.A_zimbraInvalidJWTokens, dynamicComponent).getValue(null);
    }

    /**
     * list of invalid jwt
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @param zimbraInvalidJWTokens new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=2133)
    public void addInvalidJWTokens(String dynamicComponent, String zimbraInvalidJWTokens, com.zimbra.cs.ephemeral.EphemeralInput.Expiration expiration) throws com.zimbra.common.service.ServiceException {
        modifyEphemeralAttr(Provisioning.A_zimbraInvalidJWTokens, dynamicComponent, zimbraInvalidJWTokens, true, expiration);
    }

    /**
     * list of invalid jwt
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @param zimbraInvalidJWTokens existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=2133)
    public void removeInvalidJWTokens(String dynamicComponent, String zimbraInvalidJWTokens) throws com.zimbra.common.service.ServiceException {
        deleteEphemeralAttr(Provisioning.A_zimbraInvalidJWTokens, dynamicComponent, zimbraInvalidJWTokens);
    }

    /**
     * list of invalid jwt
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=2133)
    public boolean hasInvalidJWTokens(String dynamicComponent) throws com.zimbra.common.service.ServiceException {
        return hasEphemeralAttr(Provisioning.A_zimbraInvalidJWTokens, dynamicComponent);
    }

    /**
     * list of invalid jwt
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=2133)
    public void purgeInvalidJWTokens() throws com.zimbra.common.service.ServiceException {
        purgeEphemeralAttr(Provisioning.A_zimbraInvalidJWTokens);
    }

    /**
     * set to true for admin accounts
     *
     * @return zimbraIsAdminAccount, or false if unset
     */
    @ZAttr(id=31)
    public boolean isIsAdminAccount() {
        return getBooleanAttr(Provisioning.A_zimbraIsAdminAccount, false, true);
    }

    /**
     * set to true for admin accounts
     *
     * @param zimbraIsAdminAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=31)
    public void setIsAdminAccount(boolean zimbraIsAdminAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsAdminAccount, zimbraIsAdminAccount ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to true for admin accounts
     *
     * @param zimbraIsAdminAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=31)
    public Map<String,Object> setIsAdminAccount(boolean zimbraIsAdminAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsAdminAccount, zimbraIsAdminAccount ? TRUE : FALSE);
        return attrs;
    }

    /**
     * set to true for admin accounts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=31)
    public void unsetIsAdminAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsAdminAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to true for admin accounts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=31)
    public Map<String,Object> unsetIsAdminAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsAdminAccount, "");
        return attrs;
    }

    /**
     * set to true for customer care accounts
     *
     * @return zimbraIsCustomerCareAccount, or false if unset
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=601)
    public boolean isIsCustomerCareAccount() {
        return getBooleanAttr(Provisioning.A_zimbraIsCustomerCareAccount, false, true);
    }

    /**
     * set to true for customer care accounts
     *
     * @param zimbraIsCustomerCareAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=601)
    public void setIsCustomerCareAccount(boolean zimbraIsCustomerCareAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsCustomerCareAccount, zimbraIsCustomerCareAccount ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to true for customer care accounts
     *
     * @param zimbraIsCustomerCareAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=601)
    public Map<String,Object> setIsCustomerCareAccount(boolean zimbraIsCustomerCareAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsCustomerCareAccount, zimbraIsCustomerCareAccount ? TRUE : FALSE);
        return attrs;
    }

    /**
     * set to true for customer care accounts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=601)
    public void unsetIsCustomerCareAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsCustomerCareAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to true for customer care accounts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=601)
    public Map<String,Object> unsetIsCustomerCareAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsCustomerCareAccount, "");
        return attrs;
    }

    /**
     * set to true for delegated admin accounts
     *
     * @return zimbraIsDelegatedAdminAccount, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=852)
    public boolean isIsDelegatedAdminAccount() {
        return getBooleanAttr(Provisioning.A_zimbraIsDelegatedAdminAccount, false, true);
    }

    /**
     * set to true for delegated admin accounts
     *
     * @param zimbraIsDelegatedAdminAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=852)
    public void setIsDelegatedAdminAccount(boolean zimbraIsDelegatedAdminAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsDelegatedAdminAccount, zimbraIsDelegatedAdminAccount ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to true for delegated admin accounts
     *
     * @param zimbraIsDelegatedAdminAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=852)
    public Map<String,Object> setIsDelegatedAdminAccount(boolean zimbraIsDelegatedAdminAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsDelegatedAdminAccount, zimbraIsDelegatedAdminAccount ? TRUE : FALSE);
        return attrs;
    }

    /**
     * set to true for delegated admin accounts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=852)
    public void unsetIsDelegatedAdminAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsDelegatedAdminAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to true for delegated admin accounts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=852)
    public Map<String,Object> unsetIsDelegatedAdminAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsDelegatedAdminAccount, "");
        return attrs;
    }

    /**
     * set to true for domain admin accounts
     *
     * @return zimbraIsDomainAdminAccount, or false if unset
     */
    @ZAttr(id=298)
    public boolean isIsDomainAdminAccount() {
        return getBooleanAttr(Provisioning.A_zimbraIsDomainAdminAccount, false, true);
    }

    /**
     * set to true for domain admin accounts
     *
     * @param zimbraIsDomainAdminAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=298)
    public void setIsDomainAdminAccount(boolean zimbraIsDomainAdminAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsDomainAdminAccount, zimbraIsDomainAdminAccount ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to true for domain admin accounts
     *
     * @param zimbraIsDomainAdminAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=298)
    public Map<String,Object> setIsDomainAdminAccount(boolean zimbraIsDomainAdminAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsDomainAdminAccount, zimbraIsDomainAdminAccount ? TRUE : FALSE);
        return attrs;
    }

    /**
     * set to true for domain admin accounts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=298)
    public void unsetIsDomainAdminAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsDomainAdminAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set to true for domain admin accounts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=298)
    public Map<String,Object> unsetIsDomainAdminAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsDomainAdminAccount, "");
        return attrs;
    }

    /**
     * whether it is an external user account
     *
     * @return zimbraIsExternalVirtualAccount, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1243)
    public boolean isIsExternalVirtualAccount() {
        return getBooleanAttr(Provisioning.A_zimbraIsExternalVirtualAccount, false, true);
    }

    /**
     * whether it is an external user account
     *
     * @param zimbraIsExternalVirtualAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1243)
    public void setIsExternalVirtualAccount(boolean zimbraIsExternalVirtualAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsExternalVirtualAccount, zimbraIsExternalVirtualAccount ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether it is an external user account
     *
     * @param zimbraIsExternalVirtualAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1243)
    public Map<String,Object> setIsExternalVirtualAccount(boolean zimbraIsExternalVirtualAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsExternalVirtualAccount, zimbraIsExternalVirtualAccount ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether it is an external user account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1243)
    public void unsetIsExternalVirtualAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsExternalVirtualAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether it is an external user account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1243)
    public Map<String,Object> unsetIsExternalVirtualAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsExternalVirtualAccount, "");
        return attrs;
    }

    /**
     * whether or not an account represents a Mobile Gateway app
     *
     * @return zimbraIsMobileGatewayAppAccount, or false if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1760)
    public boolean isIsMobileGatewayAppAccount() {
        return getBooleanAttr(Provisioning.A_zimbraIsMobileGatewayAppAccount, false, true);
    }

    /**
     * whether or not an account represents a Mobile Gateway app
     *
     * @param zimbraIsMobileGatewayAppAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1760)
    public void setIsMobileGatewayAppAccount(boolean zimbraIsMobileGatewayAppAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsMobileGatewayAppAccount, zimbraIsMobileGatewayAppAccount ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not an account represents a Mobile Gateway app
     *
     * @param zimbraIsMobileGatewayAppAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1760)
    public Map<String,Object> setIsMobileGatewayAppAccount(boolean zimbraIsMobileGatewayAppAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsMobileGatewayAppAccount, zimbraIsMobileGatewayAppAccount ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not an account represents a Mobile Gateway app
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1760)
    public void unsetIsMobileGatewayAppAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsMobileGatewayAppAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not an account represents a Mobile Gateway app
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1760)
    public Map<String,Object> unsetIsMobileGatewayAppAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsMobileGatewayAppAccount, "");
        return attrs;
    }

    /**
     * whether or not an account represents a Mobile Gateway Proxy account
     *
     * @return zimbraIsMobileGatewayProxyAccount, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2036)
    public boolean isIsMobileGatewayProxyAccount() {
        return getBooleanAttr(Provisioning.A_zimbraIsMobileGatewayProxyAccount, false, true);
    }

    /**
     * whether or not an account represents a Mobile Gateway Proxy account
     *
     * @param zimbraIsMobileGatewayProxyAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2036)
    public void setIsMobileGatewayProxyAccount(boolean zimbraIsMobileGatewayProxyAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsMobileGatewayProxyAccount, zimbraIsMobileGatewayProxyAccount ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not an account represents a Mobile Gateway Proxy account
     *
     * @param zimbraIsMobileGatewayProxyAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2036)
    public Map<String,Object> setIsMobileGatewayProxyAccount(boolean zimbraIsMobileGatewayProxyAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsMobileGatewayProxyAccount, zimbraIsMobileGatewayProxyAccount ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not an account represents a Mobile Gateway Proxy account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2036)
    public void unsetIsMobileGatewayProxyAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsMobileGatewayProxyAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not an account represents a Mobile Gateway Proxy account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2036)
    public Map<String,Object> unsetIsMobileGatewayProxyAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsMobileGatewayProxyAccount, "");
        return attrs;
    }

    /**
     * Indicates the account is an account used by the system such as spam
     * accounts or Notebook accounts. System accounts cannot be deleted in
     * admin console.
     *
     * @return zimbraIsSystemAccount, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1214)
    public boolean isIsSystemAccount() {
        return getBooleanAttr(Provisioning.A_zimbraIsSystemAccount, false, true);
    }

    /**
     * Indicates the account is an account used by the system such as spam
     * accounts or Notebook accounts. System accounts cannot be deleted in
     * admin console.
     *
     * @param zimbraIsSystemAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1214)
    public void setIsSystemAccount(boolean zimbraIsSystemAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsSystemAccount, zimbraIsSystemAccount ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the account is an account used by the system such as spam
     * accounts or Notebook accounts. System accounts cannot be deleted in
     * admin console.
     *
     * @param zimbraIsSystemAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1214)
    public Map<String,Object> setIsSystemAccount(boolean zimbraIsSystemAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsSystemAccount, zimbraIsSystemAccount ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Indicates the account is an account used by the system such as spam
     * accounts or Notebook accounts. System accounts cannot be deleted in
     * admin console.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1214)
    public void unsetIsSystemAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsSystemAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the account is an account used by the system such as spam
     * accounts or Notebook accounts. System accounts cannot be deleted in
     * admin console.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1214)
    public Map<String,Object> unsetIsSystemAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsSystemAccount, "");
        return attrs;
    }

    /**
     * Indicates the account is a resource used by the system. System
     * resource accounts are not counted against license quota.
     *
     * @return zimbraIsSystemResource, or false if unset
     */
    @ZAttr(id=376)
    public boolean isIsSystemResource() {
        return getBooleanAttr(Provisioning.A_zimbraIsSystemResource, false, true);
    }

    /**
     * Indicates the account is a resource used by the system. System
     * resource accounts are not counted against license quota.
     *
     * @param zimbraIsSystemResource new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=376)
    public void setIsSystemResource(boolean zimbraIsSystemResource) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsSystemResource, zimbraIsSystemResource ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the account is a resource used by the system. System
     * resource accounts are not counted against license quota.
     *
     * @param zimbraIsSystemResource new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=376)
    public Map<String,Object> setIsSystemResource(boolean zimbraIsSystemResource, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsSystemResource, zimbraIsSystemResource ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Indicates the account is a resource used by the system. System
     * resource accounts are not counted against license quota.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=376)
    public void unsetIsSystemResource() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsSystemResource, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Indicates the account is a resource used by the system. System
     * resource accounts are not counted against license quota.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=376)
    public Map<String,Object> unsetIsSystemResource(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIsSystemResource, "");
        return attrs;
    }

    /**
     * Whether to index junk messages
     *
     * @return zimbraJunkMessagesIndexingEnabled, or true if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=579)
    public boolean isJunkMessagesIndexingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraJunkMessagesIndexingEnabled, true, true);
    }

    /**
     * Whether to index junk messages
     *
     * @param zimbraJunkMessagesIndexingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=579)
    public void setJunkMessagesIndexingEnabled(boolean zimbraJunkMessagesIndexingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraJunkMessagesIndexingEnabled, zimbraJunkMessagesIndexingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to index junk messages
     *
     * @param zimbraJunkMessagesIndexingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=579)
    public Map<String,Object> setJunkMessagesIndexingEnabled(boolean zimbraJunkMessagesIndexingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraJunkMessagesIndexingEnabled, zimbraJunkMessagesIndexingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to index junk messages
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=579)
    public void unsetJunkMessagesIndexingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraJunkMessagesIndexingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to index junk messages
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=579)
    public Map<String,Object> unsetJunkMessagesIndexingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraJunkMessagesIndexingEnabled, "");
        return attrs;
    }

    /**
     * rough estimate of when the user last logged in
     *
     * <p>Use getLastLogonTimestampAsString to access value as a string.
     *
     * @see #getLastLogonTimestampAsString()
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error on accessing ephemeral data
     *
     * @return zimbraLastLogonTimestamp as Date, null if unset or unable to parse
     */
    @ZAttr(id=113)
    public Date getLastLogonTimestamp() throws com.zimbra.common.service.ServiceException {
        String v = getEphemeralAttr(Provisioning.A_zimbraLastLogonTimestamp, null).getValue(null); return v == null ? null : LdapDateUtil.parseGeneralizedTime(v);
    }

    /**
     * rough estimate of when the user last logged in
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error on accessing ephemeral data
     *
     * @return zimbraLastLogonTimestamp, or null if unset
     */
    @ZAttr(id=113)
    public String getLastLogonTimestampAsString() throws com.zimbra.common.service.ServiceException {
        return getEphemeralAttr(Provisioning.A_zimbraLastLogonTimestamp, null).getValue(null);
    }

    /**
     * rough estimate of when the user last logged in
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @param zimbraLastLogonTimestamp new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=113)
    public void setLastLogonTimestamp(Date zimbraLastLogonTimestamp) throws com.zimbra.common.service.ServiceException {
        modifyEphemeralAttr(Provisioning.A_zimbraLastLogonTimestamp, null, zimbraLastLogonTimestamp==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraLastLogonTimestamp), false, null);
    }

    /**
     * rough estimate of when the user last logged in
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @param zimbraLastLogonTimestamp new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=113)
    public void setLastLogonTimestampAsString(String zimbraLastLogonTimestamp) throws com.zimbra.common.service.ServiceException {
        modifyEphemeralAttr(Provisioning.A_zimbraLastLogonTimestamp, null, zimbraLastLogonTimestamp, false, null);
    }

    /**
     * rough estimate of when the user last logged in
     *
     * Ephemeral attribute - requests routed to EphemeralStore
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=113)
    public void unsetLastLogonTimestamp() throws com.zimbra.common.service.ServiceException {
        deleteEphemeralAttr(Provisioning.A_zimbraLastLogonTimestamp);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @return zimbraLocale, or null if unset
     */
    @ZAttr(id=345)
    public String getLocaleAsString() {
        return getAttr(Provisioning.A_zimbraLocale, null, true);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param zimbraLocale new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=345)
    public void setLocale(String zimbraLocale) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, zimbraLocale);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param zimbraLocale new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=345)
    public Map<String,Object> setLocale(String zimbraLocale, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, zimbraLocale);
        return attrs;
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=345)
    public void unsetLocale() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=345)
    public Map<String,Object> unsetLocale(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, "");
        return attrs;
    }

    /**
     * Flag to control how authtokens are invalidated in multi-server
     * environment. If set to TRUE: when this account logs out on a server,
     * the server will notify other servers that this account&#039;s
     * authtoken has been invalidated. If set to FALSE, an auth token may
     * remain vallid on servers other than the account&#039;s home server
     * after a user logs out for as long as an account object remains in
     * Provisioning Cache. Set to TRUE for increased protection against
     * Cookie Re-use attack. Default is FALSE to reduce network chatter.
     *
     * @return zimbraLogOutFromAllServers, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1634)
    public boolean isLogOutFromAllServers() {
        return getBooleanAttr(Provisioning.A_zimbraLogOutFromAllServers, false, true);
    }

    /**
     * Flag to control how authtokens are invalidated in multi-server
     * environment. If set to TRUE: when this account logs out on a server,
     * the server will notify other servers that this account&#039;s
     * authtoken has been invalidated. If set to FALSE, an auth token may
     * remain vallid on servers other than the account&#039;s home server
     * after a user logs out for as long as an account object remains in
     * Provisioning Cache. Set to TRUE for increased protection against
     * Cookie Re-use attack. Default is FALSE to reduce network chatter.
     *
     * @param zimbraLogOutFromAllServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1634)
    public void setLogOutFromAllServers(boolean zimbraLogOutFromAllServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogOutFromAllServers, zimbraLogOutFromAllServers ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to control how authtokens are invalidated in multi-server
     * environment. If set to TRUE: when this account logs out on a server,
     * the server will notify other servers that this account&#039;s
     * authtoken has been invalidated. If set to FALSE, an auth token may
     * remain vallid on servers other than the account&#039;s home server
     * after a user logs out for as long as an account object remains in
     * Provisioning Cache. Set to TRUE for increased protection against
     * Cookie Re-use attack. Default is FALSE to reduce network chatter.
     *
     * @param zimbraLogOutFromAllServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1634)
    public Map<String,Object> setLogOutFromAllServers(boolean zimbraLogOutFromAllServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogOutFromAllServers, zimbraLogOutFromAllServers ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Flag to control how authtokens are invalidated in multi-server
     * environment. If set to TRUE: when this account logs out on a server,
     * the server will notify other servers that this account&#039;s
     * authtoken has been invalidated. If set to FALSE, an auth token may
     * remain vallid on servers other than the account&#039;s home server
     * after a user logs out for as long as an account object remains in
     * Provisioning Cache. Set to TRUE for increased protection against
     * Cookie Re-use attack. Default is FALSE to reduce network chatter.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1634)
    public void unsetLogOutFromAllServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogOutFromAllServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flag to control how authtokens are invalidated in multi-server
     * environment. If set to TRUE: when this account logs out on a server,
     * the server will notify other servers that this account&#039;s
     * authtoken has been invalidated. If set to FALSE, an auth token may
     * remain vallid on servers other than the account&#039;s home server
     * after a user logs out for as long as an account object remains in
     * Provisioning Cache. Set to TRUE for increased protection against
     * Cookie Re-use attack. Default is FALSE to reduce network chatter.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1634)
    public Map<String,Object> unsetLogOutFromAllServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogOutFromAllServers, "");
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @return zimbraMailAddress, or empty array if unset
     */
    @ZAttr(id=3)
    public String[] getMailAddress() {
        return getMultiAttr(Provisioning.A_zimbraMailAddress, true, true);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=3)
    public void setMailAddress(String[] zimbraMailAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAddress, zimbraMailAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=3)
    public Map<String,Object> setMailAddress(String[] zimbraMailAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAddress, zimbraMailAddress);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=3)
    public void addMailAddress(String zimbraMailAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailAddress, zimbraMailAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=3)
    public Map<String,Object> addMailAddress(String zimbraMailAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailAddress, zimbraMailAddress);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=3)
    public void removeMailAddress(String zimbraMailAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailAddress, zimbraMailAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=3)
    public Map<String,Object> removeMailAddress(String zimbraMailAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailAddress, zimbraMailAddress);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=3)
    public void unsetMailAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=3)
    public Map<String,Object> unsetMailAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAddress, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptAfter. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * after the end user filter rule
     *
     * @return zimbraMailAdminOutgoingSieveScriptAfter, or null if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2093)
    public String getMailAdminOutgoingSieveScriptAfter() {
        return getAttr(Provisioning.A_zimbraMailAdminOutgoingSieveScriptAfter, null, true);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptAfter. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * after the end user filter rule
     *
     * @param zimbraMailAdminOutgoingSieveScriptAfter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2093)
    public void setMailAdminOutgoingSieveScriptAfter(String zimbraMailAdminOutgoingSieveScriptAfter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminOutgoingSieveScriptAfter, zimbraMailAdminOutgoingSieveScriptAfter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptAfter. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * after the end user filter rule
     *
     * @param zimbraMailAdminOutgoingSieveScriptAfter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2093)
    public Map<String,Object> setMailAdminOutgoingSieveScriptAfter(String zimbraMailAdminOutgoingSieveScriptAfter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminOutgoingSieveScriptAfter, zimbraMailAdminOutgoingSieveScriptAfter);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptAfter. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * after the end user filter rule
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2093)
    public void unsetMailAdminOutgoingSieveScriptAfter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminOutgoingSieveScriptAfter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptAfter. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * after the end user filter rule
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2093)
    public Map<String,Object> unsetMailAdminOutgoingSieveScriptAfter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminOutgoingSieveScriptAfter, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptBefore. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * before the end user filter rule
     *
     * @return zimbraMailAdminOutgoingSieveScriptBefore, or null if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2092)
    public String getMailAdminOutgoingSieveScriptBefore() {
        return getAttr(Provisioning.A_zimbraMailAdminOutgoingSieveScriptBefore, null, true);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptBefore. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * before the end user filter rule
     *
     * @param zimbraMailAdminOutgoingSieveScriptBefore new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2092)
    public void setMailAdminOutgoingSieveScriptBefore(String zimbraMailAdminOutgoingSieveScriptBefore) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminOutgoingSieveScriptBefore, zimbraMailAdminOutgoingSieveScriptBefore);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptBefore. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * before the end user filter rule
     *
     * @param zimbraMailAdminOutgoingSieveScriptBefore new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2092)
    public Map<String,Object> setMailAdminOutgoingSieveScriptBefore(String zimbraMailAdminOutgoingSieveScriptBefore, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminOutgoingSieveScriptBefore, zimbraMailAdminOutgoingSieveScriptBefore);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptBefore. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * before the end user filter rule
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2092)
    public void unsetMailAdminOutgoingSieveScriptBefore() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminOutgoingSieveScriptBefore, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminOutgoingSieveScriptBefore. Orig desc: outgoing sieve script
     * defined by admin (not able to edit and view from the end user) applied
     * before the end user filter rule
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2092)
    public Map<String,Object> unsetMailAdminOutgoingSieveScriptBefore(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminOutgoingSieveScriptBefore, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptAfter. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied after the end
     * user filter rule
     *
     * @return zimbraMailAdminSieveScriptAfter, or null if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2091)
    public String getMailAdminSieveScriptAfter() {
        return getAttr(Provisioning.A_zimbraMailAdminSieveScriptAfter, null, true);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptAfter. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied after the end
     * user filter rule
     *
     * @param zimbraMailAdminSieveScriptAfter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2091)
    public void setMailAdminSieveScriptAfter(String zimbraMailAdminSieveScriptAfter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminSieveScriptAfter, zimbraMailAdminSieveScriptAfter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptAfter. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied after the end
     * user filter rule
     *
     * @param zimbraMailAdminSieveScriptAfter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2091)
    public Map<String,Object> setMailAdminSieveScriptAfter(String zimbraMailAdminSieveScriptAfter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminSieveScriptAfter, zimbraMailAdminSieveScriptAfter);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptAfter. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied after the end
     * user filter rule
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2091)
    public void unsetMailAdminSieveScriptAfter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminSieveScriptAfter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptAfter. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied after the end
     * user filter rule
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2091)
    public Map<String,Object> unsetMailAdminSieveScriptAfter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminSieveScriptAfter, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptBefore. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied before the end
     * user filter rule
     *
     * @return zimbraMailAdminSieveScriptBefore, or null if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2090)
    public String getMailAdminSieveScriptBefore() {
        return getAttr(Provisioning.A_zimbraMailAdminSieveScriptBefore, null, true);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptBefore. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied before the end
     * user filter rule
     *
     * @param zimbraMailAdminSieveScriptBefore new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2090)
    public void setMailAdminSieveScriptBefore(String zimbraMailAdminSieveScriptBefore) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminSieveScriptBefore, zimbraMailAdminSieveScriptBefore);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptBefore. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied before the end
     * user filter rule
     *
     * @param zimbraMailAdminSieveScriptBefore new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2090)
    public Map<String,Object> setMailAdminSieveScriptBefore(String zimbraMailAdminSieveScriptBefore, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminSieveScriptBefore, zimbraMailAdminSieveScriptBefore);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptBefore. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied before the end
     * user filter rule
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2090)
    public void unsetMailAdminSieveScriptBefore() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminSieveScriptBefore, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraAdminSieveScriptBefore. Orig desc: sieve script defined by admin
     * (not able to edit and view from the end user) applied before the end
     * user filter rule
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2090)
    public Map<String,Object> unsetMailAdminSieveScriptBefore(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAdminSieveScriptBefore, "");
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @return zimbraMailAlias, or empty array if unset
     */
    @ZAttr(id=20)
    public String[] getMailAlias() {
        return getMultiAttr(Provisioning.A_zimbraMailAlias, true, true);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAlias new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=20)
    public void setMailAlias(String[] zimbraMailAlias) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAlias, zimbraMailAlias);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAlias new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=20)
    public Map<String,Object> setMailAlias(String[] zimbraMailAlias, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAlias, zimbraMailAlias);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAlias new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=20)
    public void addMailAlias(String zimbraMailAlias) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailAlias, zimbraMailAlias);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAlias new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=20)
    public Map<String,Object> addMailAlias(String zimbraMailAlias, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailAlias, zimbraMailAlias);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAlias existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=20)
    public void removeMailAlias(String zimbraMailAlias) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailAlias, zimbraMailAlias);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param zimbraMailAlias existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=20)
    public Map<String,Object> removeMailAlias(String zimbraMailAlias, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailAlias, zimbraMailAlias);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=20)
    public void unsetMailAlias() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAlias, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for accepting mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=20)
    public Map<String,Object> unsetMailAlias(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAlias, "");
        return attrs;
    }

    /**
     * If TRUE, a mailbox that exceeds its quota is still allowed to receive
     * mail, but is not allowed to send.
     *
     * @return zimbraMailAllowReceiveButNotSendWhenOverQuota, or false if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1099)
    public boolean isMailAllowReceiveButNotSendWhenOverQuota() {
        return getBooleanAttr(Provisioning.A_zimbraMailAllowReceiveButNotSendWhenOverQuota, false, true);
    }

    /**
     * If TRUE, a mailbox that exceeds its quota is still allowed to receive
     * mail, but is not allowed to send.
     *
     * @param zimbraMailAllowReceiveButNotSendWhenOverQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1099)
    public void setMailAllowReceiveButNotSendWhenOverQuota(boolean zimbraMailAllowReceiveButNotSendWhenOverQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAllowReceiveButNotSendWhenOverQuota, zimbraMailAllowReceiveButNotSendWhenOverQuota ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, a mailbox that exceeds its quota is still allowed to receive
     * mail, but is not allowed to send.
     *
     * @param zimbraMailAllowReceiveButNotSendWhenOverQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1099)
    public Map<String,Object> setMailAllowReceiveButNotSendWhenOverQuota(boolean zimbraMailAllowReceiveButNotSendWhenOverQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAllowReceiveButNotSendWhenOverQuota, zimbraMailAllowReceiveButNotSendWhenOverQuota ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, a mailbox that exceeds its quota is still allowed to receive
     * mail, but is not allowed to send.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1099)
    public void unsetMailAllowReceiveButNotSendWhenOverQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAllowReceiveButNotSendWhenOverQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, a mailbox that exceeds its quota is still allowed to receive
     * mail, but is not allowed to send.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1099)
    public Map<String,Object> unsetMailAllowReceiveButNotSendWhenOverQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAllowReceiveButNotSendWhenOverQuota, "");
        return attrs;
    }

    /**
     * Maximum number of entries for per user black list. This restricts the
     * number of values that can be set on the amavisBlacklistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @return zimbraMailBlacklistMaxNumEntries, or 100 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=799)
    public int getMailBlacklistMaxNumEntries() {
        return getIntAttr(Provisioning.A_zimbraMailBlacklistMaxNumEntries, 100, true);
    }

    /**
     * Maximum number of entries for per user black list. This restricts the
     * number of values that can be set on the amavisBlacklistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @param zimbraMailBlacklistMaxNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=799)
    public void setMailBlacklistMaxNumEntries(int zimbraMailBlacklistMaxNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBlacklistMaxNumEntries, Integer.toString(zimbraMailBlacklistMaxNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries for per user black list. This restricts the
     * number of values that can be set on the amavisBlacklistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @param zimbraMailBlacklistMaxNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=799)
    public Map<String,Object> setMailBlacklistMaxNumEntries(int zimbraMailBlacklistMaxNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBlacklistMaxNumEntries, Integer.toString(zimbraMailBlacklistMaxNumEntries));
        return attrs;
    }

    /**
     * Maximum number of entries for per user black list. This restricts the
     * number of values that can be set on the amavisBlacklistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=799)
    public void unsetMailBlacklistMaxNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBlacklistMaxNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries for per user black list. This restricts the
     * number of values that can be set on the amavisBlacklistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=799)
    public Map<String,Object> unsetMailBlacklistMaxNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailBlacklistMaxNumEntries, "");
        return attrs;
    }

    /**
     * RFC822 email address for senders outbound messages
     *
     * @return zimbraMailCanonicalAddress, or null if unset
     */
    @ZAttr(id=213)
    public String getMailCanonicalAddress() {
        return getAttr(Provisioning.A_zimbraMailCanonicalAddress, null, true);
    }

    /**
     * RFC822 email address for senders outbound messages
     *
     * @param zimbraMailCanonicalAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=213)
    public void setMailCanonicalAddress(String zimbraMailCanonicalAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCanonicalAddress, zimbraMailCanonicalAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address for senders outbound messages
     *
     * @param zimbraMailCanonicalAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=213)
    public Map<String,Object> setMailCanonicalAddress(String zimbraMailCanonicalAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCanonicalAddress, zimbraMailCanonicalAddress);
        return attrs;
    }

    /**
     * RFC822 email address for senders outbound messages
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=213)
    public void unsetMailCanonicalAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCanonicalAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address for senders outbound messages
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=213)
    public Map<String,Object> unsetMailCanonicalAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCanonicalAddress, "");
        return attrs;
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @return zimbraMailCatchAllAddress, or empty array if unset
     */
    @ZAttr(id=214)
    public String[] getMailCatchAllAddress() {
        return getMultiAttr(Provisioning.A_zimbraMailCatchAllAddress, true, true);
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @param zimbraMailCatchAllAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=214)
    public void setMailCatchAllAddress(String[] zimbraMailCatchAllAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllAddress, zimbraMailCatchAllAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @param zimbraMailCatchAllAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=214)
    public Map<String,Object> setMailCatchAllAddress(String[] zimbraMailCatchAllAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllAddress, zimbraMailCatchAllAddress);
        return attrs;
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @param zimbraMailCatchAllAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=214)
    public void addMailCatchAllAddress(String zimbraMailCatchAllAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailCatchAllAddress, zimbraMailCatchAllAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @param zimbraMailCatchAllAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=214)
    public Map<String,Object> addMailCatchAllAddress(String zimbraMailCatchAllAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailCatchAllAddress, zimbraMailCatchAllAddress);
        return attrs;
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @param zimbraMailCatchAllAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=214)
    public void removeMailCatchAllAddress(String zimbraMailCatchAllAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailCatchAllAddress, zimbraMailCatchAllAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @param zimbraMailCatchAllAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=214)
    public Map<String,Object> removeMailCatchAllAddress(String zimbraMailCatchAllAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailCatchAllAddress, zimbraMailCatchAllAddress);
        return attrs;
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=214)
    public void unsetMailCatchAllAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Address to catch all messages to specified domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=214)
    public Map<String,Object> unsetMailCatchAllAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllAddress, "");
        return attrs;
    }

    /**
     * Catch all address to rewrite to
     *
     * @return zimbraMailCatchAllCanonicalAddress, or null if unset
     */
    @ZAttr(id=216)
    public String getMailCatchAllCanonicalAddress() {
        return getAttr(Provisioning.A_zimbraMailCatchAllCanonicalAddress, null, true);
    }

    /**
     * Catch all address to rewrite to
     *
     * @param zimbraMailCatchAllCanonicalAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=216)
    public void setMailCatchAllCanonicalAddress(String zimbraMailCatchAllCanonicalAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllCanonicalAddress, zimbraMailCatchAllCanonicalAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Catch all address to rewrite to
     *
     * @param zimbraMailCatchAllCanonicalAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=216)
    public Map<String,Object> setMailCatchAllCanonicalAddress(String zimbraMailCatchAllCanonicalAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllCanonicalAddress, zimbraMailCatchAllCanonicalAddress);
        return attrs;
    }

    /**
     * Catch all address to rewrite to
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=216)
    public void unsetMailCatchAllCanonicalAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllCanonicalAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Catch all address to rewrite to
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=216)
    public Map<String,Object> unsetMailCatchAllCanonicalAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllCanonicalAddress, "");
        return attrs;
    }

    /**
     * Address to deliver catch all messages to
     *
     * @return zimbraMailCatchAllForwardingAddress, or null if unset
     */
    @ZAttr(id=215)
    public String getMailCatchAllForwardingAddress() {
        return getAttr(Provisioning.A_zimbraMailCatchAllForwardingAddress, null, true);
    }

    /**
     * Address to deliver catch all messages to
     *
     * @param zimbraMailCatchAllForwardingAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=215)
    public void setMailCatchAllForwardingAddress(String zimbraMailCatchAllForwardingAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllForwardingAddress, zimbraMailCatchAllForwardingAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Address to deliver catch all messages to
     *
     * @param zimbraMailCatchAllForwardingAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=215)
    public Map<String,Object> setMailCatchAllForwardingAddress(String zimbraMailCatchAllForwardingAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllForwardingAddress, zimbraMailCatchAllForwardingAddress);
        return attrs;
    }

    /**
     * Address to deliver catch all messages to
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=215)
    public void unsetMailCatchAllForwardingAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllForwardingAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Address to deliver catch all messages to
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=215)
    public Map<String,Object> unsetMailCatchAllForwardingAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailCatchAllForwardingAddress, "");
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @return zimbraMailDeliveryAddress, or empty array if unset
     */
    @ZAttr(id=13)
    public String[] getMailDeliveryAddress() {
        return getMultiAttr(Provisioning.A_zimbraMailDeliveryAddress, true, true);
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @param zimbraMailDeliveryAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=13)
    public void setMailDeliveryAddress(String[] zimbraMailDeliveryAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDeliveryAddress, zimbraMailDeliveryAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @param zimbraMailDeliveryAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=13)
    public Map<String,Object> setMailDeliveryAddress(String[] zimbraMailDeliveryAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDeliveryAddress, zimbraMailDeliveryAddress);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @param zimbraMailDeliveryAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=13)
    public void addMailDeliveryAddress(String zimbraMailDeliveryAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailDeliveryAddress, zimbraMailDeliveryAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @param zimbraMailDeliveryAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=13)
    public Map<String,Object> addMailDeliveryAddress(String zimbraMailDeliveryAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailDeliveryAddress, zimbraMailDeliveryAddress);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @param zimbraMailDeliveryAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=13)
    public void removeMailDeliveryAddress(String zimbraMailDeliveryAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailDeliveryAddress, zimbraMailDeliveryAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @param zimbraMailDeliveryAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=13)
    public Map<String,Object> removeMailDeliveryAddress(String zimbraMailDeliveryAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailDeliveryAddress, zimbraMailDeliveryAddress);
        return attrs;
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=13)
    public void unsetMailDeliveryAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDeliveryAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address of this recipient for local delivery
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=13)
    public Map<String,Object> unsetMailDeliveryAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDeliveryAddress, "");
        return attrs;
    }

    /**
     * Retention period of messages in the dumpster. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailDumpsterLifetimeAsString to access value as a string.
     *
     * @see #getMailDumpsterLifetimeAsString()
     *
     * @return zimbraMailDumpsterLifetime in millseconds, or 2592000000 (30d)  if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1133)
    public long getMailDumpsterLifetime() {
        return getTimeInterval(Provisioning.A_zimbraMailDumpsterLifetime, 2592000000L, true);
    }

    /**
     * Retention period of messages in the dumpster. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailDumpsterLifetime, or "30d" if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1133)
    public String getMailDumpsterLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraMailDumpsterLifetime, "30d", true);
    }

    /**
     * Retention period of messages in the dumpster. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailDumpsterLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1133)
    public void setMailDumpsterLifetime(String zimbraMailDumpsterLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDumpsterLifetime, zimbraMailDumpsterLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the dumpster. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailDumpsterLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1133)
    public Map<String,Object> setMailDumpsterLifetime(String zimbraMailDumpsterLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDumpsterLifetime, zimbraMailDumpsterLifetime);
        return attrs;
    }

    /**
     * Retention period of messages in the dumpster. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1133)
    public void unsetMailDumpsterLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDumpsterLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the dumpster. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1133)
    public Map<String,Object> unsetMailDumpsterLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDumpsterLifetime, "");
        return attrs;
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @return zimbraMailForwardingAddress, or empty array if unset
     */
    @ZAttr(id=12)
    public String[] getMailForwardingAddress() {
        return getMultiAttr(Provisioning.A_zimbraMailForwardingAddress, true, true);
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param zimbraMailForwardingAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=12)
    public void setMailForwardingAddress(String[] zimbraMailForwardingAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddress, zimbraMailForwardingAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param zimbraMailForwardingAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=12)
    public Map<String,Object> setMailForwardingAddress(String[] zimbraMailForwardingAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddress, zimbraMailForwardingAddress);
        return attrs;
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param zimbraMailForwardingAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=12)
    public void addMailForwardingAddress(String zimbraMailForwardingAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailForwardingAddress, zimbraMailForwardingAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param zimbraMailForwardingAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=12)
    public Map<String,Object> addMailForwardingAddress(String zimbraMailForwardingAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailForwardingAddress, zimbraMailForwardingAddress);
        return attrs;
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param zimbraMailForwardingAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=12)
    public void removeMailForwardingAddress(String zimbraMailForwardingAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailForwardingAddress, zimbraMailForwardingAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param zimbraMailForwardingAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=12)
    public Map<String,Object> removeMailForwardingAddress(String zimbraMailForwardingAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailForwardingAddress, zimbraMailForwardingAddress);
        return attrs;
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=12)
    public void unsetMailForwardingAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=12)
    public Map<String,Object> unsetMailForwardingAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddress, "");
        return attrs;
    }

    /**
     * max number of chars in zimbraPrefMailForwardingAddress
     *
     * @return zimbraMailForwardingAddressMaxLength, or 4096 if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1039)
    public int getMailForwardingAddressMaxLength() {
        return getIntAttr(Provisioning.A_zimbraMailForwardingAddressMaxLength, 4096, true);
    }

    /**
     * max number of chars in zimbraPrefMailForwardingAddress
     *
     * @param zimbraMailForwardingAddressMaxLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1039)
    public void setMailForwardingAddressMaxLength(int zimbraMailForwardingAddressMaxLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddressMaxLength, Integer.toString(zimbraMailForwardingAddressMaxLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of chars in zimbraPrefMailForwardingAddress
     *
     * @param zimbraMailForwardingAddressMaxLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1039)
    public Map<String,Object> setMailForwardingAddressMaxLength(int zimbraMailForwardingAddressMaxLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddressMaxLength, Integer.toString(zimbraMailForwardingAddressMaxLength));
        return attrs;
    }

    /**
     * max number of chars in zimbraPrefMailForwardingAddress
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1039)
    public void unsetMailForwardingAddressMaxLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddressMaxLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of chars in zimbraPrefMailForwardingAddress
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1039)
    public Map<String,Object> unsetMailForwardingAddressMaxLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddressMaxLength, "");
        return attrs;
    }

    /**
     * max number of email addresses in zimbraPrefMailForwardingAddress
     *
     * @return zimbraMailForwardingAddressMaxNumAddrs, or 100 if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1040)
    public int getMailForwardingAddressMaxNumAddrs() {
        return getIntAttr(Provisioning.A_zimbraMailForwardingAddressMaxNumAddrs, 100, true);
    }

    /**
     * max number of email addresses in zimbraPrefMailForwardingAddress
     *
     * @param zimbraMailForwardingAddressMaxNumAddrs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1040)
    public void setMailForwardingAddressMaxNumAddrs(int zimbraMailForwardingAddressMaxNumAddrs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddressMaxNumAddrs, Integer.toString(zimbraMailForwardingAddressMaxNumAddrs));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of email addresses in zimbraPrefMailForwardingAddress
     *
     * @param zimbraMailForwardingAddressMaxNumAddrs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1040)
    public Map<String,Object> setMailForwardingAddressMaxNumAddrs(int zimbraMailForwardingAddressMaxNumAddrs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddressMaxNumAddrs, Integer.toString(zimbraMailForwardingAddressMaxNumAddrs));
        return attrs;
    }

    /**
     * max number of email addresses in zimbraPrefMailForwardingAddress
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1040)
    public void unsetMailForwardingAddressMaxNumAddrs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddressMaxNumAddrs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of email addresses in zimbraPrefMailForwardingAddress
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1040)
    public Map<String,Object> unsetMailForwardingAddressMaxNumAddrs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailForwardingAddressMaxNumAddrs, "");
        return attrs;
    }

    /**
     * max size in KB of text emails that will automatically highlight
     * objects
     *
     * @return zimbraMailHighlightObjectsMaxSize, or 70 if unset
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1213)
    public int getMailHighlightObjectsMaxSize() {
        return getIntAttr(Provisioning.A_zimbraMailHighlightObjectsMaxSize, 70, true);
    }

    /**
     * max size in KB of text emails that will automatically highlight
     * objects
     *
     * @param zimbraMailHighlightObjectsMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1213)
    public void setMailHighlightObjectsMaxSize(int zimbraMailHighlightObjectsMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailHighlightObjectsMaxSize, Integer.toString(zimbraMailHighlightObjectsMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max size in KB of text emails that will automatically highlight
     * objects
     *
     * @param zimbraMailHighlightObjectsMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1213)
    public Map<String,Object> setMailHighlightObjectsMaxSize(int zimbraMailHighlightObjectsMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailHighlightObjectsMaxSize, Integer.toString(zimbraMailHighlightObjectsMaxSize));
        return attrs;
    }

    /**
     * max size in KB of text emails that will automatically highlight
     * objects
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1213)
    public void unsetMailHighlightObjectsMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailHighlightObjectsMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max size in KB of text emails that will automatically highlight
     * objects
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1213)
    public Map<String,Object> unsetMailHighlightObjectsMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailHighlightObjectsMaxSize, "");
        return attrs;
    }

    /**
     * the server hosting the account&#039;s mailbox
     *
     * @return zimbraMailHost, or null if unset
     */
    @ZAttr(id=4)
    public String getMailHost() {
        return getAttr(Provisioning.A_zimbraMailHost, null, true);
    }

    /**
     * the server hosting the account&#039;s mailbox
     *
     * @param zimbraMailHost new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=4)
    public void setMailHost(String zimbraMailHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailHost, zimbraMailHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the server hosting the account&#039;s mailbox
     *
     * @param zimbraMailHost new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=4)
    public Map<String,Object> setMailHost(String zimbraMailHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailHost, zimbraMailHost);
        return attrs;
    }

    /**
     * the server hosting the account&#039;s mailbox
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=4)
    public void unsetMailHost() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailHost, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the server hosting the account&#039;s mailbox
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=4)
    public Map<String,Object> unsetMailHost(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailHost, "");
        return attrs;
    }

    /**
     * idle timeout. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getMailIdleSessionTimeoutAsString to access value as a string.
     *
     * @see #getMailIdleSessionTimeoutAsString()
     *
     * @return zimbraMailIdleSessionTimeout in millseconds, or 0 (0)  if unset
     */
    @ZAttr(id=147)
    public long getMailIdleSessionTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMailIdleSessionTimeout, 0L, true);
    }

    /**
     * idle timeout. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraMailIdleSessionTimeout, or "0" if unset
     */
    @ZAttr(id=147)
    public String getMailIdleSessionTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMailIdleSessionTimeout, "0", true);
    }

    /**
     * idle timeout. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraMailIdleSessionTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=147)
    public void setMailIdleSessionTimeout(String zimbraMailIdleSessionTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailIdleSessionTimeout, zimbraMailIdleSessionTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * idle timeout. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraMailIdleSessionTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=147)
    public Map<String,Object> setMailIdleSessionTimeout(String zimbraMailIdleSessionTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailIdleSessionTimeout, zimbraMailIdleSessionTimeout);
        return attrs;
    }

    /**
     * idle timeout. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=147)
    public void unsetMailIdleSessionTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailIdleSessionTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * idle timeout. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=147)
    public Map<String,Object> unsetMailIdleSessionTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailIdleSessionTimeout, "");
        return attrs;
    }

    /**
     * lifetime of a mail message regardless of location. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailMessageLifetimeAsString to access value as a string.
     *
     * @see #getMailMessageLifetimeAsString()
     *
     * @return zimbraMailMessageLifetime in millseconds, or 0 (0)  if unset
     */
    @ZAttr(id=106)
    public long getMailMessageLifetime() {
        return getTimeInterval(Provisioning.A_zimbraMailMessageLifetime, 0L, true);
    }

    /**
     * lifetime of a mail message regardless of location. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailMessageLifetime, or "0" if unset
     */
    @ZAttr(id=106)
    public String getMailMessageLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraMailMessageLifetime, "0", true);
    }

    /**
     * lifetime of a mail message regardless of location. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailMessageLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=106)
    public void setMailMessageLifetime(String zimbraMailMessageLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMessageLifetime, zimbraMailMessageLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of a mail message regardless of location. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailMessageLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=106)
    public Map<String,Object> setMailMessageLifetime(String zimbraMailMessageLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMessageLifetime, zimbraMailMessageLifetime);
        return attrs;
    }

    /**
     * lifetime of a mail message regardless of location. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=106)
    public void unsetMailMessageLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMessageLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of a mail message regardless of location. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=106)
    public Map<String,Object> unsetMailMessageLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMessageLifetime, "");
        return attrs;
    }

    /**
     * minimum allowed value for zimbraPrefMailPollingInterval. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailMinPollingIntervalAsString to access value as a string.
     *
     * @see #getMailMinPollingIntervalAsString()
     *
     * @return zimbraMailMinPollingInterval in millseconds, or 120000 (2m)  if unset
     */
    @ZAttr(id=110)
    public long getMailMinPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraMailMinPollingInterval, 120000L, true);
    }

    /**
     * minimum allowed value for zimbraPrefMailPollingInterval. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailMinPollingInterval, or "2m" if unset
     */
    @ZAttr(id=110)
    public String getMailMinPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraMailMinPollingInterval, "2m", true);
    }

    /**
     * minimum allowed value for zimbraPrefMailPollingInterval. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailMinPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=110)
    public void setMailMinPollingInterval(String zimbraMailMinPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMinPollingInterval, zimbraMailMinPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum allowed value for zimbraPrefMailPollingInterval. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailMinPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=110)
    public Map<String,Object> setMailMinPollingInterval(String zimbraMailMinPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMinPollingInterval, zimbraMailMinPollingInterval);
        return attrs;
    }

    /**
     * minimum allowed value for zimbraPrefMailPollingInterval. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=110)
    public void unsetMailMinPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMinPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum allowed value for zimbraPrefMailPollingInterval. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=110)
    public Map<String,Object> unsetMailMinPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMinPollingInterval, "");
        return attrs;
    }

    /**
     * sieve script generated from user outgoing filter rules
     *
     * @return zimbraMailOutgoingSieveScript, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1130)
    public String getMailOutgoingSieveScript() {
        return getAttr(Provisioning.A_zimbraMailOutgoingSieveScript, null, true);
    }

    /**
     * sieve script generated from user outgoing filter rules
     *
     * @param zimbraMailOutgoingSieveScript new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1130)
    public void setMailOutgoingSieveScript(String zimbraMailOutgoingSieveScript) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailOutgoingSieveScript, zimbraMailOutgoingSieveScript);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sieve script generated from user outgoing filter rules
     *
     * @param zimbraMailOutgoingSieveScript new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1130)
    public Map<String,Object> setMailOutgoingSieveScript(String zimbraMailOutgoingSieveScript, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailOutgoingSieveScript, zimbraMailOutgoingSieveScript);
        return attrs;
    }

    /**
     * sieve script generated from user outgoing filter rules
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1130)
    public void unsetMailOutgoingSieveScript() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailOutgoingSieveScript, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sieve script generated from user outgoing filter rules
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1130)
    public Map<String,Object> unsetMailOutgoingSieveScript(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailOutgoingSieveScript, "");
        return attrs;
    }

    /**
     * If TRUE, a message is purged from Spam based on the date that it was
     * moved to the Spam folder. If FALSE, a message is purged from Spam
     * based on the date that it was added to the mailbox.
     *
     * @return zimbraMailPurgeUseChangeDateForSpam, or true if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1117)
    public boolean isMailPurgeUseChangeDateForSpam() {
        return getBooleanAttr(Provisioning.A_zimbraMailPurgeUseChangeDateForSpam, true, true);
    }

    /**
     * If TRUE, a message is purged from Spam based on the date that it was
     * moved to the Spam folder. If FALSE, a message is purged from Spam
     * based on the date that it was added to the mailbox.
     *
     * @param zimbraMailPurgeUseChangeDateForSpam new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1117)
    public void setMailPurgeUseChangeDateForSpam(boolean zimbraMailPurgeUseChangeDateForSpam) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeUseChangeDateForSpam, zimbraMailPurgeUseChangeDateForSpam ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, a message is purged from Spam based on the date that it was
     * moved to the Spam folder. If FALSE, a message is purged from Spam
     * based on the date that it was added to the mailbox.
     *
     * @param zimbraMailPurgeUseChangeDateForSpam new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1117)
    public Map<String,Object> setMailPurgeUseChangeDateForSpam(boolean zimbraMailPurgeUseChangeDateForSpam, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeUseChangeDateForSpam, zimbraMailPurgeUseChangeDateForSpam ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, a message is purged from Spam based on the date that it was
     * moved to the Spam folder. If FALSE, a message is purged from Spam
     * based on the date that it was added to the mailbox.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1117)
    public void unsetMailPurgeUseChangeDateForSpam() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeUseChangeDateForSpam, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, a message is purged from Spam based on the date that it was
     * moved to the Spam folder. If FALSE, a message is purged from Spam
     * based on the date that it was added to the mailbox.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1117)
    public Map<String,Object> unsetMailPurgeUseChangeDateForSpam(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeUseChangeDateForSpam, "");
        return attrs;
    }

    /**
     * If TRUE, a message is purged from trash based on the date that it was
     * moved to the Trash folder. If FALSE, a message is purged from Trash
     * based on the date that it was added to the mailbox.
     *
     * @return zimbraMailPurgeUseChangeDateForTrash, or true if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=748)
    public boolean isMailPurgeUseChangeDateForTrash() {
        return getBooleanAttr(Provisioning.A_zimbraMailPurgeUseChangeDateForTrash, true, true);
    }

    /**
     * If TRUE, a message is purged from trash based on the date that it was
     * moved to the Trash folder. If FALSE, a message is purged from Trash
     * based on the date that it was added to the mailbox.
     *
     * @param zimbraMailPurgeUseChangeDateForTrash new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=748)
    public void setMailPurgeUseChangeDateForTrash(boolean zimbraMailPurgeUseChangeDateForTrash) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeUseChangeDateForTrash, zimbraMailPurgeUseChangeDateForTrash ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, a message is purged from trash based on the date that it was
     * moved to the Trash folder. If FALSE, a message is purged from Trash
     * based on the date that it was added to the mailbox.
     *
     * @param zimbraMailPurgeUseChangeDateForTrash new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=748)
    public Map<String,Object> setMailPurgeUseChangeDateForTrash(boolean zimbraMailPurgeUseChangeDateForTrash, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeUseChangeDateForTrash, zimbraMailPurgeUseChangeDateForTrash ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, a message is purged from trash based on the date that it was
     * moved to the Trash folder. If FALSE, a message is purged from Trash
     * based on the date that it was added to the mailbox.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=748)
    public void unsetMailPurgeUseChangeDateForTrash() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeUseChangeDateForTrash, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, a message is purged from trash based on the date that it was
     * moved to the Trash folder. If FALSE, a message is purged from Trash
     * based on the date that it was added to the mailbox.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=748)
    public Map<String,Object> unsetMailPurgeUseChangeDateForTrash(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeUseChangeDateForTrash, "");
        return attrs;
    }

    /**
     * mail quota in bytes
     *
     * @return zimbraMailQuota, or 0 if unset
     */
    @ZAttr(id=16)
    public long getMailQuota() {
        return getLongAttr(Provisioning.A_zimbraMailQuota, 0L, true);
    }

    /**
     * mail quota in bytes
     *
     * @param zimbraMailQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=16)
    public void setMailQuota(long zimbraMailQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailQuota, Long.toString(zimbraMailQuota));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail quota in bytes
     *
     * @param zimbraMailQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=16)
    public Map<String,Object> setMailQuota(long zimbraMailQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailQuota, Long.toString(zimbraMailQuota));
        return attrs;
    }

    /**
     * mail quota in bytes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=16)
    public void unsetMailQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail quota in bytes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=16)
    public Map<String,Object> unsetMailQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailQuota, "");
        return attrs;
    }

    /**
     * sieve script generated from user filter rules
     *
     * @return zimbraMailSieveScript, or null if unset
     */
    @ZAttr(id=32)
    public String getMailSieveScript() {
        return getAttr(Provisioning.A_zimbraMailSieveScript, null, true);
    }

    /**
     * sieve script generated from user filter rules
     *
     * @param zimbraMailSieveScript new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=32)
    public void setMailSieveScript(String zimbraMailSieveScript) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSieveScript, zimbraMailSieveScript);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sieve script generated from user filter rules
     *
     * @param zimbraMailSieveScript new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=32)
    public Map<String,Object> setMailSieveScript(String zimbraMailSieveScript, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSieveScript, zimbraMailSieveScript);
        return attrs;
    }

    /**
     * sieve script generated from user filter rules
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=32)
    public void unsetMailSieveScript() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSieveScript, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sieve script generated from user filter rules
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=32)
    public Map<String,Object> unsetMailSieveScript(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSieveScript, "");
        return attrs;
    }

    /**
     * maximum length of mail signature, 0 means unlimited.
     *
     * @return zimbraMailSignatureMaxLength, or 10240 if unset
     */
    @ZAttr(id=454)
    public long getMailSignatureMaxLength() {
        return getLongAttr(Provisioning.A_zimbraMailSignatureMaxLength, 10240L, true);
    }

    /**
     * maximum length of mail signature, 0 means unlimited.
     *
     * @param zimbraMailSignatureMaxLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=454)
    public void setMailSignatureMaxLength(long zimbraMailSignatureMaxLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSignatureMaxLength, Long.toString(zimbraMailSignatureMaxLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum length of mail signature, 0 means unlimited.
     *
     * @param zimbraMailSignatureMaxLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=454)
    public Map<String,Object> setMailSignatureMaxLength(long zimbraMailSignatureMaxLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSignatureMaxLength, Long.toString(zimbraMailSignatureMaxLength));
        return attrs;
    }

    /**
     * maximum length of mail signature, 0 means unlimited.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=454)
    public void unsetMailSignatureMaxLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSignatureMaxLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum length of mail signature, 0 means unlimited.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=454)
    public Map<String,Object> unsetMailSignatureMaxLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSignatureMaxLength, "");
        return attrs;
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefJunkLifetime, which is user-modifiable. The
     * shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailSpamLifetimeAsString to access value as a string.
     *
     * @see #getMailSpamLifetimeAsString()
     *
     * @return zimbraMailSpamLifetime in millseconds, or 2592000000 (30d)  if unset
     */
    @ZAttr(id=105)
    public long getMailSpamLifetime() {
        return getTimeInterval(Provisioning.A_zimbraMailSpamLifetime, 2592000000L, true);
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefJunkLifetime, which is user-modifiable. The
     * shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailSpamLifetime, or "30d" if unset
     */
    @ZAttr(id=105)
    public String getMailSpamLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraMailSpamLifetime, "30d", true);
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefJunkLifetime, which is user-modifiable. The
     * shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailSpamLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=105)
    public void setMailSpamLifetime(String zimbraMailSpamLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSpamLifetime, zimbraMailSpamLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefJunkLifetime, which is user-modifiable. The
     * shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailSpamLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=105)
    public Map<String,Object> setMailSpamLifetime(String zimbraMailSpamLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSpamLifetime, zimbraMailSpamLifetime);
        return attrs;
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefJunkLifetime, which is user-modifiable. The
     * shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=105)
    public void unsetMailSpamLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSpamLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefJunkLifetime, which is user-modifiable. The
     * shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=105)
    public Map<String,Object> unsetMailSpamLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSpamLifetime, "");
        return attrs;
    }

    /**
     * mail delivery status (enabled/disabled)
     *
     * <p>Valid values: [enabled, disabled]
     *
     * @return zimbraMailStatus, or null if unset and/or has invalid value
     */
    @ZAttr(id=15)
    public ZAttrProvisioning.MailStatus getMailStatus() {
        try { String v = getAttr(Provisioning.A_zimbraMailStatus, true, true); return v == null ? null : ZAttrProvisioning.MailStatus.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * mail delivery status (enabled/disabled)
     *
     * <p>Valid values: [enabled, disabled]
     *
     * @return zimbraMailStatus, or null if unset
     */
    @ZAttr(id=15)
    public String getMailStatusAsString() {
        return getAttr(Provisioning.A_zimbraMailStatus, null, true);
    }

    /**
     * mail delivery status (enabled/disabled)
     *
     * <p>Valid values: [enabled, disabled]
     *
     * @param zimbraMailStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=15)
    public void setMailStatus(ZAttrProvisioning.MailStatus zimbraMailStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailStatus, zimbraMailStatus.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail delivery status (enabled/disabled)
     *
     * <p>Valid values: [enabled, disabled]
     *
     * @param zimbraMailStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=15)
    public Map<String,Object> setMailStatus(ZAttrProvisioning.MailStatus zimbraMailStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailStatus, zimbraMailStatus.toString());
        return attrs;
    }

    /**
     * mail delivery status (enabled/disabled)
     *
     * <p>Valid values: [enabled, disabled]
     *
     * @param zimbraMailStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=15)
    public void setMailStatusAsString(String zimbraMailStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailStatus, zimbraMailStatus);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail delivery status (enabled/disabled)
     *
     * <p>Valid values: [enabled, disabled]
     *
     * @param zimbraMailStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=15)
    public Map<String,Object> setMailStatusAsString(String zimbraMailStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailStatus, zimbraMailStatus);
        return attrs;
    }

    /**
     * mail delivery status (enabled/disabled)
     *
     * <p>Valid values: [enabled, disabled]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=15)
    public void unsetMailStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail delivery status (enabled/disabled)
     *
     * <p>Valid values: [enabled, disabled]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=15)
    public Map<String,Object> unsetMailStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailStatus, "");
        return attrs;
    }

    /**
     * The algorithm to use when aggregating new messages into conversations.
     * Possible values are: - &quot;none&quot;: no conversation threading is
     * performed. - &quot;subject&quot;: the message will be threaded based
     * solely on its normalized subject. - &quot;strict&quot;: only the
     * threading message headers (References, In-Reply-To, Message-ID, and
     * Resent-Message-ID) are used to correlate messages. No checking of
     * normalized subjects is performed. - &quot;references&quot;: the same
     * logic as &quot;strict&quot; with the constraints slightly altered so
     * that the non-standard Thread-Index header is considered when threading
     * messages and that a reply message lacking References and In-Reply-To
     * headers will fall back to using subject-based threading. -
     * &quot;subjrefs&quot;: the same logic as &quot;references&quot; with
     * the further caveat that changes in the normalized subject will break a
     * thread in two.
     *
     * <p>Valid values: [subject, subjrefs, references, strict, none]
     *
     * @return zimbraMailThreadingAlgorithm, or ZAttrProvisioning.MailThreadingAlgorithm.references if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1160)
    public ZAttrProvisioning.MailThreadingAlgorithm getMailThreadingAlgorithm() {
        try { String v = getAttr(Provisioning.A_zimbraMailThreadingAlgorithm, true, true); return v == null ? ZAttrProvisioning.MailThreadingAlgorithm.references : ZAttrProvisioning.MailThreadingAlgorithm.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MailThreadingAlgorithm.references; }
    }

    /**
     * The algorithm to use when aggregating new messages into conversations.
     * Possible values are: - &quot;none&quot;: no conversation threading is
     * performed. - &quot;subject&quot;: the message will be threaded based
     * solely on its normalized subject. - &quot;strict&quot;: only the
     * threading message headers (References, In-Reply-To, Message-ID, and
     * Resent-Message-ID) are used to correlate messages. No checking of
     * normalized subjects is performed. - &quot;references&quot;: the same
     * logic as &quot;strict&quot; with the constraints slightly altered so
     * that the non-standard Thread-Index header is considered when threading
     * messages and that a reply message lacking References and In-Reply-To
     * headers will fall back to using subject-based threading. -
     * &quot;subjrefs&quot;: the same logic as &quot;references&quot; with
     * the further caveat that changes in the normalized subject will break a
     * thread in two.
     *
     * <p>Valid values: [subject, subjrefs, references, strict, none]
     *
     * @return zimbraMailThreadingAlgorithm, or "references" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1160)
    public String getMailThreadingAlgorithmAsString() {
        return getAttr(Provisioning.A_zimbraMailThreadingAlgorithm, "references", true);
    }

    /**
     * The algorithm to use when aggregating new messages into conversations.
     * Possible values are: - &quot;none&quot;: no conversation threading is
     * performed. - &quot;subject&quot;: the message will be threaded based
     * solely on its normalized subject. - &quot;strict&quot;: only the
     * threading message headers (References, In-Reply-To, Message-ID, and
     * Resent-Message-ID) are used to correlate messages. No checking of
     * normalized subjects is performed. - &quot;references&quot;: the same
     * logic as &quot;strict&quot; with the constraints slightly altered so
     * that the non-standard Thread-Index header is considered when threading
     * messages and that a reply message lacking References and In-Reply-To
     * headers will fall back to using subject-based threading. -
     * &quot;subjrefs&quot;: the same logic as &quot;references&quot; with
     * the further caveat that changes in the normalized subject will break a
     * thread in two.
     *
     * <p>Valid values: [subject, subjrefs, references, strict, none]
     *
     * @param zimbraMailThreadingAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1160)
    public void setMailThreadingAlgorithm(ZAttrProvisioning.MailThreadingAlgorithm zimbraMailThreadingAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailThreadingAlgorithm, zimbraMailThreadingAlgorithm.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The algorithm to use when aggregating new messages into conversations.
     * Possible values are: - &quot;none&quot;: no conversation threading is
     * performed. - &quot;subject&quot;: the message will be threaded based
     * solely on its normalized subject. - &quot;strict&quot;: only the
     * threading message headers (References, In-Reply-To, Message-ID, and
     * Resent-Message-ID) are used to correlate messages. No checking of
     * normalized subjects is performed. - &quot;references&quot;: the same
     * logic as &quot;strict&quot; with the constraints slightly altered so
     * that the non-standard Thread-Index header is considered when threading
     * messages and that a reply message lacking References and In-Reply-To
     * headers will fall back to using subject-based threading. -
     * &quot;subjrefs&quot;: the same logic as &quot;references&quot; with
     * the further caveat that changes in the normalized subject will break a
     * thread in two.
     *
     * <p>Valid values: [subject, subjrefs, references, strict, none]
     *
     * @param zimbraMailThreadingAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1160)
    public Map<String,Object> setMailThreadingAlgorithm(ZAttrProvisioning.MailThreadingAlgorithm zimbraMailThreadingAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailThreadingAlgorithm, zimbraMailThreadingAlgorithm.toString());
        return attrs;
    }

    /**
     * The algorithm to use when aggregating new messages into conversations.
     * Possible values are: - &quot;none&quot;: no conversation threading is
     * performed. - &quot;subject&quot;: the message will be threaded based
     * solely on its normalized subject. - &quot;strict&quot;: only the
     * threading message headers (References, In-Reply-To, Message-ID, and
     * Resent-Message-ID) are used to correlate messages. No checking of
     * normalized subjects is performed. - &quot;references&quot;: the same
     * logic as &quot;strict&quot; with the constraints slightly altered so
     * that the non-standard Thread-Index header is considered when threading
     * messages and that a reply message lacking References and In-Reply-To
     * headers will fall back to using subject-based threading. -
     * &quot;subjrefs&quot;: the same logic as &quot;references&quot; with
     * the further caveat that changes in the normalized subject will break a
     * thread in two.
     *
     * <p>Valid values: [subject, subjrefs, references, strict, none]
     *
     * @param zimbraMailThreadingAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1160)
    public void setMailThreadingAlgorithmAsString(String zimbraMailThreadingAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailThreadingAlgorithm, zimbraMailThreadingAlgorithm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The algorithm to use when aggregating new messages into conversations.
     * Possible values are: - &quot;none&quot;: no conversation threading is
     * performed. - &quot;subject&quot;: the message will be threaded based
     * solely on its normalized subject. - &quot;strict&quot;: only the
     * threading message headers (References, In-Reply-To, Message-ID, and
     * Resent-Message-ID) are used to correlate messages. No checking of
     * normalized subjects is performed. - &quot;references&quot;: the same
     * logic as &quot;strict&quot; with the constraints slightly altered so
     * that the non-standard Thread-Index header is considered when threading
     * messages and that a reply message lacking References and In-Reply-To
     * headers will fall back to using subject-based threading. -
     * &quot;subjrefs&quot;: the same logic as &quot;references&quot; with
     * the further caveat that changes in the normalized subject will break a
     * thread in two.
     *
     * <p>Valid values: [subject, subjrefs, references, strict, none]
     *
     * @param zimbraMailThreadingAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1160)
    public Map<String,Object> setMailThreadingAlgorithmAsString(String zimbraMailThreadingAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailThreadingAlgorithm, zimbraMailThreadingAlgorithm);
        return attrs;
    }

    /**
     * The algorithm to use when aggregating new messages into conversations.
     * Possible values are: - &quot;none&quot;: no conversation threading is
     * performed. - &quot;subject&quot;: the message will be threaded based
     * solely on its normalized subject. - &quot;strict&quot;: only the
     * threading message headers (References, In-Reply-To, Message-ID, and
     * Resent-Message-ID) are used to correlate messages. No checking of
     * normalized subjects is performed. - &quot;references&quot;: the same
     * logic as &quot;strict&quot; with the constraints slightly altered so
     * that the non-standard Thread-Index header is considered when threading
     * messages and that a reply message lacking References and In-Reply-To
     * headers will fall back to using subject-based threading. -
     * &quot;subjrefs&quot;: the same logic as &quot;references&quot; with
     * the further caveat that changes in the normalized subject will break a
     * thread in two.
     *
     * <p>Valid values: [subject, subjrefs, references, strict, none]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1160)
    public void unsetMailThreadingAlgorithm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailThreadingAlgorithm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The algorithm to use when aggregating new messages into conversations.
     * Possible values are: - &quot;none&quot;: no conversation threading is
     * performed. - &quot;subject&quot;: the message will be threaded based
     * solely on its normalized subject. - &quot;strict&quot;: only the
     * threading message headers (References, In-Reply-To, Message-ID, and
     * Resent-Message-ID) are used to correlate messages. No checking of
     * normalized subjects is performed. - &quot;references&quot;: the same
     * logic as &quot;strict&quot; with the constraints slightly altered so
     * that the non-standard Thread-Index header is considered when threading
     * messages and that a reply message lacking References and In-Reply-To
     * headers will fall back to using subject-based threading. -
     * &quot;subjrefs&quot;: the same logic as &quot;references&quot; with
     * the further caveat that changes in the normalized subject will break a
     * thread in two.
     *
     * <p>Valid values: [subject, subjrefs, references, strict, none]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1160)
    public Map<String,Object> unsetMailThreadingAlgorithm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailThreadingAlgorithm, "");
        return attrs;
    }

    /**
     * where to deliver parameter for use in postfix transport_maps
     *
     * @return zimbraMailTransport, or null if unset
     */
    @ZAttr(id=247)
    public String getMailTransport() {
        return getAttr(Provisioning.A_zimbraMailTransport, null, true);
    }

    /**
     * where to deliver parameter for use in postfix transport_maps
     *
     * @param zimbraMailTransport new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=247)
    public void setMailTransport(String zimbraMailTransport) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTransport, zimbraMailTransport);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where to deliver parameter for use in postfix transport_maps
     *
     * @param zimbraMailTransport new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=247)
    public Map<String,Object> setMailTransport(String zimbraMailTransport, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTransport, zimbraMailTransport);
        return attrs;
    }

    /**
     * where to deliver parameter for use in postfix transport_maps
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=247)
    public void unsetMailTransport() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTransport, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where to deliver parameter for use in postfix transport_maps
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=247)
    public Map<String,Object> unsetMailTransport(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTransport, "");
        return attrs;
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefTrashLifetime, which is user-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailTrashLifetimeAsString to access value as a string.
     *
     * @see #getMailTrashLifetimeAsString()
     *
     * @return zimbraMailTrashLifetime in millseconds, or 2592000000 (30d)  if unset
     */
    @ZAttr(id=104)
    public long getMailTrashLifetime() {
        return getTimeInterval(Provisioning.A_zimbraMailTrashLifetime, 2592000000L, true);
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefTrashLifetime, which is user-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailTrashLifetime, or "30d" if unset
     */
    @ZAttr(id=104)
    public String getMailTrashLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraMailTrashLifetime, "30d", true);
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefTrashLifetime, which is user-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailTrashLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=104)
    public void setMailTrashLifetime(String zimbraMailTrashLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrashLifetime, zimbraMailTrashLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefTrashLifetime, which is user-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailTrashLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=104)
    public Map<String,Object> setMailTrashLifetime(String zimbraMailTrashLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrashLifetime, zimbraMailTrashLifetime);
        return attrs;
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefTrashLifetime, which is user-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=104)
    public void unsetMailTrashLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrashLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This admin-modifiable attribute works in
     * conjunction with zimbraPrefTrashLifetime, which is user-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=104)
    public Map<String,Object> unsetMailTrashLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrashLifetime, "");
        return attrs;
    }

    /**
     * Maximum number of entries for zimbraPrefMailTrustedSenderList.
     *
     * @return zimbraMailTrustedSenderListMaxNumEntries, or 500 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1139)
    public int getMailTrustedSenderListMaxNumEntries() {
        return getIntAttr(Provisioning.A_zimbraMailTrustedSenderListMaxNumEntries, 500, true);
    }

    /**
     * Maximum number of entries for zimbraPrefMailTrustedSenderList.
     *
     * @param zimbraMailTrustedSenderListMaxNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1139)
    public void setMailTrustedSenderListMaxNumEntries(int zimbraMailTrustedSenderListMaxNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedSenderListMaxNumEntries, Integer.toString(zimbraMailTrustedSenderListMaxNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries for zimbraPrefMailTrustedSenderList.
     *
     * @param zimbraMailTrustedSenderListMaxNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1139)
    public Map<String,Object> setMailTrustedSenderListMaxNumEntries(int zimbraMailTrustedSenderListMaxNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedSenderListMaxNumEntries, Integer.toString(zimbraMailTrustedSenderListMaxNumEntries));
        return attrs;
    }

    /**
     * Maximum number of entries for zimbraPrefMailTrustedSenderList.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1139)
    public void unsetMailTrustedSenderListMaxNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedSenderListMaxNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries for zimbraPrefMailTrustedSenderList.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1139)
    public Map<String,Object> unsetMailTrustedSenderListMaxNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedSenderListMaxNumEntries, "");
        return attrs;
    }

    /**
     * Maximum number of entries for per user white list. This restricts the
     * number of values that can be set on the amavisWhitelistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @return zimbraMailWhitelistMaxNumEntries, or 100 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=798)
    public int getMailWhitelistMaxNumEntries() {
        return getIntAttr(Provisioning.A_zimbraMailWhitelistMaxNumEntries, 100, true);
    }

    /**
     * Maximum number of entries for per user white list. This restricts the
     * number of values that can be set on the amavisWhitelistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @param zimbraMailWhitelistMaxNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=798)
    public void setMailWhitelistMaxNumEntries(int zimbraMailWhitelistMaxNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailWhitelistMaxNumEntries, Integer.toString(zimbraMailWhitelistMaxNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries for per user white list. This restricts the
     * number of values that can be set on the amavisWhitelistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @param zimbraMailWhitelistMaxNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=798)
    public Map<String,Object> setMailWhitelistMaxNumEntries(int zimbraMailWhitelistMaxNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailWhitelistMaxNumEntries, Integer.toString(zimbraMailWhitelistMaxNumEntries));
        return attrs;
    }

    /**
     * Maximum number of entries for per user white list. This restricts the
     * number of values that can be set on the amavisWhitelistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=798)
    public void unsetMailWhitelistMaxNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailWhitelistMaxNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries for per user white list. This restricts the
     * number of values that can be set on the amavisWhitelistSender
     * attribute of an account. If set to 0, the per user white list feature
     * is disabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=798)
    public Map<String,Object> unsetMailWhitelistMaxNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailWhitelistMaxNumEntries, "");
        return attrs;
    }

    /**
     * serverId:mboxId of mailbox before being moved
     *
     * @return zimbraMailboxLocationBeforeMove, or null if unset
     */
    @ZAttr(id=346)
    public String getMailboxLocationBeforeMove() {
        return getAttr(Provisioning.A_zimbraMailboxLocationBeforeMove, null, true);
    }

    /**
     * serverId:mboxId of mailbox before being moved
     *
     * @param zimbraMailboxLocationBeforeMove new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=346)
    public void setMailboxLocationBeforeMove(String zimbraMailboxLocationBeforeMove) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxLocationBeforeMove, zimbraMailboxLocationBeforeMove);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * serverId:mboxId of mailbox before being moved
     *
     * @param zimbraMailboxLocationBeforeMove new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=346)
    public Map<String,Object> setMailboxLocationBeforeMove(String zimbraMailboxLocationBeforeMove, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxLocationBeforeMove, zimbraMailboxLocationBeforeMove);
        return attrs;
    }

    /**
     * serverId:mboxId of mailbox before being moved
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=346)
    public void unsetMailboxLocationBeforeMove() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxLocationBeforeMove, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * serverId:mboxId of mailbox before being moved
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=346)
    public Map<String,Object> unsetMailboxLocationBeforeMove(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxLocationBeforeMove, "");
        return attrs;
    }

    /**
     * maximum number of application-specific passwords allowed for an
     * account
     *
     * @return zimbraMaxAppSpecificPasswords, or 25 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1837)
    public int getMaxAppSpecificPasswords() {
        return getIntAttr(Provisioning.A_zimbraMaxAppSpecificPasswords, 25, true);
    }

    /**
     * maximum number of application-specific passwords allowed for an
     * account
     *
     * @param zimbraMaxAppSpecificPasswords new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1837)
    public void setMaxAppSpecificPasswords(int zimbraMaxAppSpecificPasswords) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxAppSpecificPasswords, Integer.toString(zimbraMaxAppSpecificPasswords));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of application-specific passwords allowed for an
     * account
     *
     * @param zimbraMaxAppSpecificPasswords new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1837)
    public Map<String,Object> setMaxAppSpecificPasswords(int zimbraMaxAppSpecificPasswords, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxAppSpecificPasswords, Integer.toString(zimbraMaxAppSpecificPasswords));
        return attrs;
    }

    /**
     * maximum number of application-specific passwords allowed for an
     * account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1837)
    public void unsetMaxAppSpecificPasswords() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxAppSpecificPasswords, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of application-specific passwords allowed for an
     * account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1837)
    public Map<String,Object> unsetMaxAppSpecificPasswords(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxAppSpecificPasswords, "");
        return attrs;
    }

    /**
     * max number of contacts per page, Web client (not server) verifies that
     * zimbraPrefContactsPerPage should not exceed this attribute.
     *
     * @return zimbraMaxContactsPerPage, or 100 if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1012)
    public int getMaxContactsPerPage() {
        return getIntAttr(Provisioning.A_zimbraMaxContactsPerPage, 100, true);
    }

    /**
     * max number of contacts per page, Web client (not server) verifies that
     * zimbraPrefContactsPerPage should not exceed this attribute.
     *
     * @param zimbraMaxContactsPerPage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1012)
    public void setMaxContactsPerPage(int zimbraMaxContactsPerPage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxContactsPerPage, Integer.toString(zimbraMaxContactsPerPage));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of contacts per page, Web client (not server) verifies that
     * zimbraPrefContactsPerPage should not exceed this attribute.
     *
     * @param zimbraMaxContactsPerPage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1012)
    public Map<String,Object> setMaxContactsPerPage(int zimbraMaxContactsPerPage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxContactsPerPage, Integer.toString(zimbraMaxContactsPerPage));
        return attrs;
    }

    /**
     * max number of contacts per page, Web client (not server) verifies that
     * zimbraPrefContactsPerPage should not exceed this attribute.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1012)
    public void unsetMaxContactsPerPage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxContactsPerPage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of contacts per page, Web client (not server) verifies that
     * zimbraPrefContactsPerPage should not exceed this attribute.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1012)
    public Map<String,Object> unsetMaxContactsPerPage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxContactsPerPage, "");
        return attrs;
    }

    /**
     * max number of messages/conversations per page, Web client (not server)
     * verifies that zimbraPrefMailItemsPerPage should not exceed this
     * attribute.
     *
     * @return zimbraMaxMailItemsPerPage, or 100 if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1011)
    public int getMaxMailItemsPerPage() {
        return getIntAttr(Provisioning.A_zimbraMaxMailItemsPerPage, 100, true);
    }

    /**
     * max number of messages/conversations per page, Web client (not server)
     * verifies that zimbraPrefMailItemsPerPage should not exceed this
     * attribute.
     *
     * @param zimbraMaxMailItemsPerPage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1011)
    public void setMaxMailItemsPerPage(int zimbraMaxMailItemsPerPage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxMailItemsPerPage, Integer.toString(zimbraMaxMailItemsPerPage));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of messages/conversations per page, Web client (not server)
     * verifies that zimbraPrefMailItemsPerPage should not exceed this
     * attribute.
     *
     * @param zimbraMaxMailItemsPerPage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1011)
    public Map<String,Object> setMaxMailItemsPerPage(int zimbraMaxMailItemsPerPage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxMailItemsPerPage, Integer.toString(zimbraMaxMailItemsPerPage));
        return attrs;
    }

    /**
     * max number of messages/conversations per page, Web client (not server)
     * verifies that zimbraPrefMailItemsPerPage should not exceed this
     * attribute.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1011)
    public void unsetMaxMailItemsPerPage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxMailItemsPerPage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of messages/conversations per page, Web client (not server)
     * verifies that zimbraPrefMailItemsPerPage should not exceed this
     * attribute.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1011)
    public Map<String,Object> unsetMaxMailItemsPerPage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxMailItemsPerPage, "");
        return attrs;
    }

    /**
     * max number of voice items per page, Web client (not server) verifies
     * that zimbraPrefVoiceItemsPerPage should not exceed this attribute.
     *
     * @return zimbraMaxVoiceItemsPerPage, or 100 if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1013)
    public int getMaxVoiceItemsPerPage() {
        return getIntAttr(Provisioning.A_zimbraMaxVoiceItemsPerPage, 100, true);
    }

    /**
     * max number of voice items per page, Web client (not server) verifies
     * that zimbraPrefVoiceItemsPerPage should not exceed this attribute.
     *
     * @param zimbraMaxVoiceItemsPerPage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1013)
    public void setMaxVoiceItemsPerPage(int zimbraMaxVoiceItemsPerPage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxVoiceItemsPerPage, Integer.toString(zimbraMaxVoiceItemsPerPage));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of voice items per page, Web client (not server) verifies
     * that zimbraPrefVoiceItemsPerPage should not exceed this attribute.
     *
     * @param zimbraMaxVoiceItemsPerPage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1013)
    public Map<String,Object> setMaxVoiceItemsPerPage(int zimbraMaxVoiceItemsPerPage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxVoiceItemsPerPage, Integer.toString(zimbraMaxVoiceItemsPerPage));
        return attrs;
    }

    /**
     * max number of voice items per page, Web client (not server) verifies
     * that zimbraPrefVoiceItemsPerPage should not exceed this attribute.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1013)
    public void unsetMaxVoiceItemsPerPage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxVoiceItemsPerPage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max number of voice items per page, Web client (not server) verifies
     * that zimbraPrefVoiceItemsPerPage should not exceed this attribute.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1013)
    public Map<String,Object> unsetMaxVoiceItemsPerPage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMaxVoiceItemsPerPage, "");
        return attrs;
    }

    /**
     * dynamic group membership
     *
     * @return zimbraMemberOf, or empty array if unset
     */
    @ZAttr(id=11)
    public String[] getMemberOf() {
        return getMultiAttr(Provisioning.A_zimbraMemberOf, true, true);
    }

    /**
     * dynamic group membership
     *
     * @param zimbraMemberOf new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=11)
    public void setMemberOf(String[] zimbraMemberOf) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemberOf, zimbraMemberOf);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * dynamic group membership
     *
     * @param zimbraMemberOf new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=11)
    public Map<String,Object> setMemberOf(String[] zimbraMemberOf, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemberOf, zimbraMemberOf);
        return attrs;
    }

    /**
     * dynamic group membership
     *
     * @param zimbraMemberOf new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=11)
    public void addMemberOf(String zimbraMemberOf) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMemberOf, zimbraMemberOf);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * dynamic group membership
     *
     * @param zimbraMemberOf new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=11)
    public Map<String,Object> addMemberOf(String zimbraMemberOf, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMemberOf, zimbraMemberOf);
        return attrs;
    }

    /**
     * dynamic group membership
     *
     * @param zimbraMemberOf existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=11)
    public void removeMemberOf(String zimbraMemberOf) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMemberOf, zimbraMemberOf);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * dynamic group membership
     *
     * @param zimbraMemberOf existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=11)
    public Map<String,Object> removeMemberOf(String zimbraMemberOf, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMemberOf, zimbraMemberOf);
        return attrs;
    }

    /**
     * dynamic group membership
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=11)
    public void unsetMemberOf() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemberOf, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * dynamic group membership
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=11)
    public Map<String,Object> unsetMemberOf(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemberOf, "");
        return attrs;
    }

    /**
     * whether mobile sync should zip the skipped item and attach it to the
     * notification mail
     *
     * @return zimbraMobileAttachSkippedItemEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1423)
    public boolean isMobileAttachSkippedItemEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileAttachSkippedItemEnabled, false, true);
    }

    /**
     * whether mobile sync should zip the skipped item and attach it to the
     * notification mail
     *
     * @param zimbraMobileAttachSkippedItemEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1423)
    public void setMobileAttachSkippedItemEnabled(boolean zimbraMobileAttachSkippedItemEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileAttachSkippedItemEnabled, zimbraMobileAttachSkippedItemEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mobile sync should zip the skipped item and attach it to the
     * notification mail
     *
     * @param zimbraMobileAttachSkippedItemEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1423)
    public Map<String,Object> setMobileAttachSkippedItemEnabled(boolean zimbraMobileAttachSkippedItemEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileAttachSkippedItemEnabled, zimbraMobileAttachSkippedItemEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether mobile sync should zip the skipped item and attach it to the
     * notification mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1423)
    public void unsetMobileAttachSkippedItemEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileAttachSkippedItemEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mobile sync should zip the skipped item and attach it to the
     * notification mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1423)
    public Map<String,Object> unsetMobileAttachSkippedItemEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileAttachSkippedItemEnabled, "");
        return attrs;
    }

    /**
     * Whether to force devices using Active Sync 2.5
     *
     * @return zimbraMobileForceProtocol25, or false if unset
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1573)
    public boolean isMobileForceProtocol25() {
        return getBooleanAttr(Provisioning.A_zimbraMobileForceProtocol25, false, true);
    }

    /**
     * Whether to force devices using Active Sync 2.5
     *
     * @param zimbraMobileForceProtocol25 new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1573)
    public void setMobileForceProtocol25(boolean zimbraMobileForceProtocol25) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileForceProtocol25, zimbraMobileForceProtocol25 ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to force devices using Active Sync 2.5
     *
     * @param zimbraMobileForceProtocol25 new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1573)
    public Map<String,Object> setMobileForceProtocol25(boolean zimbraMobileForceProtocol25, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileForceProtocol25, zimbraMobileForceProtocol25 ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to force devices using Active Sync 2.5
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1573)
    public void unsetMobileForceProtocol25() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileForceProtocol25, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to force devices using Active Sync 2.5
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1573)
    public Map<String,Object> unsetMobileForceProtocol25(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileForceProtocol25, "");
        return attrs;
    }

    /**
     * Whether to force Samsung devices using Active Sync 2.5
     *
     * @return zimbraMobileForceSamsungProtocol25, or false if unset
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1572)
    public boolean isMobileForceSamsungProtocol25() {
        return getBooleanAttr(Provisioning.A_zimbraMobileForceSamsungProtocol25, false, true);
    }

    /**
     * Whether to force Samsung devices using Active Sync 2.5
     *
     * @param zimbraMobileForceSamsungProtocol25 new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1572)
    public void setMobileForceSamsungProtocol25(boolean zimbraMobileForceSamsungProtocol25) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileForceSamsungProtocol25, zimbraMobileForceSamsungProtocol25 ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to force Samsung devices using Active Sync 2.5
     *
     * @param zimbraMobileForceSamsungProtocol25 new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1572)
    public Map<String,Object> setMobileForceSamsungProtocol25(boolean zimbraMobileForceSamsungProtocol25, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileForceSamsungProtocol25, zimbraMobileForceSamsungProtocol25 ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to force Samsung devices using Active Sync 2.5
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1572)
    public void unsetMobileForceSamsungProtocol25() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileForceSamsungProtocol25, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to force Samsung devices using Active Sync 2.5
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.7
     */
    @ZAttr(id=1572)
    public Map<String,Object> unsetMobileForceSamsungProtocol25(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileForceSamsungProtocol25, "");
        return attrs;
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @return zimbraMobileItemsToTrackPerFolderMaxSize, or empty array if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public String[] getMobileItemsToTrackPerFolderMaxSize() {
        return getMultiAttr(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, true, true);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public void setMobileItemsToTrackPerFolderMaxSize(String[] zimbraMobileItemsToTrackPerFolderMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public Map<String,Object> setMobileItemsToTrackPerFolderMaxSize(String[] zimbraMobileItemsToTrackPerFolderMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        return attrs;
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public void addMobileItemsToTrackPerFolderMaxSize(String zimbraMobileItemsToTrackPerFolderMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public Map<String,Object> addMobileItemsToTrackPerFolderMaxSize(String zimbraMobileItemsToTrackPerFolderMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        return attrs;
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public void removeMobileItemsToTrackPerFolderMaxSize(String zimbraMobileItemsToTrackPerFolderMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public Map<String,Object> removeMobileItemsToTrackPerFolderMaxSize(String zimbraMobileItemsToTrackPerFolderMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        return attrs;
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public void unsetMobileItemsToTrackPerFolderMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public Map<String,Object> unsetMobileItemsToTrackPerFolderMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, "");
        return attrs;
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @return zimbraMobileMetadataMaxSizeEnabled, or false if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public boolean isMobileMetadataMaxSizeEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, false, true);
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @param zimbraMobileMetadataMaxSizeEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public void setMobileMetadataMaxSizeEnabled(boolean zimbraMobileMetadataMaxSizeEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, zimbraMobileMetadataMaxSizeEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @param zimbraMobileMetadataMaxSizeEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public Map<String,Object> setMobileMetadataMaxSizeEnabled(boolean zimbraMobileMetadataMaxSizeEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, zimbraMobileMetadataMaxSizeEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public void unsetMobileMetadataMaxSizeEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public Map<String,Object> unsetMobileMetadataMaxSizeEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, "");
        return attrs;
    }

    /**
     * admin email address used for receiving notifications
     *
     * @return zimbraMobileNotificationAdminAddress, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1422)
    public String getMobileNotificationAdminAddress() {
        return getAttr(Provisioning.A_zimbraMobileNotificationAdminAddress, null, true);
    }

    /**
     * admin email address used for receiving notifications
     *
     * @param zimbraMobileNotificationAdminAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1422)
    public void setMobileNotificationAdminAddress(String zimbraMobileNotificationAdminAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileNotificationAdminAddress, zimbraMobileNotificationAdminAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin email address used for receiving notifications
     *
     * @param zimbraMobileNotificationAdminAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1422)
    public Map<String,Object> setMobileNotificationAdminAddress(String zimbraMobileNotificationAdminAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileNotificationAdminAddress, zimbraMobileNotificationAdminAddress);
        return attrs;
    }

    /**
     * admin email address used for receiving notifications
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1422)
    public void unsetMobileNotificationAdminAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileNotificationAdminAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin email address used for receiving notifications
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1422)
    public Map<String,Object> unsetMobileNotificationAdminAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileNotificationAdminAddress, "");
        return attrs;
    }

    /**
     * whether mobile sync notification enabled or not
     *
     * @return zimbraMobileNotificationEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1421)
    public boolean isMobileNotificationEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileNotificationEnabled, false, true);
    }

    /**
     * whether mobile sync notification enabled or not
     *
     * @param zimbraMobileNotificationEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1421)
    public void setMobileNotificationEnabled(boolean zimbraMobileNotificationEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileNotificationEnabled, zimbraMobileNotificationEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mobile sync notification enabled or not
     *
     * @param zimbraMobileNotificationEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1421)
    public Map<String,Object> setMobileNotificationEnabled(boolean zimbraMobileNotificationEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileNotificationEnabled, zimbraMobileNotificationEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether mobile sync notification enabled or not
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1421)
    public void unsetMobileNotificationEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileNotificationEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mobile sync notification enabled or not
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1421)
    public Map<String,Object> unsetMobileNotificationEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileNotificationEnabled, "");
        return attrs;
    }

    /**
     * Whether to permit Outlook to sync via Active Sync
     *
     * @return zimbraMobileOutlookSyncEnabled, or true if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1453)
    public boolean isMobileOutlookSyncEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileOutlookSyncEnabled, true, true);
    }

    /**
     * Whether to permit Outlook to sync via Active Sync
     *
     * @param zimbraMobileOutlookSyncEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1453)
    public void setMobileOutlookSyncEnabled(boolean zimbraMobileOutlookSyncEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileOutlookSyncEnabled, zimbraMobileOutlookSyncEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to permit Outlook to sync via Active Sync
     *
     * @param zimbraMobileOutlookSyncEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1453)
    public Map<String,Object> setMobileOutlookSyncEnabled(boolean zimbraMobileOutlookSyncEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileOutlookSyncEnabled, zimbraMobileOutlookSyncEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to permit Outlook to sync via Active Sync
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1453)
    public void unsetMobileOutlookSyncEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileOutlookSyncEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to permit Outlook to sync via Active Sync
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1453)
    public Map<String,Object> unsetMobileOutlookSyncEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileOutlookSyncEnabled, "");
        return attrs;
    }

    /**
     * whether the Bluetooth capabilities are allowed on the device. The
     * available options are Disable, HandsfreeOnly, and Allow. 0 - DISABLE 1
     * - HANDSFREE 2 - ALLOW ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBluetooth value is set to -1
     *
     * @return zimbraMobilePolicyAllowBluetooth, or 2 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1285)
    public int getMobilePolicyAllowBluetooth() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowBluetooth, 2, true);
    }

    /**
     * whether the Bluetooth capabilities are allowed on the device. The
     * available options are Disable, HandsfreeOnly, and Allow. 0 - DISABLE 1
     * - HANDSFREE 2 - ALLOW ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBluetooth value is set to -1
     *
     * @param zimbraMobilePolicyAllowBluetooth new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1285)
    public void setMobilePolicyAllowBluetooth(int zimbraMobilePolicyAllowBluetooth) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowBluetooth, Integer.toString(zimbraMobilePolicyAllowBluetooth));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the Bluetooth capabilities are allowed on the device. The
     * available options are Disable, HandsfreeOnly, and Allow. 0 - DISABLE 1
     * - HANDSFREE 2 - ALLOW ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBluetooth value is set to -1
     *
     * @param zimbraMobilePolicyAllowBluetooth new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1285)
    public Map<String,Object> setMobilePolicyAllowBluetooth(int zimbraMobilePolicyAllowBluetooth, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowBluetooth, Integer.toString(zimbraMobilePolicyAllowBluetooth));
        return attrs;
    }

    /**
     * whether the Bluetooth capabilities are allowed on the device. The
     * available options are Disable, HandsfreeOnly, and Allow. 0 - DISABLE 1
     * - HANDSFREE 2 - ALLOW ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBluetooth value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1285)
    public void unsetMobilePolicyAllowBluetooth() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowBluetooth, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the Bluetooth capabilities are allowed on the device. The
     * available options are Disable, HandsfreeOnly, and Allow. 0 - DISABLE 1
     * - HANDSFREE 2 - ALLOW ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBluetooth value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1285)
    public Map<String,Object> unsetMobilePolicyAllowBluetooth(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowBluetooth, "");
        return attrs;
    }

    /**
     * whether Microsoft Pocket Internet Explorer is allowed on the mobile
     * phone. This parameter doesn&#039;t affect third-party browsers.
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBrowser value is set to -1
     *
     * @return zimbraMobilePolicyAllowBrowser, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1300)
    public int getMobilePolicyAllowBrowser() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowBrowser, 1, true);
    }

    /**
     * whether Microsoft Pocket Internet Explorer is allowed on the mobile
     * phone. This parameter doesn&#039;t affect third-party browsers.
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBrowser value is set to -1
     *
     * @param zimbraMobilePolicyAllowBrowser new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1300)
    public void setMobilePolicyAllowBrowser(int zimbraMobilePolicyAllowBrowser) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowBrowser, Integer.toString(zimbraMobilePolicyAllowBrowser));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether Microsoft Pocket Internet Explorer is allowed on the mobile
     * phone. This parameter doesn&#039;t affect third-party browsers.
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBrowser value is set to -1
     *
     * @param zimbraMobilePolicyAllowBrowser new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1300)
    public Map<String,Object> setMobilePolicyAllowBrowser(int zimbraMobilePolicyAllowBrowser, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowBrowser, Integer.toString(zimbraMobilePolicyAllowBrowser));
        return attrs;
    }

    /**
     * whether Microsoft Pocket Internet Explorer is allowed on the mobile
     * phone. This parameter doesn&#039;t affect third-party browsers.
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBrowser value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1300)
    public void unsetMobilePolicyAllowBrowser() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowBrowser, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether Microsoft Pocket Internet Explorer is allowed on the mobile
     * phone. This parameter doesn&#039;t affect third-party browsers.
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowBrowser value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1300)
    public Map<String,Object> unsetMobilePolicyAllowBrowser(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowBrowser, "");
        return attrs;
    }

    /**
     * whether to allow camera on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowCamera value is set to -1
     *
     * @return zimbraMobilePolicyAllowCamera, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1278)
    public int getMobilePolicyAllowCamera() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowCamera, 1, true);
    }

    /**
     * whether to allow camera on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowCamera value is set to -1
     *
     * @param zimbraMobilePolicyAllowCamera new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1278)
    public void setMobilePolicyAllowCamera(int zimbraMobilePolicyAllowCamera) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowCamera, Integer.toString(zimbraMobilePolicyAllowCamera));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow camera on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowCamera value is set to -1
     *
     * @param zimbraMobilePolicyAllowCamera new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1278)
    public Map<String,Object> setMobilePolicyAllowCamera(int zimbraMobilePolicyAllowCamera, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowCamera, Integer.toString(zimbraMobilePolicyAllowCamera));
        return attrs;
    }

    /**
     * whether to allow camera on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowCamera value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1278)
    public void unsetMobilePolicyAllowCamera() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowCamera, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow camera on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowCamera value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1278)
    public Map<String,Object> unsetMobilePolicyAllowCamera(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowCamera, "");
        return attrs;
    }

    /**
     * whether the device user can configure a personal e-mail account on the
     * mobile phone. This parameter doesn&#039;t control access to e-mails
     * using third-party mobile phone e-mail programs. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowConsumerEmail value is set to -1
     *
     * @return zimbraMobilePolicyAllowConsumerEmail, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1301)
    public int getMobilePolicyAllowConsumerEmail() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowConsumerEmail, 1, true);
    }

    /**
     * whether the device user can configure a personal e-mail account on the
     * mobile phone. This parameter doesn&#039;t control access to e-mails
     * using third-party mobile phone e-mail programs. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowConsumerEmail value is set to -1
     *
     * @param zimbraMobilePolicyAllowConsumerEmail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1301)
    public void setMobilePolicyAllowConsumerEmail(int zimbraMobilePolicyAllowConsumerEmail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowConsumerEmail, Integer.toString(zimbraMobilePolicyAllowConsumerEmail));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the device user can configure a personal e-mail account on the
     * mobile phone. This parameter doesn&#039;t control access to e-mails
     * using third-party mobile phone e-mail programs. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowConsumerEmail value is set to -1
     *
     * @param zimbraMobilePolicyAllowConsumerEmail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1301)
    public Map<String,Object> setMobilePolicyAllowConsumerEmail(int zimbraMobilePolicyAllowConsumerEmail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowConsumerEmail, Integer.toString(zimbraMobilePolicyAllowConsumerEmail));
        return attrs;
    }

    /**
     * whether the device user can configure a personal e-mail account on the
     * mobile phone. This parameter doesn&#039;t control access to e-mails
     * using third-party mobile phone e-mail programs. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowConsumerEmail value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1301)
    public void unsetMobilePolicyAllowConsumerEmail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowConsumerEmail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the device user can configure a personal e-mail account on the
     * mobile phone. This parameter doesn&#039;t control access to e-mails
     * using third-party mobile phone e-mail programs. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowConsumerEmail value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1301)
    public Map<String,Object> unsetMobilePolicyAllowConsumerEmail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowConsumerEmail, "");
        return attrs;
    }

    /**
     * whether the device can synchronize with a desktop computer through a
     * cable; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowDesktopSync value is set to -1
     *
     * @return zimbraMobilePolicyAllowDesktopSync, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1288)
    public int getMobilePolicyAllowDesktopSync() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowDesktopSync, 1, true);
    }

    /**
     * whether the device can synchronize with a desktop computer through a
     * cable; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowDesktopSync value is set to -1
     *
     * @param zimbraMobilePolicyAllowDesktopSync new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1288)
    public void setMobilePolicyAllowDesktopSync(int zimbraMobilePolicyAllowDesktopSync) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowDesktopSync, Integer.toString(zimbraMobilePolicyAllowDesktopSync));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the device can synchronize with a desktop computer through a
     * cable; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowDesktopSync value is set to -1
     *
     * @param zimbraMobilePolicyAllowDesktopSync new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1288)
    public Map<String,Object> setMobilePolicyAllowDesktopSync(int zimbraMobilePolicyAllowDesktopSync, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowDesktopSync, Integer.toString(zimbraMobilePolicyAllowDesktopSync));
        return attrs;
    }

    /**
     * whether the device can synchronize with a desktop computer through a
     * cable; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowDesktopSync value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1288)
    public void unsetMobilePolicyAllowDesktopSync() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowDesktopSync, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the device can synchronize with a desktop computer through a
     * cable; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowDesktopSync value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1288)
    public Map<String,Object> unsetMobilePolicyAllowDesktopSync(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowDesktopSync, "");
        return attrs;
    }

    /**
     * whether HTML e-mail is enabled on the device. If set to 0, all e-mail
     * will be converted to plain text before synchronization occurs. ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowHTMLEmail value is set to -1
     *
     * @return zimbraMobilePolicyAllowHTMLEmail, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1290)
    public int getMobilePolicyAllowHTMLEmail() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowHTMLEmail, 1, true);
    }

    /**
     * whether HTML e-mail is enabled on the device. If set to 0, all e-mail
     * will be converted to plain text before synchronization occurs. ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowHTMLEmail value is set to -1
     *
     * @param zimbraMobilePolicyAllowHTMLEmail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1290)
    public void setMobilePolicyAllowHTMLEmail(int zimbraMobilePolicyAllowHTMLEmail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowHTMLEmail, Integer.toString(zimbraMobilePolicyAllowHTMLEmail));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether HTML e-mail is enabled on the device. If set to 0, all e-mail
     * will be converted to plain text before synchronization occurs. ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowHTMLEmail value is set to -1
     *
     * @param zimbraMobilePolicyAllowHTMLEmail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1290)
    public Map<String,Object> setMobilePolicyAllowHTMLEmail(int zimbraMobilePolicyAllowHTMLEmail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowHTMLEmail, Integer.toString(zimbraMobilePolicyAllowHTMLEmail));
        return attrs;
    }

    /**
     * whether HTML e-mail is enabled on the device. If set to 0, all e-mail
     * will be converted to plain text before synchronization occurs. ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowHTMLEmail value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1290)
    public void unsetMobilePolicyAllowHTMLEmail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowHTMLEmail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether HTML e-mail is enabled on the device. If set to 0, all e-mail
     * will be converted to plain text before synchronization occurs. ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowHTMLEmail value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1290)
    public Map<String,Object> unsetMobilePolicyAllowHTMLEmail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowHTMLEmail, "");
        return attrs;
    }

    /**
     * whether the mobile device can be used as a modem to connect a computer
     * to the Internet; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowInternetSharing value is set to -1
     *
     * @return zimbraMobilePolicyAllowInternetSharing, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1303)
    public int getMobilePolicyAllowInternetSharing() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowInternetSharing, 1, true);
    }

    /**
     * whether the mobile device can be used as a modem to connect a computer
     * to the Internet; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowInternetSharing value is set to -1
     *
     * @param zimbraMobilePolicyAllowInternetSharing new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1303)
    public void setMobilePolicyAllowInternetSharing(int zimbraMobilePolicyAllowInternetSharing) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowInternetSharing, Integer.toString(zimbraMobilePolicyAllowInternetSharing));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the mobile device can be used as a modem to connect a computer
     * to the Internet; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowInternetSharing value is set to -1
     *
     * @param zimbraMobilePolicyAllowInternetSharing new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1303)
    public Map<String,Object> setMobilePolicyAllowInternetSharing(int zimbraMobilePolicyAllowInternetSharing, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowInternetSharing, Integer.toString(zimbraMobilePolicyAllowInternetSharing));
        return attrs;
    }

    /**
     * whether the mobile device can be used as a modem to connect a computer
     * to the Internet; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowInternetSharing value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1303)
    public void unsetMobilePolicyAllowInternetSharing() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowInternetSharing, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the mobile device can be used as a modem to connect a computer
     * to the Internet; ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowInternetSharing value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1303)
    public Map<String,Object> unsetMobilePolicyAllowInternetSharing(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowInternetSharing, "");
        return attrs;
    }

    /**
     * whether infrared connections are allowed to the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowIrDA
     * value is set to -1
     *
     * @return zimbraMobilePolicyAllowIrDA, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1286)
    public int getMobilePolicyAllowIrDA() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowIrDA, 1, true);
    }

    /**
     * whether infrared connections are allowed to the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowIrDA
     * value is set to -1
     *
     * @param zimbraMobilePolicyAllowIrDA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1286)
    public void setMobilePolicyAllowIrDA(int zimbraMobilePolicyAllowIrDA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowIrDA, Integer.toString(zimbraMobilePolicyAllowIrDA));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether infrared connections are allowed to the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowIrDA
     * value is set to -1
     *
     * @param zimbraMobilePolicyAllowIrDA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1286)
    public Map<String,Object> setMobilePolicyAllowIrDA(int zimbraMobilePolicyAllowIrDA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowIrDA, Integer.toString(zimbraMobilePolicyAllowIrDA));
        return attrs;
    }

    /**
     * whether infrared connections are allowed to the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowIrDA
     * value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1286)
    public void unsetMobilePolicyAllowIrDA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowIrDA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether infrared connections are allowed to the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowIrDA
     * value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1286)
    public Map<String,Object> unsetMobilePolicyAllowIrDA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowIrDA, "");
        return attrs;
    }

    /**
     * whether to allow non-provisionable devices; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyAllowNonProvisionableDevices, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=834)
    public boolean isMobilePolicyAllowNonProvisionableDevices() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicyAllowNonProvisionableDevices, true, true);
    }

    /**
     * whether to allow non-provisionable devices; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyAllowNonProvisionableDevices new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=834)
    public void setMobilePolicyAllowNonProvisionableDevices(boolean zimbraMobilePolicyAllowNonProvisionableDevices) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowNonProvisionableDevices, zimbraMobilePolicyAllowNonProvisionableDevices ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow non-provisionable devices; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyAllowNonProvisionableDevices new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=834)
    public Map<String,Object> setMobilePolicyAllowNonProvisionableDevices(boolean zimbraMobilePolicyAllowNonProvisionableDevices, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowNonProvisionableDevices, zimbraMobilePolicyAllowNonProvisionableDevices ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow non-provisionable devices; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=834)
    public void unsetMobilePolicyAllowNonProvisionableDevices() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowNonProvisionableDevices, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow non-provisionable devices; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=834)
    public Map<String,Object> unsetMobilePolicyAllowNonProvisionableDevices(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowNonProvisionableDevices, "");
        return attrs;
    }

    /**
     * whether the user can configure a POP3 or IMAP4 e-mail account on the
     * device. This parameter doesn&#039;t control access by third-party
     * e-mail programs. ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowPOPIMAPEmail value is set to -1
     *
     * @return zimbraMobilePolicyAllowPOPIMAPEmail, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1284)
    public int getMobilePolicyAllowPOPIMAPEmail() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowPOPIMAPEmail, 1, true);
    }

    /**
     * whether the user can configure a POP3 or IMAP4 e-mail account on the
     * device. This parameter doesn&#039;t control access by third-party
     * e-mail programs. ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowPOPIMAPEmail value is set to -1
     *
     * @param zimbraMobilePolicyAllowPOPIMAPEmail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1284)
    public void setMobilePolicyAllowPOPIMAPEmail(int zimbraMobilePolicyAllowPOPIMAPEmail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowPOPIMAPEmail, Integer.toString(zimbraMobilePolicyAllowPOPIMAPEmail));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the user can configure a POP3 or IMAP4 e-mail account on the
     * device. This parameter doesn&#039;t control access by third-party
     * e-mail programs. ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowPOPIMAPEmail value is set to -1
     *
     * @param zimbraMobilePolicyAllowPOPIMAPEmail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1284)
    public Map<String,Object> setMobilePolicyAllowPOPIMAPEmail(int zimbraMobilePolicyAllowPOPIMAPEmail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowPOPIMAPEmail, Integer.toString(zimbraMobilePolicyAllowPOPIMAPEmail));
        return attrs;
    }

    /**
     * whether the user can configure a POP3 or IMAP4 e-mail account on the
     * device. This parameter doesn&#039;t control access by third-party
     * e-mail programs. ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowPOPIMAPEmail value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1284)
    public void unsetMobilePolicyAllowPOPIMAPEmail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowPOPIMAPEmail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the user can configure a POP3 or IMAP4 e-mail account on the
     * device. This parameter doesn&#039;t control access by third-party
     * e-mail programs. ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowPOPIMAPEmail value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1284)
    public Map<String,Object> unsetMobilePolicyAllowPOPIMAPEmail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowPOPIMAPEmail, "");
        return attrs;
    }

    /**
     * whether to allow partial policy enforcement on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyAllowPartialProvisioning, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=835)
    public boolean isMobilePolicyAllowPartialProvisioning() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicyAllowPartialProvisioning, true, true);
    }

    /**
     * whether to allow partial policy enforcement on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyAllowPartialProvisioning new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=835)
    public void setMobilePolicyAllowPartialProvisioning(boolean zimbraMobilePolicyAllowPartialProvisioning) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowPartialProvisioning, zimbraMobilePolicyAllowPartialProvisioning ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow partial policy enforcement on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyAllowPartialProvisioning new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=835)
    public Map<String,Object> setMobilePolicyAllowPartialProvisioning(boolean zimbraMobilePolicyAllowPartialProvisioning, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowPartialProvisioning, zimbraMobilePolicyAllowPartialProvisioning ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow partial policy enforcement on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=835)
    public void unsetMobilePolicyAllowPartialProvisioning() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowPartialProvisioning, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow partial policy enforcement on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=835)
    public Map<String,Object> unsetMobilePolicyAllowPartialProvisioning(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowPartialProvisioning, "");
        return attrs;
    }

    /**
     * whether the mobile device can initiate a remote desktop connection;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowRemoteDesktop value is set to -1
     *
     * @return zimbraMobilePolicyAllowRemoteDesktop, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1302)
    public int getMobilePolicyAllowRemoteDesktop() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowRemoteDesktop, 1, true);
    }

    /**
     * whether the mobile device can initiate a remote desktop connection;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowRemoteDesktop value is set to -1
     *
     * @param zimbraMobilePolicyAllowRemoteDesktop new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1302)
    public void setMobilePolicyAllowRemoteDesktop(int zimbraMobilePolicyAllowRemoteDesktop) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowRemoteDesktop, Integer.toString(zimbraMobilePolicyAllowRemoteDesktop));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the mobile device can initiate a remote desktop connection;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowRemoteDesktop value is set to -1
     *
     * @param zimbraMobilePolicyAllowRemoteDesktop new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1302)
    public Map<String,Object> setMobilePolicyAllowRemoteDesktop(int zimbraMobilePolicyAllowRemoteDesktop, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowRemoteDesktop, Integer.toString(zimbraMobilePolicyAllowRemoteDesktop));
        return attrs;
    }

    /**
     * whether the mobile device can initiate a remote desktop connection;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowRemoteDesktop value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1302)
    public void unsetMobilePolicyAllowRemoteDesktop() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowRemoteDesktop, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the mobile device can initiate a remote desktop connection;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowRemoteDesktop value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1302)
    public Map<String,Object> unsetMobilePolicyAllowRemoteDesktop(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowRemoteDesktop, "");
        return attrs;
    }

    /**
     * whether the messaging application on the device can negotiate the
     * encryption algorithm if a recipient&#039;s certificate doesn&#039;t
     * support the specified encryption algorithm; 0 - BlockNegotiation 1 -
     * OnlyStrongAlgorithmNegotiation 2 - AllowAnyAlgorithmNegotiation
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation value is
     * set to -1
     *
     * @return zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation, or 2 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1298)
    public int getMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation, 2, true);
    }

    /**
     * whether the messaging application on the device can negotiate the
     * encryption algorithm if a recipient&#039;s certificate doesn&#039;t
     * support the specified encryption algorithm; 0 - BlockNegotiation 1 -
     * OnlyStrongAlgorithmNegotiation 2 - AllowAnyAlgorithmNegotiation
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation value is
     * set to -1
     *
     * @param zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1298)
    public void setMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation(int zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation, Integer.toString(zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the messaging application on the device can negotiate the
     * encryption algorithm if a recipient&#039;s certificate doesn&#039;t
     * support the specified encryption algorithm; 0 - BlockNegotiation 1 -
     * OnlyStrongAlgorithmNegotiation 2 - AllowAnyAlgorithmNegotiation
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation value is
     * set to -1
     *
     * @param zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1298)
    public Map<String,Object> setMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation(int zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation, Integer.toString(zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation));
        return attrs;
    }

    /**
     * whether the messaging application on the device can negotiate the
     * encryption algorithm if a recipient&#039;s certificate doesn&#039;t
     * support the specified encryption algorithm; 0 - BlockNegotiation 1 -
     * OnlyStrongAlgorithmNegotiation 2 - AllowAnyAlgorithmNegotiation
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation value is
     * set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1298)
    public void unsetMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the messaging application on the device can negotiate the
     * encryption algorithm if a recipient&#039;s certificate doesn&#039;t
     * support the specified encryption algorithm; 0 - BlockNegotiation 1 -
     * OnlyStrongAlgorithmNegotiation 2 - AllowAnyAlgorithmNegotiation
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation value is
     * set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1298)
    public Map<String,Object> unsetMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSMIMEEncryptionAlgorithmNegotiation, "");
        return attrs;
    }

    /**
     * whether S/MIME software certificates are allowed; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMESoftCerts value is set to -1
     *
     * @return zimbraMobilePolicyAllowSMIMESoftCerts, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1299)
    public int getMobilePolicyAllowSMIMESoftCerts() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowSMIMESoftCerts, 1, true);
    }

    /**
     * whether S/MIME software certificates are allowed; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMESoftCerts value is set to -1
     *
     * @param zimbraMobilePolicyAllowSMIMESoftCerts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1299)
    public void setMobilePolicyAllowSMIMESoftCerts(int zimbraMobilePolicyAllowSMIMESoftCerts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSMIMESoftCerts, Integer.toString(zimbraMobilePolicyAllowSMIMESoftCerts));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether S/MIME software certificates are allowed; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMESoftCerts value is set to -1
     *
     * @param zimbraMobilePolicyAllowSMIMESoftCerts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1299)
    public Map<String,Object> setMobilePolicyAllowSMIMESoftCerts(int zimbraMobilePolicyAllowSMIMESoftCerts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSMIMESoftCerts, Integer.toString(zimbraMobilePolicyAllowSMIMESoftCerts));
        return attrs;
    }

    /**
     * whether S/MIME software certificates are allowed; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMESoftCerts value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1299)
    public void unsetMobilePolicyAllowSMIMESoftCerts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSMIMESoftCerts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether S/MIME software certificates are allowed; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowSMIMESoftCerts value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1299)
    public Map<String,Object> unsetMobilePolicyAllowSMIMESoftCerts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSMIMESoftCerts, "");
        return attrs;
    }

    /**
     * whether to allow simple password; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @return zimbraMobilePolicyAllowSimpleDevicePassword, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=839)
    public boolean isMobilePolicyAllowSimpleDevicePassword() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicyAllowSimpleDevicePassword, false, true);
    }

    /**
     * whether to allow simple password; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyAllowSimpleDevicePassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=839)
    public void setMobilePolicyAllowSimpleDevicePassword(boolean zimbraMobilePolicyAllowSimpleDevicePassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSimpleDevicePassword, zimbraMobilePolicyAllowSimpleDevicePassword ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow simple password; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyAllowSimpleDevicePassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=839)
    public Map<String,Object> setMobilePolicyAllowSimpleDevicePassword(boolean zimbraMobilePolicyAllowSimpleDevicePassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSimpleDevicePassword, zimbraMobilePolicyAllowSimpleDevicePassword ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow simple password; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=839)
    public void unsetMobilePolicyAllowSimpleDevicePassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSimpleDevicePassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow simple password; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=839)
    public Map<String,Object> unsetMobilePolicyAllowSimpleDevicePassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowSimpleDevicePassword, "");
        return attrs;
    }

    /**
     * whether to allow removable storage on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowStorageCard value is set to -1
     *
     * @return zimbraMobilePolicyAllowStorageCard, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1277)
    public int getMobilePolicyAllowStorageCard() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowStorageCard, 1, true);
    }

    /**
     * whether to allow removable storage on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowStorageCard value is set to -1
     *
     * @param zimbraMobilePolicyAllowStorageCard new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1277)
    public void setMobilePolicyAllowStorageCard(int zimbraMobilePolicyAllowStorageCard) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowStorageCard, Integer.toString(zimbraMobilePolicyAllowStorageCard));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow removable storage on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowStorageCard value is set to -1
     *
     * @param zimbraMobilePolicyAllowStorageCard new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1277)
    public Map<String,Object> setMobilePolicyAllowStorageCard(int zimbraMobilePolicyAllowStorageCard, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowStorageCard, Integer.toString(zimbraMobilePolicyAllowStorageCard));
        return attrs;
    }

    /**
     * whether to allow removable storage on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowStorageCard value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1277)
    public void unsetMobilePolicyAllowStorageCard() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowStorageCard, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow removable storage on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowStorageCard value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1277)
    public Map<String,Object> unsetMobilePolicyAllowStorageCard(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowStorageCard, "");
        return attrs;
    }

    /**
     * whether text messaging is allowed from the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowTextMessaging value is set to -1
     *
     * @return zimbraMobilePolicyAllowTextMessaging, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1283)
    public int getMobilePolicyAllowTextMessaging() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowTextMessaging, 1, true);
    }

    /**
     * whether text messaging is allowed from the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowTextMessaging value is set to -1
     *
     * @param zimbraMobilePolicyAllowTextMessaging new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1283)
    public void setMobilePolicyAllowTextMessaging(int zimbraMobilePolicyAllowTextMessaging) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowTextMessaging, Integer.toString(zimbraMobilePolicyAllowTextMessaging));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether text messaging is allowed from the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowTextMessaging value is set to -1
     *
     * @param zimbraMobilePolicyAllowTextMessaging new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1283)
    public Map<String,Object> setMobilePolicyAllowTextMessaging(int zimbraMobilePolicyAllowTextMessaging, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowTextMessaging, Integer.toString(zimbraMobilePolicyAllowTextMessaging));
        return attrs;
    }

    /**
     * whether text messaging is allowed from the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowTextMessaging value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1283)
    public void unsetMobilePolicyAllowTextMessaging() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowTextMessaging, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether text messaging is allowed from the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowTextMessaging value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1283)
    public Map<String,Object> unsetMobilePolicyAllowTextMessaging(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowTextMessaging, "");
        return attrs;
    }

    /**
     * whether unsigned applications are allowed on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedApplications value is set to -1
     *
     * @return zimbraMobilePolicyAllowUnsignedApplications, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1280)
    public int getMobilePolicyAllowUnsignedApplications() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowUnsignedApplications, 1, true);
    }

    /**
     * whether unsigned applications are allowed on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedApplications value is set to -1
     *
     * @param zimbraMobilePolicyAllowUnsignedApplications new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1280)
    public void setMobilePolicyAllowUnsignedApplications(int zimbraMobilePolicyAllowUnsignedApplications) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowUnsignedApplications, Integer.toString(zimbraMobilePolicyAllowUnsignedApplications));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether unsigned applications are allowed on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedApplications value is set to -1
     *
     * @param zimbraMobilePolicyAllowUnsignedApplications new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1280)
    public Map<String,Object> setMobilePolicyAllowUnsignedApplications(int zimbraMobilePolicyAllowUnsignedApplications, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowUnsignedApplications, Integer.toString(zimbraMobilePolicyAllowUnsignedApplications));
        return attrs;
    }

    /**
     * whether unsigned applications are allowed on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedApplications value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1280)
    public void unsetMobilePolicyAllowUnsignedApplications() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowUnsignedApplications, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether unsigned applications are allowed on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedApplications value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1280)
    public Map<String,Object> unsetMobilePolicyAllowUnsignedApplications(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowUnsignedApplications, "");
        return attrs;
    }

    /**
     * whether unsigned installation packages are allowed on device; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedInstallationPackages value is set to -1
     *
     * @return zimbraMobilePolicyAllowUnsignedInstallationPackages, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1281)
    public int getMobilePolicyAllowUnsignedInstallationPackages() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowUnsignedInstallationPackages, 1, true);
    }

    /**
     * whether unsigned installation packages are allowed on device; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedInstallationPackages value is set to -1
     *
     * @param zimbraMobilePolicyAllowUnsignedInstallationPackages new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1281)
    public void setMobilePolicyAllowUnsignedInstallationPackages(int zimbraMobilePolicyAllowUnsignedInstallationPackages) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowUnsignedInstallationPackages, Integer.toString(zimbraMobilePolicyAllowUnsignedInstallationPackages));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether unsigned installation packages are allowed on device; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedInstallationPackages value is set to -1
     *
     * @param zimbraMobilePolicyAllowUnsignedInstallationPackages new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1281)
    public Map<String,Object> setMobilePolicyAllowUnsignedInstallationPackages(int zimbraMobilePolicyAllowUnsignedInstallationPackages, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowUnsignedInstallationPackages, Integer.toString(zimbraMobilePolicyAllowUnsignedInstallationPackages));
        return attrs;
    }

    /**
     * whether unsigned installation packages are allowed on device; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedInstallationPackages value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1281)
    public void unsetMobilePolicyAllowUnsignedInstallationPackages() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowUnsignedInstallationPackages, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether unsigned installation packages are allowed on device; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyAllowUnsignedInstallationPackages value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1281)
    public Map<String,Object> unsetMobilePolicyAllowUnsignedInstallationPackages(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowUnsignedInstallationPackages, "");
        return attrs;
    }

    /**
     * whether wireless Internet access is allowed on the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowWiFi
     * value is set to -1
     *
     * @return zimbraMobilePolicyAllowWiFi, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1282)
    public int getMobilePolicyAllowWiFi() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyAllowWiFi, 1, true);
    }

    /**
     * whether wireless Internet access is allowed on the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowWiFi
     * value is set to -1
     *
     * @param zimbraMobilePolicyAllowWiFi new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1282)
    public void setMobilePolicyAllowWiFi(int zimbraMobilePolicyAllowWiFi) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowWiFi, Integer.toString(zimbraMobilePolicyAllowWiFi));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether wireless Internet access is allowed on the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowWiFi
     * value is set to -1
     *
     * @param zimbraMobilePolicyAllowWiFi new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1282)
    public Map<String,Object> setMobilePolicyAllowWiFi(int zimbraMobilePolicyAllowWiFi, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowWiFi, Integer.toString(zimbraMobilePolicyAllowWiFi));
        return attrs;
    }

    /**
     * whether wireless Internet access is allowed on the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowWiFi
     * value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1282)
    public void unsetMobilePolicyAllowWiFi() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowWiFi, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether wireless Internet access is allowed on the device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or zimbraMobilePolicyAllowWiFi
     * value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1282)
    public Map<String,Object> unsetMobilePolicyAllowWiFi(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAllowWiFi, "");
        return attrs;
    }

    /**
     * whether to require alpha-numeric password as device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @return zimbraMobilePolicyAlphanumericDevicePasswordRequired, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=840)
    public boolean isMobilePolicyAlphanumericDevicePasswordRequired() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicyAlphanumericDevicePasswordRequired, false, true);
    }

    /**
     * whether to require alpha-numeric password as device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyAlphanumericDevicePasswordRequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=840)
    public void setMobilePolicyAlphanumericDevicePasswordRequired(boolean zimbraMobilePolicyAlphanumericDevicePasswordRequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAlphanumericDevicePasswordRequired, zimbraMobilePolicyAlphanumericDevicePasswordRequired ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to require alpha-numeric password as device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyAlphanumericDevicePasswordRequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=840)
    public Map<String,Object> setMobilePolicyAlphanumericDevicePasswordRequired(boolean zimbraMobilePolicyAlphanumericDevicePasswordRequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAlphanumericDevicePasswordRequired, zimbraMobilePolicyAlphanumericDevicePasswordRequired ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to require alpha-numeric password as device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=840)
    public void unsetMobilePolicyAlphanumericDevicePasswordRequired() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAlphanumericDevicePasswordRequired, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to require alpha-numeric password as device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=840)
    public Map<String,Object> unsetMobilePolicyAlphanumericDevicePasswordRequired(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyAlphanumericDevicePasswordRequired, "");
        return attrs;
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyApprovedApplication, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public String[] getMobilePolicyApprovedApplication() {
        return getMultiAttr(Provisioning.A_zimbraMobilePolicyApprovedApplication, true, true);
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyApprovedApplication new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public void setMobilePolicyApprovedApplication(String[] zimbraMobilePolicyApprovedApplication) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyApprovedApplication, zimbraMobilePolicyApprovedApplication);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyApprovedApplication new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public Map<String,Object> setMobilePolicyApprovedApplication(String[] zimbraMobilePolicyApprovedApplication, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyApprovedApplication, zimbraMobilePolicyApprovedApplication);
        return attrs;
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyApprovedApplication new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public void addMobilePolicyApprovedApplication(String zimbraMobilePolicyApprovedApplication) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobilePolicyApprovedApplication, zimbraMobilePolicyApprovedApplication);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyApprovedApplication new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public Map<String,Object> addMobilePolicyApprovedApplication(String zimbraMobilePolicyApprovedApplication, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobilePolicyApprovedApplication, zimbraMobilePolicyApprovedApplication);
        return attrs;
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyApprovedApplication existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public void removeMobilePolicyApprovedApplication(String zimbraMobilePolicyApprovedApplication) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobilePolicyApprovedApplication, zimbraMobilePolicyApprovedApplication);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyApprovedApplication existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public Map<String,Object> removeMobilePolicyApprovedApplication(String zimbraMobilePolicyApprovedApplication, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobilePolicyApprovedApplication, zimbraMobilePolicyApprovedApplication);
        return attrs;
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public void unsetMobilePolicyApprovedApplication() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyApprovedApplication, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * approved application for the mobile device the value contains a SHA1
     * hash (typically 40 characters long) for the application file (.exe,
     * .dll etc) ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1305)
    public Map<String,Object> unsetMobilePolicyApprovedApplication(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyApprovedApplication, "");
        return attrs;
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @return zimbraMobilePolicyApprovedApplicationList, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public String[] getMobilePolicyApprovedApplicationList() {
        return getMultiAttr(Provisioning.A_zimbraMobilePolicyApprovedApplicationList, true, true);
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @param zimbraMobilePolicyApprovedApplicationList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public void setMobilePolicyApprovedApplicationList(String[] zimbraMobilePolicyApprovedApplicationList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyApprovedApplicationList, zimbraMobilePolicyApprovedApplicationList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @param zimbraMobilePolicyApprovedApplicationList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public Map<String,Object> setMobilePolicyApprovedApplicationList(String[] zimbraMobilePolicyApprovedApplicationList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyApprovedApplicationList, zimbraMobilePolicyApprovedApplicationList);
        return attrs;
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @param zimbraMobilePolicyApprovedApplicationList new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public void addMobilePolicyApprovedApplicationList(String zimbraMobilePolicyApprovedApplicationList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobilePolicyApprovedApplicationList, zimbraMobilePolicyApprovedApplicationList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @param zimbraMobilePolicyApprovedApplicationList new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public Map<String,Object> addMobilePolicyApprovedApplicationList(String zimbraMobilePolicyApprovedApplicationList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobilePolicyApprovedApplicationList, zimbraMobilePolicyApprovedApplicationList);
        return attrs;
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @param zimbraMobilePolicyApprovedApplicationList existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public void removeMobilePolicyApprovedApplicationList(String zimbraMobilePolicyApprovedApplicationList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobilePolicyApprovedApplicationList, zimbraMobilePolicyApprovedApplicationList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @param zimbraMobilePolicyApprovedApplicationList existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public Map<String,Object> removeMobilePolicyApprovedApplicationList(String zimbraMobilePolicyApprovedApplicationList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobilePolicyApprovedApplicationList, zimbraMobilePolicyApprovedApplicationList);
        return attrs;
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public void unsetMobilePolicyApprovedApplicationList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyApprovedApplicationList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This is the internal attr for
     * &quot;zimbraMobilePolicyApprovedApplication&quot; which can only store
     * app hash (to keep consistent with ActiveSync specification. This
     * attr&#039;s format is &quot;app_name&quot;:&quot;app_hash&quot;, and
     * is used for showing both the app name and hash in admin console UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1411)
    public Map<String,Object> unsetMobilePolicyApprovedApplicationList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyApprovedApplicationList, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Use
     * zimbraMobilePolicyRequireStorageCardEncryption. Orig desc: require
     * data encryption on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyDeviceEncryptionEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=847)
    public boolean isMobilePolicyDeviceEncryptionEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicyDeviceEncryptionEnabled, true, true);
    }

    /**
     * Deprecated since: 8.5.0. Use
     * zimbraMobilePolicyRequireStorageCardEncryption. Orig desc: require
     * data encryption on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyDeviceEncryptionEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=847)
    public void setMobilePolicyDeviceEncryptionEnabled(boolean zimbraMobilePolicyDeviceEncryptionEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDeviceEncryptionEnabled, zimbraMobilePolicyDeviceEncryptionEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Use
     * zimbraMobilePolicyRequireStorageCardEncryption. Orig desc: require
     * data encryption on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyDeviceEncryptionEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=847)
    public Map<String,Object> setMobilePolicyDeviceEncryptionEnabled(boolean zimbraMobilePolicyDeviceEncryptionEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDeviceEncryptionEnabled, zimbraMobilePolicyDeviceEncryptionEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Use
     * zimbraMobilePolicyRequireStorageCardEncryption. Orig desc: require
     * data encryption on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=847)
    public void unsetMobilePolicyDeviceEncryptionEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDeviceEncryptionEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Use
     * zimbraMobilePolicyRequireStorageCardEncryption. Orig desc: require
     * data encryption on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=847)
    public Map<String,Object> unsetMobilePolicyDeviceEncryptionEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDeviceEncryptionEnabled, "");
        return attrs;
    }

    /**
     * whether to force pin on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyDevicePasswordEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=837)
    public boolean isMobilePolicyDevicePasswordEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicyDevicePasswordEnabled, true, true);
    }

    /**
     * whether to force pin on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyDevicePasswordEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=837)
    public void setMobilePolicyDevicePasswordEnabled(boolean zimbraMobilePolicyDevicePasswordEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordEnabled, zimbraMobilePolicyDevicePasswordEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to force pin on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyDevicePasswordEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=837)
    public Map<String,Object> setMobilePolicyDevicePasswordEnabled(boolean zimbraMobilePolicyDevicePasswordEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordEnabled, zimbraMobilePolicyDevicePasswordEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to force pin on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=837)
    public void unsetMobilePolicyDevicePasswordEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to force pin on device; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=837)
    public Map<String,Object> unsetMobilePolicyDevicePasswordEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordEnabled, "");
        return attrs;
    }

    /**
     * number of days before device pin must expire; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @return zimbraMobilePolicyDevicePasswordExpiration, or 0 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=842)
    public int getMobilePolicyDevicePasswordExpiration() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyDevicePasswordExpiration, 0, true);
    }

    /**
     * number of days before device pin must expire; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyDevicePasswordExpiration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=842)
    public void setMobilePolicyDevicePasswordExpiration(int zimbraMobilePolicyDevicePasswordExpiration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordExpiration, Integer.toString(zimbraMobilePolicyDevicePasswordExpiration));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of days before device pin must expire; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyDevicePasswordExpiration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=842)
    public Map<String,Object> setMobilePolicyDevicePasswordExpiration(int zimbraMobilePolicyDevicePasswordExpiration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordExpiration, Integer.toString(zimbraMobilePolicyDevicePasswordExpiration));
        return attrs;
    }

    /**
     * number of days before device pin must expire; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=842)
    public void unsetMobilePolicyDevicePasswordExpiration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordExpiration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of days before device pin must expire; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=842)
    public Map<String,Object> unsetMobilePolicyDevicePasswordExpiration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordExpiration, "");
        return attrs;
    }

    /**
     * number of previously used password stored in history; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordExpiration=0
     *
     * @return zimbraMobilePolicyDevicePasswordHistory, or 8 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=843)
    public int getMobilePolicyDevicePasswordHistory() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyDevicePasswordHistory, 8, true);
    }

    /**
     * number of previously used password stored in history; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordExpiration=0
     *
     * @param zimbraMobilePolicyDevicePasswordHistory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=843)
    public void setMobilePolicyDevicePasswordHistory(int zimbraMobilePolicyDevicePasswordHistory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordHistory, Integer.toString(zimbraMobilePolicyDevicePasswordHistory));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of previously used password stored in history; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordExpiration=0
     *
     * @param zimbraMobilePolicyDevicePasswordHistory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=843)
    public Map<String,Object> setMobilePolicyDevicePasswordHistory(int zimbraMobilePolicyDevicePasswordHistory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordHistory, Integer.toString(zimbraMobilePolicyDevicePasswordHistory));
        return attrs;
    }

    /**
     * number of previously used password stored in history; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordExpiration=0
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=843)
    public void unsetMobilePolicyDevicePasswordHistory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordHistory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of previously used password stored in history; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordExpiration=0
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=843)
    public Map<String,Object> unsetMobilePolicyDevicePasswordHistory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyDevicePasswordHistory, "");
        return attrs;
    }

    /**
     * the maximum range of calendar days that can be synchronized to the
     * device; 0 - PAST ALL 4 - Two Weeks 5 - One Month 6 - Three Months 7 -
     * Six Months ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyMaxCalendarAgeFilter value is set to -1, 1, 2 or, 3
     *
     * @return zimbraMobilePolicyMaxCalendarAgeFilter, or 5 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1289)
    public int getMobilePolicyMaxCalendarAgeFilter() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyMaxCalendarAgeFilter, 5, true);
    }

    /**
     * the maximum range of calendar days that can be synchronized to the
     * device; 0 - PAST ALL 4 - Two Weeks 5 - One Month 6 - Three Months 7 -
     * Six Months ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyMaxCalendarAgeFilter value is set to -1, 1, 2 or, 3
     *
     * @param zimbraMobilePolicyMaxCalendarAgeFilter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1289)
    public void setMobilePolicyMaxCalendarAgeFilter(int zimbraMobilePolicyMaxCalendarAgeFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxCalendarAgeFilter, Integer.toString(zimbraMobilePolicyMaxCalendarAgeFilter));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the maximum range of calendar days that can be synchronized to the
     * device; 0 - PAST ALL 4 - Two Weeks 5 - One Month 6 - Three Months 7 -
     * Six Months ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyMaxCalendarAgeFilter value is set to -1, 1, 2 or, 3
     *
     * @param zimbraMobilePolicyMaxCalendarAgeFilter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1289)
    public Map<String,Object> setMobilePolicyMaxCalendarAgeFilter(int zimbraMobilePolicyMaxCalendarAgeFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxCalendarAgeFilter, Integer.toString(zimbraMobilePolicyMaxCalendarAgeFilter));
        return attrs;
    }

    /**
     * the maximum range of calendar days that can be synchronized to the
     * device; 0 - PAST ALL 4 - Two Weeks 5 - One Month 6 - Three Months 7 -
     * Six Months ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyMaxCalendarAgeFilter value is set to -1, 1, 2 or, 3
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1289)
    public void unsetMobilePolicyMaxCalendarAgeFilter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxCalendarAgeFilter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the maximum range of calendar days that can be synchronized to the
     * device; 0 - PAST ALL 4 - Two Weeks 5 - One Month 6 - Three Months 7 -
     * Six Months ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyMaxCalendarAgeFilter value is set to -1, 1, 2 or, 3
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1289)
    public Map<String,Object> unsetMobilePolicyMaxCalendarAgeFilter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxCalendarAgeFilter, "");
        return attrs;
    }

    /**
     * number of consecutive incorrect pin input before device is wiped;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @return zimbraMobilePolicyMaxDevicePasswordFailedAttempts, or 4 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=845)
    public int getMobilePolicyMaxDevicePasswordFailedAttempts() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyMaxDevicePasswordFailedAttempts, 4, true);
    }

    /**
     * number of consecutive incorrect pin input before device is wiped;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyMaxDevicePasswordFailedAttempts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=845)
    public void setMobilePolicyMaxDevicePasswordFailedAttempts(int zimbraMobilePolicyMaxDevicePasswordFailedAttempts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxDevicePasswordFailedAttempts, Integer.toString(zimbraMobilePolicyMaxDevicePasswordFailedAttempts));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of consecutive incorrect pin input before device is wiped;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyMaxDevicePasswordFailedAttempts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=845)
    public Map<String,Object> setMobilePolicyMaxDevicePasswordFailedAttempts(int zimbraMobilePolicyMaxDevicePasswordFailedAttempts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxDevicePasswordFailedAttempts, Integer.toString(zimbraMobilePolicyMaxDevicePasswordFailedAttempts));
        return attrs;
    }

    /**
     * number of consecutive incorrect pin input before device is wiped;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=845)
    public void unsetMobilePolicyMaxDevicePasswordFailedAttempts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxDevicePasswordFailedAttempts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of consecutive incorrect pin input before device is wiped;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=845)
    public Map<String,Object> unsetMobilePolicyMaxDevicePasswordFailedAttempts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxDevicePasswordFailedAttempts, "");
        return attrs;
    }

    /**
     * the maximum number of days of e-mail items to synchronize to the
     * device; 0 - PAST ALL 1 - One Day 2 - Three Days 3 - One Week 4 - Two
     * Weeks 5 - One Month ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     * or zimbraMobilePolicyMaxEmailAgeFilter value is set to -1
     *
     * @return zimbraMobilePolicyMaxEmailAgeFilter, or 5 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1291)
    public int getMobilePolicyMaxEmailAgeFilter() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyMaxEmailAgeFilter, 5, true);
    }

    /**
     * the maximum number of days of e-mail items to synchronize to the
     * device; 0 - PAST ALL 1 - One Day 2 - Three Days 3 - One Week 4 - Two
     * Weeks 5 - One Month ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     * or zimbraMobilePolicyMaxEmailAgeFilter value is set to -1
     *
     * @param zimbraMobilePolicyMaxEmailAgeFilter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1291)
    public void setMobilePolicyMaxEmailAgeFilter(int zimbraMobilePolicyMaxEmailAgeFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailAgeFilter, Integer.toString(zimbraMobilePolicyMaxEmailAgeFilter));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the maximum number of days of e-mail items to synchronize to the
     * device; 0 - PAST ALL 1 - One Day 2 - Three Days 3 - One Week 4 - Two
     * Weeks 5 - One Month ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     * or zimbraMobilePolicyMaxEmailAgeFilter value is set to -1
     *
     * @param zimbraMobilePolicyMaxEmailAgeFilter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1291)
    public Map<String,Object> setMobilePolicyMaxEmailAgeFilter(int zimbraMobilePolicyMaxEmailAgeFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailAgeFilter, Integer.toString(zimbraMobilePolicyMaxEmailAgeFilter));
        return attrs;
    }

    /**
     * the maximum number of days of e-mail items to synchronize to the
     * device; 0 - PAST ALL 1 - One Day 2 - Three Days 3 - One Week 4 - Two
     * Weeks 5 - One Month ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     * or zimbraMobilePolicyMaxEmailAgeFilter value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1291)
    public void unsetMobilePolicyMaxEmailAgeFilter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailAgeFilter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the maximum number of days of e-mail items to synchronize to the
     * device; 0 - PAST ALL 1 - One Day 2 - Three Days 3 - One Week 4 - Two
     * Weeks 5 - One Month ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     * or zimbraMobilePolicyMaxEmailAgeFilter value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1291)
    public Map<String,Object> unsetMobilePolicyMaxEmailAgeFilter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailAgeFilter, "");
        return attrs;
    }

    /**
     * the maximum size at which e-mail messages are truncated when
     * synchronized to the device; The value is specified in kilobytes (KB).
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyMaxEmailBodyTruncationSize, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1292)
    public int getMobilePolicyMaxEmailBodyTruncationSize() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyMaxEmailBodyTruncationSize, -1, true);
    }

    /**
     * the maximum size at which e-mail messages are truncated when
     * synchronized to the device; The value is specified in kilobytes (KB).
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyMaxEmailBodyTruncationSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1292)
    public void setMobilePolicyMaxEmailBodyTruncationSize(int zimbraMobilePolicyMaxEmailBodyTruncationSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailBodyTruncationSize, Integer.toString(zimbraMobilePolicyMaxEmailBodyTruncationSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the maximum size at which e-mail messages are truncated when
     * synchronized to the device; The value is specified in kilobytes (KB).
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyMaxEmailBodyTruncationSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1292)
    public Map<String,Object> setMobilePolicyMaxEmailBodyTruncationSize(int zimbraMobilePolicyMaxEmailBodyTruncationSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailBodyTruncationSize, Integer.toString(zimbraMobilePolicyMaxEmailBodyTruncationSize));
        return attrs;
    }

    /**
     * the maximum size at which e-mail messages are truncated when
     * synchronized to the device; The value is specified in kilobytes (KB).
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1292)
    public void unsetMobilePolicyMaxEmailBodyTruncationSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailBodyTruncationSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the maximum size at which e-mail messages are truncated when
     * synchronized to the device; The value is specified in kilobytes (KB).
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1292)
    public Map<String,Object> unsetMobilePolicyMaxEmailBodyTruncationSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailBodyTruncationSize, "");
        return attrs;
    }

    /**
     * the maximum size at which HTML-formatted e-mail messages are
     * synchronized to the devices. The value is specified in KB. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1293)
    public int getMobilePolicyMaxEmailHTMLBodyTruncationSize() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize, -1, true);
    }

    /**
     * the maximum size at which HTML-formatted e-mail messages are
     * synchronized to the devices. The value is specified in KB. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1293)
    public void setMobilePolicyMaxEmailHTMLBodyTruncationSize(int zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize, Integer.toString(zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the maximum size at which HTML-formatted e-mail messages are
     * synchronized to the devices. The value is specified in KB. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1293)
    public Map<String,Object> setMobilePolicyMaxEmailHTMLBodyTruncationSize(int zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize, Integer.toString(zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize));
        return attrs;
    }

    /**
     * the maximum size at which HTML-formatted e-mail messages are
     * synchronized to the devices. The value is specified in KB. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1293)
    public void unsetMobilePolicyMaxEmailHTMLBodyTruncationSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the maximum size at which HTML-formatted e-mail messages are
     * synchronized to the devices. The value is specified in KB. ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1293)
    public Map<String,Object> unsetMobilePolicyMaxEmailHTMLBodyTruncationSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxEmailHTMLBodyTruncationSize, "");
        return attrs;
    }

    /**
     * max idle time in minutes before device is locked; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @return zimbraMobilePolicyMaxInactivityTimeDeviceLock, or 15 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=844)
    public int getMobilePolicyMaxInactivityTimeDeviceLock() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyMaxInactivityTimeDeviceLock, 15, true);
    }

    /**
     * max idle time in minutes before device is locked; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyMaxInactivityTimeDeviceLock new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=844)
    public void setMobilePolicyMaxInactivityTimeDeviceLock(int zimbraMobilePolicyMaxInactivityTimeDeviceLock) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxInactivityTimeDeviceLock, Integer.toString(zimbraMobilePolicyMaxInactivityTimeDeviceLock));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max idle time in minutes before device is locked; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyMaxInactivityTimeDeviceLock new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=844)
    public Map<String,Object> setMobilePolicyMaxInactivityTimeDeviceLock(int zimbraMobilePolicyMaxInactivityTimeDeviceLock, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxInactivityTimeDeviceLock, Integer.toString(zimbraMobilePolicyMaxInactivityTimeDeviceLock));
        return attrs;
    }

    /**
     * max idle time in minutes before device is locked; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=844)
    public void unsetMobilePolicyMaxInactivityTimeDeviceLock() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxInactivityTimeDeviceLock, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max idle time in minutes before device is locked; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=844)
    public Map<String,Object> unsetMobilePolicyMaxInactivityTimeDeviceLock(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMaxInactivityTimeDeviceLock, "");
        return attrs;
    }

    /**
     * least number of complex characters must be included in device pin;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @return zimbraMobilePolicyMinDevicePasswordComplexCharacters, or 0 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=841)
    public int getMobilePolicyMinDevicePasswordComplexCharacters() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyMinDevicePasswordComplexCharacters, 0, true);
    }

    /**
     * least number of complex characters must be included in device pin;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyMinDevicePasswordComplexCharacters new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=841)
    public void setMobilePolicyMinDevicePasswordComplexCharacters(int zimbraMobilePolicyMinDevicePasswordComplexCharacters) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMinDevicePasswordComplexCharacters, Integer.toString(zimbraMobilePolicyMinDevicePasswordComplexCharacters));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * least number of complex characters must be included in device pin;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyMinDevicePasswordComplexCharacters new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=841)
    public Map<String,Object> setMobilePolicyMinDevicePasswordComplexCharacters(int zimbraMobilePolicyMinDevicePasswordComplexCharacters, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMinDevicePasswordComplexCharacters, Integer.toString(zimbraMobilePolicyMinDevicePasswordComplexCharacters));
        return attrs;
    }

    /**
     * least number of complex characters must be included in device pin;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=841)
    public void unsetMobilePolicyMinDevicePasswordComplexCharacters() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMinDevicePasswordComplexCharacters, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * least number of complex characters must be included in device pin;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=841)
    public Map<String,Object> unsetMobilePolicyMinDevicePasswordComplexCharacters(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMinDevicePasswordComplexCharacters, "");
        return attrs;
    }

    /**
     * min length for device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @return zimbraMobilePolicyMinDevicePasswordLength, or 4 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=838)
    public int getMobilePolicyMinDevicePasswordLength() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyMinDevicePasswordLength, 4, true);
    }

    /**
     * min length for device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyMinDevicePasswordLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=838)
    public void setMobilePolicyMinDevicePasswordLength(int zimbraMobilePolicyMinDevicePasswordLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMinDevicePasswordLength, Integer.toString(zimbraMobilePolicyMinDevicePasswordLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * min length for device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyMinDevicePasswordLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=838)
    public Map<String,Object> setMobilePolicyMinDevicePasswordLength(int zimbraMobilePolicyMinDevicePasswordLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMinDevicePasswordLength, Integer.toString(zimbraMobilePolicyMinDevicePasswordLength));
        return attrs;
    }

    /**
     * min length for device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=838)
    public void unsetMobilePolicyMinDevicePasswordLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMinDevicePasswordLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * min length for device pin; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=838)
    public Map<String,Object> unsetMobilePolicyMinDevicePasswordLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyMinDevicePasswordLength, "");
        return attrs;
    }

    /**
     * support device pin recovery; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @return zimbraMobilePolicyPasswordRecoveryEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=846)
    public boolean isMobilePolicyPasswordRecoveryEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicyPasswordRecoveryEnabled, true, true);
    }

    /**
     * support device pin recovery; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyPasswordRecoveryEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=846)
    public void setMobilePolicyPasswordRecoveryEnabled(boolean zimbraMobilePolicyPasswordRecoveryEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyPasswordRecoveryEnabled, zimbraMobilePolicyPasswordRecoveryEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * support device pin recovery; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param zimbraMobilePolicyPasswordRecoveryEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=846)
    public Map<String,Object> setMobilePolicyPasswordRecoveryEnabled(boolean zimbraMobilePolicyPasswordRecoveryEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyPasswordRecoveryEnabled, zimbraMobilePolicyPasswordRecoveryEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * support device pin recovery; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=846)
    public void unsetMobilePolicyPasswordRecoveryEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyPasswordRecoveryEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * support device pin recovery; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyDevicePasswordEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=846)
    public Map<String,Object> unsetMobilePolicyPasswordRecoveryEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyPasswordRecoveryEnabled, "");
        return attrs;
    }

    /**
     * time interval in minutes before forcing device to refresh policy;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyRefreshInterval, or 1440 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=836)
    public int getMobilePolicyRefreshInterval() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyRefreshInterval, 1440, true);
    }

    /**
     * time interval in minutes before forcing device to refresh policy;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyRefreshInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=836)
    public void setMobilePolicyRefreshInterval(int zimbraMobilePolicyRefreshInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRefreshInterval, Integer.toString(zimbraMobilePolicyRefreshInterval));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval in minutes before forcing device to refresh policy;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyRefreshInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=836)
    public Map<String,Object> setMobilePolicyRefreshInterval(int zimbraMobilePolicyRefreshInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRefreshInterval, Integer.toString(zimbraMobilePolicyRefreshInterval));
        return attrs;
    }

    /**
     * time interval in minutes before forcing device to refresh policy;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=836)
    public void unsetMobilePolicyRefreshInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRefreshInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval in minutes before forcing device to refresh policy;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=836)
    public Map<String,Object> unsetMobilePolicyRefreshInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRefreshInterval, "");
        return attrs;
    }

    /**
     * whether encryption on device is required; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireDeviceEncryption value is set to -1
     *
     * @return zimbraMobilePolicyRequireDeviceEncryption, or 0 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1279)
    public int getMobilePolicyRequireDeviceEncryption() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyRequireDeviceEncryption, 0, true);
    }

    /**
     * whether encryption on device is required; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireDeviceEncryption value is set to -1
     *
     * @param zimbraMobilePolicyRequireDeviceEncryption new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1279)
    public void setMobilePolicyRequireDeviceEncryption(int zimbraMobilePolicyRequireDeviceEncryption) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireDeviceEncryption, Integer.toString(zimbraMobilePolicyRequireDeviceEncryption));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether encryption on device is required; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireDeviceEncryption value is set to -1
     *
     * @param zimbraMobilePolicyRequireDeviceEncryption new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1279)
    public Map<String,Object> setMobilePolicyRequireDeviceEncryption(int zimbraMobilePolicyRequireDeviceEncryption, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireDeviceEncryption, Integer.toString(zimbraMobilePolicyRequireDeviceEncryption));
        return attrs;
    }

    /**
     * whether encryption on device is required; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireDeviceEncryption value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1279)
    public void unsetMobilePolicyRequireDeviceEncryption() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireDeviceEncryption, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether encryption on device is required; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireDeviceEncryption value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1279)
    public Map<String,Object> unsetMobilePolicyRequireDeviceEncryption(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireDeviceEncryption, "");
        return attrs;
    }

    /**
     * whether you must encrypt S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptedSMIMEMessages value is set to -1
     *
     * @return zimbraMobilePolicyRequireEncryptedSMIMEMessages, or 0 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1295)
    public int getMobilePolicyRequireEncryptedSMIMEMessages() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyRequireEncryptedSMIMEMessages, 0, true);
    }

    /**
     * whether you must encrypt S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptedSMIMEMessages value is set to -1
     *
     * @param zimbraMobilePolicyRequireEncryptedSMIMEMessages new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1295)
    public void setMobilePolicyRequireEncryptedSMIMEMessages(int zimbraMobilePolicyRequireEncryptedSMIMEMessages) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireEncryptedSMIMEMessages, Integer.toString(zimbraMobilePolicyRequireEncryptedSMIMEMessages));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether you must encrypt S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptedSMIMEMessages value is set to -1
     *
     * @param zimbraMobilePolicyRequireEncryptedSMIMEMessages new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1295)
    public Map<String,Object> setMobilePolicyRequireEncryptedSMIMEMessages(int zimbraMobilePolicyRequireEncryptedSMIMEMessages, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireEncryptedSMIMEMessages, Integer.toString(zimbraMobilePolicyRequireEncryptedSMIMEMessages));
        return attrs;
    }

    /**
     * whether you must encrypt S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptedSMIMEMessages value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1295)
    public void unsetMobilePolicyRequireEncryptedSMIMEMessages() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireEncryptedSMIMEMessages, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether you must encrypt S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptedSMIMEMessages value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1295)
    public Map<String,Object> unsetMobilePolicyRequireEncryptedSMIMEMessages(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireEncryptedSMIMEMessages, "");
        return attrs;
    }

    /**
     * what required algorithm must be used when encrypting a message;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm value is set to -1
     *
     * @return zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm, or 0 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1297)
    public int getMobilePolicyRequireEncryptionSMIMEAlgorithm() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm, 0, true);
    }

    /**
     * what required algorithm must be used when encrypting a message;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm value is set to -1
     *
     * @param zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1297)
    public void setMobilePolicyRequireEncryptionSMIMEAlgorithm(int zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm, Integer.toString(zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what required algorithm must be used when encrypting a message;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm value is set to -1
     *
     * @param zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1297)
    public Map<String,Object> setMobilePolicyRequireEncryptionSMIMEAlgorithm(int zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm, Integer.toString(zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm));
        return attrs;
    }

    /**
     * what required algorithm must be used when encrypting a message;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1297)
    public void unsetMobilePolicyRequireEncryptionSMIMEAlgorithm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what required algorithm must be used when encrypting a message;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1297)
    public Map<String,Object> unsetMobilePolicyRequireEncryptionSMIMEAlgorithm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireEncryptionSMIMEAlgorithm, "");
        return attrs;
    }

    /**
     * whether the mobile device must synchronize manually while roaming;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireManualSyncWhenRoaming value is set to -1
     *
     * @return zimbraMobilePolicyRequireManualSyncWhenRoaming, or 0 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1287)
    public int getMobilePolicyRequireManualSyncWhenRoaming() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyRequireManualSyncWhenRoaming, 0, true);
    }

    /**
     * whether the mobile device must synchronize manually while roaming;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireManualSyncWhenRoaming value is set to -1
     *
     * @param zimbraMobilePolicyRequireManualSyncWhenRoaming new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1287)
    public void setMobilePolicyRequireManualSyncWhenRoaming(int zimbraMobilePolicyRequireManualSyncWhenRoaming) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireManualSyncWhenRoaming, Integer.toString(zimbraMobilePolicyRequireManualSyncWhenRoaming));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the mobile device must synchronize manually while roaming;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireManualSyncWhenRoaming value is set to -1
     *
     * @param zimbraMobilePolicyRequireManualSyncWhenRoaming new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1287)
    public Map<String,Object> setMobilePolicyRequireManualSyncWhenRoaming(int zimbraMobilePolicyRequireManualSyncWhenRoaming, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireManualSyncWhenRoaming, Integer.toString(zimbraMobilePolicyRequireManualSyncWhenRoaming));
        return attrs;
    }

    /**
     * whether the mobile device must synchronize manually while roaming;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireManualSyncWhenRoaming value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1287)
    public void unsetMobilePolicyRequireManualSyncWhenRoaming() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireManualSyncWhenRoaming, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the mobile device must synchronize manually while roaming;
     * ignored if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireManualSyncWhenRoaming value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1287)
    public Map<String,Object> unsetMobilePolicyRequireManualSyncWhenRoaming(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireManualSyncWhenRoaming, "");
        return attrs;
    }

    /**
     * what required algorithm must be used when signing a message; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEAlgorithm value is set to -1
     *
     * @return zimbraMobilePolicyRequireSignedSMIMEAlgorithm, or 0 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1296)
    public int getMobilePolicyRequireSignedSMIMEAlgorithm() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEAlgorithm, 0, true);
    }

    /**
     * what required algorithm must be used when signing a message; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEAlgorithm value is set to -1
     *
     * @param zimbraMobilePolicyRequireSignedSMIMEAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1296)
    public void setMobilePolicyRequireSignedSMIMEAlgorithm(int zimbraMobilePolicyRequireSignedSMIMEAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEAlgorithm, Integer.toString(zimbraMobilePolicyRequireSignedSMIMEAlgorithm));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what required algorithm must be used when signing a message; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEAlgorithm value is set to -1
     *
     * @param zimbraMobilePolicyRequireSignedSMIMEAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1296)
    public Map<String,Object> setMobilePolicyRequireSignedSMIMEAlgorithm(int zimbraMobilePolicyRequireSignedSMIMEAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEAlgorithm, Integer.toString(zimbraMobilePolicyRequireSignedSMIMEAlgorithm));
        return attrs;
    }

    /**
     * what required algorithm must be used when signing a message; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEAlgorithm value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1296)
    public void unsetMobilePolicyRequireSignedSMIMEAlgorithm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEAlgorithm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what required algorithm must be used when signing a message; ignored
     * if zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEAlgorithm value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1296)
    public Map<String,Object> unsetMobilePolicyRequireSignedSMIMEAlgorithm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEAlgorithm, "");
        return attrs;
    }

    /**
     * whether the device must send signed S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEMessages value is set to -1
     *
     * @return zimbraMobilePolicyRequireSignedSMIMEMessages, or 0 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1294)
    public int getMobilePolicyRequireSignedSMIMEMessages() {
        return getIntAttr(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEMessages, 0, true);
    }

    /**
     * whether the device must send signed S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEMessages value is set to -1
     *
     * @param zimbraMobilePolicyRequireSignedSMIMEMessages new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1294)
    public void setMobilePolicyRequireSignedSMIMEMessages(int zimbraMobilePolicyRequireSignedSMIMEMessages) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEMessages, Integer.toString(zimbraMobilePolicyRequireSignedSMIMEMessages));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the device must send signed S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEMessages value is set to -1
     *
     * @param zimbraMobilePolicyRequireSignedSMIMEMessages new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1294)
    public Map<String,Object> setMobilePolicyRequireSignedSMIMEMessages(int zimbraMobilePolicyRequireSignedSMIMEMessages, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEMessages, Integer.toString(zimbraMobilePolicyRequireSignedSMIMEMessages));
        return attrs;
    }

    /**
     * whether the device must send signed S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEMessages value is set to -1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1294)
    public void unsetMobilePolicyRequireSignedSMIMEMessages() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEMessages, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether the device must send signed S/MIME messages; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE or
     * zimbraMobilePolicyRequireSignedSMIMEMessages value is set to -1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1294)
    public Map<String,Object> unsetMobilePolicyRequireSignedSMIMEMessages(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireSignedSMIMEMessages, "");
        return attrs;
    }

    /**
     * require data encryption on storage card; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyRequireStorageCardEncryption, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1444)
    public boolean isMobilePolicyRequireStorageCardEncryption() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicyRequireStorageCardEncryption, false, true);
    }

    /**
     * require data encryption on storage card; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyRequireStorageCardEncryption new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1444)
    public void setMobilePolicyRequireStorageCardEncryption(boolean zimbraMobilePolicyRequireStorageCardEncryption) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireStorageCardEncryption, zimbraMobilePolicyRequireStorageCardEncryption ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * require data encryption on storage card; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyRequireStorageCardEncryption new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1444)
    public Map<String,Object> setMobilePolicyRequireStorageCardEncryption(boolean zimbraMobilePolicyRequireStorageCardEncryption, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireStorageCardEncryption, zimbraMobilePolicyRequireStorageCardEncryption ? TRUE : FALSE);
        return attrs;
    }

    /**
     * require data encryption on storage card; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1444)
    public void unsetMobilePolicyRequireStorageCardEncryption() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireStorageCardEncryption, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * require data encryption on storage card; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1444)
    public Map<String,Object> unsetMobilePolicyRequireStorageCardEncryption(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyRequireStorageCardEncryption, "");
        return attrs;
    }

    /**
     * when set to TRUE, suppresses DeviceEncryptionEnabled to be sent down
     * to the device; Some devices choke when DeviceEncryptionEnabled policy
     * is downloaded irrespective of their value set to 0 or, 1 ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicySuppressDeviceEncryption, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1306)
    public boolean isMobilePolicySuppressDeviceEncryption() {
        return getBooleanAttr(Provisioning.A_zimbraMobilePolicySuppressDeviceEncryption, false, true);
    }

    /**
     * when set to TRUE, suppresses DeviceEncryptionEnabled to be sent down
     * to the device; Some devices choke when DeviceEncryptionEnabled policy
     * is downloaded irrespective of their value set to 0 or, 1 ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicySuppressDeviceEncryption new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1306)
    public void setMobilePolicySuppressDeviceEncryption(boolean zimbraMobilePolicySuppressDeviceEncryption) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicySuppressDeviceEncryption, zimbraMobilePolicySuppressDeviceEncryption ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * when set to TRUE, suppresses DeviceEncryptionEnabled to be sent down
     * to the device; Some devices choke when DeviceEncryptionEnabled policy
     * is downloaded irrespective of their value set to 0 or, 1 ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicySuppressDeviceEncryption new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1306)
    public Map<String,Object> setMobilePolicySuppressDeviceEncryption(boolean zimbraMobilePolicySuppressDeviceEncryption, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicySuppressDeviceEncryption, zimbraMobilePolicySuppressDeviceEncryption ? TRUE : FALSE);
        return attrs;
    }

    /**
     * when set to TRUE, suppresses DeviceEncryptionEnabled to be sent down
     * to the device; Some devices choke when DeviceEncryptionEnabled policy
     * is downloaded irrespective of their value set to 0 or, 1 ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1306)
    public void unsetMobilePolicySuppressDeviceEncryption() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicySuppressDeviceEncryption, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * when set to TRUE, suppresses DeviceEncryptionEnabled to be sent down
     * to the device; Some devices choke when DeviceEncryptionEnabled policy
     * is downloaded irrespective of their value set to 0 or, 1 ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1306)
    public Map<String,Object> unsetMobilePolicySuppressDeviceEncryption(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicySuppressDeviceEncryption, "");
        return attrs;
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @return zimbraMobilePolicyUnapprovedInROMApplication, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public String[] getMobilePolicyUnapprovedInROMApplication() {
        return getMultiAttr(Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, true, true);
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyUnapprovedInROMApplication new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public void setMobilePolicyUnapprovedInROMApplication(String[] zimbraMobilePolicyUnapprovedInROMApplication) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, zimbraMobilePolicyUnapprovedInROMApplication);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyUnapprovedInROMApplication new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public Map<String,Object> setMobilePolicyUnapprovedInROMApplication(String[] zimbraMobilePolicyUnapprovedInROMApplication, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, zimbraMobilePolicyUnapprovedInROMApplication);
        return attrs;
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyUnapprovedInROMApplication new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public void addMobilePolicyUnapprovedInROMApplication(String zimbraMobilePolicyUnapprovedInROMApplication) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, zimbraMobilePolicyUnapprovedInROMApplication);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyUnapprovedInROMApplication new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public Map<String,Object> addMobilePolicyUnapprovedInROMApplication(String zimbraMobilePolicyUnapprovedInROMApplication, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, zimbraMobilePolicyUnapprovedInROMApplication);
        return attrs;
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyUnapprovedInROMApplication existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public void removeMobilePolicyUnapprovedInROMApplication(String zimbraMobilePolicyUnapprovedInROMApplication) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, zimbraMobilePolicyUnapprovedInROMApplication);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param zimbraMobilePolicyUnapprovedInROMApplication existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public Map<String,Object> removeMobilePolicyUnapprovedInROMApplication(String zimbraMobilePolicyUnapprovedInROMApplication, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, zimbraMobilePolicyUnapprovedInROMApplication);
        return attrs;
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public void unsetMobilePolicyUnapprovedInROMApplication() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * application that can&#039;t be run in device ROM; ignored if
     * zimbraFeatureMobilePolicyEnabled=FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1304)
    public Map<String,Object> unsetMobilePolicyUnapprovedInROMApplication(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobilePolicyUnapprovedInROMApplication, "");
        return attrs;
    }

    /**
     * Specifies whether MIME body parts are supported in search responses or
     * not. Some devices, like Samsung S5 with Lollipop OS, specify a body
     * preference for either MIME or HTML in search requests. However they do
     * not handle the MIME sent in responses correctly, and are unable to
     * display messages in search results.(Bugs - 99686, 100436) This is
     * actually a device issue, but it breaks visibility of email in search
     * results on the device. If devices are used which do correctly support
     * MIME in search results, zimbraMobileSearchMimeSupportEnabled can be
     * set to TRUE for users of those devices.
     *
     * @return zimbraMobileSearchMimeSupportEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2055)
    public boolean isMobileSearchMimeSupportEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileSearchMimeSupportEnabled, false, true);
    }

    /**
     * Specifies whether MIME body parts are supported in search responses or
     * not. Some devices, like Samsung S5 with Lollipop OS, specify a body
     * preference for either MIME or HTML in search requests. However they do
     * not handle the MIME sent in responses correctly, and are unable to
     * display messages in search results.(Bugs - 99686, 100436) This is
     * actually a device issue, but it breaks visibility of email in search
     * results on the device. If devices are used which do correctly support
     * MIME in search results, zimbraMobileSearchMimeSupportEnabled can be
     * set to TRUE for users of those devices.
     *
     * @param zimbraMobileSearchMimeSupportEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2055)
    public void setMobileSearchMimeSupportEnabled(boolean zimbraMobileSearchMimeSupportEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSearchMimeSupportEnabled, zimbraMobileSearchMimeSupportEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies whether MIME body parts are supported in search responses or
     * not. Some devices, like Samsung S5 with Lollipop OS, specify a body
     * preference for either MIME or HTML in search requests. However they do
     * not handle the MIME sent in responses correctly, and are unable to
     * display messages in search results.(Bugs - 99686, 100436) This is
     * actually a device issue, but it breaks visibility of email in search
     * results on the device. If devices are used which do correctly support
     * MIME in search results, zimbraMobileSearchMimeSupportEnabled can be
     * set to TRUE for users of those devices.
     *
     * @param zimbraMobileSearchMimeSupportEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2055)
    public Map<String,Object> setMobileSearchMimeSupportEnabled(boolean zimbraMobileSearchMimeSupportEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSearchMimeSupportEnabled, zimbraMobileSearchMimeSupportEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Specifies whether MIME body parts are supported in search responses or
     * not. Some devices, like Samsung S5 with Lollipop OS, specify a body
     * preference for either MIME or HTML in search requests. However they do
     * not handle the MIME sent in responses correctly, and are unable to
     * display messages in search results.(Bugs - 99686, 100436) This is
     * actually a device issue, but it breaks visibility of email in search
     * results on the device. If devices are used which do correctly support
     * MIME in search results, zimbraMobileSearchMimeSupportEnabled can be
     * set to TRUE for users of those devices.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2055)
    public void unsetMobileSearchMimeSupportEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSearchMimeSupportEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies whether MIME body parts are supported in search responses or
     * not. Some devices, like Samsung S5 with Lollipop OS, specify a body
     * preference for either MIME or HTML in search requests. However they do
     * not handle the MIME sent in responses correctly, and are unable to
     * display messages in search results.(Bugs - 99686, 100436) This is
     * actually a device issue, but it breaks visibility of email in search
     * results on the device. If devices are used which do correctly support
     * MIME in search results, zimbraMobileSearchMimeSupportEnabled can be
     * set to TRUE for users of those devices.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2055)
    public Map<String,Object> unsetMobileSearchMimeSupportEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSearchMimeSupportEnabled, "");
        return attrs;
    }

    /**
     * Whether to permit syncing shared contact folders
     *
     * @return zimbraMobileShareContactEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1570)
    public boolean isMobileShareContactEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileShareContactEnabled, false, true);
    }

    /**
     * Whether to permit syncing shared contact folders
     *
     * @param zimbraMobileShareContactEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1570)
    public void setMobileShareContactEnabled(boolean zimbraMobileShareContactEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileShareContactEnabled, zimbraMobileShareContactEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to permit syncing shared contact folders
     *
     * @param zimbraMobileShareContactEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1570)
    public Map<String,Object> setMobileShareContactEnabled(boolean zimbraMobileShareContactEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileShareContactEnabled, zimbraMobileShareContactEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to permit syncing shared contact folders
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1570)
    public void unsetMobileShareContactEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileShareContactEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to permit syncing shared contact folders
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1570)
    public Map<String,Object> unsetMobileShareContactEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileShareContactEnabled, "");
        return attrs;
    }

    /**
     * indicates whether the application can forward original email as RFC
     * 822 .eml attachment. Note: this setting is applicable only to the
     * devices using activesync smart forward for forwarding email messages.
     *
     * @return zimbraMobileSmartForwardRFC822Enabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1205)
    public boolean isMobileSmartForwardRFC822Enabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileSmartForwardRFC822Enabled, false, true);
    }

    /**
     * indicates whether the application can forward original email as RFC
     * 822 .eml attachment. Note: this setting is applicable only to the
     * devices using activesync smart forward for forwarding email messages.
     *
     * @param zimbraMobileSmartForwardRFC822Enabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1205)
    public void setMobileSmartForwardRFC822Enabled(boolean zimbraMobileSmartForwardRFC822Enabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSmartForwardRFC822Enabled, zimbraMobileSmartForwardRFC822Enabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicates whether the application can forward original email as RFC
     * 822 .eml attachment. Note: this setting is applicable only to the
     * devices using activesync smart forward for forwarding email messages.
     *
     * @param zimbraMobileSmartForwardRFC822Enabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1205)
    public Map<String,Object> setMobileSmartForwardRFC822Enabled(boolean zimbraMobileSmartForwardRFC822Enabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSmartForwardRFC822Enabled, zimbraMobileSmartForwardRFC822Enabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * indicates whether the application can forward original email as RFC
     * 822 .eml attachment. Note: this setting is applicable only to the
     * devices using activesync smart forward for forwarding email messages.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1205)
    public void unsetMobileSmartForwardRFC822Enabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSmartForwardRFC822Enabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicates whether the application can forward original email as RFC
     * 822 .eml attachment. Note: this setting is applicable only to the
     * devices using activesync smart forward for forwarding email messages.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1205)
    public Map<String,Object> unsetMobileSmartForwardRFC822Enabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSmartForwardRFC822Enabled, "");
        return attrs;
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @return zimbraMobileSyncKeyFormatConvertedFolders, or empty array if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public String[] getMobileSyncKeyFormatConvertedFolders() {
        return getMultiAttr(Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, true, true);
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @param zimbraMobileSyncKeyFormatConvertedFolders new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public void setMobileSyncKeyFormatConvertedFolders(String[] zimbraMobileSyncKeyFormatConvertedFolders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, zimbraMobileSyncKeyFormatConvertedFolders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @param zimbraMobileSyncKeyFormatConvertedFolders new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public Map<String,Object> setMobileSyncKeyFormatConvertedFolders(String[] zimbraMobileSyncKeyFormatConvertedFolders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, zimbraMobileSyncKeyFormatConvertedFolders);
        return attrs;
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @param zimbraMobileSyncKeyFormatConvertedFolders new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public void addMobileSyncKeyFormatConvertedFolders(String zimbraMobileSyncKeyFormatConvertedFolders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, zimbraMobileSyncKeyFormatConvertedFolders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @param zimbraMobileSyncKeyFormatConvertedFolders new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public Map<String,Object> addMobileSyncKeyFormatConvertedFolders(String zimbraMobileSyncKeyFormatConvertedFolders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, zimbraMobileSyncKeyFormatConvertedFolders);
        return attrs;
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @param zimbraMobileSyncKeyFormatConvertedFolders existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public void removeMobileSyncKeyFormatConvertedFolders(String zimbraMobileSyncKeyFormatConvertedFolders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, zimbraMobileSyncKeyFormatConvertedFolders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @param zimbraMobileSyncKeyFormatConvertedFolders existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public Map<String,Object> removeMobileSyncKeyFormatConvertedFolders(String zimbraMobileSyncKeyFormatConvertedFolders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, zimbraMobileSyncKeyFormatConvertedFolders);
        return attrs;
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public void unsetMobileSyncKeyFormatConvertedFolders() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * folders whose sync key are already converted, each device has a list
     * of folders. e.g. ApplDN6GJSQJDFHW:0,2,10 meaning device
     * ApplDN6GJSQJDFHW&#039;s folders, inbox and calendar folder sync key
     * format are converted, use 0 for FolderSync
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1439)
    public Map<String,Object> unsetMobileSyncKeyFormatConvertedFolders(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSyncKeyFormatConvertedFolders, "");
        return attrs;
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @return zimbraMobileSyncRedoMaxAttempts, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public String[] getMobileSyncRedoMaxAttempts() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMobileSyncRedoMaxAttempts, true, true); return value.length > 0 ? value : new String[] {"windows:2","default:1"};
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @param zimbraMobileSyncRedoMaxAttempts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public void setMobileSyncRedoMaxAttempts(String[] zimbraMobileSyncRedoMaxAttempts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSyncRedoMaxAttempts, zimbraMobileSyncRedoMaxAttempts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @param zimbraMobileSyncRedoMaxAttempts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public Map<String,Object> setMobileSyncRedoMaxAttempts(String[] zimbraMobileSyncRedoMaxAttempts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSyncRedoMaxAttempts, zimbraMobileSyncRedoMaxAttempts);
        return attrs;
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @param zimbraMobileSyncRedoMaxAttempts new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public void addMobileSyncRedoMaxAttempts(String zimbraMobileSyncRedoMaxAttempts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobileSyncRedoMaxAttempts, zimbraMobileSyncRedoMaxAttempts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @param zimbraMobileSyncRedoMaxAttempts new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public Map<String,Object> addMobileSyncRedoMaxAttempts(String zimbraMobileSyncRedoMaxAttempts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobileSyncRedoMaxAttempts, zimbraMobileSyncRedoMaxAttempts);
        return attrs;
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @param zimbraMobileSyncRedoMaxAttempts existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public void removeMobileSyncRedoMaxAttempts(String zimbraMobileSyncRedoMaxAttempts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobileSyncRedoMaxAttempts, zimbraMobileSyncRedoMaxAttempts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @param zimbraMobileSyncRedoMaxAttempts existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public Map<String,Object> removeMobileSyncRedoMaxAttempts(String zimbraMobileSyncRedoMaxAttempts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobileSyncRedoMaxAttempts, zimbraMobileSyncRedoMaxAttempts);
        return attrs;
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public void unsetMobileSyncRedoMaxAttempts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSyncRedoMaxAttempts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of times allowed to retry the same sync version before going
     * into penalty. In general, windows phone should be set to 2, iOS should
     * be set to 1. example of config values: windows:2, ios:1, android:1,
     * default:1
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1642)
    public Map<String,Object> unsetMobileSyncRedoMaxAttempts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileSyncRedoMaxAttempts, "");
        return attrs;
    }

    /**
     * whether to enable tombstone syncing. If disabled, changes of
     * tombstones won&#039;t be synced to device
     *
     * @return zimbraMobileTombstoneEnabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1633)
    public boolean isMobileTombstoneEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileTombstoneEnabled, true, true);
    }

    /**
     * whether to enable tombstone syncing. If disabled, changes of
     * tombstones won&#039;t be synced to device
     *
     * @param zimbraMobileTombstoneEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1633)
    public void setMobileTombstoneEnabled(boolean zimbraMobileTombstoneEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileTombstoneEnabled, zimbraMobileTombstoneEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable tombstone syncing. If disabled, changes of
     * tombstones won&#039;t be synced to device
     *
     * @param zimbraMobileTombstoneEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1633)
    public Map<String,Object> setMobileTombstoneEnabled(boolean zimbraMobileTombstoneEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileTombstoneEnabled, zimbraMobileTombstoneEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to enable tombstone syncing. If disabled, changes of
     * tombstones won&#039;t be synced to device
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1633)
    public void unsetMobileTombstoneEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileTombstoneEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable tombstone syncing. If disabled, changes of
     * tombstones won&#039;t be synced to device
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1633)
    public Map<String,Object> unsetMobileTombstoneEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileTombstoneEnabled, "");
        return attrs;
    }

    /**
     * Template used to construct the body of an email notification message.
     * This attribute is ignored when zimbraNewMailNotificationMessage is
     * set.
     *
     * @return zimbraNewMailNotificationBody, or "New message received at ${RECIPIENT_ADDRESS}.${NEWLINE}Sender: ${SENDER_ADDRESS}${NEWLINE}Subject: ${SUBJECT}" if unset
     */
    @ZAttr(id=152)
    public String getNewMailNotificationBody() {
        return getAttr(Provisioning.A_zimbraNewMailNotificationBody, "New message received at ${RECIPIENT_ADDRESS}.${NEWLINE}Sender: ${SENDER_ADDRESS}${NEWLINE}Subject: ${SUBJECT}", true);
    }

    /**
     * Template used to construct the body of an email notification message.
     * This attribute is ignored when zimbraNewMailNotificationMessage is
     * set.
     *
     * @param zimbraNewMailNotificationBody new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=152)
    public void setNewMailNotificationBody(String zimbraNewMailNotificationBody) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationBody, zimbraNewMailNotificationBody);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the body of an email notification message.
     * This attribute is ignored when zimbraNewMailNotificationMessage is
     * set.
     *
     * @param zimbraNewMailNotificationBody new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=152)
    public Map<String,Object> setNewMailNotificationBody(String zimbraNewMailNotificationBody, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationBody, zimbraNewMailNotificationBody);
        return attrs;
    }

    /**
     * Template used to construct the body of an email notification message.
     * This attribute is ignored when zimbraNewMailNotificationMessage is
     * set.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=152)
    public void unsetNewMailNotificationBody() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationBody, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the body of an email notification message.
     * This attribute is ignored when zimbraNewMailNotificationMessage is
     * set.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=152)
    public Map<String,Object> unsetNewMailNotificationBody(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationBody, "");
        return attrs;
    }

    /**
     * Template used to construct the sender of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @return zimbraNewMailNotificationFrom, or "Postmaster <postmaster@${RECIPIENT_DOMAIN}>" if unset
     */
    @ZAttr(id=150)
    public String getNewMailNotificationFrom() {
        return getAttr(Provisioning.A_zimbraNewMailNotificationFrom, "Postmaster <postmaster@${RECIPIENT_DOMAIN}>", true);
    }

    /**
     * Template used to construct the sender of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @param zimbraNewMailNotificationFrom new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=150)
    public void setNewMailNotificationFrom(String zimbraNewMailNotificationFrom) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationFrom, zimbraNewMailNotificationFrom);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the sender of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @param zimbraNewMailNotificationFrom new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=150)
    public Map<String,Object> setNewMailNotificationFrom(String zimbraNewMailNotificationFrom, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationFrom, zimbraNewMailNotificationFrom);
        return attrs;
    }

    /**
     * Template used to construct the sender of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=150)
    public void unsetNewMailNotificationFrom() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationFrom, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the sender of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=150)
    public Map<String,Object> unsetNewMailNotificationFrom(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationFrom, "");
        return attrs;
    }

    /**
     * Template used to construct an email notification message. When this
     * attribute is not set, email notification message is composed using
     * zimbraNewMailNotificationBody, zimbraNewMailNotificationFrom and
     * zimbraNewMailNotificationSubject attributes. Use this attribute when
     * you need to specify custom email headers such as charset and
     * content-type. Sample configuration: From: Postmaster
     * &lt;postmaster@${RECIPIENT_DOMAIN}&gt;${NEWLINE}To:
     * &lt;${RECIPIENT_ADDRESS}&gt;${NEWLINE}Subject: New message received at
     * ${RECIPIENT_ADDRESS}${NEWLINE}Date: ${DATE}${NEWLINE}Content-Type:
     * text/plain${NEWLINE}${NEWLINE}New message received at
     * ${RECIPIENT_ADDRESS}.${NEWLINE}Sender:
     * ${SENDER_ADDRESS}${NEWLINE}Subject: ${SUBJECT}
     *
     * @return zimbraNewMailNotificationMessage, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2019)
    public String getNewMailNotificationMessage() {
        return getAttr(Provisioning.A_zimbraNewMailNotificationMessage, null, true);
    }

    /**
     * Template used to construct an email notification message. When this
     * attribute is not set, email notification message is composed using
     * zimbraNewMailNotificationBody, zimbraNewMailNotificationFrom and
     * zimbraNewMailNotificationSubject attributes. Use this attribute when
     * you need to specify custom email headers such as charset and
     * content-type. Sample configuration: From: Postmaster
     * &lt;postmaster@${RECIPIENT_DOMAIN}&gt;${NEWLINE}To:
     * &lt;${RECIPIENT_ADDRESS}&gt;${NEWLINE}Subject: New message received at
     * ${RECIPIENT_ADDRESS}${NEWLINE}Date: ${DATE}${NEWLINE}Content-Type:
     * text/plain${NEWLINE}${NEWLINE}New message received at
     * ${RECIPIENT_ADDRESS}.${NEWLINE}Sender:
     * ${SENDER_ADDRESS}${NEWLINE}Subject: ${SUBJECT}
     *
     * @param zimbraNewMailNotificationMessage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2019)
    public void setNewMailNotificationMessage(String zimbraNewMailNotificationMessage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationMessage, zimbraNewMailNotificationMessage);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct an email notification message. When this
     * attribute is not set, email notification message is composed using
     * zimbraNewMailNotificationBody, zimbraNewMailNotificationFrom and
     * zimbraNewMailNotificationSubject attributes. Use this attribute when
     * you need to specify custom email headers such as charset and
     * content-type. Sample configuration: From: Postmaster
     * &lt;postmaster@${RECIPIENT_DOMAIN}&gt;${NEWLINE}To:
     * &lt;${RECIPIENT_ADDRESS}&gt;${NEWLINE}Subject: New message received at
     * ${RECIPIENT_ADDRESS}${NEWLINE}Date: ${DATE}${NEWLINE}Content-Type:
     * text/plain${NEWLINE}${NEWLINE}New message received at
     * ${RECIPIENT_ADDRESS}.${NEWLINE}Sender:
     * ${SENDER_ADDRESS}${NEWLINE}Subject: ${SUBJECT}
     *
     * @param zimbraNewMailNotificationMessage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2019)
    public Map<String,Object> setNewMailNotificationMessage(String zimbraNewMailNotificationMessage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationMessage, zimbraNewMailNotificationMessage);
        return attrs;
    }

    /**
     * Template used to construct an email notification message. When this
     * attribute is not set, email notification message is composed using
     * zimbraNewMailNotificationBody, zimbraNewMailNotificationFrom and
     * zimbraNewMailNotificationSubject attributes. Use this attribute when
     * you need to specify custom email headers such as charset and
     * content-type. Sample configuration: From: Postmaster
     * &lt;postmaster@${RECIPIENT_DOMAIN}&gt;${NEWLINE}To:
     * &lt;${RECIPIENT_ADDRESS}&gt;${NEWLINE}Subject: New message received at
     * ${RECIPIENT_ADDRESS}${NEWLINE}Date: ${DATE}${NEWLINE}Content-Type:
     * text/plain${NEWLINE}${NEWLINE}New message received at
     * ${RECIPIENT_ADDRESS}.${NEWLINE}Sender:
     * ${SENDER_ADDRESS}${NEWLINE}Subject: ${SUBJECT}
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2019)
    public void unsetNewMailNotificationMessage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationMessage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct an email notification message. When this
     * attribute is not set, email notification message is composed using
     * zimbraNewMailNotificationBody, zimbraNewMailNotificationFrom and
     * zimbraNewMailNotificationSubject attributes. Use this attribute when
     * you need to specify custom email headers such as charset and
     * content-type. Sample configuration: From: Postmaster
     * &lt;postmaster@${RECIPIENT_DOMAIN}&gt;${NEWLINE}To:
     * &lt;${RECIPIENT_ADDRESS}&gt;${NEWLINE}Subject: New message received at
     * ${RECIPIENT_ADDRESS}${NEWLINE}Date: ${DATE}${NEWLINE}Content-Type:
     * text/plain${NEWLINE}${NEWLINE}New message received at
     * ${RECIPIENT_ADDRESS}.${NEWLINE}Sender:
     * ${SENDER_ADDRESS}${NEWLINE}Subject: ${SUBJECT}
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2019)
    public Map<String,Object> unsetNewMailNotificationMessage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationMessage, "");
        return attrs;
    }

    /**
     * Template used to construct the subject of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @return zimbraNewMailNotificationSubject, or "New message received at ${RECIPIENT_ADDRESS}" if unset
     */
    @ZAttr(id=151)
    public String getNewMailNotificationSubject() {
        return getAttr(Provisioning.A_zimbraNewMailNotificationSubject, "New message received at ${RECIPIENT_ADDRESS}", true);
    }

    /**
     * Template used to construct the subject of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @param zimbraNewMailNotificationSubject new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=151)
    public void setNewMailNotificationSubject(String zimbraNewMailNotificationSubject) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationSubject, zimbraNewMailNotificationSubject);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the subject of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @param zimbraNewMailNotificationSubject new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=151)
    public Map<String,Object> setNewMailNotificationSubject(String zimbraNewMailNotificationSubject, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationSubject, zimbraNewMailNotificationSubject);
        return attrs;
    }

    /**
     * Template used to construct the subject of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=151)
    public void unsetNewMailNotificationSubject() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationSubject, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the subject of an email notification
     * message. This attribute is ignored when
     * zimbraNewMailNotificationMessage is set.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=151)
    public Map<String,Object> unsetNewMailNotificationSubject(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNewMailNotificationSubject, "");
        return attrs;
    }

    /**
     * maximum number of revisions to keep for wiki pages and documents. 0
     * means unlimited.
     *
     * @return zimbraNotebookMaxRevisions, or 0 if unset
     */
    @ZAttr(id=482)
    public int getNotebookMaxRevisions() {
        return getIntAttr(Provisioning.A_zimbraNotebookMaxRevisions, 0, true);
    }

    /**
     * maximum number of revisions to keep for wiki pages and documents. 0
     * means unlimited.
     *
     * @param zimbraNotebookMaxRevisions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=482)
    public void setNotebookMaxRevisions(int zimbraNotebookMaxRevisions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookMaxRevisions, Integer.toString(zimbraNotebookMaxRevisions));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of revisions to keep for wiki pages and documents. 0
     * means unlimited.
     *
     * @param zimbraNotebookMaxRevisions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=482)
    public Map<String,Object> setNotebookMaxRevisions(int zimbraNotebookMaxRevisions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookMaxRevisions, Integer.toString(zimbraNotebookMaxRevisions));
        return attrs;
    }

    /**
     * maximum number of revisions to keep for wiki pages and documents. 0
     * means unlimited.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=482)
    public void unsetNotebookMaxRevisions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookMaxRevisions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of revisions to keep for wiki pages and documents. 0
     * means unlimited.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=482)
    public Map<String,Object> unsetNotebookMaxRevisions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookMaxRevisions, "");
        return attrs;
    }

    /**
     * whether to strip off potentially harming HTML tags in Wiki and HTML
     * Documents.
     *
     * @return zimbraNotebookSanitizeHtml, or true if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=646)
    public boolean isNotebookSanitizeHtml() {
        return getBooleanAttr(Provisioning.A_zimbraNotebookSanitizeHtml, true, true);
    }

    /**
     * whether to strip off potentially harming HTML tags in Wiki and HTML
     * Documents.
     *
     * @param zimbraNotebookSanitizeHtml new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=646)
    public void setNotebookSanitizeHtml(boolean zimbraNotebookSanitizeHtml) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookSanitizeHtml, zimbraNotebookSanitizeHtml ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to strip off potentially harming HTML tags in Wiki and HTML
     * Documents.
     *
     * @param zimbraNotebookSanitizeHtml new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=646)
    public Map<String,Object> setNotebookSanitizeHtml(boolean zimbraNotebookSanitizeHtml, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookSanitizeHtml, zimbraNotebookSanitizeHtml ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to strip off potentially harming HTML tags in Wiki and HTML
     * Documents.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=646)
    public void unsetNotebookSanitizeHtml() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookSanitizeHtml, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to strip off potentially harming HTML tags in Wiki and HTML
     * Documents.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=646)
    public Map<String,Object> unsetNotebookSanitizeHtml(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookSanitizeHtml, "");
        return attrs;
    }

    /**
     * administrative notes
     *
     * @return zimbraNotes, or null if unset
     */
    @ZAttr(id=9)
    public String getNotes() {
        return getAttr(Provisioning.A_zimbraNotes, null, true);
    }

    /**
     * administrative notes
     *
     * @param zimbraNotes new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=9)
    public void setNotes(String zimbraNotes) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotes, zimbraNotes);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * administrative notes
     *
     * @param zimbraNotes new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=9)
    public Map<String,Object> setNotes(String zimbraNotes, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotes, zimbraNotes);
        return attrs;
    }

    /**
     * administrative notes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=9)
    public void unsetNotes() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotes, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * administrative notes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=9)
    public Map<String,Object> unsetNotes(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotes, "");
        return attrs;
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @return zimbraOAuthAccessor, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public String[] getOAuthAccessor() {
        return getMultiAttr(Provisioning.A_zimbraOAuthAccessor, true, true);
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @param zimbraOAuthAccessor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public void setOAuthAccessor(String[] zimbraOAuthAccessor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthAccessor, zimbraOAuthAccessor);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @param zimbraOAuthAccessor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public Map<String,Object> setOAuthAccessor(String[] zimbraOAuthAccessor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthAccessor, zimbraOAuthAccessor);
        return attrs;
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @param zimbraOAuthAccessor new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public void addOAuthAccessor(String zimbraOAuthAccessor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOAuthAccessor, zimbraOAuthAccessor);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @param zimbraOAuthAccessor new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public Map<String,Object> addOAuthAccessor(String zimbraOAuthAccessor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOAuthAccessor, zimbraOAuthAccessor);
        return attrs;
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @param zimbraOAuthAccessor existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public void removeOAuthAccessor(String zimbraOAuthAccessor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOAuthAccessor, zimbraOAuthAccessor);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @param zimbraOAuthAccessor existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public Map<String,Object> removeOAuthAccessor(String zimbraOAuthAccessor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOAuthAccessor, zimbraOAuthAccessor);
        return attrs;
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public void unsetOAuthAccessor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthAccessor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Credentials associated with a successfully authorized OAuth Consumer
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2049)
    public Map<String,Object> unsetOAuthAccessor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthAccessor, "");
        return attrs;
    }

    /**
     * temporary RFC822 email address of this recipient for accepting mail
     * during account rename
     *
     * @return zimbraOldMailAddress, or null if unset
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2143)
    public String getOldMailAddress() {
        return getAttr(Provisioning.A_zimbraOldMailAddress, null, true);
    }

    /**
     * temporary RFC822 email address of this recipient for accepting mail
     * during account rename
     *
     * @param zimbraOldMailAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2143)
    public void setOldMailAddress(String zimbraOldMailAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOldMailAddress, zimbraOldMailAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * temporary RFC822 email address of this recipient for accepting mail
     * during account rename
     *
     * @param zimbraOldMailAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2143)
    public Map<String,Object> setOldMailAddress(String zimbraOldMailAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOldMailAddress, zimbraOldMailAddress);
        return attrs;
    }

    /**
     * temporary RFC822 email address of this recipient for accepting mail
     * during account rename
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2143)
    public void unsetOldMailAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOldMailAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * temporary RFC822 email address of this recipient for accepting mail
     * during account rename
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2143)
    public Map<String,Object> unsetOldMailAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOldMailAddress, "");
        return attrs;
    }

    /**
     * regex of allowed characters in password
     *
     * @return zimbraPasswordAllowedChars, or null if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1163)
    public String getPasswordAllowedChars() {
        return getAttr(Provisioning.A_zimbraPasswordAllowedChars, null, true);
    }

    /**
     * regex of allowed characters in password
     *
     * @param zimbraPasswordAllowedChars new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1163)
    public void setPasswordAllowedChars(String zimbraPasswordAllowedChars) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordAllowedChars, zimbraPasswordAllowedChars);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex of allowed characters in password
     *
     * @param zimbraPasswordAllowedChars new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1163)
    public Map<String,Object> setPasswordAllowedChars(String zimbraPasswordAllowedChars, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordAllowedChars, zimbraPasswordAllowedChars);
        return attrs;
    }

    /**
     * regex of allowed characters in password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1163)
    public void unsetPasswordAllowedChars() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordAllowedChars, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex of allowed characters in password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1163)
    public Map<String,Object> unsetPasswordAllowedChars(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordAllowedChars, "");
        return attrs;
    }

    /**
     * regex of allowed punctuation characters in password
     *
     * @return zimbraPasswordAllowedPunctuationChars, or null if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1256)
    public String getPasswordAllowedPunctuationChars() {
        return getAttr(Provisioning.A_zimbraPasswordAllowedPunctuationChars, null, true);
    }

    /**
     * regex of allowed punctuation characters in password
     *
     * @param zimbraPasswordAllowedPunctuationChars new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1256)
    public void setPasswordAllowedPunctuationChars(String zimbraPasswordAllowedPunctuationChars) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordAllowedPunctuationChars, zimbraPasswordAllowedPunctuationChars);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex of allowed punctuation characters in password
     *
     * @param zimbraPasswordAllowedPunctuationChars new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1256)
    public Map<String,Object> setPasswordAllowedPunctuationChars(String zimbraPasswordAllowedPunctuationChars, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordAllowedPunctuationChars, zimbraPasswordAllowedPunctuationChars);
        return attrs;
    }

    /**
     * regex of allowed punctuation characters in password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1256)
    public void unsetPasswordAllowedPunctuationChars() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordAllowedPunctuationChars, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex of allowed punctuation characters in password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1256)
    public Map<String,Object> unsetPasswordAllowedPunctuationChars(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordAllowedPunctuationChars, "");
        return attrs;
    }

    /**
     * whether or not blocking common passwords is enabled
     *
     * @return zimbraPasswordBlockCommonEnabled, or false if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3081)
    public boolean isPasswordBlockCommonEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPasswordBlockCommonEnabled, false, true);
    }

    /**
     * whether or not blocking common passwords is enabled
     *
     * @param zimbraPasswordBlockCommonEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3081)
    public void setPasswordBlockCommonEnabled(boolean zimbraPasswordBlockCommonEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordBlockCommonEnabled, zimbraPasswordBlockCommonEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not blocking common passwords is enabled
     *
     * @param zimbraPasswordBlockCommonEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3081)
    public Map<String,Object> setPasswordBlockCommonEnabled(boolean zimbraPasswordBlockCommonEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordBlockCommonEnabled, zimbraPasswordBlockCommonEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not blocking common passwords is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3081)
    public void unsetPasswordBlockCommonEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordBlockCommonEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not blocking common passwords is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3081)
    public Map<String,Object> unsetPasswordBlockCommonEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordBlockCommonEnabled, "");
        return attrs;
    }

    /**
     * whether or not to enforce password history. Number of unique passwords
     * a user must have before being allowed to re-use an old one. A value of
     * 0 means no password history.
     *
     * @return zimbraPasswordEnforceHistory, or 0 if unset
     */
    @ZAttr(id=37)
    public int getPasswordEnforceHistory() {
        return getIntAttr(Provisioning.A_zimbraPasswordEnforceHistory, 0, true);
    }

    /**
     * whether or not to enforce password history. Number of unique passwords
     * a user must have before being allowed to re-use an old one. A value of
     * 0 means no password history.
     *
     * @param zimbraPasswordEnforceHistory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=37)
    public void setPasswordEnforceHistory(int zimbraPasswordEnforceHistory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordEnforceHistory, Integer.toString(zimbraPasswordEnforceHistory));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to enforce password history. Number of unique passwords
     * a user must have before being allowed to re-use an old one. A value of
     * 0 means no password history.
     *
     * @param zimbraPasswordEnforceHistory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=37)
    public Map<String,Object> setPasswordEnforceHistory(int zimbraPasswordEnforceHistory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordEnforceHistory, Integer.toString(zimbraPasswordEnforceHistory));
        return attrs;
    }

    /**
     * whether or not to enforce password history. Number of unique passwords
     * a user must have before being allowed to re-use an old one. A value of
     * 0 means no password history.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=37)
    public void unsetPasswordEnforceHistory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordEnforceHistory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to enforce password history. Number of unique passwords
     * a user must have before being allowed to re-use an old one. A value of
     * 0 means no password history.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=37)
    public Map<String,Object> unsetPasswordEnforceHistory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordEnforceHistory, "");
        return attrs;
    }

    /**
     * historical password values
     *
     * @return zimbraPasswordHistory, or empty array if unset
     */
    @ZAttr(id=38)
    public String[] getPasswordHistory() {
        return getMultiAttr(Provisioning.A_zimbraPasswordHistory, true, true);
    }

    /**
     * historical password values
     *
     * @param zimbraPasswordHistory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=38)
    public void setPasswordHistory(String[] zimbraPasswordHistory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordHistory, zimbraPasswordHistory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * historical password values
     *
     * @param zimbraPasswordHistory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=38)
    public Map<String,Object> setPasswordHistory(String[] zimbraPasswordHistory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordHistory, zimbraPasswordHistory);
        return attrs;
    }

    /**
     * historical password values
     *
     * @param zimbraPasswordHistory new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=38)
    public void addPasswordHistory(String zimbraPasswordHistory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPasswordHistory, zimbraPasswordHistory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * historical password values
     *
     * @param zimbraPasswordHistory new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=38)
    public Map<String,Object> addPasswordHistory(String zimbraPasswordHistory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPasswordHistory, zimbraPasswordHistory);
        return attrs;
    }

    /**
     * historical password values
     *
     * @param zimbraPasswordHistory existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=38)
    public void removePasswordHistory(String zimbraPasswordHistory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPasswordHistory, zimbraPasswordHistory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * historical password values
     *
     * @param zimbraPasswordHistory existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=38)
    public Map<String,Object> removePasswordHistory(String zimbraPasswordHistory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPasswordHistory, zimbraPasswordHistory);
        return attrs;
    }

    /**
     * historical password values
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=38)
    public void unsetPasswordHistory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordHistory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * historical password values
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=38)
    public Map<String,Object> unsetPasswordHistory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordHistory, "");
        return attrs;
    }

    /**
     * user is unable to change password
     *
     * @return zimbraPasswordLocked, or false if unset
     */
    @ZAttr(id=45)
    public boolean isPasswordLocked() {
        return getBooleanAttr(Provisioning.A_zimbraPasswordLocked, false, true);
    }

    /**
     * user is unable to change password
     *
     * @param zimbraPasswordLocked new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=45)
    public void setPasswordLocked(boolean zimbraPasswordLocked) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLocked, zimbraPasswordLocked ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * user is unable to change password
     *
     * @param zimbraPasswordLocked new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=45)
    public Map<String,Object> setPasswordLocked(boolean zimbraPasswordLocked, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLocked, zimbraPasswordLocked ? TRUE : FALSE);
        return attrs;
    }

    /**
     * user is unable to change password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=45)
    public void unsetPasswordLocked() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLocked, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * user is unable to change password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=45)
    public Map<String,Object> unsetPasswordLocked(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLocked, "");
        return attrs;
    }

    /**
     * how long an account is locked out. Use 0 to lockout an account until
     * admin resets it. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPasswordLockoutDurationAsString to access value as a string.
     *
     * @see #getPasswordLockoutDurationAsString()
     *
     * @return zimbraPasswordLockoutDuration in millseconds, or 3600000 (1h)  if unset
     */
    @ZAttr(id=379)
    public long getPasswordLockoutDuration() {
        return getTimeInterval(Provisioning.A_zimbraPasswordLockoutDuration, 3600000L, true);
    }

    /**
     * how long an account is locked out. Use 0 to lockout an account until
     * admin resets it. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPasswordLockoutDuration, or "1h" if unset
     */
    @ZAttr(id=379)
    public String getPasswordLockoutDurationAsString() {
        return getAttr(Provisioning.A_zimbraPasswordLockoutDuration, "1h", true);
    }

    /**
     * how long an account is locked out. Use 0 to lockout an account until
     * admin resets it. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPasswordLockoutDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=379)
    public void setPasswordLockoutDuration(String zimbraPasswordLockoutDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutDuration, zimbraPasswordLockoutDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how long an account is locked out. Use 0 to lockout an account until
     * admin resets it. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPasswordLockoutDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=379)
    public Map<String,Object> setPasswordLockoutDuration(String zimbraPasswordLockoutDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutDuration, zimbraPasswordLockoutDuration);
        return attrs;
    }

    /**
     * how long an account is locked out. Use 0 to lockout an account until
     * admin resets it. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=379)
    public void unsetPasswordLockoutDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how long an account is locked out. Use 0 to lockout an account until
     * admin resets it. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=379)
    public Map<String,Object> unsetPasswordLockoutDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutDuration, "");
        return attrs;
    }

    /**
     * whether or not account lockout is enabled.
     *
     * @return zimbraPasswordLockoutEnabled, or false if unset
     */
    @ZAttr(id=378)
    public boolean isPasswordLockoutEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPasswordLockoutEnabled, false, true);
    }

    /**
     * whether or not account lockout is enabled.
     *
     * @param zimbraPasswordLockoutEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=378)
    public void setPasswordLockoutEnabled(boolean zimbraPasswordLockoutEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutEnabled, zimbraPasswordLockoutEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not account lockout is enabled.
     *
     * @param zimbraPasswordLockoutEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=378)
    public Map<String,Object> setPasswordLockoutEnabled(boolean zimbraPasswordLockoutEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutEnabled, zimbraPasswordLockoutEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not account lockout is enabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=378)
    public void unsetPasswordLockoutEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not account lockout is enabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=378)
    public Map<String,Object> unsetPasswordLockoutEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutEnabled, "");
        return attrs;
    }

    /**
     * the duration after which old consecutive failed login attempts are
     * purged from the list, even though no successful authentication has
     * occurred. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getPasswordLockoutFailureLifetimeAsString to access value as a string.
     *
     * @see #getPasswordLockoutFailureLifetimeAsString()
     *
     * @return zimbraPasswordLockoutFailureLifetime in millseconds, or 3600000 (1h)  if unset
     */
    @ZAttr(id=381)
    public long getPasswordLockoutFailureLifetime() {
        return getTimeInterval(Provisioning.A_zimbraPasswordLockoutFailureLifetime, 3600000L, true);
    }

    /**
     * the duration after which old consecutive failed login attempts are
     * purged from the list, even though no successful authentication has
     * occurred. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraPasswordLockoutFailureLifetime, or "1h" if unset
     */
    @ZAttr(id=381)
    public String getPasswordLockoutFailureLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraPasswordLockoutFailureLifetime, "1h", true);
    }

    /**
     * the duration after which old consecutive failed login attempts are
     * purged from the list, even though no successful authentication has
     * occurred. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraPasswordLockoutFailureLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=381)
    public void setPasswordLockoutFailureLifetime(String zimbraPasswordLockoutFailureLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureLifetime, zimbraPasswordLockoutFailureLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the duration after which old consecutive failed login attempts are
     * purged from the list, even though no successful authentication has
     * occurred. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraPasswordLockoutFailureLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=381)
    public Map<String,Object> setPasswordLockoutFailureLifetime(String zimbraPasswordLockoutFailureLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureLifetime, zimbraPasswordLockoutFailureLifetime);
        return attrs;
    }

    /**
     * the duration after which old consecutive failed login attempts are
     * purged from the list, even though no successful authentication has
     * occurred. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=381)
    public void unsetPasswordLockoutFailureLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the duration after which old consecutive failed login attempts are
     * purged from the list, even though no successful authentication has
     * occurred. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=381)
    public Map<String,Object> unsetPasswordLockoutFailureLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureLifetime, "");
        return attrs;
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * authentication failures made on an account
     *
     * @return zimbraPasswordLockoutFailureTime, or empty array if unset
     */
    @ZAttr(id=383)
    public String[] getPasswordLockoutFailureTimeAsString() {
        return getMultiAttr(Provisioning.A_zimbraPasswordLockoutFailureTime, true, true);
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * authentication failures made on an account
     *
     * @param zimbraPasswordLockoutFailureTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=383)
    public void setPasswordLockoutFailureTime(Date zimbraPasswordLockoutFailureTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureTime, zimbraPasswordLockoutFailureTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPasswordLockoutFailureTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * authentication failures made on an account
     *
     * @param zimbraPasswordLockoutFailureTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=383)
    public Map<String,Object> setPasswordLockoutFailureTime(Date zimbraPasswordLockoutFailureTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureTime, zimbraPasswordLockoutFailureTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPasswordLockoutFailureTime));
        return attrs;
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * authentication failures made on an account
     *
     * @param zimbraPasswordLockoutFailureTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=383)
    public void setPasswordLockoutFailureTimeAsString(String[] zimbraPasswordLockoutFailureTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureTime, zimbraPasswordLockoutFailureTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * authentication failures made on an account
     *
     * @param zimbraPasswordLockoutFailureTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=383)
    public Map<String,Object> setPasswordLockoutFailureTimeAsString(String[] zimbraPasswordLockoutFailureTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureTime, zimbraPasswordLockoutFailureTime);
        return attrs;
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * authentication failures made on an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=383)
    public void unsetPasswordLockoutFailureTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * authentication failures made on an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=383)
    public Map<String,Object> unsetPasswordLockoutFailureTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutFailureTime, "");
        return attrs;
    }

    /**
     * the time at which an account was locked
     *
     * <p>Use getPasswordLockoutLockedTimeAsString to access value as a string.
     *
     * @see #getPasswordLockoutLockedTimeAsString()
     *
     * @return zimbraPasswordLockoutLockedTime as Date, null if unset or unable to parse
     */
    @ZAttr(id=382)
    public Date getPasswordLockoutLockedTime() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraPasswordLockoutLockedTime, null, true);
    }

    /**
     * the time at which an account was locked
     *
     * @return zimbraPasswordLockoutLockedTime, or null if unset
     */
    @ZAttr(id=382)
    public String getPasswordLockoutLockedTimeAsString() {
        return getAttr(Provisioning.A_zimbraPasswordLockoutLockedTime, null, true);
    }

    /**
     * the time at which an account was locked
     *
     * @param zimbraPasswordLockoutLockedTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=382)
    public void setPasswordLockoutLockedTime(Date zimbraPasswordLockoutLockedTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutLockedTime, zimbraPasswordLockoutLockedTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPasswordLockoutLockedTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the time at which an account was locked
     *
     * @param zimbraPasswordLockoutLockedTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=382)
    public Map<String,Object> setPasswordLockoutLockedTime(Date zimbraPasswordLockoutLockedTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutLockedTime, zimbraPasswordLockoutLockedTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPasswordLockoutLockedTime));
        return attrs;
    }

    /**
     * the time at which an account was locked
     *
     * @param zimbraPasswordLockoutLockedTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=382)
    public void setPasswordLockoutLockedTimeAsString(String zimbraPasswordLockoutLockedTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutLockedTime, zimbraPasswordLockoutLockedTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the time at which an account was locked
     *
     * @param zimbraPasswordLockoutLockedTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=382)
    public Map<String,Object> setPasswordLockoutLockedTimeAsString(String zimbraPasswordLockoutLockedTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutLockedTime, zimbraPasswordLockoutLockedTime);
        return attrs;
    }

    /**
     * the time at which an account was locked
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=382)
    public void unsetPasswordLockoutLockedTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutLockedTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the time at which an account was locked
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=382)
    public Map<String,Object> unsetPasswordLockoutLockedTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutLockedTime, "");
        return attrs;
    }

    /**
     * number of consecutive failed login attempts until an account is locked
     * out
     *
     * @return zimbraPasswordLockoutMaxFailures, or 10 if unset
     */
    @ZAttr(id=380)
    public int getPasswordLockoutMaxFailures() {
        return getIntAttr(Provisioning.A_zimbraPasswordLockoutMaxFailures, 10, true);
    }

    /**
     * number of consecutive failed login attempts until an account is locked
     * out
     *
     * @param zimbraPasswordLockoutMaxFailures new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=380)
    public void setPasswordLockoutMaxFailures(int zimbraPasswordLockoutMaxFailures) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutMaxFailures, Integer.toString(zimbraPasswordLockoutMaxFailures));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of consecutive failed login attempts until an account is locked
     * out
     *
     * @param zimbraPasswordLockoutMaxFailures new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=380)
    public Map<String,Object> setPasswordLockoutMaxFailures(int zimbraPasswordLockoutMaxFailures, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutMaxFailures, Integer.toString(zimbraPasswordLockoutMaxFailures));
        return attrs;
    }

    /**
     * number of consecutive failed login attempts until an account is locked
     * out
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=380)
    public void unsetPasswordLockoutMaxFailures() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutMaxFailures, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of consecutive failed login attempts until an account is locked
     * out
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=380)
    public Map<String,Object> unsetPasswordLockoutMaxFailures(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutMaxFailures, "");
        return attrs;
    }

    /**
     * Number of invalid passwords kept in a cache per account. Any number of
     * login attempts using password present in cache will be considered as
     * single failed attempt. If Twofactor authentication enabled the cache
     * size will be sum of zimbraPasswordLockoutSuppressionCacheSize and
     * number of application specific password generated.
     *
     * @return zimbraPasswordLockoutSuppressionCacheSize, or 1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2086)
    public int getPasswordLockoutSuppressionCacheSize() {
        return getIntAttr(Provisioning.A_zimbraPasswordLockoutSuppressionCacheSize, 1, true);
    }

    /**
     * Number of invalid passwords kept in a cache per account. Any number of
     * login attempts using password present in cache will be considered as
     * single failed attempt. If Twofactor authentication enabled the cache
     * size will be sum of zimbraPasswordLockoutSuppressionCacheSize and
     * number of application specific password generated.
     *
     * @param zimbraPasswordLockoutSuppressionCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2086)
    public void setPasswordLockoutSuppressionCacheSize(int zimbraPasswordLockoutSuppressionCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionCacheSize, Integer.toString(zimbraPasswordLockoutSuppressionCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of invalid passwords kept in a cache per account. Any number of
     * login attempts using password present in cache will be considered as
     * single failed attempt. If Twofactor authentication enabled the cache
     * size will be sum of zimbraPasswordLockoutSuppressionCacheSize and
     * number of application specific password generated.
     *
     * @param zimbraPasswordLockoutSuppressionCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2086)
    public Map<String,Object> setPasswordLockoutSuppressionCacheSize(int zimbraPasswordLockoutSuppressionCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionCacheSize, Integer.toString(zimbraPasswordLockoutSuppressionCacheSize));
        return attrs;
    }

    /**
     * Number of invalid passwords kept in a cache per account. Any number of
     * login attempts using password present in cache will be considered as
     * single failed attempt. If Twofactor authentication enabled the cache
     * size will be sum of zimbraPasswordLockoutSuppressionCacheSize and
     * number of application specific password generated.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2086)
    public void unsetPasswordLockoutSuppressionCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of invalid passwords kept in a cache per account. Any number of
     * login attempts using password present in cache will be considered as
     * single failed attempt. If Twofactor authentication enabled the cache
     * size will be sum of zimbraPasswordLockoutSuppressionCacheSize and
     * number of application specific password generated.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2086)
    public Map<String,Object> unsetPasswordLockoutSuppressionCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionCacheSize, "");
        return attrs;
    }

    /**
     * If TRUE it will not increment the repeated failed login attempt using
     * old or invalid password from
     * zimbraPasswordLockoutSuppressionProtocols.
     *
     * @return zimbraPasswordLockoutSuppressionEnabled, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2087)
    public boolean isPasswordLockoutSuppressionEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPasswordLockoutSuppressionEnabled, true, true);
    }

    /**
     * If TRUE it will not increment the repeated failed login attempt using
     * old or invalid password from
     * zimbraPasswordLockoutSuppressionProtocols.
     *
     * @param zimbraPasswordLockoutSuppressionEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2087)
    public void setPasswordLockoutSuppressionEnabled(boolean zimbraPasswordLockoutSuppressionEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionEnabled, zimbraPasswordLockoutSuppressionEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE it will not increment the repeated failed login attempt using
     * old or invalid password from
     * zimbraPasswordLockoutSuppressionProtocols.
     *
     * @param zimbraPasswordLockoutSuppressionEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2087)
    public Map<String,Object> setPasswordLockoutSuppressionEnabled(boolean zimbraPasswordLockoutSuppressionEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionEnabled, zimbraPasswordLockoutSuppressionEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE it will not increment the repeated failed login attempt using
     * old or invalid password from
     * zimbraPasswordLockoutSuppressionProtocols.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2087)
    public void unsetPasswordLockoutSuppressionEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE it will not increment the repeated failed login attempt using
     * old or invalid password from
     * zimbraPasswordLockoutSuppressionProtocols.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2087)
    public Map<String,Object> unsetPasswordLockoutSuppressionEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionEnabled, "");
        return attrs;
    }

    /**
     * Protocols for which repeated failed login attempts with same password
     * considered as single failure. Supported protocols
     * zsync,imap,pop3,http_basic,http_dav,soap.
     *
     * <p>Valid values: [zsync, imap, pop3, http_basic, http_dav, soap]
     *
     * @return zimbraPasswordLockoutSuppressionProtocols, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2088)
    public String[] getPasswordLockoutSuppressionProtocolsAsString() {
        String[] value = getMultiAttr(Provisioning.A_zimbraPasswordLockoutSuppressionProtocols, true, true); return value.length > 0 ? value : new String[] {"zsync"};
    }

    /**
     * Protocols for which repeated failed login attempts with same password
     * considered as single failure. Supported protocols
     * zsync,imap,pop3,http_basic,http_dav,soap.
     *
     * <p>Valid values: [zsync, imap, pop3, http_basic, http_dav, soap]
     *
     * @param zimbraPasswordLockoutSuppressionProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2088)
    public void setPasswordLockoutSuppressionProtocols(ZAttrProvisioning.PasswordLockoutSuppressionProtocols zimbraPasswordLockoutSuppressionProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionProtocols, zimbraPasswordLockoutSuppressionProtocols.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Protocols for which repeated failed login attempts with same password
     * considered as single failure. Supported protocols
     * zsync,imap,pop3,http_basic,http_dav,soap.
     *
     * <p>Valid values: [zsync, imap, pop3, http_basic, http_dav, soap]
     *
     * @param zimbraPasswordLockoutSuppressionProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2088)
    public Map<String,Object> setPasswordLockoutSuppressionProtocols(ZAttrProvisioning.PasswordLockoutSuppressionProtocols zimbraPasswordLockoutSuppressionProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionProtocols, zimbraPasswordLockoutSuppressionProtocols.toString());
        return attrs;
    }

    /**
     * Protocols for which repeated failed login attempts with same password
     * considered as single failure. Supported protocols
     * zsync,imap,pop3,http_basic,http_dav,soap.
     *
     * <p>Valid values: [zsync, imap, pop3, http_basic, http_dav, soap]
     *
     * @param zimbraPasswordLockoutSuppressionProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2088)
    public void setPasswordLockoutSuppressionProtocolsAsString(String[] zimbraPasswordLockoutSuppressionProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionProtocols, zimbraPasswordLockoutSuppressionProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Protocols for which repeated failed login attempts with same password
     * considered as single failure. Supported protocols
     * zsync,imap,pop3,http_basic,http_dav,soap.
     *
     * <p>Valid values: [zsync, imap, pop3, http_basic, http_dav, soap]
     *
     * @param zimbraPasswordLockoutSuppressionProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2088)
    public Map<String,Object> setPasswordLockoutSuppressionProtocolsAsString(String[] zimbraPasswordLockoutSuppressionProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionProtocols, zimbraPasswordLockoutSuppressionProtocols);
        return attrs;
    }

    /**
     * Protocols for which repeated failed login attempts with same password
     * considered as single failure. Supported protocols
     * zsync,imap,pop3,http_basic,http_dav,soap.
     *
     * <p>Valid values: [zsync, imap, pop3, http_basic, http_dav, soap]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2088)
    public void unsetPasswordLockoutSuppressionProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Protocols for which repeated failed login attempts with same password
     * considered as single failure. Supported protocols
     * zsync,imap,pop3,http_basic,http_dav,soap.
     *
     * <p>Valid values: [zsync, imap, pop3, http_basic, http_dav, soap]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2088)
    public Map<String,Object> unsetPasswordLockoutSuppressionProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordLockoutSuppressionProtocols, "");
        return attrs;
    }

    /**
     * maximum days between password changes
     *
     * @return zimbraPasswordMaxAge, or 0 if unset
     */
    @ZAttr(id=36)
    public int getPasswordMaxAge() {
        return getIntAttr(Provisioning.A_zimbraPasswordMaxAge, 0, true);
    }

    /**
     * maximum days between password changes
     *
     * @param zimbraPasswordMaxAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=36)
    public void setPasswordMaxAge(int zimbraPasswordMaxAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMaxAge, Integer.toString(zimbraPasswordMaxAge));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum days between password changes
     *
     * @param zimbraPasswordMaxAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=36)
    public Map<String,Object> setPasswordMaxAge(int zimbraPasswordMaxAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMaxAge, Integer.toString(zimbraPasswordMaxAge));
        return attrs;
    }

    /**
     * maximum days between password changes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=36)
    public void unsetPasswordMaxAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMaxAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum days between password changes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=36)
    public Map<String,Object> unsetPasswordMaxAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMaxAge, "");
        return attrs;
    }

    /**
     * max length of a password
     *
     * @return zimbraPasswordMaxLength, or 64 if unset
     */
    @ZAttr(id=34)
    public int getPasswordMaxLength() {
        return getIntAttr(Provisioning.A_zimbraPasswordMaxLength, 64, true);
    }

    /**
     * max length of a password
     *
     * @param zimbraPasswordMaxLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=34)
    public void setPasswordMaxLength(int zimbraPasswordMaxLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMaxLength, Integer.toString(zimbraPasswordMaxLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max length of a password
     *
     * @param zimbraPasswordMaxLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=34)
    public Map<String,Object> setPasswordMaxLength(int zimbraPasswordMaxLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMaxLength, Integer.toString(zimbraPasswordMaxLength));
        return attrs;
    }

    /**
     * max length of a password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=34)
    public void unsetPasswordMaxLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMaxLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max length of a password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=34)
    public Map<String,Object> unsetPasswordMaxLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMaxLength, "");
        return attrs;
    }

    /**
     * minimum days between password changes
     *
     * @return zimbraPasswordMinAge, or 0 if unset
     */
    @ZAttr(id=35)
    public int getPasswordMinAge() {
        return getIntAttr(Provisioning.A_zimbraPasswordMinAge, 0, true);
    }

    /**
     * minimum days between password changes
     *
     * @param zimbraPasswordMinAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=35)
    public void setPasswordMinAge(int zimbraPasswordMinAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinAge, Integer.toString(zimbraPasswordMinAge));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum days between password changes
     *
     * @param zimbraPasswordMinAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=35)
    public Map<String,Object> setPasswordMinAge(int zimbraPasswordMinAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinAge, Integer.toString(zimbraPasswordMinAge));
        return attrs;
    }

    /**
     * minimum days between password changes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=35)
    public void unsetPasswordMinAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum days between password changes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=35)
    public Map<String,Object> unsetPasswordMinAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinAge, "");
        return attrs;
    }

    /**
     * minimum number of alphabet characters required in a password
     *
     * @return zimbraPasswordMinAlphaChars, or 0 if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1162)
    public int getPasswordMinAlphaChars() {
        return getIntAttr(Provisioning.A_zimbraPasswordMinAlphaChars, 0, true);
    }

    /**
     * minimum number of alphabet characters required in a password
     *
     * @param zimbraPasswordMinAlphaChars new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1162)
    public void setPasswordMinAlphaChars(int zimbraPasswordMinAlphaChars) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinAlphaChars, Integer.toString(zimbraPasswordMinAlphaChars));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of alphabet characters required in a password
     *
     * @param zimbraPasswordMinAlphaChars new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1162)
    public Map<String,Object> setPasswordMinAlphaChars(int zimbraPasswordMinAlphaChars, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinAlphaChars, Integer.toString(zimbraPasswordMinAlphaChars));
        return attrs;
    }

    /**
     * minimum number of alphabet characters required in a password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1162)
    public void unsetPasswordMinAlphaChars() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinAlphaChars, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of alphabet characters required in a password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1162)
    public Map<String,Object> unsetPasswordMinAlphaChars(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinAlphaChars, "");
        return attrs;
    }

    /**
     * minimum number of numeric or ascii punctuation characters required in
     * a password
     *
     * @return zimbraPasswordMinDigitsOrPuncs, or 0 if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1255)
    public int getPasswordMinDigitsOrPuncs() {
        return getIntAttr(Provisioning.A_zimbraPasswordMinDigitsOrPuncs, 0, true);
    }

    /**
     * minimum number of numeric or ascii punctuation characters required in
     * a password
     *
     * @param zimbraPasswordMinDigitsOrPuncs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1255)
    public void setPasswordMinDigitsOrPuncs(int zimbraPasswordMinDigitsOrPuncs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinDigitsOrPuncs, Integer.toString(zimbraPasswordMinDigitsOrPuncs));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of numeric or ascii punctuation characters required in
     * a password
     *
     * @param zimbraPasswordMinDigitsOrPuncs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1255)
    public Map<String,Object> setPasswordMinDigitsOrPuncs(int zimbraPasswordMinDigitsOrPuncs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinDigitsOrPuncs, Integer.toString(zimbraPasswordMinDigitsOrPuncs));
        return attrs;
    }

    /**
     * minimum number of numeric or ascii punctuation characters required in
     * a password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1255)
    public void unsetPasswordMinDigitsOrPuncs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinDigitsOrPuncs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of numeric or ascii punctuation characters required in
     * a password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1255)
    public Map<String,Object> unsetPasswordMinDigitsOrPuncs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinDigitsOrPuncs, "");
        return attrs;
    }

    /**
     * minimum length of a password
     *
     * @return zimbraPasswordMinLength, or 6 if unset
     */
    @ZAttr(id=33)
    public int getPasswordMinLength() {
        return getIntAttr(Provisioning.A_zimbraPasswordMinLength, 6, true);
    }

    /**
     * minimum length of a password
     *
     * @param zimbraPasswordMinLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=33)
    public void setPasswordMinLength(int zimbraPasswordMinLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinLength, Integer.toString(zimbraPasswordMinLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum length of a password
     *
     * @param zimbraPasswordMinLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=33)
    public Map<String,Object> setPasswordMinLength(int zimbraPasswordMinLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinLength, Integer.toString(zimbraPasswordMinLength));
        return attrs;
    }

    /**
     * minimum length of a password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=33)
    public void unsetPasswordMinLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum length of a password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=33)
    public Map<String,Object> unsetPasswordMinLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinLength, "");
        return attrs;
    }

    /**
     * minimum number of lower case characters required in a password
     *
     * @return zimbraPasswordMinLowerCaseChars, or 0 if unset
     */
    @ZAttr(id=390)
    public int getPasswordMinLowerCaseChars() {
        return getIntAttr(Provisioning.A_zimbraPasswordMinLowerCaseChars, 0, true);
    }

    /**
     * minimum number of lower case characters required in a password
     *
     * @param zimbraPasswordMinLowerCaseChars new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=390)
    public void setPasswordMinLowerCaseChars(int zimbraPasswordMinLowerCaseChars) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinLowerCaseChars, Integer.toString(zimbraPasswordMinLowerCaseChars));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of lower case characters required in a password
     *
     * @param zimbraPasswordMinLowerCaseChars new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=390)
    public Map<String,Object> setPasswordMinLowerCaseChars(int zimbraPasswordMinLowerCaseChars, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinLowerCaseChars, Integer.toString(zimbraPasswordMinLowerCaseChars));
        return attrs;
    }

    /**
     * minimum number of lower case characters required in a password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=390)
    public void unsetPasswordMinLowerCaseChars() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinLowerCaseChars, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of lower case characters required in a password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=390)
    public Map<String,Object> unsetPasswordMinLowerCaseChars(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinLowerCaseChars, "");
        return attrs;
    }

    /**
     * minimum number of numeric characters required in a password
     *
     * @return zimbraPasswordMinNumericChars, or 0 if unset
     */
    @ZAttr(id=392)
    public int getPasswordMinNumericChars() {
        return getIntAttr(Provisioning.A_zimbraPasswordMinNumericChars, 0, true);
    }

    /**
     * minimum number of numeric characters required in a password
     *
     * @param zimbraPasswordMinNumericChars new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=392)
    public void setPasswordMinNumericChars(int zimbraPasswordMinNumericChars) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinNumericChars, Integer.toString(zimbraPasswordMinNumericChars));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of numeric characters required in a password
     *
     * @param zimbraPasswordMinNumericChars new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=392)
    public Map<String,Object> setPasswordMinNumericChars(int zimbraPasswordMinNumericChars, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinNumericChars, Integer.toString(zimbraPasswordMinNumericChars));
        return attrs;
    }

    /**
     * minimum number of numeric characters required in a password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=392)
    public void unsetPasswordMinNumericChars() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinNumericChars, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of numeric characters required in a password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=392)
    public Map<String,Object> unsetPasswordMinNumericChars(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinNumericChars, "");
        return attrs;
    }

    /**
     * minimum number of ascii punctuation characters required in a password
     *
     * @return zimbraPasswordMinPunctuationChars, or 0 if unset
     */
    @ZAttr(id=391)
    public int getPasswordMinPunctuationChars() {
        return getIntAttr(Provisioning.A_zimbraPasswordMinPunctuationChars, 0, true);
    }

    /**
     * minimum number of ascii punctuation characters required in a password
     *
     * @param zimbraPasswordMinPunctuationChars new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=391)
    public void setPasswordMinPunctuationChars(int zimbraPasswordMinPunctuationChars) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinPunctuationChars, Integer.toString(zimbraPasswordMinPunctuationChars));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of ascii punctuation characters required in a password
     *
     * @param zimbraPasswordMinPunctuationChars new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=391)
    public Map<String,Object> setPasswordMinPunctuationChars(int zimbraPasswordMinPunctuationChars, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinPunctuationChars, Integer.toString(zimbraPasswordMinPunctuationChars));
        return attrs;
    }

    /**
     * minimum number of ascii punctuation characters required in a password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=391)
    public void unsetPasswordMinPunctuationChars() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinPunctuationChars, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of ascii punctuation characters required in a password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=391)
    public Map<String,Object> unsetPasswordMinPunctuationChars(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinPunctuationChars, "");
        return attrs;
    }

    /**
     * minimum number of upper case characters required in a password
     *
     * @return zimbraPasswordMinUpperCaseChars, or 0 if unset
     */
    @ZAttr(id=389)
    public int getPasswordMinUpperCaseChars() {
        return getIntAttr(Provisioning.A_zimbraPasswordMinUpperCaseChars, 0, true);
    }

    /**
     * minimum number of upper case characters required in a password
     *
     * @param zimbraPasswordMinUpperCaseChars new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=389)
    public void setPasswordMinUpperCaseChars(int zimbraPasswordMinUpperCaseChars) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinUpperCaseChars, Integer.toString(zimbraPasswordMinUpperCaseChars));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of upper case characters required in a password
     *
     * @param zimbraPasswordMinUpperCaseChars new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=389)
    public Map<String,Object> setPasswordMinUpperCaseChars(int zimbraPasswordMinUpperCaseChars, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinUpperCaseChars, Integer.toString(zimbraPasswordMinUpperCaseChars));
        return attrs;
    }

    /**
     * minimum number of upper case characters required in a password
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=389)
    public void unsetPasswordMinUpperCaseChars() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinUpperCaseChars, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of upper case characters required in a password
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=389)
    public Map<String,Object> unsetPasswordMinUpperCaseChars(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMinUpperCaseChars, "");
        return attrs;
    }

    /**
     * time password was last changed
     *
     * <p>Use getPasswordModifiedTimeAsString to access value as a string.
     *
     * @see #getPasswordModifiedTimeAsString()
     *
     * @return zimbraPasswordModifiedTime as Date, null if unset or unable to parse
     */
    @ZAttr(id=39)
    public Date getPasswordModifiedTime() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraPasswordModifiedTime, null, true);
    }

    /**
     * time password was last changed
     *
     * @return zimbraPasswordModifiedTime, or null if unset
     */
    @ZAttr(id=39)
    public String getPasswordModifiedTimeAsString() {
        return getAttr(Provisioning.A_zimbraPasswordModifiedTime, null, true);
    }

    /**
     * time password was last changed
     *
     * @param zimbraPasswordModifiedTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=39)
    public void setPasswordModifiedTime(Date zimbraPasswordModifiedTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordModifiedTime, zimbraPasswordModifiedTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPasswordModifiedTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time password was last changed
     *
     * @param zimbraPasswordModifiedTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=39)
    public Map<String,Object> setPasswordModifiedTime(Date zimbraPasswordModifiedTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordModifiedTime, zimbraPasswordModifiedTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPasswordModifiedTime));
        return attrs;
    }

    /**
     * time password was last changed
     *
     * @param zimbraPasswordModifiedTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=39)
    public void setPasswordModifiedTimeAsString(String zimbraPasswordModifiedTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordModifiedTime, zimbraPasswordModifiedTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time password was last changed
     *
     * @param zimbraPasswordModifiedTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=39)
    public Map<String,Object> setPasswordModifiedTimeAsString(String zimbraPasswordModifiedTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordModifiedTime, zimbraPasswordModifiedTime);
        return attrs;
    }

    /**
     * time password was last changed
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=39)
    public void unsetPasswordModifiedTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordModifiedTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time password was last changed
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=39)
    public Map<String,Object> unsetPasswordModifiedTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordModifiedTime, "");
        return attrs;
    }

    /**
     * must change password on auth
     *
     * @return zimbraPasswordMustChange, or false if unset
     */
    @ZAttr(id=41)
    public boolean isPasswordMustChange() {
        return getBooleanAttr(Provisioning.A_zimbraPasswordMustChange, false, true);
    }

    /**
     * must change password on auth
     *
     * @param zimbraPasswordMustChange new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=41)
    public void setPasswordMustChange(boolean zimbraPasswordMustChange) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMustChange, zimbraPasswordMustChange ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * must change password on auth
     *
     * @param zimbraPasswordMustChange new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=41)
    public Map<String,Object> setPasswordMustChange(boolean zimbraPasswordMustChange, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMustChange, zimbraPasswordMustChange ? TRUE : FALSE);
        return attrs;
    }

    /**
     * must change password on auth
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=41)
    public void unsetPasswordMustChange() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMustChange, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * must change password on auth
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=41)
    public Map<String,Object> unsetPasswordMustChange(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordMustChange, "");
        return attrs;
    }

    /**
     * Maximum attempts for password recovery resend
     *
     * @return zimbraPasswordRecoveryMaxAttempts, or 10 if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2141)
    public int getPasswordRecoveryMaxAttempts() {
        return getIntAttr(Provisioning.A_zimbraPasswordRecoveryMaxAttempts, 10, true);
    }

    /**
     * Maximum attempts for password recovery resend
     *
     * @param zimbraPasswordRecoveryMaxAttempts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2141)
    public void setPasswordRecoveryMaxAttempts(int zimbraPasswordRecoveryMaxAttempts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordRecoveryMaxAttempts, Integer.toString(zimbraPasswordRecoveryMaxAttempts));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum attempts for password recovery resend
     *
     * @param zimbraPasswordRecoveryMaxAttempts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2141)
    public Map<String,Object> setPasswordRecoveryMaxAttempts(int zimbraPasswordRecoveryMaxAttempts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordRecoveryMaxAttempts, Integer.toString(zimbraPasswordRecoveryMaxAttempts));
        return attrs;
    }

    /**
     * Maximum attempts for password recovery resend
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2141)
    public void unsetPasswordRecoveryMaxAttempts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordRecoveryMaxAttempts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum attempts for password recovery resend
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2141)
    public Map<String,Object> unsetPasswordRecoveryMaxAttempts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordRecoveryMaxAttempts, "");
        return attrs;
    }

    /**
     * phonetic company name
     *
     * @return zimbraPhoneticCompany, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1149)
    public String getPhoneticCompany() {
        return getAttr(Provisioning.A_zimbraPhoneticCompany, null, true);
    }

    /**
     * phonetic company name
     *
     * @param zimbraPhoneticCompany new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1149)
    public void setPhoneticCompany(String zimbraPhoneticCompany) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticCompany, zimbraPhoneticCompany);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * phonetic company name
     *
     * @param zimbraPhoneticCompany new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1149)
    public Map<String,Object> setPhoneticCompany(String zimbraPhoneticCompany, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticCompany, zimbraPhoneticCompany);
        return attrs;
    }

    /**
     * phonetic company name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1149)
    public void unsetPhoneticCompany() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticCompany, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * phonetic company name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1149)
    public Map<String,Object> unsetPhoneticCompany(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticCompany, "");
        return attrs;
    }

    /**
     * phonetic first name
     *
     * @return zimbraPhoneticFirstName, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1147)
    public String getPhoneticFirstName() {
        return getAttr(Provisioning.A_zimbraPhoneticFirstName, null, true);
    }

    /**
     * phonetic first name
     *
     * @param zimbraPhoneticFirstName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1147)
    public void setPhoneticFirstName(String zimbraPhoneticFirstName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticFirstName, zimbraPhoneticFirstName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * phonetic first name
     *
     * @param zimbraPhoneticFirstName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1147)
    public Map<String,Object> setPhoneticFirstName(String zimbraPhoneticFirstName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticFirstName, zimbraPhoneticFirstName);
        return attrs;
    }

    /**
     * phonetic first name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1147)
    public void unsetPhoneticFirstName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticFirstName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * phonetic first name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1147)
    public Map<String,Object> unsetPhoneticFirstName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticFirstName, "");
        return attrs;
    }

    /**
     * phonetic last name
     *
     * @return zimbraPhoneticLastName, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1148)
    public String getPhoneticLastName() {
        return getAttr(Provisioning.A_zimbraPhoneticLastName, null, true);
    }

    /**
     * phonetic last name
     *
     * @param zimbraPhoneticLastName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1148)
    public void setPhoneticLastName(String zimbraPhoneticLastName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticLastName, zimbraPhoneticLastName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * phonetic last name
     *
     * @param zimbraPhoneticLastName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1148)
    public Map<String,Object> setPhoneticLastName(String zimbraPhoneticLastName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticLastName, zimbraPhoneticLastName);
        return attrs;
    }

    /**
     * phonetic last name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1148)
    public void unsetPhoneticLastName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticLastName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * phonetic last name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1148)
    public Map<String,Object> unsetPhoneticLastName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPhoneticLastName, "");
        return attrs;
    }

    /**
     * whether POP3 is enabled for an account
     *
     * @return zimbraPop3Enabled, or true if unset
     */
    @ZAttr(id=175)
    public boolean isPop3Enabled() {
        return getBooleanAttr(Provisioning.A_zimbraPop3Enabled, true, true);
    }

    /**
     * whether POP3 is enabled for an account
     *
     * @param zimbraPop3Enabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=175)
    public void setPop3Enabled(boolean zimbraPop3Enabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3Enabled, zimbraPop3Enabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 is enabled for an account
     *
     * @param zimbraPop3Enabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=175)
    public Map<String,Object> setPop3Enabled(boolean zimbraPop3Enabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3Enabled, zimbraPop3Enabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether POP3 is enabled for an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=175)
    public void unsetPop3Enabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3Enabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 is enabled for an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=175)
    public Map<String,Object> unsetPop3Enabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3Enabled, "");
        return attrs;
    }

    /**
     * portal name
     *
     * @return zimbraPortalName, or "example" if unset
     */
    @ZAttr(id=448)
    public String getPortalName() {
        return getAttr(Provisioning.A_zimbraPortalName, "example", true);
    }

    /**
     * portal name
     *
     * @param zimbraPortalName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=448)
    public void setPortalName(String zimbraPortalName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPortalName, zimbraPortalName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * portal name
     *
     * @param zimbraPortalName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=448)
    public Map<String,Object> setPortalName(String zimbraPortalName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPortalName, zimbraPortalName);
        return attrs;
    }

    /**
     * portal name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=448)
    public void unsetPortalName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPortalName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * portal name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=448)
    public Map<String,Object> unsetPortalName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPortalName, "");
        return attrs;
    }

    /**
     * whether or not the user has accepted the client&#039;s terms of
     * service
     *
     * @return zimbraPrefAcceptedClientTOS, or false if unset
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3068)
    public boolean isPrefAcceptedClientTOS() {
        return getBooleanAttr(Provisioning.A_zimbraPrefAcceptedClientTOS, false, true);
    }

    /**
     * whether or not the user has accepted the client&#039;s terms of
     * service
     *
     * @param zimbraPrefAcceptedClientTOS new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3068)
    public void setPrefAcceptedClientTOS(boolean zimbraPrefAcceptedClientTOS) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAcceptedClientTOS, zimbraPrefAcceptedClientTOS ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not the user has accepted the client&#039;s terms of
     * service
     *
     * @param zimbraPrefAcceptedClientTOS new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3068)
    public Map<String,Object> setPrefAcceptedClientTOS(boolean zimbraPrefAcceptedClientTOS, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAcceptedClientTOS, zimbraPrefAcceptedClientTOS ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not the user has accepted the client&#039;s terms of
     * service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3068)
    public void unsetPrefAcceptedClientTOS() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAcceptedClientTOS, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not the user has accepted the client&#039;s terms of
     * service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3068)
    public Map<String,Object> unsetPrefAcceptedClientTOS(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAcceptedClientTOS, "");
        return attrs;
    }

    /**
     * whether or not account tree is expanded
     *
     * @return zimbraPrefAccountTreeOpen, or true if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1048)
    public boolean isPrefAccountTreeOpen() {
        return getBooleanAttr(Provisioning.A_zimbraPrefAccountTreeOpen, true, true);
    }

    /**
     * whether or not account tree is expanded
     *
     * @param zimbraPrefAccountTreeOpen new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1048)
    public void setPrefAccountTreeOpen(boolean zimbraPrefAccountTreeOpen) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAccountTreeOpen, zimbraPrefAccountTreeOpen ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not account tree is expanded
     *
     * @param zimbraPrefAccountTreeOpen new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1048)
    public Map<String,Object> setPrefAccountTreeOpen(boolean zimbraPrefAccountTreeOpen, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAccountTreeOpen, zimbraPrefAccountTreeOpen ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not account tree is expanded
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1048)
    public void unsetPrefAccountTreeOpen() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAccountTreeOpen, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not account tree is expanded
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1048)
    public Map<String,Object> unsetPrefAccountTreeOpen(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAccountTreeOpen, "");
        return attrs;
    }

    /**
     * whether to display a warning when users try to navigate away from the
     * admin console
     *
     * @return zimbraPrefAdminConsoleWarnOnExit, or true if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1036)
    public boolean isPrefAdminConsoleWarnOnExit() {
        return getBooleanAttr(Provisioning.A_zimbraPrefAdminConsoleWarnOnExit, true, true);
    }

    /**
     * whether to display a warning when users try to navigate away from the
     * admin console
     *
     * @param zimbraPrefAdminConsoleWarnOnExit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1036)
    public void setPrefAdminConsoleWarnOnExit(boolean zimbraPrefAdminConsoleWarnOnExit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAdminConsoleWarnOnExit, zimbraPrefAdminConsoleWarnOnExit ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display a warning when users try to navigate away from the
     * admin console
     *
     * @param zimbraPrefAdminConsoleWarnOnExit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1036)
    public Map<String,Object> setPrefAdminConsoleWarnOnExit(boolean zimbraPrefAdminConsoleWarnOnExit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAdminConsoleWarnOnExit, zimbraPrefAdminConsoleWarnOnExit ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to display a warning when users try to navigate away from the
     * admin console
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1036)
    public void unsetPrefAdminConsoleWarnOnExit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAdminConsoleWarnOnExit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display a warning when users try to navigate away from the
     * admin console
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1036)
    public Map<String,Object> unsetPrefAdminConsoleWarnOnExit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAdminConsoleWarnOnExit, "");
        return attrs;
    }

    /**
     * After login, whether the advanced client should enforce minimum
     * display resolution
     *
     * @return zimbraPrefAdvancedClientEnforceMinDisplay, or true if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=678)
    public boolean isPrefAdvancedClientEnforceMinDisplay() {
        return getBooleanAttr(Provisioning.A_zimbraPrefAdvancedClientEnforceMinDisplay, true, true);
    }

    /**
     * After login, whether the advanced client should enforce minimum
     * display resolution
     *
     * @param zimbraPrefAdvancedClientEnforceMinDisplay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=678)
    public void setPrefAdvancedClientEnforceMinDisplay(boolean zimbraPrefAdvancedClientEnforceMinDisplay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAdvancedClientEnforceMinDisplay, zimbraPrefAdvancedClientEnforceMinDisplay ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * After login, whether the advanced client should enforce minimum
     * display resolution
     *
     * @param zimbraPrefAdvancedClientEnforceMinDisplay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=678)
    public Map<String,Object> setPrefAdvancedClientEnforceMinDisplay(boolean zimbraPrefAdvancedClientEnforceMinDisplay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAdvancedClientEnforceMinDisplay, zimbraPrefAdvancedClientEnforceMinDisplay ? TRUE : FALSE);
        return attrs;
    }

    /**
     * After login, whether the advanced client should enforce minimum
     * display resolution
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=678)
    public void unsetPrefAdvancedClientEnforceMinDisplay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAdvancedClientEnforceMinDisplay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * After login, whether the advanced client should enforce minimum
     * display resolution
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=678)
    public Map<String,Object> unsetPrefAdvancedClientEnforceMinDisplay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAdvancedClientEnforceMinDisplay, "");
        return attrs;
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @return zimbraPrefAllowAddressForDelegatedSender, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public String[] getPrefAllowAddressForDelegatedSender() {
        return getMultiAttr(Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, true, true);
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @param zimbraPrefAllowAddressForDelegatedSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public void setPrefAllowAddressForDelegatedSender(String[] zimbraPrefAllowAddressForDelegatedSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, zimbraPrefAllowAddressForDelegatedSender);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @param zimbraPrefAllowAddressForDelegatedSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public Map<String,Object> setPrefAllowAddressForDelegatedSender(String[] zimbraPrefAllowAddressForDelegatedSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, zimbraPrefAllowAddressForDelegatedSender);
        return attrs;
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @param zimbraPrefAllowAddressForDelegatedSender new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public void addPrefAllowAddressForDelegatedSender(String zimbraPrefAllowAddressForDelegatedSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, zimbraPrefAllowAddressForDelegatedSender);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @param zimbraPrefAllowAddressForDelegatedSender new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public Map<String,Object> addPrefAllowAddressForDelegatedSender(String zimbraPrefAllowAddressForDelegatedSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, zimbraPrefAllowAddressForDelegatedSender);
        return attrs;
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @param zimbraPrefAllowAddressForDelegatedSender existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public void removePrefAllowAddressForDelegatedSender(String zimbraPrefAllowAddressForDelegatedSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, zimbraPrefAllowAddressForDelegatedSender);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @param zimbraPrefAllowAddressForDelegatedSender existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public Map<String,Object> removePrefAllowAddressForDelegatedSender(String zimbraPrefAllowAddressForDelegatedSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, zimbraPrefAllowAddressForDelegatedSender);
        return attrs;
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public void unsetPrefAllowAddressForDelegatedSender() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Addresses of the account that can be used by allowed delegated senders
     * as From and Sender address.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1333)
    public Map<String,Object> unsetPrefAllowAddressForDelegatedSender(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAllowAddressForDelegatedSender, "");
        return attrs;
    }

    /**
     * Use the iCal style delegation model for shared calendars for CalDAV
     * interface when set to TRUE.
     *
     * @return zimbraPrefAppleIcalDelegationEnabled, or false if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1028)
    public boolean isPrefAppleIcalDelegationEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefAppleIcalDelegationEnabled, false, true);
    }

    /**
     * Use the iCal style delegation model for shared calendars for CalDAV
     * interface when set to TRUE.
     *
     * @param zimbraPrefAppleIcalDelegationEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1028)
    public void setPrefAppleIcalDelegationEnabled(boolean zimbraPrefAppleIcalDelegationEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAppleIcalDelegationEnabled, zimbraPrefAppleIcalDelegationEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Use the iCal style delegation model for shared calendars for CalDAV
     * interface when set to TRUE.
     *
     * @param zimbraPrefAppleIcalDelegationEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1028)
    public Map<String,Object> setPrefAppleIcalDelegationEnabled(boolean zimbraPrefAppleIcalDelegationEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAppleIcalDelegationEnabled, zimbraPrefAppleIcalDelegationEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Use the iCal style delegation model for shared calendars for CalDAV
     * interface when set to TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1028)
    public void unsetPrefAppleIcalDelegationEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAppleIcalDelegationEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Use the iCal style delegation model for shared calendars for CalDAV
     * interface when set to TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1028)
    public Map<String,Object> unsetPrefAppleIcalDelegationEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAppleIcalDelegationEnabled, "");
        return attrs;
    }

    /**
     * whether or not new address in outgoing email are auto added to address
     * book
     *
     * @return zimbraPrefAutoAddAddressEnabled, or true if unset
     */
    @ZAttr(id=131)
    public boolean isPrefAutoAddAddressEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefAutoAddAddressEnabled, true, true);
    }

    /**
     * whether or not new address in outgoing email are auto added to address
     * book
     *
     * @param zimbraPrefAutoAddAddressEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=131)
    public void setPrefAutoAddAddressEnabled(boolean zimbraPrefAutoAddAddressEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoAddAddressEnabled, zimbraPrefAutoAddAddressEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not new address in outgoing email are auto added to address
     * book
     *
     * @param zimbraPrefAutoAddAddressEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=131)
    public Map<String,Object> setPrefAutoAddAddressEnabled(boolean zimbraPrefAutoAddAddressEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoAddAddressEnabled, zimbraPrefAutoAddAddressEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not new address in outgoing email are auto added to address
     * book
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=131)
    public void unsetPrefAutoAddAddressEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoAddAddressEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not new address in outgoing email are auto added to address
     * book
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=131)
    public Map<String,Object> unsetPrefAutoAddAddressEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoAddAddressEnabled, "");
        return attrs;
    }

    /**
     * whether to end auto-complete on comma
     *
     * @return zimbraPrefAutoCompleteQuickCompletionOnComma, or true if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1091)
    public boolean isPrefAutoCompleteQuickCompletionOnComma() {
        return getBooleanAttr(Provisioning.A_zimbraPrefAutoCompleteQuickCompletionOnComma, true, true);
    }

    /**
     * whether to end auto-complete on comma
     *
     * @param zimbraPrefAutoCompleteQuickCompletionOnComma new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1091)
    public void setPrefAutoCompleteQuickCompletionOnComma(boolean zimbraPrefAutoCompleteQuickCompletionOnComma) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoCompleteQuickCompletionOnComma, zimbraPrefAutoCompleteQuickCompletionOnComma ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to end auto-complete on comma
     *
     * @param zimbraPrefAutoCompleteQuickCompletionOnComma new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1091)
    public Map<String,Object> setPrefAutoCompleteQuickCompletionOnComma(boolean zimbraPrefAutoCompleteQuickCompletionOnComma, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoCompleteQuickCompletionOnComma, zimbraPrefAutoCompleteQuickCompletionOnComma ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to end auto-complete on comma
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1091)
    public void unsetPrefAutoCompleteQuickCompletionOnComma() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoCompleteQuickCompletionOnComma, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to end auto-complete on comma
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1091)
    public Map<String,Object> unsetPrefAutoCompleteQuickCompletionOnComma(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoCompleteQuickCompletionOnComma, "");
        return attrs;
    }

    /**
     * time to wait before auto saving a draft. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getPrefAutoSaveDraftIntervalAsString to access value as a string.
     *
     * @see #getPrefAutoSaveDraftIntervalAsString()
     *
     * @return zimbraPrefAutoSaveDraftInterval in millseconds, or 30000 (30s)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=561)
    public long getPrefAutoSaveDraftInterval() {
        return getTimeInterval(Provisioning.A_zimbraPrefAutoSaveDraftInterval, 30000L, true);
    }

    /**
     * time to wait before auto saving a draft. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraPrefAutoSaveDraftInterval, or "30s" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=561)
    public String getPrefAutoSaveDraftIntervalAsString() {
        return getAttr(Provisioning.A_zimbraPrefAutoSaveDraftInterval, "30s", true);
    }

    /**
     * time to wait before auto saving a draft. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraPrefAutoSaveDraftInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=561)
    public void setPrefAutoSaveDraftInterval(String zimbraPrefAutoSaveDraftInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoSaveDraftInterval, zimbraPrefAutoSaveDraftInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time to wait before auto saving a draft. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraPrefAutoSaveDraftInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=561)
    public Map<String,Object> setPrefAutoSaveDraftInterval(String zimbraPrefAutoSaveDraftInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoSaveDraftInterval, zimbraPrefAutoSaveDraftInterval);
        return attrs;
    }

    /**
     * time to wait before auto saving a draft. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=561)
    public void unsetPrefAutoSaveDraftInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoSaveDraftInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time to wait before auto saving a draft. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=561)
    public Map<String,Object> unsetPrefAutoSaveDraftInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutoSaveDraftInterval, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. address bubbles always enabled since 8.5.0.
     * Orig desc: whether actionable address objects result from autocomplete
     * is enabled
     *
     * @return zimbraPrefAutocompleteAddressBubblesEnabled, or true if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1146)
    public boolean isPrefAutocompleteAddressBubblesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefAutocompleteAddressBubblesEnabled, true, true);
    }

    /**
     * Deprecated since: 8.5.0. address bubbles always enabled since 8.5.0.
     * Orig desc: whether actionable address objects result from autocomplete
     * is enabled
     *
     * @param zimbraPrefAutocompleteAddressBubblesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1146)
    public void setPrefAutocompleteAddressBubblesEnabled(boolean zimbraPrefAutocompleteAddressBubblesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutocompleteAddressBubblesEnabled, zimbraPrefAutocompleteAddressBubblesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. address bubbles always enabled since 8.5.0.
     * Orig desc: whether actionable address objects result from autocomplete
     * is enabled
     *
     * @param zimbraPrefAutocompleteAddressBubblesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1146)
    public Map<String,Object> setPrefAutocompleteAddressBubblesEnabled(boolean zimbraPrefAutocompleteAddressBubblesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutocompleteAddressBubblesEnabled, zimbraPrefAutocompleteAddressBubblesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. address bubbles always enabled since 8.5.0.
     * Orig desc: whether actionable address objects result from autocomplete
     * is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1146)
    public void unsetPrefAutocompleteAddressBubblesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutocompleteAddressBubblesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. address bubbles always enabled since 8.5.0.
     * Orig desc: whether actionable address objects result from autocomplete
     * is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1146)
    public Map<String,Object> unsetPrefAutocompleteAddressBubblesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefAutocompleteAddressBubblesEnabled, "");
        return attrs;
    }

    /**
     * address that we will bcc when using sending mail with this identity
     * (deprecatedSince 5.0 in identity)
     *
     * @return zimbraPrefBccAddress, or null if unset
     */
    @ZAttr(id=411)
    public String getPrefBccAddress() {
        return getAttr(Provisioning.A_zimbraPrefBccAddress, null, true);
    }

    /**
     * address that we will bcc when using sending mail with this identity
     * (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefBccAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=411)
    public void setPrefBccAddress(String zimbraPrefBccAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBccAddress, zimbraPrefBccAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * address that we will bcc when using sending mail with this identity
     * (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefBccAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=411)
    public Map<String,Object> setPrefBccAddress(String zimbraPrefBccAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBccAddress, zimbraPrefBccAddress);
        return attrs;
    }

    /**
     * address that we will bcc when using sending mail with this identity
     * (deprecatedSince 5.0 in identity)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=411)
    public void unsetPrefBccAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBccAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * address that we will bcc when using sending mail with this identity
     * (deprecatedSince 5.0 in identity)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=411)
    public Map<String,Object> unsetPrefBccAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBccAddress, "");
        return attrs;
    }

    /**
     * where the reading pane is displayed for briefcase
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @return zimbraPrefBriefcaseReadingPaneLocation, or ZAttrProvisioning.PrefBriefcaseReadingPaneLocation.right if unset and/or has invalid value
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1152)
    public ZAttrProvisioning.PrefBriefcaseReadingPaneLocation getPrefBriefcaseReadingPaneLocation() {
        try { String v = getAttr(Provisioning.A_zimbraPrefBriefcaseReadingPaneLocation, true, true); return v == null ? ZAttrProvisioning.PrefBriefcaseReadingPaneLocation.right : ZAttrProvisioning.PrefBriefcaseReadingPaneLocation.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefBriefcaseReadingPaneLocation.right; }
    }

    /**
     * where the reading pane is displayed for briefcase
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @return zimbraPrefBriefcaseReadingPaneLocation, or "right" if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1152)
    public String getPrefBriefcaseReadingPaneLocationAsString() {
        return getAttr(Provisioning.A_zimbraPrefBriefcaseReadingPaneLocation, "right", true);
    }

    /**
     * where the reading pane is displayed for briefcase
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefBriefcaseReadingPaneLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1152)
    public void setPrefBriefcaseReadingPaneLocation(ZAttrProvisioning.PrefBriefcaseReadingPaneLocation zimbraPrefBriefcaseReadingPaneLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBriefcaseReadingPaneLocation, zimbraPrefBriefcaseReadingPaneLocation.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the reading pane is displayed for briefcase
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefBriefcaseReadingPaneLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1152)
    public Map<String,Object> setPrefBriefcaseReadingPaneLocation(ZAttrProvisioning.PrefBriefcaseReadingPaneLocation zimbraPrefBriefcaseReadingPaneLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBriefcaseReadingPaneLocation, zimbraPrefBriefcaseReadingPaneLocation.toString());
        return attrs;
    }

    /**
     * where the reading pane is displayed for briefcase
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefBriefcaseReadingPaneLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1152)
    public void setPrefBriefcaseReadingPaneLocationAsString(String zimbraPrefBriefcaseReadingPaneLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBriefcaseReadingPaneLocation, zimbraPrefBriefcaseReadingPaneLocation);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the reading pane is displayed for briefcase
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefBriefcaseReadingPaneLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1152)
    public Map<String,Object> setPrefBriefcaseReadingPaneLocationAsString(String zimbraPrefBriefcaseReadingPaneLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBriefcaseReadingPaneLocation, zimbraPrefBriefcaseReadingPaneLocation);
        return attrs;
    }

    /**
     * where the reading pane is displayed for briefcase
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1152)
    public void unsetPrefBriefcaseReadingPaneLocation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBriefcaseReadingPaneLocation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the reading pane is displayed for briefcase
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1152)
    public Map<String,Object> unsetPrefBriefcaseReadingPaneLocation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefBriefcaseReadingPaneLocation, "");
        return attrs;
    }

    /**
     * calendar manual accept reply signature for account/identity/dataSource
     *
     * @return zimbraPrefCalendarAcceptSignatureId, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1202)
    public String getPrefCalendarAcceptSignatureId() {
        return getAttr(Provisioning.A_zimbraPrefCalendarAcceptSignatureId, null, true);
    }

    /**
     * calendar manual accept reply signature for account/identity/dataSource
     *
     * @param zimbraPrefCalendarAcceptSignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1202)
    public void setPrefCalendarAcceptSignatureId(String zimbraPrefCalendarAcceptSignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAcceptSignatureId, zimbraPrefCalendarAcceptSignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar manual accept reply signature for account/identity/dataSource
     *
     * @param zimbraPrefCalendarAcceptSignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1202)
    public Map<String,Object> setPrefCalendarAcceptSignatureId(String zimbraPrefCalendarAcceptSignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAcceptSignatureId, zimbraPrefCalendarAcceptSignatureId);
        return attrs;
    }

    /**
     * calendar manual accept reply signature for account/identity/dataSource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1202)
    public void unsetPrefCalendarAcceptSignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAcceptSignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar manual accept reply signature for account/identity/dataSource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1202)
    public Map<String,Object> unsetPrefCalendarAcceptSignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAcceptSignatureId, "");
        return attrs;
    }

    /**
     * whether to allow a cancel email sent to organizer of appointment
     *
     * @return zimbraPrefCalendarAllowCancelEmailToSelf, or false if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=702)
    public boolean isPrefCalendarAllowCancelEmailToSelf() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarAllowCancelEmailToSelf, false, true);
    }

    /**
     * whether to allow a cancel email sent to organizer of appointment
     *
     * @param zimbraPrefCalendarAllowCancelEmailToSelf new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=702)
    public void setPrefCalendarAllowCancelEmailToSelf(boolean zimbraPrefCalendarAllowCancelEmailToSelf) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowCancelEmailToSelf, zimbraPrefCalendarAllowCancelEmailToSelf ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow a cancel email sent to organizer of appointment
     *
     * @param zimbraPrefCalendarAllowCancelEmailToSelf new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=702)
    public Map<String,Object> setPrefCalendarAllowCancelEmailToSelf(boolean zimbraPrefCalendarAllowCancelEmailToSelf, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowCancelEmailToSelf, zimbraPrefCalendarAllowCancelEmailToSelf ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow a cancel email sent to organizer of appointment
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=702)
    public void unsetPrefCalendarAllowCancelEmailToSelf() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowCancelEmailToSelf, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow a cancel email sent to organizer of appointment
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=702)
    public Map<String,Object> unsetPrefCalendarAllowCancelEmailToSelf(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowCancelEmailToSelf, "");
        return attrs;
    }

    /**
     * whether calendar invite part in a forwarded email is auto-added to
     * calendar
     *
     * @return zimbraPrefCalendarAllowForwardedInvite, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=686)
    public boolean isPrefCalendarAllowForwardedInvite() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarAllowForwardedInvite, true, true);
    }

    /**
     * whether calendar invite part in a forwarded email is auto-added to
     * calendar
     *
     * @param zimbraPrefCalendarAllowForwardedInvite new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=686)
    public void setPrefCalendarAllowForwardedInvite(boolean zimbraPrefCalendarAllowForwardedInvite) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowForwardedInvite, zimbraPrefCalendarAllowForwardedInvite ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether calendar invite part in a forwarded email is auto-added to
     * calendar
     *
     * @param zimbraPrefCalendarAllowForwardedInvite new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=686)
    public Map<String,Object> setPrefCalendarAllowForwardedInvite(boolean zimbraPrefCalendarAllowForwardedInvite, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowForwardedInvite, zimbraPrefCalendarAllowForwardedInvite ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether calendar invite part in a forwarded email is auto-added to
     * calendar
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=686)
    public void unsetPrefCalendarAllowForwardedInvite() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowForwardedInvite, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether calendar invite part in a forwarded email is auto-added to
     * calendar
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=686)
    public Map<String,Object> unsetPrefCalendarAllowForwardedInvite(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowForwardedInvite, "");
        return attrs;
    }

    /**
     * whether calendar invite part with PUBLISH method is auto-added to
     * calendar
     *
     * @return zimbraPrefCalendarAllowPublishMethodInvite, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=688)
    public boolean isPrefCalendarAllowPublishMethodInvite() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarAllowPublishMethodInvite, false, true);
    }

    /**
     * whether calendar invite part with PUBLISH method is auto-added to
     * calendar
     *
     * @param zimbraPrefCalendarAllowPublishMethodInvite new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=688)
    public void setPrefCalendarAllowPublishMethodInvite(boolean zimbraPrefCalendarAllowPublishMethodInvite) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowPublishMethodInvite, zimbraPrefCalendarAllowPublishMethodInvite ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether calendar invite part with PUBLISH method is auto-added to
     * calendar
     *
     * @param zimbraPrefCalendarAllowPublishMethodInvite new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=688)
    public Map<String,Object> setPrefCalendarAllowPublishMethodInvite(boolean zimbraPrefCalendarAllowPublishMethodInvite, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowPublishMethodInvite, zimbraPrefCalendarAllowPublishMethodInvite ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether calendar invite part with PUBLISH method is auto-added to
     * calendar
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=688)
    public void unsetPrefCalendarAllowPublishMethodInvite() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowPublishMethodInvite, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether calendar invite part with PUBLISH method is auto-added to
     * calendar
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=688)
    public Map<String,Object> unsetPrefCalendarAllowPublishMethodInvite(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowPublishMethodInvite, "");
        return attrs;
    }

    /**
     * Allowed recipients if
     * &quot;zimbraPrefCalendarSendInviteDeniedAutoReply&quot; is TRUE:
     * internal - Only send &quot;invite denied&quot; auto-response if the
     * sender of the original invite is an internal user. sameDomain - Only
     * send &quot;invite denied&quot; auto-response if the sender of the
     * original invite is in the same domain as the invitee. all - No
     * restrictions on who to send &quot;invite denied&quot; auto-responses
     * to.
     *
     * <p>Valid values: [internal, sameDomain, all]
     *
     * @return zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, or ZAttrProvisioning.PrefCalendarAllowedTargetsForInviteDeniedAutoReply.internal if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1632)
    public ZAttrProvisioning.PrefCalendarAllowedTargetsForInviteDeniedAutoReply getPrefCalendarAllowedTargetsForInviteDeniedAutoReply() {
        try { String v = getAttr(Provisioning.A_zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, true, true); return v == null ? ZAttrProvisioning.PrefCalendarAllowedTargetsForInviteDeniedAutoReply.internal : ZAttrProvisioning.PrefCalendarAllowedTargetsForInviteDeniedAutoReply.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefCalendarAllowedTargetsForInviteDeniedAutoReply.internal; }
    }

    /**
     * Allowed recipients if
     * &quot;zimbraPrefCalendarSendInviteDeniedAutoReply&quot; is TRUE:
     * internal - Only send &quot;invite denied&quot; auto-response if the
     * sender of the original invite is an internal user. sameDomain - Only
     * send &quot;invite denied&quot; auto-response if the sender of the
     * original invite is in the same domain as the invitee. all - No
     * restrictions on who to send &quot;invite denied&quot; auto-responses
     * to.
     *
     * <p>Valid values: [internal, sameDomain, all]
     *
     * @return zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, or "internal" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1632)
    public String getPrefCalendarAllowedTargetsForInviteDeniedAutoReplyAsString() {
        return getAttr(Provisioning.A_zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, "internal", true);
    }

    /**
     * Allowed recipients if
     * &quot;zimbraPrefCalendarSendInviteDeniedAutoReply&quot; is TRUE:
     * internal - Only send &quot;invite denied&quot; auto-response if the
     * sender of the original invite is an internal user. sameDomain - Only
     * send &quot;invite denied&quot; auto-response if the sender of the
     * original invite is in the same domain as the invitee. all - No
     * restrictions on who to send &quot;invite denied&quot; auto-responses
     * to.
     *
     * <p>Valid values: [internal, sameDomain, all]
     *
     * @param zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1632)
    public void setPrefCalendarAllowedTargetsForInviteDeniedAutoReply(ZAttrProvisioning.PrefCalendarAllowedTargetsForInviteDeniedAutoReply zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed recipients if
     * &quot;zimbraPrefCalendarSendInviteDeniedAutoReply&quot; is TRUE:
     * internal - Only send &quot;invite denied&quot; auto-response if the
     * sender of the original invite is an internal user. sameDomain - Only
     * send &quot;invite denied&quot; auto-response if the sender of the
     * original invite is in the same domain as the invitee. all - No
     * restrictions on who to send &quot;invite denied&quot; auto-responses
     * to.
     *
     * <p>Valid values: [internal, sameDomain, all]
     *
     * @param zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1632)
    public Map<String,Object> setPrefCalendarAllowedTargetsForInviteDeniedAutoReply(ZAttrProvisioning.PrefCalendarAllowedTargetsForInviteDeniedAutoReply zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply.toString());
        return attrs;
    }

    /**
     * Allowed recipients if
     * &quot;zimbraPrefCalendarSendInviteDeniedAutoReply&quot; is TRUE:
     * internal - Only send &quot;invite denied&quot; auto-response if the
     * sender of the original invite is an internal user. sameDomain - Only
     * send &quot;invite denied&quot; auto-response if the sender of the
     * original invite is in the same domain as the invitee. all - No
     * restrictions on who to send &quot;invite denied&quot; auto-responses
     * to.
     *
     * <p>Valid values: [internal, sameDomain, all]
     *
     * @param zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1632)
    public void setPrefCalendarAllowedTargetsForInviteDeniedAutoReplyAsString(String zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed recipients if
     * &quot;zimbraPrefCalendarSendInviteDeniedAutoReply&quot; is TRUE:
     * internal - Only send &quot;invite denied&quot; auto-response if the
     * sender of the original invite is an internal user. sameDomain - Only
     * send &quot;invite denied&quot; auto-response if the sender of the
     * original invite is in the same domain as the invitee. all - No
     * restrictions on who to send &quot;invite denied&quot; auto-responses
     * to.
     *
     * <p>Valid values: [internal, sameDomain, all]
     *
     * @param zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1632)
    public Map<String,Object> setPrefCalendarAllowedTargetsForInviteDeniedAutoReplyAsString(String zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply);
        return attrs;
    }

    /**
     * Allowed recipients if
     * &quot;zimbraPrefCalendarSendInviteDeniedAutoReply&quot; is TRUE:
     * internal - Only send &quot;invite denied&quot; auto-response if the
     * sender of the original invite is an internal user. sameDomain - Only
     * send &quot;invite denied&quot; auto-response if the sender of the
     * original invite is in the same domain as the invitee. all - No
     * restrictions on who to send &quot;invite denied&quot; auto-responses
     * to.
     *
     * <p>Valid values: [internal, sameDomain, all]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1632)
    public void unsetPrefCalendarAllowedTargetsForInviteDeniedAutoReply() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed recipients if
     * &quot;zimbraPrefCalendarSendInviteDeniedAutoReply&quot; is TRUE:
     * internal - Only send &quot;invite denied&quot; auto-response if the
     * sender of the original invite is an internal user. sameDomain - Only
     * send &quot;invite denied&quot; auto-response if the sender of the
     * original invite is in the same domain as the invitee. all - No
     * restrictions on who to send &quot;invite denied&quot; auto-responses
     * to.
     *
     * <p>Valid values: [internal, sameDomain, all]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1632)
    public Map<String,Object> unsetPrefCalendarAllowedTargetsForInviteDeniedAutoReply(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply, "");
        return attrs;
    }

    /**
     * always show the mini calendar
     *
     * @return zimbraPrefCalendarAlwaysShowMiniCal, or true if unset
     */
    @ZAttr(id=276)
    public boolean isPrefCalendarAlwaysShowMiniCal() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarAlwaysShowMiniCal, true, true);
    }

    /**
     * always show the mini calendar
     *
     * @param zimbraPrefCalendarAlwaysShowMiniCal new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=276)
    public void setPrefCalendarAlwaysShowMiniCal(boolean zimbraPrefCalendarAlwaysShowMiniCal) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAlwaysShowMiniCal, zimbraPrefCalendarAlwaysShowMiniCal ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * always show the mini calendar
     *
     * @param zimbraPrefCalendarAlwaysShowMiniCal new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=276)
    public Map<String,Object> setPrefCalendarAlwaysShowMiniCal(boolean zimbraPrefCalendarAlwaysShowMiniCal, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAlwaysShowMiniCal, zimbraPrefCalendarAlwaysShowMiniCal ? TRUE : FALSE);
        return attrs;
    }

    /**
     * always show the mini calendar
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=276)
    public void unsetPrefCalendarAlwaysShowMiniCal() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAlwaysShowMiniCal, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * always show the mini calendar
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=276)
    public Map<String,Object> unsetPrefCalendarAlwaysShowMiniCal(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAlwaysShowMiniCal, "");
        return attrs;
    }

    /**
     * Whether to allow attendees to make local edits to appointments. The
     * change is only on the attendees copy of the message and changes from
     * the organizer will overwrite the local changes.
     *
     * @return zimbraPrefCalendarApptAllowAtendeeEdit, or true if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1089)
    public boolean isPrefCalendarApptAllowAtendeeEdit() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarApptAllowAtendeeEdit, true, true);
    }

    /**
     * Whether to allow attendees to make local edits to appointments. The
     * change is only on the attendees copy of the message and changes from
     * the organizer will overwrite the local changes.
     *
     * @param zimbraPrefCalendarApptAllowAtendeeEdit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1089)
    public void setPrefCalendarApptAllowAtendeeEdit(boolean zimbraPrefCalendarApptAllowAtendeeEdit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptAllowAtendeeEdit, zimbraPrefCalendarApptAllowAtendeeEdit ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow attendees to make local edits to appointments. The
     * change is only on the attendees copy of the message and changes from
     * the organizer will overwrite the local changes.
     *
     * @param zimbraPrefCalendarApptAllowAtendeeEdit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1089)
    public Map<String,Object> setPrefCalendarApptAllowAtendeeEdit(boolean zimbraPrefCalendarApptAllowAtendeeEdit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptAllowAtendeeEdit, zimbraPrefCalendarApptAllowAtendeeEdit ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow attendees to make local edits to appointments. The
     * change is only on the attendees copy of the message and changes from
     * the organizer will overwrite the local changes.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1089)
    public void unsetPrefCalendarApptAllowAtendeeEdit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptAllowAtendeeEdit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow attendees to make local edits to appointments. The
     * change is only on the attendees copy of the message and changes from
     * the organizer will overwrite the local changes.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1089)
    public Map<String,Object> unsetPrefCalendarApptAllowAtendeeEdit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptAllowAtendeeEdit, "");
        return attrs;
    }

    /**
     * number of minutes (0 = never and -1 = At the time of event) before
     * appt to show reminder dialog. Note:&quot;0&quot; was chosen to mean
     * &quot;never&quot; before reminders &quot;at the time of event&quot;
     * were supported, hence the need to use &quot;-1&quot; to mean &quot;At
     * the time of event&quot; (instead of &quot;0&quot; which would be more
     * intuitive) to avoid breaking backwards compatibility
     *
     * @return zimbraPrefCalendarApptReminderWarningTime, or 5 if unset
     */
    @ZAttr(id=341)
    public int getPrefCalendarApptReminderWarningTime() {
        return getIntAttr(Provisioning.A_zimbraPrefCalendarApptReminderWarningTime, 5, true);
    }

    /**
     * number of minutes (0 = never and -1 = At the time of event) before
     * appt to show reminder dialog. Note:&quot;0&quot; was chosen to mean
     * &quot;never&quot; before reminders &quot;at the time of event&quot;
     * were supported, hence the need to use &quot;-1&quot; to mean &quot;At
     * the time of event&quot; (instead of &quot;0&quot; which would be more
     * intuitive) to avoid breaking backwards compatibility
     *
     * @param zimbraPrefCalendarApptReminderWarningTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=341)
    public void setPrefCalendarApptReminderWarningTime(int zimbraPrefCalendarApptReminderWarningTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptReminderWarningTime, Integer.toString(zimbraPrefCalendarApptReminderWarningTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of minutes (0 = never and -1 = At the time of event) before
     * appt to show reminder dialog. Note:&quot;0&quot; was chosen to mean
     * &quot;never&quot; before reminders &quot;at the time of event&quot;
     * were supported, hence the need to use &quot;-1&quot; to mean &quot;At
     * the time of event&quot; (instead of &quot;0&quot; which would be more
     * intuitive) to avoid breaking backwards compatibility
     *
     * @param zimbraPrefCalendarApptReminderWarningTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=341)
    public Map<String,Object> setPrefCalendarApptReminderWarningTime(int zimbraPrefCalendarApptReminderWarningTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptReminderWarningTime, Integer.toString(zimbraPrefCalendarApptReminderWarningTime));
        return attrs;
    }

    /**
     * number of minutes (0 = never and -1 = At the time of event) before
     * appt to show reminder dialog. Note:&quot;0&quot; was chosen to mean
     * &quot;never&quot; before reminders &quot;at the time of event&quot;
     * were supported, hence the need to use &quot;-1&quot; to mean &quot;At
     * the time of event&quot; (instead of &quot;0&quot; which would be more
     * intuitive) to avoid breaking backwards compatibility
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=341)
    public void unsetPrefCalendarApptReminderWarningTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptReminderWarningTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of minutes (0 = never and -1 = At the time of event) before
     * appt to show reminder dialog. Note:&quot;0&quot; was chosen to mean
     * &quot;never&quot; before reminders &quot;at the time of event&quot;
     * were supported, hence the need to use &quot;-1&quot; to mean &quot;At
     * the time of event&quot; (instead of &quot;0&quot; which would be more
     * intuitive) to avoid breaking backwards compatibility
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=341)
    public Map<String,Object> unsetPrefCalendarApptReminderWarningTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptReminderWarningTime, "");
        return attrs;
    }

    /**
     * default visibility of the appointment when starting a new appointment
     * in the UI
     *
     * <p>Valid values: [public, private]
     *
     * @return zimbraPrefCalendarApptVisibility, or ZAttrProvisioning.PrefCalendarApptVisibility.public_ if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=832)
    public ZAttrProvisioning.PrefCalendarApptVisibility getPrefCalendarApptVisibility() {
        try { String v = getAttr(Provisioning.A_zimbraPrefCalendarApptVisibility, true, true); return v == null ? ZAttrProvisioning.PrefCalendarApptVisibility.public_ : ZAttrProvisioning.PrefCalendarApptVisibility.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefCalendarApptVisibility.public_; }
    }

    /**
     * default visibility of the appointment when starting a new appointment
     * in the UI
     *
     * <p>Valid values: [public, private]
     *
     * @return zimbraPrefCalendarApptVisibility, or "public" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=832)
    public String getPrefCalendarApptVisibilityAsString() {
        return getAttr(Provisioning.A_zimbraPrefCalendarApptVisibility, "public", true);
    }

    /**
     * default visibility of the appointment when starting a new appointment
     * in the UI
     *
     * <p>Valid values: [public, private]
     *
     * @param zimbraPrefCalendarApptVisibility new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=832)
    public void setPrefCalendarApptVisibility(ZAttrProvisioning.PrefCalendarApptVisibility zimbraPrefCalendarApptVisibility) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptVisibility, zimbraPrefCalendarApptVisibility.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default visibility of the appointment when starting a new appointment
     * in the UI
     *
     * <p>Valid values: [public, private]
     *
     * @param zimbraPrefCalendarApptVisibility new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=832)
    public Map<String,Object> setPrefCalendarApptVisibility(ZAttrProvisioning.PrefCalendarApptVisibility zimbraPrefCalendarApptVisibility, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptVisibility, zimbraPrefCalendarApptVisibility.toString());
        return attrs;
    }

    /**
     * default visibility of the appointment when starting a new appointment
     * in the UI
     *
     * <p>Valid values: [public, private]
     *
     * @param zimbraPrefCalendarApptVisibility new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=832)
    public void setPrefCalendarApptVisibilityAsString(String zimbraPrefCalendarApptVisibility) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptVisibility, zimbraPrefCalendarApptVisibility);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default visibility of the appointment when starting a new appointment
     * in the UI
     *
     * <p>Valid values: [public, private]
     *
     * @param zimbraPrefCalendarApptVisibility new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=832)
    public Map<String,Object> setPrefCalendarApptVisibilityAsString(String zimbraPrefCalendarApptVisibility, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptVisibility, zimbraPrefCalendarApptVisibility);
        return attrs;
    }

    /**
     * default visibility of the appointment when starting a new appointment
     * in the UI
     *
     * <p>Valid values: [public, private]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=832)
    public void unsetPrefCalendarApptVisibility() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptVisibility, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default visibility of the appointment when starting a new appointment
     * in the UI
     *
     * <p>Valid values: [public, private]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=832)
    public Map<String,Object> unsetPrefCalendarApptVisibility(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarApptVisibility, "");
        return attrs;
    }

    /**
     * calendar auto accept reply signature for account/identity/dataSource
     *
     * @return zimbraPrefCalendarAutoAcceptSignatureId, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1192)
    public String getPrefCalendarAutoAcceptSignatureId() {
        return getAttr(Provisioning.A_zimbraPrefCalendarAutoAcceptSignatureId, null, true);
    }

    /**
     * calendar auto accept reply signature for account/identity/dataSource
     *
     * @param zimbraPrefCalendarAutoAcceptSignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1192)
    public void setPrefCalendarAutoAcceptSignatureId(String zimbraPrefCalendarAutoAcceptSignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoAcceptSignatureId, zimbraPrefCalendarAutoAcceptSignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar auto accept reply signature for account/identity/dataSource
     *
     * @param zimbraPrefCalendarAutoAcceptSignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1192)
    public Map<String,Object> setPrefCalendarAutoAcceptSignatureId(String zimbraPrefCalendarAutoAcceptSignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoAcceptSignatureId, zimbraPrefCalendarAutoAcceptSignatureId);
        return attrs;
    }

    /**
     * calendar auto accept reply signature for account/identity/dataSource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1192)
    public void unsetPrefCalendarAutoAcceptSignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoAcceptSignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar auto accept reply signature for account/identity/dataSource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1192)
    public Map<String,Object> unsetPrefCalendarAutoAcceptSignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoAcceptSignatureId, "");
        return attrs;
    }

    /**
     * automatically add appointments when invited
     *
     * @return zimbraPrefCalendarAutoAddInvites, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=848)
    public boolean isPrefCalendarAutoAddInvites() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarAutoAddInvites, true, true);
    }

    /**
     * automatically add appointments when invited
     *
     * @param zimbraPrefCalendarAutoAddInvites new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=848)
    public void setPrefCalendarAutoAddInvites(boolean zimbraPrefCalendarAutoAddInvites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoAddInvites, zimbraPrefCalendarAutoAddInvites ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * automatically add appointments when invited
     *
     * @param zimbraPrefCalendarAutoAddInvites new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=848)
    public Map<String,Object> setPrefCalendarAutoAddInvites(boolean zimbraPrefCalendarAutoAddInvites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoAddInvites, zimbraPrefCalendarAutoAddInvites ? TRUE : FALSE);
        return attrs;
    }

    /**
     * automatically add appointments when invited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=848)
    public void unsetPrefCalendarAutoAddInvites() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoAddInvites, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * automatically add appointments when invited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=848)
    public Map<String,Object> unsetPrefCalendarAutoAddInvites(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoAddInvites, "");
        return attrs;
    }

    /**
     * calendar auto decline reply signature id for
     * account/identity/dataSource
     *
     * @return zimbraPrefCalendarAutoDeclineSignatureId, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1193)
    public String getPrefCalendarAutoDeclineSignatureId() {
        return getAttr(Provisioning.A_zimbraPrefCalendarAutoDeclineSignatureId, null, true);
    }

    /**
     * calendar auto decline reply signature id for
     * account/identity/dataSource
     *
     * @param zimbraPrefCalendarAutoDeclineSignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1193)
    public void setPrefCalendarAutoDeclineSignatureId(String zimbraPrefCalendarAutoDeclineSignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoDeclineSignatureId, zimbraPrefCalendarAutoDeclineSignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar auto decline reply signature id for
     * account/identity/dataSource
     *
     * @param zimbraPrefCalendarAutoDeclineSignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1193)
    public Map<String,Object> setPrefCalendarAutoDeclineSignatureId(String zimbraPrefCalendarAutoDeclineSignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoDeclineSignatureId, zimbraPrefCalendarAutoDeclineSignatureId);
        return attrs;
    }

    /**
     * calendar auto decline reply signature id for
     * account/identity/dataSource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1193)
    public void unsetPrefCalendarAutoDeclineSignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoDeclineSignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar auto decline reply signature id for
     * account/identity/dataSource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1193)
    public Map<String,Object> unsetPrefCalendarAutoDeclineSignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoDeclineSignatureId, "");
        return attrs;
    }

    /**
     * calendar auto deny reply signature id for account/identity/dataSource
     *
     * @return zimbraPrefCalendarAutoDenySignatureId, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1194)
    public String getPrefCalendarAutoDenySignatureId() {
        return getAttr(Provisioning.A_zimbraPrefCalendarAutoDenySignatureId, null, true);
    }

    /**
     * calendar auto deny reply signature id for account/identity/dataSource
     *
     * @param zimbraPrefCalendarAutoDenySignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1194)
    public void setPrefCalendarAutoDenySignatureId(String zimbraPrefCalendarAutoDenySignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoDenySignatureId, zimbraPrefCalendarAutoDenySignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar auto deny reply signature id for account/identity/dataSource
     *
     * @param zimbraPrefCalendarAutoDenySignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1194)
    public Map<String,Object> setPrefCalendarAutoDenySignatureId(String zimbraPrefCalendarAutoDenySignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoDenySignatureId, zimbraPrefCalendarAutoDenySignatureId);
        return attrs;
    }

    /**
     * calendar auto deny reply signature id for account/identity/dataSource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1194)
    public void unsetPrefCalendarAutoDenySignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoDenySignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar auto deny reply signature id for account/identity/dataSource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1194)
    public Map<String,Object> unsetPrefCalendarAutoDenySignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarAutoDenySignatureId, "");
        return attrs;
    }

    /**
     * hour of day that the day view should end at, non-inclusive (16=4pm, 24
     * = midnight, etc)
     *
     * @return zimbraPrefCalendarDayHourEnd, or 18 if unset
     */
    @ZAttr(id=440)
    public int getPrefCalendarDayHourEnd() {
        return getIntAttr(Provisioning.A_zimbraPrefCalendarDayHourEnd, 18, true);
    }

    /**
     * hour of day that the day view should end at, non-inclusive (16=4pm, 24
     * = midnight, etc)
     *
     * @param zimbraPrefCalendarDayHourEnd new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=440)
    public void setPrefCalendarDayHourEnd(int zimbraPrefCalendarDayHourEnd) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDayHourEnd, Integer.toString(zimbraPrefCalendarDayHourEnd));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * hour of day that the day view should end at, non-inclusive (16=4pm, 24
     * = midnight, etc)
     *
     * @param zimbraPrefCalendarDayHourEnd new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=440)
    public Map<String,Object> setPrefCalendarDayHourEnd(int zimbraPrefCalendarDayHourEnd, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDayHourEnd, Integer.toString(zimbraPrefCalendarDayHourEnd));
        return attrs;
    }

    /**
     * hour of day that the day view should end at, non-inclusive (16=4pm, 24
     * = midnight, etc)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=440)
    public void unsetPrefCalendarDayHourEnd() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDayHourEnd, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * hour of day that the day view should end at, non-inclusive (16=4pm, 24
     * = midnight, etc)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=440)
    public Map<String,Object> unsetPrefCalendarDayHourEnd(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDayHourEnd, "");
        return attrs;
    }

    /**
     * hour of day that the day view should start at (1=1 AM, 8=8 AM, etc)
     *
     * @return zimbraPrefCalendarDayHourStart, or 8 if unset
     */
    @ZAttr(id=439)
    public int getPrefCalendarDayHourStart() {
        return getIntAttr(Provisioning.A_zimbraPrefCalendarDayHourStart, 8, true);
    }

    /**
     * hour of day that the day view should start at (1=1 AM, 8=8 AM, etc)
     *
     * @param zimbraPrefCalendarDayHourStart new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=439)
    public void setPrefCalendarDayHourStart(int zimbraPrefCalendarDayHourStart) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDayHourStart, Integer.toString(zimbraPrefCalendarDayHourStart));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * hour of day that the day view should start at (1=1 AM, 8=8 AM, etc)
     *
     * @param zimbraPrefCalendarDayHourStart new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=439)
    public Map<String,Object> setPrefCalendarDayHourStart(int zimbraPrefCalendarDayHourStart, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDayHourStart, Integer.toString(zimbraPrefCalendarDayHourStart));
        return attrs;
    }

    /**
     * hour of day that the day view should start at (1=1 AM, 8=8 AM, etc)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=439)
    public void unsetPrefCalendarDayHourStart() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDayHourStart, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * hour of day that the day view should start at (1=1 AM, 8=8 AM, etc)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=439)
    public Map<String,Object> unsetPrefCalendarDayHourStart(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDayHourStart, "");
        return attrs;
    }

    /**
     * calendar manual decline reply signature id for
     * account/identity/dataSource
     *
     * @return zimbraPrefCalendarDeclineSignatureId, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1204)
    public String getPrefCalendarDeclineSignatureId() {
        return getAttr(Provisioning.A_zimbraPrefCalendarDeclineSignatureId, null, true);
    }

    /**
     * calendar manual decline reply signature id for
     * account/identity/dataSource
     *
     * @param zimbraPrefCalendarDeclineSignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1204)
    public void setPrefCalendarDeclineSignatureId(String zimbraPrefCalendarDeclineSignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDeclineSignatureId, zimbraPrefCalendarDeclineSignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar manual decline reply signature id for
     * account/identity/dataSource
     *
     * @param zimbraPrefCalendarDeclineSignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1204)
    public Map<String,Object> setPrefCalendarDeclineSignatureId(String zimbraPrefCalendarDeclineSignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDeclineSignatureId, zimbraPrefCalendarDeclineSignatureId);
        return attrs;
    }

    /**
     * calendar manual decline reply signature id for
     * account/identity/dataSource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1204)
    public void unsetPrefCalendarDeclineSignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDeclineSignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar manual decline reply signature id for
     * account/identity/dataSource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1204)
    public Map<String,Object> unsetPrefCalendarDeclineSignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDeclineSignatureId, "");
        return attrs;
    }

    /**
     * default appointment duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPrefCalendarDefaultApptDurationAsString to access value as a string.
     *
     * @see #getPrefCalendarDefaultApptDurationAsString()
     *
     * @return zimbraPrefCalendarDefaultApptDuration in millseconds, or 3600000 (60m)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1187)
    public long getPrefCalendarDefaultApptDuration() {
        return getTimeInterval(Provisioning.A_zimbraPrefCalendarDefaultApptDuration, 3600000L, true);
    }

    /**
     * default appointment duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPrefCalendarDefaultApptDuration, or "60m" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1187)
    public String getPrefCalendarDefaultApptDurationAsString() {
        return getAttr(Provisioning.A_zimbraPrefCalendarDefaultApptDuration, "60m", true);
    }

    /**
     * default appointment duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefCalendarDefaultApptDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1187)
    public void setPrefCalendarDefaultApptDuration(String zimbraPrefCalendarDefaultApptDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDefaultApptDuration, zimbraPrefCalendarDefaultApptDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default appointment duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefCalendarDefaultApptDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1187)
    public Map<String,Object> setPrefCalendarDefaultApptDuration(String zimbraPrefCalendarDefaultApptDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDefaultApptDuration, zimbraPrefCalendarDefaultApptDuration);
        return attrs;
    }

    /**
     * default appointment duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1187)
    public void unsetPrefCalendarDefaultApptDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDefaultApptDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default appointment duration. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1187)
    public Map<String,Object> unsetPrefCalendarDefaultApptDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarDefaultApptDuration, "");
        return attrs;
    }

    /**
     * first day of week to show in calendar (0=sunday, 6=saturday)
     *
     * @return zimbraPrefCalendarFirstDayOfWeek, or 0 if unset
     */
    @ZAttr(id=261)
    public int getPrefCalendarFirstDayOfWeek() {
        return getIntAttr(Provisioning.A_zimbraPrefCalendarFirstDayOfWeek, 0, true);
    }

    /**
     * first day of week to show in calendar (0=sunday, 6=saturday)
     *
     * @param zimbraPrefCalendarFirstDayOfWeek new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=261)
    public void setPrefCalendarFirstDayOfWeek(int zimbraPrefCalendarFirstDayOfWeek) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarFirstDayOfWeek, Integer.toString(zimbraPrefCalendarFirstDayOfWeek));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * first day of week to show in calendar (0=sunday, 6=saturday)
     *
     * @param zimbraPrefCalendarFirstDayOfWeek new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=261)
    public Map<String,Object> setPrefCalendarFirstDayOfWeek(int zimbraPrefCalendarFirstDayOfWeek, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarFirstDayOfWeek, Integer.toString(zimbraPrefCalendarFirstDayOfWeek));
        return attrs;
    }

    /**
     * first day of week to show in calendar (0=sunday, 6=saturday)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=261)
    public void unsetPrefCalendarFirstDayOfWeek() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarFirstDayOfWeek, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * first day of week to show in calendar (0=sunday, 6=saturday)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=261)
    public Map<String,Object> unsetPrefCalendarFirstDayOfWeek(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarFirstDayOfWeek, "");
        return attrs;
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @return zimbraPrefCalendarForwardInvitesTo, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public String[] getPrefCalendarForwardInvitesTo() {
        return getMultiAttr(Provisioning.A_zimbraPrefCalendarForwardInvitesTo, true, true);
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @param zimbraPrefCalendarForwardInvitesTo new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public void setPrefCalendarForwardInvitesTo(String[] zimbraPrefCalendarForwardInvitesTo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarForwardInvitesTo, zimbraPrefCalendarForwardInvitesTo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @param zimbraPrefCalendarForwardInvitesTo new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public Map<String,Object> setPrefCalendarForwardInvitesTo(String[] zimbraPrefCalendarForwardInvitesTo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarForwardInvitesTo, zimbraPrefCalendarForwardInvitesTo);
        return attrs;
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @param zimbraPrefCalendarForwardInvitesTo new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public void addPrefCalendarForwardInvitesTo(String zimbraPrefCalendarForwardInvitesTo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefCalendarForwardInvitesTo, zimbraPrefCalendarForwardInvitesTo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @param zimbraPrefCalendarForwardInvitesTo new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public Map<String,Object> addPrefCalendarForwardInvitesTo(String zimbraPrefCalendarForwardInvitesTo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefCalendarForwardInvitesTo, zimbraPrefCalendarForwardInvitesTo);
        return attrs;
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @param zimbraPrefCalendarForwardInvitesTo existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public void removePrefCalendarForwardInvitesTo(String zimbraPrefCalendarForwardInvitesTo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefCalendarForwardInvitesTo, zimbraPrefCalendarForwardInvitesTo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @param zimbraPrefCalendarForwardInvitesTo existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public Map<String,Object> removePrefCalendarForwardInvitesTo(String zimbraPrefCalendarForwardInvitesTo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefCalendarForwardInvitesTo, zimbraPrefCalendarForwardInvitesTo);
        return attrs;
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public void unsetPrefCalendarForwardInvitesTo() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarForwardInvitesTo, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Forward a copy of calendar invites received to these users.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=851)
    public Map<String,Object> unsetPrefCalendarForwardInvitesTo(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarForwardInvitesTo, "");
        return attrs;
    }

    /**
     * comma-sep list of calendars that are initially checked
     *
     * @return zimbraPrefCalendarInitialCheckedCalendars, or null if unset
     */
    @ZAttr(id=275)
    public String getPrefCalendarInitialCheckedCalendars() {
        return getAttr(Provisioning.A_zimbraPrefCalendarInitialCheckedCalendars, null, true);
    }

    /**
     * comma-sep list of calendars that are initially checked
     *
     * @param zimbraPrefCalendarInitialCheckedCalendars new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=275)
    public void setPrefCalendarInitialCheckedCalendars(String zimbraPrefCalendarInitialCheckedCalendars) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialCheckedCalendars, zimbraPrefCalendarInitialCheckedCalendars);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * comma-sep list of calendars that are initially checked
     *
     * @param zimbraPrefCalendarInitialCheckedCalendars new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=275)
    public Map<String,Object> setPrefCalendarInitialCheckedCalendars(String zimbraPrefCalendarInitialCheckedCalendars, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialCheckedCalendars, zimbraPrefCalendarInitialCheckedCalendars);
        return attrs;
    }

    /**
     * comma-sep list of calendars that are initially checked
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=275)
    public void unsetPrefCalendarInitialCheckedCalendars() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialCheckedCalendars, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * comma-sep list of calendars that are initially checked
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=275)
    public Map<String,Object> unsetPrefCalendarInitialCheckedCalendars(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialCheckedCalendars, "");
        return attrs;
    }

    /**
     * initial calendar view to use
     *
     * <p>Valid values: [day, week, workWeek, month, list, year]
     *
     * @return zimbraPrefCalendarInitialView, or ZAttrProvisioning.PrefCalendarInitialView.workWeek if unset and/or has invalid value
     */
    @ZAttr(id=240)
    public ZAttrProvisioning.PrefCalendarInitialView getPrefCalendarInitialView() {
        try { String v = getAttr(Provisioning.A_zimbraPrefCalendarInitialView, true, true); return v == null ? ZAttrProvisioning.PrefCalendarInitialView.workWeek : ZAttrProvisioning.PrefCalendarInitialView.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefCalendarInitialView.workWeek; }
    }

    /**
     * initial calendar view to use
     *
     * <p>Valid values: [day, week, workWeek, month, list, year]
     *
     * @return zimbraPrefCalendarInitialView, or "workWeek" if unset
     */
    @ZAttr(id=240)
    public String getPrefCalendarInitialViewAsString() {
        return getAttr(Provisioning.A_zimbraPrefCalendarInitialView, "workWeek", true);
    }

    /**
     * initial calendar view to use
     *
     * <p>Valid values: [day, week, workWeek, month, list, year]
     *
     * @param zimbraPrefCalendarInitialView new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=240)
    public void setPrefCalendarInitialView(ZAttrProvisioning.PrefCalendarInitialView zimbraPrefCalendarInitialView) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialView, zimbraPrefCalendarInitialView.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * initial calendar view to use
     *
     * <p>Valid values: [day, week, workWeek, month, list, year]
     *
     * @param zimbraPrefCalendarInitialView new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=240)
    public Map<String,Object> setPrefCalendarInitialView(ZAttrProvisioning.PrefCalendarInitialView zimbraPrefCalendarInitialView, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialView, zimbraPrefCalendarInitialView.toString());
        return attrs;
    }

    /**
     * initial calendar view to use
     *
     * <p>Valid values: [day, week, workWeek, month, list, year]
     *
     * @param zimbraPrefCalendarInitialView new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=240)
    public void setPrefCalendarInitialViewAsString(String zimbraPrefCalendarInitialView) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialView, zimbraPrefCalendarInitialView);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * initial calendar view to use
     *
     * <p>Valid values: [day, week, workWeek, month, list, year]
     *
     * @param zimbraPrefCalendarInitialView new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=240)
    public Map<String,Object> setPrefCalendarInitialViewAsString(String zimbraPrefCalendarInitialView, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialView, zimbraPrefCalendarInitialView);
        return attrs;
    }

    /**
     * initial calendar view to use
     *
     * <p>Valid values: [day, week, workWeek, month, list, year]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=240)
    public void unsetPrefCalendarInitialView() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialView, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * initial calendar view to use
     *
     * <p>Valid values: [day, week, workWeek, month, list, year]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=240)
    public Map<String,Object> unsetPrefCalendarInitialView(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarInitialView, "");
        return attrs;
    }

    /**
     * If set to true, user is notified by email of changes made to her
     * calendar by others via delegated calendar access.
     *
     * @return zimbraPrefCalendarNotifyDelegatedChanges, or false if unset
     */
    @ZAttr(id=273)
    public boolean isPrefCalendarNotifyDelegatedChanges() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarNotifyDelegatedChanges, false, true);
    }

    /**
     * If set to true, user is notified by email of changes made to her
     * calendar by others via delegated calendar access.
     *
     * @param zimbraPrefCalendarNotifyDelegatedChanges new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=273)
    public void setPrefCalendarNotifyDelegatedChanges(boolean zimbraPrefCalendarNotifyDelegatedChanges) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarNotifyDelegatedChanges, zimbraPrefCalendarNotifyDelegatedChanges ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If set to true, user is notified by email of changes made to her
     * calendar by others via delegated calendar access.
     *
     * @param zimbraPrefCalendarNotifyDelegatedChanges new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=273)
    public Map<String,Object> setPrefCalendarNotifyDelegatedChanges(boolean zimbraPrefCalendarNotifyDelegatedChanges, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarNotifyDelegatedChanges, zimbraPrefCalendarNotifyDelegatedChanges ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If set to true, user is notified by email of changes made to her
     * calendar by others via delegated calendar access.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=273)
    public void unsetPrefCalendarNotifyDelegatedChanges() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarNotifyDelegatedChanges, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If set to true, user is notified by email of changes made to her
     * calendar by others via delegated calendar access.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=273)
    public Map<String,Object> unsetPrefCalendarNotifyDelegatedChanges(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarNotifyDelegatedChanges, "");
        return attrs;
    }

    /**
     * device information entered by the user for receiving reminders for
     * appointments and tasks
     *
     * @return zimbraPrefCalendarReminderDeviceInfo, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1307)
    public String getPrefCalendarReminderDeviceInfo() {
        return getAttr(Provisioning.A_zimbraPrefCalendarReminderDeviceInfo, null, true);
    }

    /**
     * device information entered by the user for receiving reminders for
     * appointments and tasks
     *
     * @param zimbraPrefCalendarReminderDeviceInfo new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1307)
    public void setPrefCalendarReminderDeviceInfo(String zimbraPrefCalendarReminderDeviceInfo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDeviceInfo, zimbraPrefCalendarReminderDeviceInfo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * device information entered by the user for receiving reminders for
     * appointments and tasks
     *
     * @param zimbraPrefCalendarReminderDeviceInfo new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1307)
    public Map<String,Object> setPrefCalendarReminderDeviceInfo(String zimbraPrefCalendarReminderDeviceInfo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDeviceInfo, zimbraPrefCalendarReminderDeviceInfo);
        return attrs;
    }

    /**
     * device information entered by the user for receiving reminders for
     * appointments and tasks
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1307)
    public void unsetPrefCalendarReminderDeviceInfo() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDeviceInfo, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * device information entered by the user for receiving reminders for
     * appointments and tasks
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1307)
    public Map<String,Object> unsetPrefCalendarReminderDeviceInfo(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDeviceInfo, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the first reminder for an event.
     *
     * @return zimbraPrefCalendarReminderDuration1, or "-PT15M" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=573)
    public String getPrefCalendarReminderDuration1() {
        return getAttr(Provisioning.A_zimbraPrefCalendarReminderDuration1, "-PT15M", true);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the first reminder for an event.
     *
     * @param zimbraPrefCalendarReminderDuration1 new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=573)
    public void setPrefCalendarReminderDuration1(String zimbraPrefCalendarReminderDuration1) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDuration1, zimbraPrefCalendarReminderDuration1);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the first reminder for an event.
     *
     * @param zimbraPrefCalendarReminderDuration1 new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=573)
    public Map<String,Object> setPrefCalendarReminderDuration1(String zimbraPrefCalendarReminderDuration1, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDuration1, zimbraPrefCalendarReminderDuration1);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the first reminder for an event.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=573)
    public void unsetPrefCalendarReminderDuration1() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDuration1, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the first reminder for an event.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=573)
    public Map<String,Object> unsetPrefCalendarReminderDuration1(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDuration1, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the second reminder for an event.
     *
     * @return zimbraPrefCalendarReminderDuration2, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=574)
    public String getPrefCalendarReminderDuration2() {
        return getAttr(Provisioning.A_zimbraPrefCalendarReminderDuration2, null, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the second reminder for an event.
     *
     * @param zimbraPrefCalendarReminderDuration2 new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=574)
    public void setPrefCalendarReminderDuration2(String zimbraPrefCalendarReminderDuration2) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDuration2, zimbraPrefCalendarReminderDuration2);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the second reminder for an event.
     *
     * @param zimbraPrefCalendarReminderDuration2 new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=574)
    public Map<String,Object> setPrefCalendarReminderDuration2(String zimbraPrefCalendarReminderDuration2, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDuration2, zimbraPrefCalendarReminderDuration2);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the second reminder for an event.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=574)
    public void unsetPrefCalendarReminderDuration2() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDuration2, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: When to send the second reminder for an event.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=574)
    public Map<String,Object> unsetPrefCalendarReminderDuration2(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderDuration2, "");
        return attrs;
    }

    /**
     * RFC822 email address for receiving reminders for appointments and
     * tasks
     *
     * @return zimbraPrefCalendarReminderEmail, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=575)
    public String getPrefCalendarReminderEmail() {
        return getAttr(Provisioning.A_zimbraPrefCalendarReminderEmail, null, true);
    }

    /**
     * RFC822 email address for receiving reminders for appointments and
     * tasks
     *
     * @param zimbraPrefCalendarReminderEmail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=575)
    public void setPrefCalendarReminderEmail(String zimbraPrefCalendarReminderEmail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderEmail, zimbraPrefCalendarReminderEmail);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address for receiving reminders for appointments and
     * tasks
     *
     * @param zimbraPrefCalendarReminderEmail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=575)
    public Map<String,Object> setPrefCalendarReminderEmail(String zimbraPrefCalendarReminderEmail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderEmail, zimbraPrefCalendarReminderEmail);
        return attrs;
    }

    /**
     * RFC822 email address for receiving reminders for appointments and
     * tasks
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=575)
    public void unsetPrefCalendarReminderEmail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderEmail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address for receiving reminders for appointments and
     * tasks
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=575)
    public Map<String,Object> unsetPrefCalendarReminderEmail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderEmail, "");
        return attrs;
    }

    /**
     * Flash title when on appointment reminder notification
     *
     * @return zimbraPrefCalendarReminderFlashTitle, or true if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=682)
    public boolean isPrefCalendarReminderFlashTitle() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarReminderFlashTitle, true, true);
    }

    /**
     * Flash title when on appointment reminder notification
     *
     * @param zimbraPrefCalendarReminderFlashTitle new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=682)
    public void setPrefCalendarReminderFlashTitle(boolean zimbraPrefCalendarReminderFlashTitle) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderFlashTitle, zimbraPrefCalendarReminderFlashTitle ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flash title when on appointment reminder notification
     *
     * @param zimbraPrefCalendarReminderFlashTitle new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=682)
    public Map<String,Object> setPrefCalendarReminderFlashTitle(boolean zimbraPrefCalendarReminderFlashTitle, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderFlashTitle, zimbraPrefCalendarReminderFlashTitle ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Flash title when on appointment reminder notification
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=682)
    public void unsetPrefCalendarReminderFlashTitle() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderFlashTitle, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flash title when on appointment reminder notification
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=682)
    public Map<String,Object> unsetPrefCalendarReminderFlashTitle(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderFlashTitle, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: The mobile device (phone) the reminder goes to.
     *
     * @return zimbraPrefCalendarReminderMobile, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=577)
    public boolean isPrefCalendarReminderMobile() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarReminderMobile, false, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: The mobile device (phone) the reminder goes to.
     *
     * @param zimbraPrefCalendarReminderMobile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=577)
    public void setPrefCalendarReminderMobile(boolean zimbraPrefCalendarReminderMobile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderMobile, zimbraPrefCalendarReminderMobile ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: The mobile device (phone) the reminder goes to.
     *
     * @param zimbraPrefCalendarReminderMobile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=577)
    public Map<String,Object> setPrefCalendarReminderMobile(boolean zimbraPrefCalendarReminderMobile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderMobile, zimbraPrefCalendarReminderMobile ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: The mobile device (phone) the reminder goes to.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=577)
    public void unsetPrefCalendarReminderMobile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderMobile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: The mobile device (phone) the reminder goes to.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=577)
    public Map<String,Object> unsetPrefCalendarReminderMobile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderMobile, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: whether or not email reminders for appointments and
     * tasks are enabled
     *
     * @return zimbraPrefCalendarReminderSendEmail, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=576)
    public boolean isPrefCalendarReminderSendEmail() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarReminderSendEmail, false, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: whether or not email reminders for appointments and
     * tasks are enabled
     *
     * @param zimbraPrefCalendarReminderSendEmail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=576)
    public void setPrefCalendarReminderSendEmail(boolean zimbraPrefCalendarReminderSendEmail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderSendEmail, zimbraPrefCalendarReminderSendEmail ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: whether or not email reminders for appointments and
     * tasks are enabled
     *
     * @param zimbraPrefCalendarReminderSendEmail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=576)
    public Map<String,Object> setPrefCalendarReminderSendEmail(boolean zimbraPrefCalendarReminderSendEmail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderSendEmail, zimbraPrefCalendarReminderSendEmail ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: whether or not email reminders for appointments and
     * tasks are enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=576)
    public void unsetPrefCalendarReminderSendEmail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderSendEmail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: whether or not email reminders for appointments and
     * tasks are enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=576)
    public Map<String,Object> unsetPrefCalendarReminderSendEmail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderSendEmail, "");
        return attrs;
    }

    /**
     * whether audible alert is enabled when appointment notification is
     * played
     *
     * @return zimbraPrefCalendarReminderSoundsEnabled, or true if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=667)
    public boolean isPrefCalendarReminderSoundsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarReminderSoundsEnabled, true, true);
    }

    /**
     * whether audible alert is enabled when appointment notification is
     * played
     *
     * @param zimbraPrefCalendarReminderSoundsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=667)
    public void setPrefCalendarReminderSoundsEnabled(boolean zimbraPrefCalendarReminderSoundsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderSoundsEnabled, zimbraPrefCalendarReminderSoundsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether audible alert is enabled when appointment notification is
     * played
     *
     * @param zimbraPrefCalendarReminderSoundsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=667)
    public Map<String,Object> setPrefCalendarReminderSoundsEnabled(boolean zimbraPrefCalendarReminderSoundsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderSoundsEnabled, zimbraPrefCalendarReminderSoundsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether audible alert is enabled when appointment notification is
     * played
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=667)
    public void unsetPrefCalendarReminderSoundsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderSoundsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether audible alert is enabled when appointment notification is
     * played
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=667)
    public Map<String,Object> unsetPrefCalendarReminderSoundsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderSoundsEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: Send a reminder via YIM
     *
     * @return zimbraPrefCalendarReminderYMessenger, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=578)
    public boolean isPrefCalendarReminderYMessenger() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarReminderYMessenger, false, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: Send a reminder via YIM
     *
     * @param zimbraPrefCalendarReminderYMessenger new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=578)
    public void setPrefCalendarReminderYMessenger(boolean zimbraPrefCalendarReminderYMessenger) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderYMessenger, zimbraPrefCalendarReminderYMessenger ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: Send a reminder via YIM
     *
     * @param zimbraPrefCalendarReminderYMessenger new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=578)
    public Map<String,Object> setPrefCalendarReminderYMessenger(boolean zimbraPrefCalendarReminderYMessenger, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderYMessenger, zimbraPrefCalendarReminderYMessenger ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: Send a reminder via YIM
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=578)
    public void unsetPrefCalendarReminderYMessenger() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderYMessenger, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. was added for Yahoo calendar, no longer
     * used. Orig desc: Send a reminder via YIM
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=578)
    public Map<String,Object> unsetPrefCalendarReminderYMessenger(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarReminderYMessenger, "");
        return attrs;
    }

    /**
     * If an invite is received from an organizer who does not have
     * permission to invite this user to a meeting, send an auto-decline
     * reply. Note that
     * zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply may further
     * restrict who can receive this reply.
     *
     * @return zimbraPrefCalendarSendInviteDeniedAutoReply, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=849)
    public boolean isPrefCalendarSendInviteDeniedAutoReply() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarSendInviteDeniedAutoReply, false, true);
    }

    /**
     * If an invite is received from an organizer who does not have
     * permission to invite this user to a meeting, send an auto-decline
     * reply. Note that
     * zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply may further
     * restrict who can receive this reply.
     *
     * @param zimbraPrefCalendarSendInviteDeniedAutoReply new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=849)
    public void setPrefCalendarSendInviteDeniedAutoReply(boolean zimbraPrefCalendarSendInviteDeniedAutoReply) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarSendInviteDeniedAutoReply, zimbraPrefCalendarSendInviteDeniedAutoReply ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If an invite is received from an organizer who does not have
     * permission to invite this user to a meeting, send an auto-decline
     * reply. Note that
     * zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply may further
     * restrict who can receive this reply.
     *
     * @param zimbraPrefCalendarSendInviteDeniedAutoReply new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=849)
    public Map<String,Object> setPrefCalendarSendInviteDeniedAutoReply(boolean zimbraPrefCalendarSendInviteDeniedAutoReply, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarSendInviteDeniedAutoReply, zimbraPrefCalendarSendInviteDeniedAutoReply ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If an invite is received from an organizer who does not have
     * permission to invite this user to a meeting, send an auto-decline
     * reply. Note that
     * zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply may further
     * restrict who can receive this reply.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=849)
    public void unsetPrefCalendarSendInviteDeniedAutoReply() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarSendInviteDeniedAutoReply, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If an invite is received from an organizer who does not have
     * permission to invite this user to a meeting, send an auto-decline
     * reply. Note that
     * zimbraPrefCalendarAllowedTargetsForInviteDeniedAutoReply may further
     * restrict who can receive this reply.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=849)
    public Map<String,Object> unsetPrefCalendarSendInviteDeniedAutoReply(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarSendInviteDeniedAutoReply, "");
        return attrs;
    }

    /**
     * whether to show declined meetings in calendar
     *
     * @return zimbraPrefCalendarShowDeclinedMeetings, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1196)
    public boolean isPrefCalendarShowDeclinedMeetings() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarShowDeclinedMeetings, true, true);
    }

    /**
     * whether to show declined meetings in calendar
     *
     * @param zimbraPrefCalendarShowDeclinedMeetings new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1196)
    public void setPrefCalendarShowDeclinedMeetings(boolean zimbraPrefCalendarShowDeclinedMeetings) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarShowDeclinedMeetings, zimbraPrefCalendarShowDeclinedMeetings ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to show declined meetings in calendar
     *
     * @param zimbraPrefCalendarShowDeclinedMeetings new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1196)
    public Map<String,Object> setPrefCalendarShowDeclinedMeetings(boolean zimbraPrefCalendarShowDeclinedMeetings, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarShowDeclinedMeetings, zimbraPrefCalendarShowDeclinedMeetings ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to show declined meetings in calendar
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1196)
    public void unsetPrefCalendarShowDeclinedMeetings() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarShowDeclinedMeetings, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to show declined meetings in calendar
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1196)
    public Map<String,Object> unsetPrefCalendarShowDeclinedMeetings(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarShowDeclinedMeetings, "");
        return attrs;
    }

    /**
     * whether to pop-up reminder for past due appointments in the UI
     *
     * @return zimbraPrefCalendarShowPastDueReminders, or true if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1022)
    public boolean isPrefCalendarShowPastDueReminders() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarShowPastDueReminders, true, true);
    }

    /**
     * whether to pop-up reminder for past due appointments in the UI
     *
     * @param zimbraPrefCalendarShowPastDueReminders new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1022)
    public void setPrefCalendarShowPastDueReminders(boolean zimbraPrefCalendarShowPastDueReminders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarShowPastDueReminders, zimbraPrefCalendarShowPastDueReminders ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to pop-up reminder for past due appointments in the UI
     *
     * @param zimbraPrefCalendarShowPastDueReminders new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1022)
    public Map<String,Object> setPrefCalendarShowPastDueReminders(boolean zimbraPrefCalendarShowPastDueReminders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarShowPastDueReminders, zimbraPrefCalendarShowPastDueReminders ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to pop-up reminder for past due appointments in the UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1022)
    public void unsetPrefCalendarShowPastDueReminders() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarShowPastDueReminders, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to pop-up reminder for past due appointments in the UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1022)
    public Map<String,Object> unsetPrefCalendarShowPastDueReminders(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarShowPastDueReminders, "");
        return attrs;
    }

    /**
     * calendar manual tentative accept reply signature id for
     * account/identity/dataSource
     *
     * @return zimbraPrefCalendarTentativeSignatureId, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1203)
    public String getPrefCalendarTentativeSignatureId() {
        return getAttr(Provisioning.A_zimbraPrefCalendarTentativeSignatureId, null, true);
    }

    /**
     * calendar manual tentative accept reply signature id for
     * account/identity/dataSource
     *
     * @param zimbraPrefCalendarTentativeSignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1203)
    public void setPrefCalendarTentativeSignatureId(String zimbraPrefCalendarTentativeSignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarTentativeSignatureId, zimbraPrefCalendarTentativeSignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar manual tentative accept reply signature id for
     * account/identity/dataSource
     *
     * @param zimbraPrefCalendarTentativeSignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1203)
    public Map<String,Object> setPrefCalendarTentativeSignatureId(String zimbraPrefCalendarTentativeSignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarTentativeSignatureId, zimbraPrefCalendarTentativeSignatureId);
        return attrs;
    }

    /**
     * calendar manual tentative accept reply signature id for
     * account/identity/dataSource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1203)
    public void unsetPrefCalendarTentativeSignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarTentativeSignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * calendar manual tentative accept reply signature id for
     * account/identity/dataSource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1203)
    public Map<String,Object> unsetPrefCalendarTentativeSignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarTentativeSignatureId, "");
        return attrs;
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @return zimbraPrefCalendarToasterEnabled, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=813)
    public boolean isPrefCalendarToasterEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarToasterEnabled, false, true);
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @param zimbraPrefCalendarToasterEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=813)
    public void setPrefCalendarToasterEnabled(boolean zimbraPrefCalendarToasterEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarToasterEnabled, zimbraPrefCalendarToasterEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @param zimbraPrefCalendarToasterEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=813)
    public Map<String,Object> setPrefCalendarToasterEnabled(boolean zimbraPrefCalendarToasterEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarToasterEnabled, zimbraPrefCalendarToasterEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=813)
    public void unsetPrefCalendarToasterEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarToasterEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=813)
    public Map<String,Object> unsetPrefCalendarToasterEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarToasterEnabled, "");
        return attrs;
    }

    /**
     * whether or not use quick add dialog or go into full appt edit view
     *
     * @return zimbraPrefCalendarUseQuickAdd, or true if unset
     */
    @ZAttr(id=274)
    public boolean isPrefCalendarUseQuickAdd() {
        return getBooleanAttr(Provisioning.A_zimbraPrefCalendarUseQuickAdd, true, true);
    }

    /**
     * whether or not use quick add dialog or go into full appt edit view
     *
     * @param zimbraPrefCalendarUseQuickAdd new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=274)
    public void setPrefCalendarUseQuickAdd(boolean zimbraPrefCalendarUseQuickAdd) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarUseQuickAdd, zimbraPrefCalendarUseQuickAdd ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not use quick add dialog or go into full appt edit view
     *
     * @param zimbraPrefCalendarUseQuickAdd new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=274)
    public Map<String,Object> setPrefCalendarUseQuickAdd(boolean zimbraPrefCalendarUseQuickAdd, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarUseQuickAdd, zimbraPrefCalendarUseQuickAdd ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not use quick add dialog or go into full appt edit view
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=274)
    public void unsetPrefCalendarUseQuickAdd() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarUseQuickAdd, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not use quick add dialog or go into full appt edit view
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=274)
    public Map<String,Object> unsetPrefCalendarUseQuickAdd(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarUseQuickAdd, "");
        return attrs;
    }

    /**
     * time interval to display on calendar views. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getPrefCalendarViewTimeIntervalAsString to access value as a string.
     *
     * @see #getPrefCalendarViewTimeIntervalAsString()
     *
     * @return zimbraPrefCalendarViewTimeInterval in millseconds, or 3600000 (1h)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1195)
    public long getPrefCalendarViewTimeInterval() {
        return getTimeInterval(Provisioning.A_zimbraPrefCalendarViewTimeInterval, 3600000L, true);
    }

    /**
     * time interval to display on calendar views. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraPrefCalendarViewTimeInterval, or "1h" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1195)
    public String getPrefCalendarViewTimeIntervalAsString() {
        return getAttr(Provisioning.A_zimbraPrefCalendarViewTimeInterval, "1h", true);
    }

    /**
     * time interval to display on calendar views. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraPrefCalendarViewTimeInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1195)
    public void setPrefCalendarViewTimeInterval(String zimbraPrefCalendarViewTimeInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarViewTimeInterval, zimbraPrefCalendarViewTimeInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval to display on calendar views. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraPrefCalendarViewTimeInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1195)
    public Map<String,Object> setPrefCalendarViewTimeInterval(String zimbraPrefCalendarViewTimeInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarViewTimeInterval, zimbraPrefCalendarViewTimeInterval);
        return attrs;
    }

    /**
     * time interval to display on calendar views. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1195)
    public void unsetPrefCalendarViewTimeInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarViewTimeInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval to display on calendar views. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1195)
    public Map<String,Object> unsetPrefCalendarViewTimeInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarViewTimeInterval, "");
        return attrs;
    }

    /**
     * working hours for each day of the week
     *
     * @return zimbraPrefCalendarWorkingHours, or "1:N:0800:1700,2:Y:0800:1700,3:Y:0800:1700,4:Y:0800:1700,5:Y:0800:1700,6:Y:0800:1700,7:N:0800:1700" if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1103)
    public String getPrefCalendarWorkingHours() {
        return getAttr(Provisioning.A_zimbraPrefCalendarWorkingHours, "1:N:0800:1700,2:Y:0800:1700,3:Y:0800:1700,4:Y:0800:1700,5:Y:0800:1700,6:Y:0800:1700,7:N:0800:1700", true);
    }

    /**
     * working hours for each day of the week
     *
     * @param zimbraPrefCalendarWorkingHours new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1103)
    public void setPrefCalendarWorkingHours(String zimbraPrefCalendarWorkingHours) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarWorkingHours, zimbraPrefCalendarWorkingHours);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * working hours for each day of the week
     *
     * @param zimbraPrefCalendarWorkingHours new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1103)
    public Map<String,Object> setPrefCalendarWorkingHours(String zimbraPrefCalendarWorkingHours, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarWorkingHours, zimbraPrefCalendarWorkingHours);
        return attrs;
    }

    /**
     * working hours for each day of the week
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1103)
    public void unsetPrefCalendarWorkingHours() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarWorkingHours, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * working hours for each day of the week
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1103)
    public Map<String,Object> unsetPrefCalendarWorkingHours(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefCalendarWorkingHours, "");
        return attrs;
    }

    /**
     * If FALSE, chat features are disabled in the client and user presence
     * is shown as offline to all other users.
     *
     * @return zimbraPrefChatEnabled, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2057)
    public boolean isPrefChatEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefChatEnabled, true, true);
    }

    /**
     * If FALSE, chat features are disabled in the client and user presence
     * is shown as offline to all other users.
     *
     * @param zimbraPrefChatEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2057)
    public void setPrefChatEnabled(boolean zimbraPrefChatEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChatEnabled, zimbraPrefChatEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If FALSE, chat features are disabled in the client and user presence
     * is shown as offline to all other users.
     *
     * @param zimbraPrefChatEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2057)
    public Map<String,Object> setPrefChatEnabled(boolean zimbraPrefChatEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChatEnabled, zimbraPrefChatEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If FALSE, chat features are disabled in the client and user presence
     * is shown as offline to all other users.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2057)
    public void unsetPrefChatEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChatEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If FALSE, chat features are disabled in the client and user presence
     * is shown as offline to all other users.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2057)
    public Map<String,Object> unsetPrefChatEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChatEnabled, "");
        return attrs;
    }

    /**
     * Whether to enable audible notifications for Chat
     *
     * @return zimbraPrefChatPlaySound, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2051)
    public boolean isPrefChatPlaySound() {
        return getBooleanAttr(Provisioning.A_zimbraPrefChatPlaySound, false, true);
    }

    /**
     * Whether to enable audible notifications for Chat
     *
     * @param zimbraPrefChatPlaySound new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2051)
    public void setPrefChatPlaySound(boolean zimbraPrefChatPlaySound) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChatPlaySound, zimbraPrefChatPlaySound ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable audible notifications for Chat
     *
     * @param zimbraPrefChatPlaySound new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2051)
    public Map<String,Object> setPrefChatPlaySound(boolean zimbraPrefChatPlaySound, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChatPlaySound, zimbraPrefChatPlaySound ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable audible notifications for Chat
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2051)
    public void unsetPrefChatPlaySound() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChatPlaySound, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable audible notifications for Chat
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2051)
    public Map<String,Object> unsetPrefChatPlaySound(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChatPlaySound, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @return zimbraPrefChildVisibleAccount, or empty array if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public String[] getPrefChildVisibleAccount() {
        return getMultiAttr(Provisioning.A_zimbraPrefChildVisibleAccount, true, true);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @param zimbraPrefChildVisibleAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public void setPrefChildVisibleAccount(String[] zimbraPrefChildVisibleAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChildVisibleAccount, zimbraPrefChildVisibleAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @param zimbraPrefChildVisibleAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public Map<String,Object> setPrefChildVisibleAccount(String[] zimbraPrefChildVisibleAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChildVisibleAccount, zimbraPrefChildVisibleAccount);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @param zimbraPrefChildVisibleAccount new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public void addPrefChildVisibleAccount(String zimbraPrefChildVisibleAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefChildVisibleAccount, zimbraPrefChildVisibleAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @param zimbraPrefChildVisibleAccount new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public Map<String,Object> addPrefChildVisibleAccount(String zimbraPrefChildVisibleAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefChildVisibleAccount, zimbraPrefChildVisibleAccount);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @param zimbraPrefChildVisibleAccount existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public void removePrefChildVisibleAccount(String zimbraPrefChildVisibleAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefChildVisibleAccount, zimbraPrefChildVisibleAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @param zimbraPrefChildVisibleAccount existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public Map<String,Object> removePrefChildVisibleAccount(String zimbraPrefChildVisibleAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefChildVisibleAccount, zimbraPrefChildVisibleAccount);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public void unsetPrefChildVisibleAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChildVisibleAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. family mailbox feature is deprecated. Orig
     * desc: zimbraId of visible child accounts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=553)
    public Map<String,Object> unsetPrefChildVisibleAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefChildVisibleAccount, "");
        return attrs;
    }

    /**
     * user preference of client type
     *
     * <p>Valid values: [standard, advanced, modern]
     *
     * @return zimbraPrefClientType, or ZAttrProvisioning.PrefClientType.modern if unset and/or has invalid value
     */
    @ZAttr(id=453)
    public ZAttrProvisioning.PrefClientType getPrefClientType() {
        try { String v = getAttr(Provisioning.A_zimbraPrefClientType, true, true); return v == null ? ZAttrProvisioning.PrefClientType.modern : ZAttrProvisioning.PrefClientType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefClientType.modern; }
    }

    /**
     * user preference of client type
     *
     * <p>Valid values: [standard, advanced, modern]
     *
     * @return zimbraPrefClientType, or "modern" if unset
     */
    @ZAttr(id=453)
    public String getPrefClientTypeAsString() {
        return getAttr(Provisioning.A_zimbraPrefClientType, "modern", true);
    }

    /**
     * user preference of client type
     *
     * <p>Valid values: [standard, advanced, modern]
     *
     * @param zimbraPrefClientType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=453)
    public void setPrefClientType(ZAttrProvisioning.PrefClientType zimbraPrefClientType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefClientType, zimbraPrefClientType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * user preference of client type
     *
     * <p>Valid values: [standard, advanced, modern]
     *
     * @param zimbraPrefClientType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=453)
    public Map<String,Object> setPrefClientType(ZAttrProvisioning.PrefClientType zimbraPrefClientType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefClientType, zimbraPrefClientType.toString());
        return attrs;
    }

    /**
     * user preference of client type
     *
     * <p>Valid values: [standard, advanced, modern]
     *
     * @param zimbraPrefClientType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=453)
    public void setPrefClientTypeAsString(String zimbraPrefClientType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefClientType, zimbraPrefClientType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * user preference of client type
     *
     * <p>Valid values: [standard, advanced, modern]
     *
     * @param zimbraPrefClientType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=453)
    public Map<String,Object> setPrefClientTypeAsString(String zimbraPrefClientType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefClientType, zimbraPrefClientType);
        return attrs;
    }

    /**
     * user preference of client type
     *
     * <p>Valid values: [standard, advanced, modern]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=453)
    public void unsetPrefClientType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefClientType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * user preference of client type
     *
     * <p>Valid values: [standard, advanced, modern]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=453)
    public Map<String,Object> unsetPrefClientType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefClientType, "");
        return attrs;
    }

    /**
     * whether or not to use tag color as the color for message items
     *
     * @return zimbraPrefColorMessagesEnabled, or false if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1424)
    public boolean isPrefColorMessagesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefColorMessagesEnabled, false, true);
    }

    /**
     * whether or not to use tag color as the color for message items
     *
     * @param zimbraPrefColorMessagesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1424)
    public void setPrefColorMessagesEnabled(boolean zimbraPrefColorMessagesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefColorMessagesEnabled, zimbraPrefColorMessagesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to use tag color as the color for message items
     *
     * @param zimbraPrefColorMessagesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1424)
    public Map<String,Object> setPrefColorMessagesEnabled(boolean zimbraPrefColorMessagesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefColorMessagesEnabled, zimbraPrefColorMessagesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to use tag color as the color for message items
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1424)
    public void unsetPrefColorMessagesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefColorMessagesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to use tag color as the color for message items
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1424)
    public Map<String,Object> unsetPrefColorMessagesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefColorMessagesEnabled, "");
        return attrs;
    }

    /**
     * direction for composing messages in the web client UI
     *
     * <p>Valid values: [LTR, RTL]
     *
     * @return zimbraPrefComposeDirection, or null if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1273)
    public ZAttrProvisioning.PrefComposeDirection getPrefComposeDirection() {
        try { String v = getAttr(Provisioning.A_zimbraPrefComposeDirection, true, true); return v == null ? null : ZAttrProvisioning.PrefComposeDirection.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * direction for composing messages in the web client UI
     *
     * <p>Valid values: [LTR, RTL]
     *
     * @return zimbraPrefComposeDirection, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1273)
    public String getPrefComposeDirectionAsString() {
        return getAttr(Provisioning.A_zimbraPrefComposeDirection, null, true);
    }

    /**
     * direction for composing messages in the web client UI
     *
     * <p>Valid values: [LTR, RTL]
     *
     * @param zimbraPrefComposeDirection new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1273)
    public void setPrefComposeDirection(ZAttrProvisioning.PrefComposeDirection zimbraPrefComposeDirection) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeDirection, zimbraPrefComposeDirection.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * direction for composing messages in the web client UI
     *
     * <p>Valid values: [LTR, RTL]
     *
     * @param zimbraPrefComposeDirection new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1273)
    public Map<String,Object> setPrefComposeDirection(ZAttrProvisioning.PrefComposeDirection zimbraPrefComposeDirection, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeDirection, zimbraPrefComposeDirection.toString());
        return attrs;
    }

    /**
     * direction for composing messages in the web client UI
     *
     * <p>Valid values: [LTR, RTL]
     *
     * @param zimbraPrefComposeDirection new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1273)
    public void setPrefComposeDirectionAsString(String zimbraPrefComposeDirection) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeDirection, zimbraPrefComposeDirection);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * direction for composing messages in the web client UI
     *
     * <p>Valid values: [LTR, RTL]
     *
     * @param zimbraPrefComposeDirection new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1273)
    public Map<String,Object> setPrefComposeDirectionAsString(String zimbraPrefComposeDirection, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeDirection, zimbraPrefComposeDirection);
        return attrs;
    }

    /**
     * direction for composing messages in the web client UI
     *
     * <p>Valid values: [LTR, RTL]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1273)
    public void unsetPrefComposeDirection() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeDirection, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * direction for composing messages in the web client UI
     *
     * <p>Valid values: [LTR, RTL]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1273)
    public Map<String,Object> unsetPrefComposeDirection(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeDirection, "");
        return attrs;
    }

    /**
     * whether or not to compose in html or text.
     *
     * <p>Valid values: [text, html]
     *
     * @return zimbraPrefComposeFormat, or ZAttrProvisioning.PrefComposeFormat.html if unset and/or has invalid value
     */
    @ZAttr(id=217)
    public ZAttrProvisioning.PrefComposeFormat getPrefComposeFormat() {
        try { String v = getAttr(Provisioning.A_zimbraPrefComposeFormat, true, true); return v == null ? ZAttrProvisioning.PrefComposeFormat.html : ZAttrProvisioning.PrefComposeFormat.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefComposeFormat.html; }
    }

    /**
     * whether or not to compose in html or text.
     *
     * <p>Valid values: [text, html]
     *
     * @return zimbraPrefComposeFormat, or "html" if unset
     */
    @ZAttr(id=217)
    public String getPrefComposeFormatAsString() {
        return getAttr(Provisioning.A_zimbraPrefComposeFormat, "html", true);
    }

    /**
     * whether or not to compose in html or text.
     *
     * <p>Valid values: [text, html]
     *
     * @param zimbraPrefComposeFormat new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=217)
    public void setPrefComposeFormat(ZAttrProvisioning.PrefComposeFormat zimbraPrefComposeFormat) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeFormat, zimbraPrefComposeFormat.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to compose in html or text.
     *
     * <p>Valid values: [text, html]
     *
     * @param zimbraPrefComposeFormat new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=217)
    public Map<String,Object> setPrefComposeFormat(ZAttrProvisioning.PrefComposeFormat zimbraPrefComposeFormat, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeFormat, zimbraPrefComposeFormat.toString());
        return attrs;
    }

    /**
     * whether or not to compose in html or text.
     *
     * <p>Valid values: [text, html]
     *
     * @param zimbraPrefComposeFormat new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=217)
    public void setPrefComposeFormatAsString(String zimbraPrefComposeFormat) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeFormat, zimbraPrefComposeFormat);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to compose in html or text.
     *
     * <p>Valid values: [text, html]
     *
     * @param zimbraPrefComposeFormat new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=217)
    public Map<String,Object> setPrefComposeFormatAsString(String zimbraPrefComposeFormat, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeFormat, zimbraPrefComposeFormat);
        return attrs;
    }

    /**
     * whether or not to compose in html or text.
     *
     * <p>Valid values: [text, html]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=217)
    public void unsetPrefComposeFormat() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeFormat, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to compose in html or text.
     *
     * <p>Valid values: [text, html]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=217)
    public Map<String,Object> unsetPrefComposeFormat(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeFormat, "");
        return attrs;
    }

    /**
     * whether or not compose messages in a new windows by default
     *
     * @return zimbraPrefComposeInNewWindow, or false if unset
     */
    @ZAttr(id=209)
    public boolean isPrefComposeInNewWindow() {
        return getBooleanAttr(Provisioning.A_zimbraPrefComposeInNewWindow, false, true);
    }

    /**
     * whether or not compose messages in a new windows by default
     *
     * @param zimbraPrefComposeInNewWindow new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=209)
    public void setPrefComposeInNewWindow(boolean zimbraPrefComposeInNewWindow) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeInNewWindow, zimbraPrefComposeInNewWindow ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not compose messages in a new windows by default
     *
     * @param zimbraPrefComposeInNewWindow new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=209)
    public Map<String,Object> setPrefComposeInNewWindow(boolean zimbraPrefComposeInNewWindow, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeInNewWindow, zimbraPrefComposeInNewWindow ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not compose messages in a new windows by default
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=209)
    public void unsetPrefComposeInNewWindow() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeInNewWindow, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not compose messages in a new windows by default
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=209)
    public Map<String,Object> unsetPrefComposeInNewWindow(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefComposeInNewWindow, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Since 8.0.0, the contact group can contain
     * member references, but member references are not searchable.. Orig
     * desc: Disables autocomplete matching against the members email
     * address.
     *
     * @return zimbraPrefContactsDisableAutocompleteOnContactGroupMembers, or false if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1090)
    public boolean isPrefContactsDisableAutocompleteOnContactGroupMembers() {
        return getBooleanAttr(Provisioning.A_zimbraPrefContactsDisableAutocompleteOnContactGroupMembers, false, true);
    }

    /**
     * Deprecated since: 8.0.0. Since 8.0.0, the contact group can contain
     * member references, but member references are not searchable.. Orig
     * desc: Disables autocomplete matching against the members email
     * address.
     *
     * @param zimbraPrefContactsDisableAutocompleteOnContactGroupMembers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1090)
    public void setPrefContactsDisableAutocompleteOnContactGroupMembers(boolean zimbraPrefContactsDisableAutocompleteOnContactGroupMembers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsDisableAutocompleteOnContactGroupMembers, zimbraPrefContactsDisableAutocompleteOnContactGroupMembers ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Since 8.0.0, the contact group can contain
     * member references, but member references are not searchable.. Orig
     * desc: Disables autocomplete matching against the members email
     * address.
     *
     * @param zimbraPrefContactsDisableAutocompleteOnContactGroupMembers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1090)
    public Map<String,Object> setPrefContactsDisableAutocompleteOnContactGroupMembers(boolean zimbraPrefContactsDisableAutocompleteOnContactGroupMembers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsDisableAutocompleteOnContactGroupMembers, zimbraPrefContactsDisableAutocompleteOnContactGroupMembers ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Since 8.0.0, the contact group can contain
     * member references, but member references are not searchable.. Orig
     * desc: Disables autocomplete matching against the members email
     * address.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1090)
    public void unsetPrefContactsDisableAutocompleteOnContactGroupMembers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsDisableAutocompleteOnContactGroupMembers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Since 8.0.0, the contact group can contain
     * member references, but member references are not searchable.. Orig
     * desc: Disables autocomplete matching against the members email
     * address.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1090)
    public Map<String,Object> unsetPrefContactsDisableAutocompleteOnContactGroupMembers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsDisableAutocompleteOnContactGroupMembers, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. deprecated now that Zimbra supports keeping
     * member references in a contact group. Orig desc: Expand the contact
     * groups in Apple Address Book format to Zimbra format over CardDAV.
     *
     * @return zimbraPrefContactsExpandAppleContactGroups, or false if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1102)
    public boolean isPrefContactsExpandAppleContactGroups() {
        return getBooleanAttr(Provisioning.A_zimbraPrefContactsExpandAppleContactGroups, false, true);
    }

    /**
     * Deprecated since: 8.0.0. deprecated now that Zimbra supports keeping
     * member references in a contact group. Orig desc: Expand the contact
     * groups in Apple Address Book format to Zimbra format over CardDAV.
     *
     * @param zimbraPrefContactsExpandAppleContactGroups new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1102)
    public void setPrefContactsExpandAppleContactGroups(boolean zimbraPrefContactsExpandAppleContactGroups) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsExpandAppleContactGroups, zimbraPrefContactsExpandAppleContactGroups ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. deprecated now that Zimbra supports keeping
     * member references in a contact group. Orig desc: Expand the contact
     * groups in Apple Address Book format to Zimbra format over CardDAV.
     *
     * @param zimbraPrefContactsExpandAppleContactGroups new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1102)
    public Map<String,Object> setPrefContactsExpandAppleContactGroups(boolean zimbraPrefContactsExpandAppleContactGroups, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsExpandAppleContactGroups, zimbraPrefContactsExpandAppleContactGroups ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. deprecated now that Zimbra supports keeping
     * member references in a contact group. Orig desc: Expand the contact
     * groups in Apple Address Book format to Zimbra format over CardDAV.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1102)
    public void unsetPrefContactsExpandAppleContactGroups() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsExpandAppleContactGroups, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. deprecated now that Zimbra supports keeping
     * member references in a contact group. Orig desc: Expand the contact
     * groups in Apple Address Book format to Zimbra format over CardDAV.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1102)
    public Map<String,Object> unsetPrefContactsExpandAppleContactGroups(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsExpandAppleContactGroups, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.5. We do not support cards view any more. See
     * bug 47439. Orig desc: initial contact view to use
     *
     * <p>Valid values: [cards, list]
     *
     * @return zimbraPrefContactsInitialView, or ZAttrProvisioning.PrefContactsInitialView.list if unset and/or has invalid value
     */
    @ZAttr(id=167)
    public ZAttrProvisioning.PrefContactsInitialView getPrefContactsInitialView() {
        try { String v = getAttr(Provisioning.A_zimbraPrefContactsInitialView, true, true); return v == null ? ZAttrProvisioning.PrefContactsInitialView.list : ZAttrProvisioning.PrefContactsInitialView.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefContactsInitialView.list; }
    }

    /**
     * Deprecated since: 6.0.5. We do not support cards view any more. See
     * bug 47439. Orig desc: initial contact view to use
     *
     * <p>Valid values: [cards, list]
     *
     * @return zimbraPrefContactsInitialView, or "list" if unset
     */
    @ZAttr(id=167)
    public String getPrefContactsInitialViewAsString() {
        return getAttr(Provisioning.A_zimbraPrefContactsInitialView, "list", true);
    }

    /**
     * Deprecated since: 6.0.5. We do not support cards view any more. See
     * bug 47439. Orig desc: initial contact view to use
     *
     * <p>Valid values: [cards, list]
     *
     * @param zimbraPrefContactsInitialView new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=167)
    public void setPrefContactsInitialView(ZAttrProvisioning.PrefContactsInitialView zimbraPrefContactsInitialView) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsInitialView, zimbraPrefContactsInitialView.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.5. We do not support cards view any more. See
     * bug 47439. Orig desc: initial contact view to use
     *
     * <p>Valid values: [cards, list]
     *
     * @param zimbraPrefContactsInitialView new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=167)
    public Map<String,Object> setPrefContactsInitialView(ZAttrProvisioning.PrefContactsInitialView zimbraPrefContactsInitialView, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsInitialView, zimbraPrefContactsInitialView.toString());
        return attrs;
    }

    /**
     * Deprecated since: 6.0.5. We do not support cards view any more. See
     * bug 47439. Orig desc: initial contact view to use
     *
     * <p>Valid values: [cards, list]
     *
     * @param zimbraPrefContactsInitialView new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=167)
    public void setPrefContactsInitialViewAsString(String zimbraPrefContactsInitialView) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsInitialView, zimbraPrefContactsInitialView);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.5. We do not support cards view any more. See
     * bug 47439. Orig desc: initial contact view to use
     *
     * <p>Valid values: [cards, list]
     *
     * @param zimbraPrefContactsInitialView new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=167)
    public Map<String,Object> setPrefContactsInitialViewAsString(String zimbraPrefContactsInitialView, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsInitialView, zimbraPrefContactsInitialView);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.5. We do not support cards view any more. See
     * bug 47439. Orig desc: initial contact view to use
     *
     * <p>Valid values: [cards, list]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=167)
    public void unsetPrefContactsInitialView() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsInitialView, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.5. We do not support cards view any more. See
     * bug 47439. Orig desc: initial contact view to use
     *
     * <p>Valid values: [cards, list]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=167)
    public Map<String,Object> unsetPrefContactsInitialView(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsInitialView, "");
        return attrs;
    }

    /**
     * number of contacts per page
     *
     * @return zimbraPrefContactsPerPage, or 25 if unset
     */
    @ZAttr(id=148)
    public int getPrefContactsPerPage() {
        return getIntAttr(Provisioning.A_zimbraPrefContactsPerPage, 25, true);
    }

    /**
     * number of contacts per page
     *
     * @param zimbraPrefContactsPerPage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=148)
    public void setPrefContactsPerPage(int zimbraPrefContactsPerPage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsPerPage, Integer.toString(zimbraPrefContactsPerPage));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of contacts per page
     *
     * @param zimbraPrefContactsPerPage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=148)
    public Map<String,Object> setPrefContactsPerPage(int zimbraPrefContactsPerPage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsPerPage, Integer.toString(zimbraPrefContactsPerPage));
        return attrs;
    }

    /**
     * number of contacts per page
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=148)
    public void unsetPrefContactsPerPage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsPerPage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of contacts per page
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=148)
    public Map<String,Object> unsetPrefContactsPerPage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefContactsPerPage, "");
        return attrs;
    }

    /**
     * where the message reading pane is displayed in conv view
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @return zimbraPrefConvReadingPaneLocation, or ZAttrProvisioning.PrefConvReadingPaneLocation.bottom if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1010)
    public ZAttrProvisioning.PrefConvReadingPaneLocation getPrefConvReadingPaneLocation() {
        try { String v = getAttr(Provisioning.A_zimbraPrefConvReadingPaneLocation, true, true); return v == null ? ZAttrProvisioning.PrefConvReadingPaneLocation.bottom : ZAttrProvisioning.PrefConvReadingPaneLocation.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefConvReadingPaneLocation.bottom; }
    }

    /**
     * where the message reading pane is displayed in conv view
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @return zimbraPrefConvReadingPaneLocation, or "bottom" if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1010)
    public String getPrefConvReadingPaneLocationAsString() {
        return getAttr(Provisioning.A_zimbraPrefConvReadingPaneLocation, "bottom", true);
    }

    /**
     * where the message reading pane is displayed in conv view
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefConvReadingPaneLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1010)
    public void setPrefConvReadingPaneLocation(ZAttrProvisioning.PrefConvReadingPaneLocation zimbraPrefConvReadingPaneLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvReadingPaneLocation, zimbraPrefConvReadingPaneLocation.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the message reading pane is displayed in conv view
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefConvReadingPaneLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1010)
    public Map<String,Object> setPrefConvReadingPaneLocation(ZAttrProvisioning.PrefConvReadingPaneLocation zimbraPrefConvReadingPaneLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvReadingPaneLocation, zimbraPrefConvReadingPaneLocation.toString());
        return attrs;
    }

    /**
     * where the message reading pane is displayed in conv view
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefConvReadingPaneLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1010)
    public void setPrefConvReadingPaneLocationAsString(String zimbraPrefConvReadingPaneLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvReadingPaneLocation, zimbraPrefConvReadingPaneLocation);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the message reading pane is displayed in conv view
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefConvReadingPaneLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1010)
    public Map<String,Object> setPrefConvReadingPaneLocationAsString(String zimbraPrefConvReadingPaneLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvReadingPaneLocation, zimbraPrefConvReadingPaneLocation);
        return attrs;
    }

    /**
     * where the message reading pane is displayed in conv view
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1010)
    public void unsetPrefConvReadingPaneLocation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvReadingPaneLocation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the message reading pane is displayed in conv view
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1010)
    public Map<String,Object> unsetPrefConvReadingPaneLocation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvReadingPaneLocation, "");
        return attrs;
    }

    /**
     * When displaying an invite in a conversation, show the day calendar
     * immediately.
     *
     * @return zimbraPrefConvShowCalendar, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1394)
    public boolean isPrefConvShowCalendar() {
        return getBooleanAttr(Provisioning.A_zimbraPrefConvShowCalendar, false, true);
    }

    /**
     * When displaying an invite in a conversation, show the day calendar
     * immediately.
     *
     * @param zimbraPrefConvShowCalendar new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1394)
    public void setPrefConvShowCalendar(boolean zimbraPrefConvShowCalendar) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvShowCalendar, zimbraPrefConvShowCalendar ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When displaying an invite in a conversation, show the day calendar
     * immediately.
     *
     * @param zimbraPrefConvShowCalendar new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1394)
    public Map<String,Object> setPrefConvShowCalendar(boolean zimbraPrefConvShowCalendar, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvShowCalendar, zimbraPrefConvShowCalendar ? TRUE : FALSE);
        return attrs;
    }

    /**
     * When displaying an invite in a conversation, show the day calendar
     * immediately.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1394)
    public void unsetPrefConvShowCalendar() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvShowCalendar, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When displaying an invite in a conversation, show the day calendar
     * immediately.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1394)
    public Map<String,Object> unsetPrefConvShowCalendar(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConvShowCalendar, "");
        return attrs;
    }

    /**
     * order of messages displayed within a conversation
     *
     * <p>Valid values: [dateDesc, dateAsc]
     *
     * @return zimbraPrefConversationOrder, or ZAttrProvisioning.PrefConversationOrder.dateDesc if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=818)
    public ZAttrProvisioning.PrefConversationOrder getPrefConversationOrder() {
        try { String v = getAttr(Provisioning.A_zimbraPrefConversationOrder, true, true); return v == null ? ZAttrProvisioning.PrefConversationOrder.dateDesc : ZAttrProvisioning.PrefConversationOrder.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefConversationOrder.dateDesc; }
    }

    /**
     * order of messages displayed within a conversation
     *
     * <p>Valid values: [dateDesc, dateAsc]
     *
     * @return zimbraPrefConversationOrder, or "dateDesc" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=818)
    public String getPrefConversationOrderAsString() {
        return getAttr(Provisioning.A_zimbraPrefConversationOrder, "dateDesc", true);
    }

    /**
     * order of messages displayed within a conversation
     *
     * <p>Valid values: [dateDesc, dateAsc]
     *
     * @param zimbraPrefConversationOrder new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=818)
    public void setPrefConversationOrder(ZAttrProvisioning.PrefConversationOrder zimbraPrefConversationOrder) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConversationOrder, zimbraPrefConversationOrder.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * order of messages displayed within a conversation
     *
     * <p>Valid values: [dateDesc, dateAsc]
     *
     * @param zimbraPrefConversationOrder new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=818)
    public Map<String,Object> setPrefConversationOrder(ZAttrProvisioning.PrefConversationOrder zimbraPrefConversationOrder, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConversationOrder, zimbraPrefConversationOrder.toString());
        return attrs;
    }

    /**
     * order of messages displayed within a conversation
     *
     * <p>Valid values: [dateDesc, dateAsc]
     *
     * @param zimbraPrefConversationOrder new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=818)
    public void setPrefConversationOrderAsString(String zimbraPrefConversationOrder) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConversationOrder, zimbraPrefConversationOrder);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * order of messages displayed within a conversation
     *
     * <p>Valid values: [dateDesc, dateAsc]
     *
     * @param zimbraPrefConversationOrder new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=818)
    public Map<String,Object> setPrefConversationOrderAsString(String zimbraPrefConversationOrder, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConversationOrder, zimbraPrefConversationOrder);
        return attrs;
    }

    /**
     * order of messages displayed within a conversation
     *
     * <p>Valid values: [dateDesc, dateAsc]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=818)
    public void unsetPrefConversationOrder() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConversationOrder, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * order of messages displayed within a conversation
     *
     * <p>Valid values: [dateDesc, dateAsc]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=818)
    public Map<String,Object> unsetPrefConversationOrder(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefConversationOrder, "");
        return attrs;
    }

    /**
     * dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll
     *
     * <p>Valid values: [dedupeNone, secondCopyifOnToOrCC, dedupeAll]
     *
     * @return zimbraPrefDedupeMessagesSentToSelf, or ZAttrProvisioning.PrefDedupeMessagesSentToSelf.dedupeNone if unset and/or has invalid value
     */
    @ZAttr(id=144)
    public ZAttrProvisioning.PrefDedupeMessagesSentToSelf getPrefDedupeMessagesSentToSelf() {
        try { String v = getAttr(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, true, true); return v == null ? ZAttrProvisioning.PrefDedupeMessagesSentToSelf.dedupeNone : ZAttrProvisioning.PrefDedupeMessagesSentToSelf.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefDedupeMessagesSentToSelf.dedupeNone; }
    }

    /**
     * dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll
     *
     * <p>Valid values: [dedupeNone, secondCopyifOnToOrCC, dedupeAll]
     *
     * @return zimbraPrefDedupeMessagesSentToSelf, or "dedupeNone" if unset
     */
    @ZAttr(id=144)
    public String getPrefDedupeMessagesSentToSelfAsString() {
        return getAttr(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, "dedupeNone", true);
    }

    /**
     * dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll
     *
     * <p>Valid values: [dedupeNone, secondCopyifOnToOrCC, dedupeAll]
     *
     * @param zimbraPrefDedupeMessagesSentToSelf new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=144)
    public void setPrefDedupeMessagesSentToSelf(ZAttrProvisioning.PrefDedupeMessagesSentToSelf zimbraPrefDedupeMessagesSentToSelf) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, zimbraPrefDedupeMessagesSentToSelf.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll
     *
     * <p>Valid values: [dedupeNone, secondCopyifOnToOrCC, dedupeAll]
     *
     * @param zimbraPrefDedupeMessagesSentToSelf new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=144)
    public Map<String,Object> setPrefDedupeMessagesSentToSelf(ZAttrProvisioning.PrefDedupeMessagesSentToSelf zimbraPrefDedupeMessagesSentToSelf, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, zimbraPrefDedupeMessagesSentToSelf.toString());
        return attrs;
    }

    /**
     * dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll
     *
     * <p>Valid values: [dedupeNone, secondCopyifOnToOrCC, dedupeAll]
     *
     * @param zimbraPrefDedupeMessagesSentToSelf new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=144)
    public void setPrefDedupeMessagesSentToSelfAsString(String zimbraPrefDedupeMessagesSentToSelf) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, zimbraPrefDedupeMessagesSentToSelf);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll
     *
     * <p>Valid values: [dedupeNone, secondCopyifOnToOrCC, dedupeAll]
     *
     * @param zimbraPrefDedupeMessagesSentToSelf new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=144)
    public Map<String,Object> setPrefDedupeMessagesSentToSelfAsString(String zimbraPrefDedupeMessagesSentToSelf, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, zimbraPrefDedupeMessagesSentToSelf);
        return attrs;
    }

    /**
     * dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll
     *
     * <p>Valid values: [dedupeNone, secondCopyifOnToOrCC, dedupeAll]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=144)
    public void unsetPrefDedupeMessagesSentToSelf() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll
     *
     * <p>Valid values: [dedupeNone, secondCopyifOnToOrCC, dedupeAll]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=144)
    public Map<String,Object> unsetPrefDedupeMessagesSentToSelf(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, "");
        return attrs;
    }

    /**
     * Default calendar folder id. Current default calendar id is 10, as
     * calendar folder with id 10, is created for all users. Cos level change
     * is blocked. So admin can not change value of this attribute on cos
     * level.
     *
     * @return zimbraPrefDefaultCalendarId, or 10 if unset
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2994)
    public int getPrefDefaultCalendarId() {
        return getIntAttr(Provisioning.A_zimbraPrefDefaultCalendarId, 10, true);
    }

    /**
     * Default calendar folder id. Current default calendar id is 10, as
     * calendar folder with id 10, is created for all users. Cos level change
     * is blocked. So admin can not change value of this attribute on cos
     * level.
     *
     * @param zimbraPrefDefaultCalendarId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2994)
    public void setPrefDefaultCalendarId(int zimbraPrefDefaultCalendarId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultCalendarId, Integer.toString(zimbraPrefDefaultCalendarId));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default calendar folder id. Current default calendar id is 10, as
     * calendar folder with id 10, is created for all users. Cos level change
     * is blocked. So admin can not change value of this attribute on cos
     * level.
     *
     * @param zimbraPrefDefaultCalendarId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2994)
    public Map<String,Object> setPrefDefaultCalendarId(int zimbraPrefDefaultCalendarId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultCalendarId, Integer.toString(zimbraPrefDefaultCalendarId));
        return attrs;
    }

    /**
     * Default calendar folder id. Current default calendar id is 10, as
     * calendar folder with id 10, is created for all users. Cos level change
     * is blocked. So admin can not change value of this attribute on cos
     * level.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2994)
    public void unsetPrefDefaultCalendarId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultCalendarId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default calendar folder id. Current default calendar id is 10, as
     * calendar folder with id 10, is created for all users. Cos level change
     * is blocked. So admin can not change value of this attribute on cos
     * level.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2994)
    public Map<String,Object> unsetPrefDefaultCalendarId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultCalendarId, "");
        return attrs;
    }

    /**
     * default font size
     *
     * @return zimbraPrefDefaultPrintFontSize, or "12pt" if unset
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1095)
    public String getPrefDefaultPrintFontSize() {
        return getAttr(Provisioning.A_zimbraPrefDefaultPrintFontSize, "12pt", true);
    }

    /**
     * default font size
     *
     * @param zimbraPrefDefaultPrintFontSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1095)
    public void setPrefDefaultPrintFontSize(String zimbraPrefDefaultPrintFontSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultPrintFontSize, zimbraPrefDefaultPrintFontSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default font size
     *
     * @param zimbraPrefDefaultPrintFontSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1095)
    public Map<String,Object> setPrefDefaultPrintFontSize(String zimbraPrefDefaultPrintFontSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultPrintFontSize, zimbraPrefDefaultPrintFontSize);
        return attrs;
    }

    /**
     * default font size
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1095)
    public void unsetPrefDefaultPrintFontSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultPrintFontSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default font size
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1095)
    public Map<String,Object> unsetPrefDefaultPrintFontSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultPrintFontSize, "");
        return attrs;
    }

    /**
     * default mail signature for account/identity/dataSource
     *
     * @return zimbraPrefDefaultSignatureId, or null if unset
     */
    @ZAttr(id=492)
    public String getPrefDefaultSignatureId() {
        return getAttr(Provisioning.A_zimbraPrefDefaultSignatureId, null, true);
    }

    /**
     * default mail signature for account/identity/dataSource
     *
     * @param zimbraPrefDefaultSignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=492)
    public void setPrefDefaultSignatureId(String zimbraPrefDefaultSignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultSignatureId, zimbraPrefDefaultSignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default mail signature for account/identity/dataSource
     *
     * @param zimbraPrefDefaultSignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=492)
    public Map<String,Object> setPrefDefaultSignatureId(String zimbraPrefDefaultSignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultSignatureId, zimbraPrefDefaultSignatureId);
        return attrs;
    }

    /**
     * default mail signature for account/identity/dataSource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=492)
    public void unsetPrefDefaultSignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultSignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default mail signature for account/identity/dataSource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=492)
    public Map<String,Object> unsetPrefDefaultSignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDefaultSignatureId, "");
        return attrs;
    }

    /**
     * Which mailbox to save messages sent via sendAs/sendOnBehalfOf
     * delegation to.
     *
     * <p>Valid values: [owner, sender, both, none]
     *
     * @return zimbraPrefDelegatedSendSaveTarget, or ZAttrProvisioning.PrefDelegatedSendSaveTarget.owner if unset and/or has invalid value
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1651)
    public ZAttrProvisioning.PrefDelegatedSendSaveTarget getPrefDelegatedSendSaveTarget() {
        try { String v = getAttr(Provisioning.A_zimbraPrefDelegatedSendSaveTarget, true, true); return v == null ? ZAttrProvisioning.PrefDelegatedSendSaveTarget.owner : ZAttrProvisioning.PrefDelegatedSendSaveTarget.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefDelegatedSendSaveTarget.owner; }
    }

    /**
     * Which mailbox to save messages sent via sendAs/sendOnBehalfOf
     * delegation to.
     *
     * <p>Valid values: [owner, sender, both, none]
     *
     * @return zimbraPrefDelegatedSendSaveTarget, or "owner" if unset
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1651)
    public String getPrefDelegatedSendSaveTargetAsString() {
        return getAttr(Provisioning.A_zimbraPrefDelegatedSendSaveTarget, "owner", true);
    }

    /**
     * Which mailbox to save messages sent via sendAs/sendOnBehalfOf
     * delegation to.
     *
     * <p>Valid values: [owner, sender, both, none]
     *
     * @param zimbraPrefDelegatedSendSaveTarget new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1651)
    public void setPrefDelegatedSendSaveTarget(ZAttrProvisioning.PrefDelegatedSendSaveTarget zimbraPrefDelegatedSendSaveTarget) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDelegatedSendSaveTarget, zimbraPrefDelegatedSendSaveTarget.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Which mailbox to save messages sent via sendAs/sendOnBehalfOf
     * delegation to.
     *
     * <p>Valid values: [owner, sender, both, none]
     *
     * @param zimbraPrefDelegatedSendSaveTarget new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1651)
    public Map<String,Object> setPrefDelegatedSendSaveTarget(ZAttrProvisioning.PrefDelegatedSendSaveTarget zimbraPrefDelegatedSendSaveTarget, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDelegatedSendSaveTarget, zimbraPrefDelegatedSendSaveTarget.toString());
        return attrs;
    }

    /**
     * Which mailbox to save messages sent via sendAs/sendOnBehalfOf
     * delegation to.
     *
     * <p>Valid values: [owner, sender, both, none]
     *
     * @param zimbraPrefDelegatedSendSaveTarget new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1651)
    public void setPrefDelegatedSendSaveTargetAsString(String zimbraPrefDelegatedSendSaveTarget) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDelegatedSendSaveTarget, zimbraPrefDelegatedSendSaveTarget);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Which mailbox to save messages sent via sendAs/sendOnBehalfOf
     * delegation to.
     *
     * <p>Valid values: [owner, sender, both, none]
     *
     * @param zimbraPrefDelegatedSendSaveTarget new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1651)
    public Map<String,Object> setPrefDelegatedSendSaveTargetAsString(String zimbraPrefDelegatedSendSaveTarget, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDelegatedSendSaveTarget, zimbraPrefDelegatedSendSaveTarget);
        return attrs;
    }

    /**
     * Which mailbox to save messages sent via sendAs/sendOnBehalfOf
     * delegation to.
     *
     * <p>Valid values: [owner, sender, both, none]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1651)
    public void unsetPrefDelegatedSendSaveTarget() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDelegatedSendSaveTarget, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Which mailbox to save messages sent via sendAs/sendOnBehalfOf
     * delegation to.
     *
     * <p>Valid values: [owner, sender, both, none]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1651)
    public Map<String,Object> unsetPrefDelegatedSendSaveTarget(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDelegatedSendSaveTarget, "");
        return attrs;
    }

    /**
     * whether meeting invite emails are moved to Trash folder upon
     * accept/decline
     *
     * @return zimbraPrefDeleteInviteOnReply, or true if unset
     */
    @ZAttr(id=470)
    public boolean isPrefDeleteInviteOnReply() {
        return getBooleanAttr(Provisioning.A_zimbraPrefDeleteInviteOnReply, true, true);
    }

    /**
     * whether meeting invite emails are moved to Trash folder upon
     * accept/decline
     *
     * @param zimbraPrefDeleteInviteOnReply new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=470)
    public void setPrefDeleteInviteOnReply(boolean zimbraPrefDeleteInviteOnReply) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDeleteInviteOnReply, zimbraPrefDeleteInviteOnReply ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether meeting invite emails are moved to Trash folder upon
     * accept/decline
     *
     * @param zimbraPrefDeleteInviteOnReply new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=470)
    public Map<String,Object> setPrefDeleteInviteOnReply(boolean zimbraPrefDeleteInviteOnReply, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDeleteInviteOnReply, zimbraPrefDeleteInviteOnReply ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether meeting invite emails are moved to Trash folder upon
     * accept/decline
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=470)
    public void unsetPrefDeleteInviteOnReply() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDeleteInviteOnReply, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether meeting invite emails are moved to Trash folder upon
     * accept/decline
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=470)
    public Map<String,Object> unsetPrefDeleteInviteOnReply(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDeleteInviteOnReply, "");
        return attrs;
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @return zimbraPrefDisabledZimlets, or empty array if unset
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public String[] getPrefDisabledZimlets() {
        return getMultiAttr(Provisioning.A_zimbraPrefDisabledZimlets, true, true);
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @param zimbraPrefDisabledZimlets new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public void setPrefDisabledZimlets(String[] zimbraPrefDisabledZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisabledZimlets, zimbraPrefDisabledZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @param zimbraPrefDisabledZimlets new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public Map<String,Object> setPrefDisabledZimlets(String[] zimbraPrefDisabledZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisabledZimlets, zimbraPrefDisabledZimlets);
        return attrs;
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @param zimbraPrefDisabledZimlets new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public void addPrefDisabledZimlets(String zimbraPrefDisabledZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefDisabledZimlets, zimbraPrefDisabledZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @param zimbraPrefDisabledZimlets new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public Map<String,Object> addPrefDisabledZimlets(String zimbraPrefDisabledZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefDisabledZimlets, zimbraPrefDisabledZimlets);
        return attrs;
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @param zimbraPrefDisabledZimlets existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public void removePrefDisabledZimlets(String zimbraPrefDisabledZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefDisabledZimlets, zimbraPrefDisabledZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @param zimbraPrefDisabledZimlets existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public Map<String,Object> removePrefDisabledZimlets(String zimbraPrefDisabledZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefDisabledZimlets, zimbraPrefDisabledZimlets);
        return attrs;
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public void unsetPrefDisabledZimlets() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisabledZimlets, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimlets user does not want to see in the UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1076)
    public Map<String,Object> unsetPrefDisabledZimlets(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisabledZimlets, "");
        return attrs;
    }

    /**
     * whether to display external images in HTML mail
     *
     * @return zimbraPrefDisplayExternalImages, or false if unset
     */
    @ZAttr(id=511)
    public boolean isPrefDisplayExternalImages() {
        return getBooleanAttr(Provisioning.A_zimbraPrefDisplayExternalImages, false, true);
    }

    /**
     * whether to display external images in HTML mail
     *
     * @param zimbraPrefDisplayExternalImages new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=511)
    public void setPrefDisplayExternalImages(boolean zimbraPrefDisplayExternalImages) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisplayExternalImages, zimbraPrefDisplayExternalImages ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display external images in HTML mail
     *
     * @param zimbraPrefDisplayExternalImages new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=511)
    public Map<String,Object> setPrefDisplayExternalImages(boolean zimbraPrefDisplayExternalImages, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisplayExternalImages, zimbraPrefDisplayExternalImages ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to display external images in HTML mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=511)
    public void unsetPrefDisplayExternalImages() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisplayExternalImages, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display external images in HTML mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=511)
    public Map<String,Object> unsetPrefDisplayExternalImages(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisplayExternalImages, "");
        return attrs;
    }

    /**
     * Display received/sent time in mail list
     *
     * @return zimbraPrefDisplayTimeInMailList, or false if unset
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3022)
    public boolean isPrefDisplayTimeInMailList() {
        return getBooleanAttr(Provisioning.A_zimbraPrefDisplayTimeInMailList, false, true);
    }

    /**
     * Display received/sent time in mail list
     *
     * @param zimbraPrefDisplayTimeInMailList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3022)
    public void setPrefDisplayTimeInMailList(boolean zimbraPrefDisplayTimeInMailList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisplayTimeInMailList, zimbraPrefDisplayTimeInMailList ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Display received/sent time in mail list
     *
     * @param zimbraPrefDisplayTimeInMailList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3022)
    public Map<String,Object> setPrefDisplayTimeInMailList(boolean zimbraPrefDisplayTimeInMailList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisplayTimeInMailList, zimbraPrefDisplayTimeInMailList ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Display received/sent time in mail list
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3022)
    public void unsetPrefDisplayTimeInMailList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisplayTimeInMailList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Display received/sent time in mail list
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3022)
    public Map<String,Object> unsetPrefDisplayTimeInMailList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefDisplayTimeInMailList, "");
        return attrs;
    }

    /**
     * Specifies the meaning of an external sender. &quot;ALL&quot; means
     * users whose domain doesn&#039;t match the recipient&#039;s or
     * zimbraInternalSendersDomain. &quot;ALLNOTINAB&quot; means
     * &quot;ALL&quot; minus users who are in the recipient&#039;s address
     * book. &quot;INAB&quot; Users/Addresses whose domain doesn&#039;t match
     * the recipient&#039;s domain or zimbraInternalSendersDomain and which
     * are present in recipient&#039;s address book. &quot;INSD&quot; means
     * users whose domain matches the specific domain
     *
     * <p>Valid values: [ALL, ALLNOTINAB, INAB, INSD]
     *
     * @return zimbraPrefExternalSendersType, or ZAttrProvisioning.PrefExternalSendersType.ALL if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1320)
    public ZAttrProvisioning.PrefExternalSendersType getPrefExternalSendersType() {
        try { String v = getAttr(Provisioning.A_zimbraPrefExternalSendersType, true, true); return v == null ? ZAttrProvisioning.PrefExternalSendersType.ALL : ZAttrProvisioning.PrefExternalSendersType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefExternalSendersType.ALL; }
    }

    /**
     * Specifies the meaning of an external sender. &quot;ALL&quot; means
     * users whose domain doesn&#039;t match the recipient&#039;s or
     * zimbraInternalSendersDomain. &quot;ALLNOTINAB&quot; means
     * &quot;ALL&quot; minus users who are in the recipient&#039;s address
     * book. &quot;INAB&quot; Users/Addresses whose domain doesn&#039;t match
     * the recipient&#039;s domain or zimbraInternalSendersDomain and which
     * are present in recipient&#039;s address book. &quot;INSD&quot; means
     * users whose domain matches the specific domain
     *
     * <p>Valid values: [ALL, ALLNOTINAB, INAB, INSD]
     *
     * @return zimbraPrefExternalSendersType, or "ALL" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1320)
    public String getPrefExternalSendersTypeAsString() {
        return getAttr(Provisioning.A_zimbraPrefExternalSendersType, "ALL", true);
    }

    /**
     * Specifies the meaning of an external sender. &quot;ALL&quot; means
     * users whose domain doesn&#039;t match the recipient&#039;s or
     * zimbraInternalSendersDomain. &quot;ALLNOTINAB&quot; means
     * &quot;ALL&quot; minus users who are in the recipient&#039;s address
     * book. &quot;INAB&quot; Users/Addresses whose domain doesn&#039;t match
     * the recipient&#039;s domain or zimbraInternalSendersDomain and which
     * are present in recipient&#039;s address book. &quot;INSD&quot; means
     * users whose domain matches the specific domain
     *
     * <p>Valid values: [ALL, ALLNOTINAB, INAB, INSD]
     *
     * @param zimbraPrefExternalSendersType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1320)
    public void setPrefExternalSendersType(ZAttrProvisioning.PrefExternalSendersType zimbraPrefExternalSendersType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefExternalSendersType, zimbraPrefExternalSendersType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies the meaning of an external sender. &quot;ALL&quot; means
     * users whose domain doesn&#039;t match the recipient&#039;s or
     * zimbraInternalSendersDomain. &quot;ALLNOTINAB&quot; means
     * &quot;ALL&quot; minus users who are in the recipient&#039;s address
     * book. &quot;INAB&quot; Users/Addresses whose domain doesn&#039;t match
     * the recipient&#039;s domain or zimbraInternalSendersDomain and which
     * are present in recipient&#039;s address book. &quot;INSD&quot; means
     * users whose domain matches the specific domain
     *
     * <p>Valid values: [ALL, ALLNOTINAB, INAB, INSD]
     *
     * @param zimbraPrefExternalSendersType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1320)
    public Map<String,Object> setPrefExternalSendersType(ZAttrProvisioning.PrefExternalSendersType zimbraPrefExternalSendersType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefExternalSendersType, zimbraPrefExternalSendersType.toString());
        return attrs;
    }

    /**
     * Specifies the meaning of an external sender. &quot;ALL&quot; means
     * users whose domain doesn&#039;t match the recipient&#039;s or
     * zimbraInternalSendersDomain. &quot;ALLNOTINAB&quot; means
     * &quot;ALL&quot; minus users who are in the recipient&#039;s address
     * book. &quot;INAB&quot; Users/Addresses whose domain doesn&#039;t match
     * the recipient&#039;s domain or zimbraInternalSendersDomain and which
     * are present in recipient&#039;s address book. &quot;INSD&quot; means
     * users whose domain matches the specific domain
     *
     * <p>Valid values: [ALL, ALLNOTINAB, INAB, INSD]
     *
     * @param zimbraPrefExternalSendersType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1320)
    public void setPrefExternalSendersTypeAsString(String zimbraPrefExternalSendersType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefExternalSendersType, zimbraPrefExternalSendersType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies the meaning of an external sender. &quot;ALL&quot; means
     * users whose domain doesn&#039;t match the recipient&#039;s or
     * zimbraInternalSendersDomain. &quot;ALLNOTINAB&quot; means
     * &quot;ALL&quot; minus users who are in the recipient&#039;s address
     * book. &quot;INAB&quot; Users/Addresses whose domain doesn&#039;t match
     * the recipient&#039;s domain or zimbraInternalSendersDomain and which
     * are present in recipient&#039;s address book. &quot;INSD&quot; means
     * users whose domain matches the specific domain
     *
     * <p>Valid values: [ALL, ALLNOTINAB, INAB, INSD]
     *
     * @param zimbraPrefExternalSendersType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1320)
    public Map<String,Object> setPrefExternalSendersTypeAsString(String zimbraPrefExternalSendersType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefExternalSendersType, zimbraPrefExternalSendersType);
        return attrs;
    }

    /**
     * Specifies the meaning of an external sender. &quot;ALL&quot; means
     * users whose domain doesn&#039;t match the recipient&#039;s or
     * zimbraInternalSendersDomain. &quot;ALLNOTINAB&quot; means
     * &quot;ALL&quot; minus users who are in the recipient&#039;s address
     * book. &quot;INAB&quot; Users/Addresses whose domain doesn&#039;t match
     * the recipient&#039;s domain or zimbraInternalSendersDomain and which
     * are present in recipient&#039;s address book. &quot;INSD&quot; means
     * users whose domain matches the specific domain
     *
     * <p>Valid values: [ALL, ALLNOTINAB, INAB, INSD]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1320)
    public void unsetPrefExternalSendersType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefExternalSendersType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies the meaning of an external sender. &quot;ALL&quot; means
     * users whose domain doesn&#039;t match the recipient&#039;s or
     * zimbraInternalSendersDomain. &quot;ALLNOTINAB&quot; means
     * &quot;ALL&quot; minus users who are in the recipient&#039;s address
     * book. &quot;INAB&quot; Users/Addresses whose domain doesn&#039;t match
     * the recipient&#039;s domain or zimbraInternalSendersDomain and which
     * are present in recipient&#039;s address book. &quot;INSD&quot; means
     * users whose domain matches the specific domain
     *
     * <p>Valid values: [ALL, ALLNOTINAB, INAB, INSD]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1320)
    public Map<String,Object> unsetPrefExternalSendersType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefExternalSendersType, "");
        return attrs;
    }

    /**
     * indicates which application to use for file sharing
     *
     * <p>Valid values: [briefcase]
     *
     * @return zimbraPrefFileSharingApplication, or ZAttrProvisioning.PrefFileSharingApplication.briefcase if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1197)
    public ZAttrProvisioning.PrefFileSharingApplication getPrefFileSharingApplication() {
        try { String v = getAttr(Provisioning.A_zimbraPrefFileSharingApplication, true, true); return v == null ? ZAttrProvisioning.PrefFileSharingApplication.briefcase : ZAttrProvisioning.PrefFileSharingApplication.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefFileSharingApplication.briefcase; }
    }

    /**
     * indicates which application to use for file sharing
     *
     * <p>Valid values: [briefcase]
     *
     * @return zimbraPrefFileSharingApplication, or "briefcase" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1197)
    public String getPrefFileSharingApplicationAsString() {
        return getAttr(Provisioning.A_zimbraPrefFileSharingApplication, "briefcase", true);
    }

    /**
     * indicates which application to use for file sharing
     *
     * <p>Valid values: [briefcase]
     *
     * @param zimbraPrefFileSharingApplication new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1197)
    public void setPrefFileSharingApplication(ZAttrProvisioning.PrefFileSharingApplication zimbraPrefFileSharingApplication) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFileSharingApplication, zimbraPrefFileSharingApplication.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicates which application to use for file sharing
     *
     * <p>Valid values: [briefcase]
     *
     * @param zimbraPrefFileSharingApplication new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1197)
    public Map<String,Object> setPrefFileSharingApplication(ZAttrProvisioning.PrefFileSharingApplication zimbraPrefFileSharingApplication, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFileSharingApplication, zimbraPrefFileSharingApplication.toString());
        return attrs;
    }

    /**
     * indicates which application to use for file sharing
     *
     * <p>Valid values: [briefcase]
     *
     * @param zimbraPrefFileSharingApplication new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1197)
    public void setPrefFileSharingApplicationAsString(String zimbraPrefFileSharingApplication) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFileSharingApplication, zimbraPrefFileSharingApplication);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicates which application to use for file sharing
     *
     * <p>Valid values: [briefcase]
     *
     * @param zimbraPrefFileSharingApplication new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1197)
    public Map<String,Object> setPrefFileSharingApplicationAsString(String zimbraPrefFileSharingApplication, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFileSharingApplication, zimbraPrefFileSharingApplication);
        return attrs;
    }

    /**
     * indicates which application to use for file sharing
     *
     * <p>Valid values: [briefcase]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1197)
    public void unsetPrefFileSharingApplication() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFileSharingApplication, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicates which application to use for file sharing
     *
     * <p>Valid values: [briefcase]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1197)
    public Map<String,Object> unsetPrefFileSharingApplication(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFileSharingApplication, "");
        return attrs;
    }

    /**
     * whether folder color is enabled
     *
     * @return zimbraPrefFolderColorEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=771)
    public boolean isPrefFolderColorEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefFolderColorEnabled, true, true);
    }

    /**
     * whether folder color is enabled
     *
     * @param zimbraPrefFolderColorEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=771)
    public void setPrefFolderColorEnabled(boolean zimbraPrefFolderColorEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFolderColorEnabled, zimbraPrefFolderColorEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether folder color is enabled
     *
     * @param zimbraPrefFolderColorEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=771)
    public Map<String,Object> setPrefFolderColorEnabled(boolean zimbraPrefFolderColorEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFolderColorEnabled, zimbraPrefFolderColorEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether folder color is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=771)
    public void unsetPrefFolderColorEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFolderColorEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether folder color is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=771)
    public Map<String,Object> unsetPrefFolderColorEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFolderColorEnabled, "");
        return attrs;
    }

    /**
     * whether or not folder tree is expanded
     *
     * @return zimbraPrefFolderTreeOpen, or true if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=637)
    public boolean isPrefFolderTreeOpen() {
        return getBooleanAttr(Provisioning.A_zimbraPrefFolderTreeOpen, true, true);
    }

    /**
     * whether or not folder tree is expanded
     *
     * @param zimbraPrefFolderTreeOpen new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=637)
    public void setPrefFolderTreeOpen(boolean zimbraPrefFolderTreeOpen) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFolderTreeOpen, zimbraPrefFolderTreeOpen ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not folder tree is expanded
     *
     * @param zimbraPrefFolderTreeOpen new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=637)
    public Map<String,Object> setPrefFolderTreeOpen(boolean zimbraPrefFolderTreeOpen, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFolderTreeOpen, zimbraPrefFolderTreeOpen ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not folder tree is expanded
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=637)
    public void unsetPrefFolderTreeOpen() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFolderTreeOpen, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not folder tree is expanded
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=637)
    public Map<String,Object> unsetPrefFolderTreeOpen(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFolderTreeOpen, "");
        return attrs;
    }

    /**
     * the font for the web client
     *
     * @return zimbraPrefFont, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1246)
    public String getPrefFont() {
        return getAttr(Provisioning.A_zimbraPrefFont, null, true);
    }

    /**
     * the font for the web client
     *
     * @param zimbraPrefFont new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1246)
    public void setPrefFont(String zimbraPrefFont) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFont, zimbraPrefFont);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the font for the web client
     *
     * @param zimbraPrefFont new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1246)
    public Map<String,Object> setPrefFont(String zimbraPrefFont, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFont, zimbraPrefFont);
        return attrs;
    }

    /**
     * the font for the web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1246)
    public void unsetPrefFont() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFont, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the font for the web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1246)
    public Map<String,Object> unsetPrefFont(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFont, "");
        return attrs;
    }

    /**
     * the font size for the web client
     *
     * @return zimbraPrefFontSize, or "normal" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1448)
    public String getPrefFontSize() {
        return getAttr(Provisioning.A_zimbraPrefFontSize, "normal", true);
    }

    /**
     * the font size for the web client
     *
     * @param zimbraPrefFontSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1448)
    public void setPrefFontSize(String zimbraPrefFontSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFontSize, zimbraPrefFontSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the font size for the web client
     *
     * @param zimbraPrefFontSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1448)
    public Map<String,Object> setPrefFontSize(String zimbraPrefFontSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFontSize, zimbraPrefFontSize);
        return attrs;
    }

    /**
     * the font size for the web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1448)
    public void unsetPrefFontSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFontSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the font size for the web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1448)
    public Map<String,Object> unsetPrefFontSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFontSize, "");
        return attrs;
    }

    /**
     * what part of the original message to include during forwards
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeBodyOnly]
     *
     * @return zimbraPrefForwardIncludeOriginalText, or ZAttrProvisioning.PrefForwardIncludeOriginalText.includeBody if unset and/or has invalid value
     */
    @ZAttr(id=134)
    public ZAttrProvisioning.PrefForwardIncludeOriginalText getPrefForwardIncludeOriginalText() {
        try { String v = getAttr(Provisioning.A_zimbraPrefForwardIncludeOriginalText, true, true); return v == null ? ZAttrProvisioning.PrefForwardIncludeOriginalText.includeBody : ZAttrProvisioning.PrefForwardIncludeOriginalText.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefForwardIncludeOriginalText.includeBody; }
    }

    /**
     * what part of the original message to include during forwards
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeBodyOnly]
     *
     * @return zimbraPrefForwardIncludeOriginalText, or "includeBody" if unset
     */
    @ZAttr(id=134)
    public String getPrefForwardIncludeOriginalTextAsString() {
        return getAttr(Provisioning.A_zimbraPrefForwardIncludeOriginalText, "includeBody", true);
    }

    /**
     * what part of the original message to include during forwards
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeBodyOnly]
     *
     * @param zimbraPrefForwardIncludeOriginalText new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=134)
    public void setPrefForwardIncludeOriginalText(ZAttrProvisioning.PrefForwardIncludeOriginalText zimbraPrefForwardIncludeOriginalText) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardIncludeOriginalText, zimbraPrefForwardIncludeOriginalText.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what part of the original message to include during forwards
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeBodyOnly]
     *
     * @param zimbraPrefForwardIncludeOriginalText new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=134)
    public Map<String,Object> setPrefForwardIncludeOriginalText(ZAttrProvisioning.PrefForwardIncludeOriginalText zimbraPrefForwardIncludeOriginalText, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardIncludeOriginalText, zimbraPrefForwardIncludeOriginalText.toString());
        return attrs;
    }

    /**
     * what part of the original message to include during forwards
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeBodyOnly]
     *
     * @param zimbraPrefForwardIncludeOriginalText new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=134)
    public void setPrefForwardIncludeOriginalTextAsString(String zimbraPrefForwardIncludeOriginalText) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardIncludeOriginalText, zimbraPrefForwardIncludeOriginalText);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what part of the original message to include during forwards
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeBodyOnly]
     *
     * @param zimbraPrefForwardIncludeOriginalText new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=134)
    public Map<String,Object> setPrefForwardIncludeOriginalTextAsString(String zimbraPrefForwardIncludeOriginalText, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardIncludeOriginalText, zimbraPrefForwardIncludeOriginalText);
        return attrs;
    }

    /**
     * what part of the original message to include during forwards
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeBodyOnly]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=134)
    public void unsetPrefForwardIncludeOriginalText() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardIncludeOriginalText, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what part of the original message to include during forwards
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeBodyOnly]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=134)
    public Map<String,Object> unsetPrefForwardIncludeOriginalText(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardIncludeOriginalText, "");
        return attrs;
    }

    /**
     * what format we reply/forward messages in (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [text, html, same]
     *
     * @return zimbraPrefForwardReplyFormat, or ZAttrProvisioning.PrefForwardReplyFormat.text if unset and/or has invalid value
     */
    @ZAttr(id=413)
    public ZAttrProvisioning.PrefForwardReplyFormat getPrefForwardReplyFormat() {
        try { String v = getAttr(Provisioning.A_zimbraPrefForwardReplyFormat, true, true); return v == null ? ZAttrProvisioning.PrefForwardReplyFormat.text : ZAttrProvisioning.PrefForwardReplyFormat.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefForwardReplyFormat.text; }
    }

    /**
     * what format we reply/forward messages in (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [text, html, same]
     *
     * @return zimbraPrefForwardReplyFormat, or "text" if unset
     */
    @ZAttr(id=413)
    public String getPrefForwardReplyFormatAsString() {
        return getAttr(Provisioning.A_zimbraPrefForwardReplyFormat, "text", true);
    }

    /**
     * what format we reply/forward messages in (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [text, html, same]
     *
     * @param zimbraPrefForwardReplyFormat new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=413)
    public void setPrefForwardReplyFormat(ZAttrProvisioning.PrefForwardReplyFormat zimbraPrefForwardReplyFormat) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyFormat, zimbraPrefForwardReplyFormat.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what format we reply/forward messages in (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [text, html, same]
     *
     * @param zimbraPrefForwardReplyFormat new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=413)
    public Map<String,Object> setPrefForwardReplyFormat(ZAttrProvisioning.PrefForwardReplyFormat zimbraPrefForwardReplyFormat, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyFormat, zimbraPrefForwardReplyFormat.toString());
        return attrs;
    }

    /**
     * what format we reply/forward messages in (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [text, html, same]
     *
     * @param zimbraPrefForwardReplyFormat new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=413)
    public void setPrefForwardReplyFormatAsString(String zimbraPrefForwardReplyFormat) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyFormat, zimbraPrefForwardReplyFormat);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what format we reply/forward messages in (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [text, html, same]
     *
     * @param zimbraPrefForwardReplyFormat new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=413)
    public Map<String,Object> setPrefForwardReplyFormatAsString(String zimbraPrefForwardReplyFormat, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyFormat, zimbraPrefForwardReplyFormat);
        return attrs;
    }

    /**
     * what format we reply/forward messages in (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [text, html, same]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=413)
    public void unsetPrefForwardReplyFormat() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyFormat, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what format we reply/forward messages in (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [text, html, same]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=413)
    public Map<String,Object> unsetPrefForwardReplyFormat(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyFormat, "");
        return attrs;
    }

    /**
     * whether or not to use same format (text or html) of message we are
     * replying to
     *
     * @return zimbraPrefForwardReplyInOriginalFormat, or true if unset
     */
    @ZAttr(id=218)
    public boolean isPrefForwardReplyInOriginalFormat() {
        return getBooleanAttr(Provisioning.A_zimbraPrefForwardReplyInOriginalFormat, true, true);
    }

    /**
     * whether or not to use same format (text or html) of message we are
     * replying to
     *
     * @param zimbraPrefForwardReplyInOriginalFormat new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=218)
    public void setPrefForwardReplyInOriginalFormat(boolean zimbraPrefForwardReplyInOriginalFormat) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyInOriginalFormat, zimbraPrefForwardReplyInOriginalFormat ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to use same format (text or html) of message we are
     * replying to
     *
     * @param zimbraPrefForwardReplyInOriginalFormat new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=218)
    public Map<String,Object> setPrefForwardReplyInOriginalFormat(boolean zimbraPrefForwardReplyInOriginalFormat, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyInOriginalFormat, zimbraPrefForwardReplyInOriginalFormat ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to use same format (text or html) of message we are
     * replying to
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=218)
    public void unsetPrefForwardReplyInOriginalFormat() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyInOriginalFormat, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to use same format (text or html) of message we are
     * replying to
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=218)
    public Map<String,Object> unsetPrefForwardReplyInOriginalFormat(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyInOriginalFormat, "");
        return attrs;
    }

    /**
     * prefix character to use during forward/reply (deprecatedSince 5.0 in
     * identity)
     *
     * @return zimbraPrefForwardReplyPrefixChar, or ">" if unset
     */
    @ZAttr(id=130)
    public String getPrefForwardReplyPrefixChar() {
        return getAttr(Provisioning.A_zimbraPrefForwardReplyPrefixChar, ">", true);
    }

    /**
     * prefix character to use during forward/reply (deprecatedSince 5.0 in
     * identity)
     *
     * @param zimbraPrefForwardReplyPrefixChar new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=130)
    public void setPrefForwardReplyPrefixChar(String zimbraPrefForwardReplyPrefixChar) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyPrefixChar, zimbraPrefForwardReplyPrefixChar);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * prefix character to use during forward/reply (deprecatedSince 5.0 in
     * identity)
     *
     * @param zimbraPrefForwardReplyPrefixChar new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=130)
    public Map<String,Object> setPrefForwardReplyPrefixChar(String zimbraPrefForwardReplyPrefixChar, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyPrefixChar, zimbraPrefForwardReplyPrefixChar);
        return attrs;
    }

    /**
     * prefix character to use during forward/reply (deprecatedSince 5.0 in
     * identity)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=130)
    public void unsetPrefForwardReplyPrefixChar() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyPrefixChar, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * prefix character to use during forward/reply (deprecatedSince 5.0 in
     * identity)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=130)
    public Map<String,Object> unsetPrefForwardReplyPrefixChar(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplyPrefixChar, "");
        return attrs;
    }

    /**
     * forward/reply signature id for account/identity/dataSource
     *
     * @return zimbraPrefForwardReplySignatureId, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1125)
    public String getPrefForwardReplySignatureId() {
        return getAttr(Provisioning.A_zimbraPrefForwardReplySignatureId, null, true);
    }

    /**
     * forward/reply signature id for account/identity/dataSource
     *
     * @param zimbraPrefForwardReplySignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1125)
    public void setPrefForwardReplySignatureId(String zimbraPrefForwardReplySignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplySignatureId, zimbraPrefForwardReplySignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * forward/reply signature id for account/identity/dataSource
     *
     * @param zimbraPrefForwardReplySignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1125)
    public Map<String,Object> setPrefForwardReplySignatureId(String zimbraPrefForwardReplySignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplySignatureId, zimbraPrefForwardReplySignatureId);
        return attrs;
    }

    /**
     * forward/reply signature id for account/identity/dataSource
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1125)
    public void unsetPrefForwardReplySignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplySignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * forward/reply signature id for account/identity/dataSource
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1125)
    public Map<String,Object> unsetPrefForwardReplySignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefForwardReplySignatureId, "");
        return attrs;
    }

    /**
     * email address to put in from header. Deprecated on data source as of
     * bug 67068.
     *
     * @return zimbraPrefFromAddress, or null if unset
     */
    @ZAttr(id=403)
    public String getPrefFromAddress() {
        return getAttr(Provisioning.A_zimbraPrefFromAddress, null, true);
    }

    /**
     * email address to put in from header. Deprecated on data source as of
     * bug 67068.
     *
     * @param zimbraPrefFromAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=403)
    public void setPrefFromAddress(String zimbraPrefFromAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddress, zimbraPrefFromAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email address to put in from header. Deprecated on data source as of
     * bug 67068.
     *
     * @param zimbraPrefFromAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=403)
    public Map<String,Object> setPrefFromAddress(String zimbraPrefFromAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddress, zimbraPrefFromAddress);
        return attrs;
    }

    /**
     * email address to put in from header. Deprecated on data source as of
     * bug 67068.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=403)
    public void unsetPrefFromAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email address to put in from header. Deprecated on data source as of
     * bug 67068.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=403)
    public Map<String,Object> unsetPrefFromAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddress, "");
        return attrs;
    }

    /**
     * Type of the email address from header. (sendAs or sendOnBehalfOf)
     *
     * <p>Valid values: [sendAs, sendOnBehalfOf]
     *
     * @return zimbraPrefFromAddressType, or null if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1419)
    public ZAttrProvisioning.PrefFromAddressType getPrefFromAddressType() {
        try { String v = getAttr(Provisioning.A_zimbraPrefFromAddressType, true, true); return v == null ? null : ZAttrProvisioning.PrefFromAddressType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Type of the email address from header. (sendAs or sendOnBehalfOf)
     *
     * <p>Valid values: [sendAs, sendOnBehalfOf]
     *
     * @return zimbraPrefFromAddressType, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1419)
    public String getPrefFromAddressTypeAsString() {
        return getAttr(Provisioning.A_zimbraPrefFromAddressType, null, true);
    }

    /**
     * Type of the email address from header. (sendAs or sendOnBehalfOf)
     *
     * <p>Valid values: [sendAs, sendOnBehalfOf]
     *
     * @param zimbraPrefFromAddressType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1419)
    public void setPrefFromAddressType(ZAttrProvisioning.PrefFromAddressType zimbraPrefFromAddressType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddressType, zimbraPrefFromAddressType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of the email address from header. (sendAs or sendOnBehalfOf)
     *
     * <p>Valid values: [sendAs, sendOnBehalfOf]
     *
     * @param zimbraPrefFromAddressType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1419)
    public Map<String,Object> setPrefFromAddressType(ZAttrProvisioning.PrefFromAddressType zimbraPrefFromAddressType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddressType, zimbraPrefFromAddressType.toString());
        return attrs;
    }

    /**
     * Type of the email address from header. (sendAs or sendOnBehalfOf)
     *
     * <p>Valid values: [sendAs, sendOnBehalfOf]
     *
     * @param zimbraPrefFromAddressType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1419)
    public void setPrefFromAddressTypeAsString(String zimbraPrefFromAddressType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddressType, zimbraPrefFromAddressType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of the email address from header. (sendAs or sendOnBehalfOf)
     *
     * <p>Valid values: [sendAs, sendOnBehalfOf]
     *
     * @param zimbraPrefFromAddressType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1419)
    public Map<String,Object> setPrefFromAddressTypeAsString(String zimbraPrefFromAddressType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddressType, zimbraPrefFromAddressType);
        return attrs;
    }

    /**
     * Type of the email address from header. (sendAs or sendOnBehalfOf)
     *
     * <p>Valid values: [sendAs, sendOnBehalfOf]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1419)
    public void unsetPrefFromAddressType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddressType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of the email address from header. (sendAs or sendOnBehalfOf)
     *
     * <p>Valid values: [sendAs, sendOnBehalfOf]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1419)
    public Map<String,Object> unsetPrefFromAddressType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromAddressType, "");
        return attrs;
    }

    /**
     * personal part of email address put in from header
     *
     * @return zimbraPrefFromDisplay, or null if unset
     */
    @ZAttr(id=402)
    public String getPrefFromDisplay() {
        return getAttr(Provisioning.A_zimbraPrefFromDisplay, null, true);
    }

    /**
     * personal part of email address put in from header
     *
     * @param zimbraPrefFromDisplay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=402)
    public void setPrefFromDisplay(String zimbraPrefFromDisplay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromDisplay, zimbraPrefFromDisplay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * personal part of email address put in from header
     *
     * @param zimbraPrefFromDisplay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=402)
    public Map<String,Object> setPrefFromDisplay(String zimbraPrefFromDisplay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromDisplay, zimbraPrefFromDisplay);
        return attrs;
    }

    /**
     * personal part of email address put in from header
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=402)
    public void unsetPrefFromDisplay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromDisplay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * personal part of email address put in from header
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=402)
    public Map<String,Object> unsetPrefFromDisplay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefFromDisplay, "");
        return attrs;
    }

    /**
     * whether end-user wants auto-complete from GAL. Feature must also be
     * enabled.
     *
     * @return zimbraPrefGalAutoCompleteEnabled, or true if unset
     */
    @ZAttr(id=372)
    public boolean isPrefGalAutoCompleteEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefGalAutoCompleteEnabled, true, true);
    }

    /**
     * whether end-user wants auto-complete from GAL. Feature must also be
     * enabled.
     *
     * @param zimbraPrefGalAutoCompleteEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=372)
    public void setPrefGalAutoCompleteEnabled(boolean zimbraPrefGalAutoCompleteEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGalAutoCompleteEnabled, zimbraPrefGalAutoCompleteEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end-user wants auto-complete from GAL. Feature must also be
     * enabled.
     *
     * @param zimbraPrefGalAutoCompleteEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=372)
    public Map<String,Object> setPrefGalAutoCompleteEnabled(boolean zimbraPrefGalAutoCompleteEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGalAutoCompleteEnabled, zimbraPrefGalAutoCompleteEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether end-user wants auto-complete from GAL. Feature must also be
     * enabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=372)
    public void unsetPrefGalAutoCompleteEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGalAutoCompleteEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end-user wants auto-complete from GAL. Feature must also be
     * enabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=372)
    public Map<String,Object> unsetPrefGalAutoCompleteEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGalAutoCompleteEnabled, "");
        return attrs;
    }

    /**
     * whether end-user wants search from GAL. Feature must also be enabled
     *
     * @return zimbraPrefGalSearchEnabled, or true if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=635)
    public boolean isPrefGalSearchEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefGalSearchEnabled, true, true);
    }

    /**
     * whether end-user wants search from GAL. Feature must also be enabled
     *
     * @param zimbraPrefGalSearchEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=635)
    public void setPrefGalSearchEnabled(boolean zimbraPrefGalSearchEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGalSearchEnabled, zimbraPrefGalSearchEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end-user wants search from GAL. Feature must also be enabled
     *
     * @param zimbraPrefGalSearchEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=635)
    public Map<String,Object> setPrefGalSearchEnabled(boolean zimbraPrefGalSearchEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGalSearchEnabled, zimbraPrefGalSearchEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether end-user wants search from GAL. Feature must also be enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=635)
    public void unsetPrefGalSearchEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGalSearchEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end-user wants search from GAL. Feature must also be enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=635)
    public Map<String,Object> unsetPrefGalSearchEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGalSearchEnabled, "");
        return attrs;
    }

    /**
     * action to perform for the get mail button in UI
     *
     * <p>Valid values: [default, update]
     *
     * @return zimbraPrefGetMailAction, or ZAttrProvisioning.PrefGetMailAction.default_ if unset and/or has invalid value
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1067)
    public ZAttrProvisioning.PrefGetMailAction getPrefGetMailAction() {
        try { String v = getAttr(Provisioning.A_zimbraPrefGetMailAction, true, true); return v == null ? ZAttrProvisioning.PrefGetMailAction.default_ : ZAttrProvisioning.PrefGetMailAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefGetMailAction.default_; }
    }

    /**
     * action to perform for the get mail button in UI
     *
     * <p>Valid values: [default, update]
     *
     * @return zimbraPrefGetMailAction, or "default" if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1067)
    public String getPrefGetMailActionAsString() {
        return getAttr(Provisioning.A_zimbraPrefGetMailAction, "default", true);
    }

    /**
     * action to perform for the get mail button in UI
     *
     * <p>Valid values: [default, update]
     *
     * @param zimbraPrefGetMailAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1067)
    public void setPrefGetMailAction(ZAttrProvisioning.PrefGetMailAction zimbraPrefGetMailAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGetMailAction, zimbraPrefGetMailAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * action to perform for the get mail button in UI
     *
     * <p>Valid values: [default, update]
     *
     * @param zimbraPrefGetMailAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1067)
    public Map<String,Object> setPrefGetMailAction(ZAttrProvisioning.PrefGetMailAction zimbraPrefGetMailAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGetMailAction, zimbraPrefGetMailAction.toString());
        return attrs;
    }

    /**
     * action to perform for the get mail button in UI
     *
     * <p>Valid values: [default, update]
     *
     * @param zimbraPrefGetMailAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1067)
    public void setPrefGetMailActionAsString(String zimbraPrefGetMailAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGetMailAction, zimbraPrefGetMailAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * action to perform for the get mail button in UI
     *
     * <p>Valid values: [default, update]
     *
     * @param zimbraPrefGetMailAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1067)
    public Map<String,Object> setPrefGetMailActionAsString(String zimbraPrefGetMailAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGetMailAction, zimbraPrefGetMailAction);
        return attrs;
    }

    /**
     * action to perform for the get mail button in UI
     *
     * <p>Valid values: [default, update]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1067)
    public void unsetPrefGetMailAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGetMailAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * action to perform for the get mail button in UI
     *
     * <p>Valid values: [default, update]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1067)
    public Map<String,Object> unsetPrefGetMailAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGetMailAction, "");
        return attrs;
    }

    /**
     * how to group mail by default
     *
     * <p>Valid values: [conversation, message]
     *
     * @return zimbraPrefGroupMailBy, or ZAttrProvisioning.PrefGroupMailBy.conversation if unset and/or has invalid value
     */
    @ZAttr(id=54)
    public ZAttrProvisioning.PrefGroupMailBy getPrefGroupMailBy() {
        try { String v = getAttr(Provisioning.A_zimbraPrefGroupMailBy, true, true); return v == null ? ZAttrProvisioning.PrefGroupMailBy.conversation : ZAttrProvisioning.PrefGroupMailBy.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefGroupMailBy.conversation; }
    }

    /**
     * how to group mail by default
     *
     * <p>Valid values: [conversation, message]
     *
     * @return zimbraPrefGroupMailBy, or "conversation" if unset
     */
    @ZAttr(id=54)
    public String getPrefGroupMailByAsString() {
        return getAttr(Provisioning.A_zimbraPrefGroupMailBy, "conversation", true);
    }

    /**
     * how to group mail by default
     *
     * <p>Valid values: [conversation, message]
     *
     * @param zimbraPrefGroupMailBy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=54)
    public void setPrefGroupMailBy(ZAttrProvisioning.PrefGroupMailBy zimbraPrefGroupMailBy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGroupMailBy, zimbraPrefGroupMailBy.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how to group mail by default
     *
     * <p>Valid values: [conversation, message]
     *
     * @param zimbraPrefGroupMailBy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=54)
    public Map<String,Object> setPrefGroupMailBy(ZAttrProvisioning.PrefGroupMailBy zimbraPrefGroupMailBy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGroupMailBy, zimbraPrefGroupMailBy.toString());
        return attrs;
    }

    /**
     * how to group mail by default
     *
     * <p>Valid values: [conversation, message]
     *
     * @param zimbraPrefGroupMailBy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=54)
    public void setPrefGroupMailByAsString(String zimbraPrefGroupMailBy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGroupMailBy, zimbraPrefGroupMailBy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how to group mail by default
     *
     * <p>Valid values: [conversation, message]
     *
     * @param zimbraPrefGroupMailBy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=54)
    public Map<String,Object> setPrefGroupMailByAsString(String zimbraPrefGroupMailBy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGroupMailBy, zimbraPrefGroupMailBy);
        return attrs;
    }

    /**
     * how to group mail by default
     *
     * <p>Valid values: [conversation, message]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=54)
    public void unsetPrefGroupMailBy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGroupMailBy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how to group mail by default
     *
     * <p>Valid values: [conversation, message]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=54)
    public Map<String,Object> unsetPrefGroupMailBy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefGroupMailBy, "");
        return attrs;
    }

    /**
     * default font color
     *
     * @return zimbraPrefHtmlEditorDefaultFontColor, or "#000000" if unset
     */
    @ZAttr(id=260)
    public String getPrefHtmlEditorDefaultFontColor() {
        return getAttr(Provisioning.A_zimbraPrefHtmlEditorDefaultFontColor, "#000000", true);
    }

    /**
     * default font color
     *
     * @param zimbraPrefHtmlEditorDefaultFontColor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=260)
    public void setPrefHtmlEditorDefaultFontColor(String zimbraPrefHtmlEditorDefaultFontColor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontColor, zimbraPrefHtmlEditorDefaultFontColor);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default font color
     *
     * @param zimbraPrefHtmlEditorDefaultFontColor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=260)
    public Map<String,Object> setPrefHtmlEditorDefaultFontColor(String zimbraPrefHtmlEditorDefaultFontColor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontColor, zimbraPrefHtmlEditorDefaultFontColor);
        return attrs;
    }

    /**
     * default font color
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=260)
    public void unsetPrefHtmlEditorDefaultFontColor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontColor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default font color
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=260)
    public Map<String,Object> unsetPrefHtmlEditorDefaultFontColor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontColor, "");
        return attrs;
    }

    /**
     * default font family
     *
     * @return zimbraPrefHtmlEditorDefaultFontFamily, or "arial, helvetica, sans-serif" if unset
     */
    @ZAttr(id=258)
    public String getPrefHtmlEditorDefaultFontFamily() {
        return getAttr(Provisioning.A_zimbraPrefHtmlEditorDefaultFontFamily, "arial, helvetica, sans-serif", true);
    }

    /**
     * default font family
     *
     * @param zimbraPrefHtmlEditorDefaultFontFamily new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=258)
    public void setPrefHtmlEditorDefaultFontFamily(String zimbraPrefHtmlEditorDefaultFontFamily) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontFamily, zimbraPrefHtmlEditorDefaultFontFamily);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default font family
     *
     * @param zimbraPrefHtmlEditorDefaultFontFamily new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=258)
    public Map<String,Object> setPrefHtmlEditorDefaultFontFamily(String zimbraPrefHtmlEditorDefaultFontFamily, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontFamily, zimbraPrefHtmlEditorDefaultFontFamily);
        return attrs;
    }

    /**
     * default font family
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=258)
    public void unsetPrefHtmlEditorDefaultFontFamily() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontFamily, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default font family
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=258)
    public Map<String,Object> unsetPrefHtmlEditorDefaultFontFamily(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontFamily, "");
        return attrs;
    }

    /**
     * default font size
     *
     * @return zimbraPrefHtmlEditorDefaultFontSize, or "12pt" if unset
     */
    @ZAttr(id=259)
    public String getPrefHtmlEditorDefaultFontSize() {
        return getAttr(Provisioning.A_zimbraPrefHtmlEditorDefaultFontSize, "12pt", true);
    }

    /**
     * default font size
     *
     * @param zimbraPrefHtmlEditorDefaultFontSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=259)
    public void setPrefHtmlEditorDefaultFontSize(String zimbraPrefHtmlEditorDefaultFontSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontSize, zimbraPrefHtmlEditorDefaultFontSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default font size
     *
     * @param zimbraPrefHtmlEditorDefaultFontSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=259)
    public Map<String,Object> setPrefHtmlEditorDefaultFontSize(String zimbraPrefHtmlEditorDefaultFontSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontSize, zimbraPrefHtmlEditorDefaultFontSize);
        return attrs;
    }

    /**
     * default font size
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=259)
    public void unsetPrefHtmlEditorDefaultFontSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default font size
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=259)
    public Map<String,Object> unsetPrefHtmlEditorDefaultFontSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefHtmlEditorDefaultFontSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to login to the IM client automatically
     *
     * @return zimbraPrefIMAutoLogin, or false if unset
     */
    @ZAttr(id=488)
    public boolean isPrefIMAutoLogin() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMAutoLogin, false, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to login to the IM client automatically
     *
     * @param zimbraPrefIMAutoLogin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=488)
    public void setPrefIMAutoLogin(boolean zimbraPrefIMAutoLogin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMAutoLogin, zimbraPrefIMAutoLogin ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to login to the IM client automatically
     *
     * @param zimbraPrefIMAutoLogin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=488)
    public Map<String,Object> setPrefIMAutoLogin(boolean zimbraPrefIMAutoLogin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMAutoLogin, zimbraPrefIMAutoLogin ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to login to the IM client automatically
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=488)
    public void unsetPrefIMAutoLogin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMAutoLogin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to login to the IM client automatically
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=488)
    public Map<String,Object> unsetPrefIMAutoLogin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMAutoLogin, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * buddy list sort order
     *
     * @return zimbraPrefIMBuddyListSort, or null if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=705)
    public String getPrefIMBuddyListSort() {
        return getAttr(Provisioning.A_zimbraPrefIMBuddyListSort, null, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * buddy list sort order
     *
     * @param zimbraPrefIMBuddyListSort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=705)
    public void setPrefIMBuddyListSort(String zimbraPrefIMBuddyListSort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMBuddyListSort, zimbraPrefIMBuddyListSort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * buddy list sort order
     *
     * @param zimbraPrefIMBuddyListSort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=705)
    public Map<String,Object> setPrefIMBuddyListSort(String zimbraPrefIMBuddyListSort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMBuddyListSort, zimbraPrefIMBuddyListSort);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * buddy list sort order
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=705)
    public void unsetPrefIMBuddyListSort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMBuddyListSort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * buddy list sort order
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=705)
    public Map<String,Object> unsetPrefIMBuddyListSort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMBuddyListSort, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @return zimbraPrefIMCustomStatusMessage, or empty array if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public String[] getPrefIMCustomStatusMessage() {
        return getMultiAttr(Provisioning.A_zimbraPrefIMCustomStatusMessage, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @param zimbraPrefIMCustomStatusMessage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public void setPrefIMCustomStatusMessage(String[] zimbraPrefIMCustomStatusMessage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMCustomStatusMessage, zimbraPrefIMCustomStatusMessage);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @param zimbraPrefIMCustomStatusMessage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public Map<String,Object> setPrefIMCustomStatusMessage(String[] zimbraPrefIMCustomStatusMessage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMCustomStatusMessage, zimbraPrefIMCustomStatusMessage);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @param zimbraPrefIMCustomStatusMessage new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public void addPrefIMCustomStatusMessage(String zimbraPrefIMCustomStatusMessage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefIMCustomStatusMessage, zimbraPrefIMCustomStatusMessage);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @param zimbraPrefIMCustomStatusMessage new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public Map<String,Object> addPrefIMCustomStatusMessage(String zimbraPrefIMCustomStatusMessage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefIMCustomStatusMessage, zimbraPrefIMCustomStatusMessage);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @param zimbraPrefIMCustomStatusMessage existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public void removePrefIMCustomStatusMessage(String zimbraPrefIMCustomStatusMessage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefIMCustomStatusMessage, zimbraPrefIMCustomStatusMessage);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @param zimbraPrefIMCustomStatusMessage existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public Map<String,Object> removePrefIMCustomStatusMessage(String zimbraPrefIMCustomStatusMessage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefIMCustomStatusMessage, zimbraPrefIMCustomStatusMessage);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public void unsetPrefIMCustomStatusMessage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMCustomStatusMessage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Custom
     * IM status messages
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=645)
    public Map<String,Object> unsetPrefIMCustomStatusMessage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMCustomStatusMessage, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * IM icon on new messages
     *
     * @return zimbraPrefIMFlashIcon, or true if unset
     */
    @ZAttr(id=462)
    public boolean isPrefIMFlashIcon() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMFlashIcon, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * IM icon on new messages
     *
     * @param zimbraPrefIMFlashIcon new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=462)
    public void setPrefIMFlashIcon(boolean zimbraPrefIMFlashIcon) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMFlashIcon, zimbraPrefIMFlashIcon ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * IM icon on new messages
     *
     * @param zimbraPrefIMFlashIcon new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=462)
    public Map<String,Object> setPrefIMFlashIcon(boolean zimbraPrefIMFlashIcon, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMFlashIcon, zimbraPrefIMFlashIcon ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * IM icon on new messages
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=462)
    public void unsetPrefIMFlashIcon() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMFlashIcon, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * IM icon on new messages
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=462)
    public Map<String,Object> unsetPrefIMFlashIcon(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMFlashIcon, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * title bar when a new IM arrives
     *
     * @return zimbraPrefIMFlashTitle, or true if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=679)
    public boolean isPrefIMFlashTitle() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMFlashTitle, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * title bar when a new IM arrives
     *
     * @param zimbraPrefIMFlashTitle new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=679)
    public void setPrefIMFlashTitle(boolean zimbraPrefIMFlashTitle) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMFlashTitle, zimbraPrefIMFlashTitle ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * title bar when a new IM arrives
     *
     * @param zimbraPrefIMFlashTitle new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=679)
    public Map<String,Object> setPrefIMFlashTitle(boolean zimbraPrefIMFlashTitle, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMFlashTitle, zimbraPrefIMFlashTitle ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * title bar when a new IM arrives
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=679)
    public void unsetPrefIMFlashTitle() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMFlashTitle, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Flash
     * title bar when a new IM arrives
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=679)
    public Map<String,Object> unsetPrefIMFlashTitle(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMFlashTitle, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM blocked buddies
     *
     * @return zimbraPrefIMHideBlockedBuddies, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=707)
    public boolean isPrefIMHideBlockedBuddies() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMHideBlockedBuddies, false, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM blocked buddies
     *
     * @param zimbraPrefIMHideBlockedBuddies new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=707)
    public void setPrefIMHideBlockedBuddies(boolean zimbraPrefIMHideBlockedBuddies) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMHideBlockedBuddies, zimbraPrefIMHideBlockedBuddies ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM blocked buddies
     *
     * @param zimbraPrefIMHideBlockedBuddies new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=707)
    public Map<String,Object> setPrefIMHideBlockedBuddies(boolean zimbraPrefIMHideBlockedBuddies, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMHideBlockedBuddies, zimbraPrefIMHideBlockedBuddies ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM blocked buddies
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=707)
    public void unsetPrefIMHideBlockedBuddies() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMHideBlockedBuddies, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM blocked buddies
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=707)
    public Map<String,Object> unsetPrefIMHideBlockedBuddies(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMHideBlockedBuddies, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM offline buddies
     *
     * @return zimbraPrefIMHideOfflineBuddies, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=706)
    public boolean isPrefIMHideOfflineBuddies() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMHideOfflineBuddies, false, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM offline buddies
     *
     * @param zimbraPrefIMHideOfflineBuddies new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=706)
    public void setPrefIMHideOfflineBuddies(boolean zimbraPrefIMHideOfflineBuddies) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMHideOfflineBuddies, zimbraPrefIMHideOfflineBuddies ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM offline buddies
     *
     * @param zimbraPrefIMHideOfflineBuddies new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=706)
    public Map<String,Object> setPrefIMHideOfflineBuddies(boolean zimbraPrefIMHideOfflineBuddies, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMHideOfflineBuddies, zimbraPrefIMHideOfflineBuddies ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM offline buddies
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=706)
    public void unsetPrefIMHideOfflineBuddies() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMHideOfflineBuddies, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to hide IM offline buddies
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=706)
    public Map<String,Object> unsetPrefIMHideOfflineBuddies(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMHideOfflineBuddies, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * idle status
     *
     * <p>Valid values: [away, xa, invisible, offline]
     *
     * @return zimbraPrefIMIdleStatus, or ZAttrProvisioning.PrefIMIdleStatus.away if unset and/or has invalid value
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=560)
    public ZAttrProvisioning.PrefIMIdleStatus getPrefIMIdleStatus() {
        try { String v = getAttr(Provisioning.A_zimbraPrefIMIdleStatus, true, true); return v == null ? ZAttrProvisioning.PrefIMIdleStatus.away : ZAttrProvisioning.PrefIMIdleStatus.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefIMIdleStatus.away; }
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * idle status
     *
     * <p>Valid values: [away, xa, invisible, offline]
     *
     * @return zimbraPrefIMIdleStatus, or "away" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=560)
    public String getPrefIMIdleStatusAsString() {
        return getAttr(Provisioning.A_zimbraPrefIMIdleStatus, "away", true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * idle status
     *
     * <p>Valid values: [away, xa, invisible, offline]
     *
     * @param zimbraPrefIMIdleStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=560)
    public void setPrefIMIdleStatus(ZAttrProvisioning.PrefIMIdleStatus zimbraPrefIMIdleStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleStatus, zimbraPrefIMIdleStatus.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * idle status
     *
     * <p>Valid values: [away, xa, invisible, offline]
     *
     * @param zimbraPrefIMIdleStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=560)
    public Map<String,Object> setPrefIMIdleStatus(ZAttrProvisioning.PrefIMIdleStatus zimbraPrefIMIdleStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleStatus, zimbraPrefIMIdleStatus.toString());
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * idle status
     *
     * <p>Valid values: [away, xa, invisible, offline]
     *
     * @param zimbraPrefIMIdleStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=560)
    public void setPrefIMIdleStatusAsString(String zimbraPrefIMIdleStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleStatus, zimbraPrefIMIdleStatus);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * idle status
     *
     * <p>Valid values: [away, xa, invisible, offline]
     *
     * @param zimbraPrefIMIdleStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=560)
    public Map<String,Object> setPrefIMIdleStatusAsString(String zimbraPrefIMIdleStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleStatus, zimbraPrefIMIdleStatus);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * idle status
     *
     * <p>Valid values: [away, xa, invisible, offline]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=560)
    public void unsetPrefIMIdleStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * idle status
     *
     * <p>Valid values: [away, xa, invisible, offline]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=560)
    public Map<String,Object> unsetPrefIMIdleStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleStatus, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * session idle timeout in minutes
     *
     * @return zimbraPrefIMIdleTimeout, or 10 if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=559)
    public int getPrefIMIdleTimeout() {
        return getIntAttr(Provisioning.A_zimbraPrefIMIdleTimeout, 10, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * session idle timeout in minutes
     *
     * @param zimbraPrefIMIdleTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=559)
    public void setPrefIMIdleTimeout(int zimbraPrefIMIdleTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleTimeout, Integer.toString(zimbraPrefIMIdleTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * session idle timeout in minutes
     *
     * @param zimbraPrefIMIdleTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=559)
    public Map<String,Object> setPrefIMIdleTimeout(int zimbraPrefIMIdleTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleTimeout, Integer.toString(zimbraPrefIMIdleTimeout));
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * session idle timeout in minutes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=559)
    public void unsetPrefIMIdleTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: IM
     * session idle timeout in minutes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=559)
    public Map<String,Object> unsetPrefIMIdleTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMIdleTimeout, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Enable
     * instant notifications
     *
     * @return zimbraPrefIMInstantNotify, or true if unset
     */
    @ZAttr(id=517)
    public boolean isPrefIMInstantNotify() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMInstantNotify, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Enable
     * instant notifications
     *
     * @param zimbraPrefIMInstantNotify new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=517)
    public void setPrefIMInstantNotify(boolean zimbraPrefIMInstantNotify) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMInstantNotify, zimbraPrefIMInstantNotify ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Enable
     * instant notifications
     *
     * @param zimbraPrefIMInstantNotify new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=517)
    public Map<String,Object> setPrefIMInstantNotify(boolean zimbraPrefIMInstantNotify, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMInstantNotify, zimbraPrefIMInstantNotify ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Enable
     * instant notifications
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=517)
    public void unsetPrefIMInstantNotify() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMInstantNotify, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Enable
     * instant notifications
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=517)
    public Map<String,Object> unsetPrefIMInstantNotify(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMInstantNotify, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to log IM chats to the Chats folder
     *
     * @return zimbraPrefIMLogChats, or true if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=556)
    public boolean isPrefIMLogChats() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMLogChats, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to log IM chats to the Chats folder
     *
     * @param zimbraPrefIMLogChats new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=556)
    public void setPrefIMLogChats(boolean zimbraPrefIMLogChats) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMLogChats, zimbraPrefIMLogChats ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to log IM chats to the Chats folder
     *
     * @param zimbraPrefIMLogChats new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=556)
    public Map<String,Object> setPrefIMLogChats(boolean zimbraPrefIMLogChats, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMLogChats, zimbraPrefIMLogChats ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to log IM chats to the Chats folder
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=556)
    public void unsetPrefIMLogChats() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMLogChats, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to log IM chats to the Chats folder
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=556)
    public Map<String,Object> unsetPrefIMLogChats(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMLogChats, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether IM log chats is enabled
     *
     * @return zimbraPrefIMLogChatsEnabled, or true if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=552)
    public boolean isPrefIMLogChatsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMLogChatsEnabled, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether IM log chats is enabled
     *
     * @param zimbraPrefIMLogChatsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=552)
    public void setPrefIMLogChatsEnabled(boolean zimbraPrefIMLogChatsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMLogChatsEnabled, zimbraPrefIMLogChatsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether IM log chats is enabled
     *
     * @param zimbraPrefIMLogChatsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=552)
    public Map<String,Object> setPrefIMLogChatsEnabled(boolean zimbraPrefIMLogChatsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMLogChatsEnabled, zimbraPrefIMLogChatsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether IM log chats is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=552)
    public void unsetPrefIMLogChatsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMLogChatsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether IM log chats is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=552)
    public Map<String,Object> unsetPrefIMLogChatsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMLogChatsEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for presence modifications
     *
     * @return zimbraPrefIMNotifyPresence, or true if unset
     */
    @ZAttr(id=463)
    public boolean isPrefIMNotifyPresence() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMNotifyPresence, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for presence modifications
     *
     * @param zimbraPrefIMNotifyPresence new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=463)
    public void setPrefIMNotifyPresence(boolean zimbraPrefIMNotifyPresence) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMNotifyPresence, zimbraPrefIMNotifyPresence ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for presence modifications
     *
     * @param zimbraPrefIMNotifyPresence new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=463)
    public Map<String,Object> setPrefIMNotifyPresence(boolean zimbraPrefIMNotifyPresence, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMNotifyPresence, zimbraPrefIMNotifyPresence ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for presence modifications
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=463)
    public void unsetPrefIMNotifyPresence() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMNotifyPresence, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for presence modifications
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=463)
    public Map<String,Object> unsetPrefIMNotifyPresence(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMNotifyPresence, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for status change
     *
     * @return zimbraPrefIMNotifyStatus, or true if unset
     */
    @ZAttr(id=464)
    public boolean isPrefIMNotifyStatus() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMNotifyStatus, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for status change
     *
     * @param zimbraPrefIMNotifyStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=464)
    public void setPrefIMNotifyStatus(boolean zimbraPrefIMNotifyStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMNotifyStatus, zimbraPrefIMNotifyStatus ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for status change
     *
     * @param zimbraPrefIMNotifyStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=464)
    public Map<String,Object> setPrefIMNotifyStatus(boolean zimbraPrefIMNotifyStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMNotifyStatus, zimbraPrefIMNotifyStatus ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for status change
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=464)
    public void unsetPrefIMNotifyStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMNotifyStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: Notify
     * for status change
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=464)
    public Map<String,Object> unsetPrefIMNotifyStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMNotifyStatus, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to report IM idle status
     *
     * @return zimbraPrefIMReportIdle, or true if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=558)
    public boolean isPrefIMReportIdle() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMReportIdle, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to report IM idle status
     *
     * @param zimbraPrefIMReportIdle new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=558)
    public void setPrefIMReportIdle(boolean zimbraPrefIMReportIdle) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMReportIdle, zimbraPrefIMReportIdle ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to report IM idle status
     *
     * @param zimbraPrefIMReportIdle new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=558)
    public Map<String,Object> setPrefIMReportIdle(boolean zimbraPrefIMReportIdle, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMReportIdle, zimbraPrefIMReportIdle ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to report IM idle status
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=558)
    public void unsetPrefIMReportIdle() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMReportIdle, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether to report IM idle status
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=558)
    public Map<String,Object> unsetPrefIMReportIdle(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMReportIdle, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether sounds is enabled in IM
     *
     * @return zimbraPrefIMSoundsEnabled, or true if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=570)
    public boolean isPrefIMSoundsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMSoundsEnabled, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether sounds is enabled in IM
     *
     * @param zimbraPrefIMSoundsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=570)
    public void setPrefIMSoundsEnabled(boolean zimbraPrefIMSoundsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMSoundsEnabled, zimbraPrefIMSoundsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether sounds is enabled in IM
     *
     * @param zimbraPrefIMSoundsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=570)
    public Map<String,Object> setPrefIMSoundsEnabled(boolean zimbraPrefIMSoundsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMSoundsEnabled, zimbraPrefIMSoundsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether sounds is enabled in IM
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=570)
    public void unsetPrefIMSoundsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMSoundsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc:
     * whether sounds is enabled in IM
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=570)
    public Map<String,Object> unsetPrefIMSoundsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMSoundsEnabled, "");
        return attrs;
    }

    /**
     * whether to enable toaster notification for IM
     *
     * @return zimbraPrefIMToasterEnabled, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=814)
    public boolean isPrefIMToasterEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIMToasterEnabled, false, true);
    }

    /**
     * whether to enable toaster notification for IM
     *
     * @param zimbraPrefIMToasterEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=814)
    public void setPrefIMToasterEnabled(boolean zimbraPrefIMToasterEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMToasterEnabled, zimbraPrefIMToasterEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable toaster notification for IM
     *
     * @param zimbraPrefIMToasterEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=814)
    public Map<String,Object> setPrefIMToasterEnabled(boolean zimbraPrefIMToasterEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMToasterEnabled, zimbraPrefIMToasterEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to enable toaster notification for IM
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=814)
    public void unsetPrefIMToasterEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMToasterEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable toaster notification for IM
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=814)
    public Map<String,Object> unsetPrefIMToasterEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMToasterEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: last
     * used yahoo id
     *
     * @return zimbraPrefIMYahooId, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=757)
    public String getPrefIMYahooId() {
        return getAttr(Provisioning.A_zimbraPrefIMYahooId, null, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: last
     * used yahoo id
     *
     * @param zimbraPrefIMYahooId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=757)
    public void setPrefIMYahooId(String zimbraPrefIMYahooId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMYahooId, zimbraPrefIMYahooId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: last
     * used yahoo id
     *
     * @param zimbraPrefIMYahooId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=757)
    public Map<String,Object> setPrefIMYahooId(String zimbraPrefIMYahooId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMYahooId, zimbraPrefIMYahooId);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: last
     * used yahoo id
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=757)
    public void unsetPrefIMYahooId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMYahooId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra IM has been discontinued. Zimbra Chat
     * feature uses a new set of configuration attributes.. Orig desc: last
     * used yahoo id
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=757)
    public Map<String,Object> unsetPrefIMYahooId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIMYahooId, "");
        return attrs;
    }

    /**
     * name of the identity
     *
     * @return zimbraPrefIdentityName, or null if unset
     */
    @ZAttr(id=412)
    public String getPrefIdentityName() {
        return getAttr(Provisioning.A_zimbraPrefIdentityName, null, true);
    }

    /**
     * name of the identity
     *
     * @param zimbraPrefIdentityName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=412)
    public void setPrefIdentityName(String zimbraPrefIdentityName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIdentityName, zimbraPrefIdentityName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name of the identity
     *
     * @param zimbraPrefIdentityName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=412)
    public Map<String,Object> setPrefIdentityName(String zimbraPrefIdentityName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIdentityName, zimbraPrefIdentityName);
        return attrs;
    }

    /**
     * name of the identity
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=412)
    public void unsetPrefIdentityName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIdentityName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name of the identity
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=412)
    public Map<String,Object> unsetPrefIdentityName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIdentityName, "");
        return attrs;
    }

    /**
     * whether end user choose to use IMAP feature. If it is set to TRUE,
     * IMAP feature is available only when zimbraImapEnabled is TRUE.
     *
     * @return zimbraPrefImapEnabled, or true if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3086)
    public boolean isPrefImapEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefImapEnabled, true, true);
    }

    /**
     * whether end user choose to use IMAP feature. If it is set to TRUE,
     * IMAP feature is available only when zimbraImapEnabled is TRUE.
     *
     * @param zimbraPrefImapEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3086)
    public void setPrefImapEnabled(boolean zimbraPrefImapEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefImapEnabled, zimbraPrefImapEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end user choose to use IMAP feature. If it is set to TRUE,
     * IMAP feature is available only when zimbraImapEnabled is TRUE.
     *
     * @param zimbraPrefImapEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3086)
    public Map<String,Object> setPrefImapEnabled(boolean zimbraPrefImapEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefImapEnabled, zimbraPrefImapEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether end user choose to use IMAP feature. If it is set to TRUE,
     * IMAP feature is available only when zimbraImapEnabled is TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3086)
    public void unsetPrefImapEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefImapEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end user choose to use IMAP feature. If it is set to TRUE,
     * IMAP feature is available only when zimbraImapEnabled is TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3086)
    public Map<String,Object> unsetPrefImapEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefImapEnabled, "");
        return attrs;
    }

    /**
     * whether or not the IMAP server exports search folders
     *
     * @return zimbraPrefImapSearchFoldersEnabled, or true if unset
     */
    @ZAttr(id=241)
    public boolean isPrefImapSearchFoldersEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefImapSearchFoldersEnabled, true, true);
    }

    /**
     * whether or not the IMAP server exports search folders
     *
     * @param zimbraPrefImapSearchFoldersEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=241)
    public void setPrefImapSearchFoldersEnabled(boolean zimbraPrefImapSearchFoldersEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefImapSearchFoldersEnabled, zimbraPrefImapSearchFoldersEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not the IMAP server exports search folders
     *
     * @param zimbraPrefImapSearchFoldersEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=241)
    public Map<String,Object> setPrefImapSearchFoldersEnabled(boolean zimbraPrefImapSearchFoldersEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefImapSearchFoldersEnabled, zimbraPrefImapSearchFoldersEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not the IMAP server exports search folders
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=241)
    public void unsetPrefImapSearchFoldersEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefImapSearchFoldersEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not the IMAP server exports search folders
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=241)
    public Map<String,Object> unsetPrefImapSearchFoldersEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefImapSearchFoldersEnabled, "");
        return attrs;
    }

    /**
     * Retention period of read messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPrefInboxReadLifetimeAsString to access value as a string.
     *
     * @see #getPrefInboxReadLifetimeAsString()
     *
     * @return zimbraPrefInboxReadLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=538)
    public long getPrefInboxReadLifetime() {
        return getTimeInterval(Provisioning.A_zimbraPrefInboxReadLifetime, 0L, true);
    }

    /**
     * Retention period of read messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPrefInboxReadLifetime, or "0" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=538)
    public String getPrefInboxReadLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraPrefInboxReadLifetime, "0", true);
    }

    /**
     * Retention period of read messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefInboxReadLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=538)
    public void setPrefInboxReadLifetime(String zimbraPrefInboxReadLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefInboxReadLifetime, zimbraPrefInboxReadLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of read messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefInboxReadLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=538)
    public Map<String,Object> setPrefInboxReadLifetime(String zimbraPrefInboxReadLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefInboxReadLifetime, zimbraPrefInboxReadLifetime);
        return attrs;
    }

    /**
     * Retention period of read messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=538)
    public void unsetPrefInboxReadLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefInboxReadLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of read messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=538)
    public Map<String,Object> unsetPrefInboxReadLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefInboxReadLifetime, "");
        return attrs;
    }

    /**
     * Retention period of unread messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPrefInboxUnreadLifetimeAsString to access value as a string.
     *
     * @see #getPrefInboxUnreadLifetimeAsString()
     *
     * @return zimbraPrefInboxUnreadLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=537)
    public long getPrefInboxUnreadLifetime() {
        return getTimeInterval(Provisioning.A_zimbraPrefInboxUnreadLifetime, 0L, true);
    }

    /**
     * Retention period of unread messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPrefInboxUnreadLifetime, or "0" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=537)
    public String getPrefInboxUnreadLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraPrefInboxUnreadLifetime, "0", true);
    }

    /**
     * Retention period of unread messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefInboxUnreadLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=537)
    public void setPrefInboxUnreadLifetime(String zimbraPrefInboxUnreadLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefInboxUnreadLifetime, zimbraPrefInboxUnreadLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of unread messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefInboxUnreadLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=537)
    public Map<String,Object> setPrefInboxUnreadLifetime(String zimbraPrefInboxUnreadLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefInboxUnreadLifetime, zimbraPrefInboxUnreadLifetime);
        return attrs;
    }

    /**
     * Retention period of unread messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=537)
    public void unsetPrefInboxUnreadLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefInboxUnreadLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of unread messages in the Inbox folder. 0 means that
     * all messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=537)
    public Map<String,Object> unsetPrefInboxUnreadLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefInboxUnreadLifetime, "");
        return attrs;
    }

    /**
     * whether to include shared items in search
     *
     * @return zimbraPrefIncludeSharedItemsInSearch, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1338)
    public boolean isPrefIncludeSharedItemsInSearch() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIncludeSharedItemsInSearch, false, true);
    }

    /**
     * whether to include shared items in search
     *
     * @param zimbraPrefIncludeSharedItemsInSearch new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1338)
    public void setPrefIncludeSharedItemsInSearch(boolean zimbraPrefIncludeSharedItemsInSearch) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeSharedItemsInSearch, zimbraPrefIncludeSharedItemsInSearch ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to include shared items in search
     *
     * @param zimbraPrefIncludeSharedItemsInSearch new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1338)
    public Map<String,Object> setPrefIncludeSharedItemsInSearch(boolean zimbraPrefIncludeSharedItemsInSearch, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeSharedItemsInSearch, zimbraPrefIncludeSharedItemsInSearch ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to include shared items in search
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1338)
    public void unsetPrefIncludeSharedItemsInSearch() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeSharedItemsInSearch, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to include shared items in search
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1338)
    public Map<String,Object> unsetPrefIncludeSharedItemsInSearch(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeSharedItemsInSearch, "");
        return attrs;
    }

    /**
     * whether or not to include spam in search by default
     *
     * @return zimbraPrefIncludeSpamInSearch, or false if unset
     */
    @ZAttr(id=55)
    public boolean isPrefIncludeSpamInSearch() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIncludeSpamInSearch, false, true);
    }

    /**
     * whether or not to include spam in search by default
     *
     * @param zimbraPrefIncludeSpamInSearch new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=55)
    public void setPrefIncludeSpamInSearch(boolean zimbraPrefIncludeSpamInSearch) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeSpamInSearch, zimbraPrefIncludeSpamInSearch ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to include spam in search by default
     *
     * @param zimbraPrefIncludeSpamInSearch new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=55)
    public Map<String,Object> setPrefIncludeSpamInSearch(boolean zimbraPrefIncludeSpamInSearch, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeSpamInSearch, zimbraPrefIncludeSpamInSearch ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to include spam in search by default
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=55)
    public void unsetPrefIncludeSpamInSearch() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeSpamInSearch, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to include spam in search by default
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=55)
    public Map<String,Object> unsetPrefIncludeSpamInSearch(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeSpamInSearch, "");
        return attrs;
    }

    /**
     * whether or not to include trash in search by default
     *
     * @return zimbraPrefIncludeTrashInSearch, or false if unset
     */
    @ZAttr(id=56)
    public boolean isPrefIncludeTrashInSearch() {
        return getBooleanAttr(Provisioning.A_zimbraPrefIncludeTrashInSearch, false, true);
    }

    /**
     * whether or not to include trash in search by default
     *
     * @param zimbraPrefIncludeTrashInSearch new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=56)
    public void setPrefIncludeTrashInSearch(boolean zimbraPrefIncludeTrashInSearch) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeTrashInSearch, zimbraPrefIncludeTrashInSearch ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to include trash in search by default
     *
     * @param zimbraPrefIncludeTrashInSearch new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=56)
    public Map<String,Object> setPrefIncludeTrashInSearch(boolean zimbraPrefIncludeTrashInSearch, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeTrashInSearch, zimbraPrefIncludeTrashInSearch ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to include trash in search by default
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=56)
    public void unsetPrefIncludeTrashInSearch() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeTrashInSearch, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to include trash in search by default
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=56)
    public Map<String,Object> unsetPrefIncludeTrashInSearch(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefIncludeTrashInSearch, "");
        return attrs;
    }

    /**
     * number of messages/conversations per virtual page
     *
     * @return zimbraPrefItemsPerVirtualPage, or 50 if unset
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1079)
    public int getPrefItemsPerVirtualPage() {
        return getIntAttr(Provisioning.A_zimbraPrefItemsPerVirtualPage, 50, true);
    }

    /**
     * number of messages/conversations per virtual page
     *
     * @param zimbraPrefItemsPerVirtualPage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1079)
    public void setPrefItemsPerVirtualPage(int zimbraPrefItemsPerVirtualPage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefItemsPerVirtualPage, Integer.toString(zimbraPrefItemsPerVirtualPage));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of messages/conversations per virtual page
     *
     * @param zimbraPrefItemsPerVirtualPage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1079)
    public Map<String,Object> setPrefItemsPerVirtualPage(int zimbraPrefItemsPerVirtualPage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefItemsPerVirtualPage, Integer.toString(zimbraPrefItemsPerVirtualPage));
        return attrs;
    }

    /**
     * number of messages/conversations per virtual page
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1079)
    public void unsetPrefItemsPerVirtualPage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefItemsPerVirtualPage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of messages/conversations per virtual page
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1079)
    public Map<String,Object> unsetPrefItemsPerVirtualPage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefItemsPerVirtualPage, "");
        return attrs;
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailSpamLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPrefJunkLifetimeAsString to access value as a string.
     *
     * @see #getPrefJunkLifetimeAsString()
     *
     * @return zimbraPrefJunkLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=540)
    public long getPrefJunkLifetime() {
        return getTimeInterval(Provisioning.A_zimbraPrefJunkLifetime, 0L, true);
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailSpamLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPrefJunkLifetime, or "0" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=540)
    public String getPrefJunkLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraPrefJunkLifetime, "0", true);
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailSpamLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefJunkLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=540)
    public void setPrefJunkLifetime(String zimbraPrefJunkLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefJunkLifetime, zimbraPrefJunkLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailSpamLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefJunkLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=540)
    public Map<String,Object> setPrefJunkLifetime(String zimbraPrefJunkLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefJunkLifetime, zimbraPrefJunkLifetime);
        return attrs;
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailSpamLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=540)
    public void unsetPrefJunkLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefJunkLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Junk folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailSpamLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=540)
    public Map<String,Object> unsetPrefJunkLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefJunkLifetime, "");
        return attrs;
    }

    /**
     * optional account descriptive label
     *
     * @return zimbraPrefLabel, or null if unset
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=603)
    public String getPrefLabel() {
        return getAttr(Provisioning.A_zimbraPrefLabel, null, true);
    }

    /**
     * optional account descriptive label
     *
     * @param zimbraPrefLabel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=603)
    public void setPrefLabel(String zimbraPrefLabel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefLabel, zimbraPrefLabel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * optional account descriptive label
     *
     * @param zimbraPrefLabel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=603)
    public Map<String,Object> setPrefLabel(String zimbraPrefLabel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefLabel, zimbraPrefLabel);
        return attrs;
    }

    /**
     * optional account descriptive label
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=603)
    public void unsetPrefLabel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefLabel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * optional account descriptive label
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=603)
    public Map<String,Object> unsetPrefLabel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefLabel, "");
        return attrs;
    }

    /**
     * list view columns in web client
     *
     * @return zimbraPrefListViewColumns, or null if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=694)
    public String getPrefListViewColumns() {
        return getAttr(Provisioning.A_zimbraPrefListViewColumns, null, true);
    }

    /**
     * list view columns in web client
     *
     * @param zimbraPrefListViewColumns new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=694)
    public void setPrefListViewColumns(String zimbraPrefListViewColumns) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefListViewColumns, zimbraPrefListViewColumns);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list view columns in web client
     *
     * @param zimbraPrefListViewColumns new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=694)
    public Map<String,Object> setPrefListViewColumns(String zimbraPrefListViewColumns, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefListViewColumns, zimbraPrefListViewColumns);
        return attrs;
    }

    /**
     * list view columns in web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=694)
    public void unsetPrefListViewColumns() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefListViewColumns, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list view columns in web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=694)
    public Map<String,Object> unsetPrefListViewColumns(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefListViewColumns, "");
        return attrs;
    }

    /**
     * user locale preference, e.g. en_US Whenever the server looks for the
     * user locale, it will first look for zimbraPrefLocale, if it is not set
     * then it will fallback to the current mechanism of looking for
     * zimbraLocale in the various places for a user. zimbraLocale is the non
     * end-user attribute that specifies which locale an object defaults to,
     * it is not an end-user setting.
     *
     * @return zimbraPrefLocale, or null if unset
     */
    @ZAttr(id=442)
    public String getPrefLocale() {
        return getAttr(Provisioning.A_zimbraPrefLocale, null, true);
    }

    /**
     * user locale preference, e.g. en_US Whenever the server looks for the
     * user locale, it will first look for zimbraPrefLocale, if it is not set
     * then it will fallback to the current mechanism of looking for
     * zimbraLocale in the various places for a user. zimbraLocale is the non
     * end-user attribute that specifies which locale an object defaults to,
     * it is not an end-user setting.
     *
     * @param zimbraPrefLocale new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=442)
    public void setPrefLocale(String zimbraPrefLocale) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefLocale, zimbraPrefLocale);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * user locale preference, e.g. en_US Whenever the server looks for the
     * user locale, it will first look for zimbraPrefLocale, if it is not set
     * then it will fallback to the current mechanism of looking for
     * zimbraLocale in the various places for a user. zimbraLocale is the non
     * end-user attribute that specifies which locale an object defaults to,
     * it is not an end-user setting.
     *
     * @param zimbraPrefLocale new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=442)
    public Map<String,Object> setPrefLocale(String zimbraPrefLocale, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefLocale, zimbraPrefLocale);
        return attrs;
    }

    /**
     * user locale preference, e.g. en_US Whenever the server looks for the
     * user locale, it will first look for zimbraPrefLocale, if it is not set
     * then it will fallback to the current mechanism of looking for
     * zimbraLocale in the various places for a user. zimbraLocale is the non
     * end-user attribute that specifies which locale an object defaults to,
     * it is not an end-user setting.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=442)
    public void unsetPrefLocale() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefLocale, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * user locale preference, e.g. en_US Whenever the server looks for the
     * user locale, it will first look for zimbraPrefLocale, if it is not set
     * then it will fallback to the current mechanism of looking for
     * zimbraLocale in the various places for a user. zimbraLocale is the non
     * end-user attribute that specifies which locale an object defaults to,
     * it is not an end-user setting.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=442)
    public Map<String,Object> unsetPrefLocale(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefLocale, "");
        return attrs;
    }

    /**
     * Default Charset for mail composing and parsing text
     *
     * @return zimbraPrefMailDefaultCharset, or null if unset
     */
    @ZAttr(id=469)
    public String getPrefMailDefaultCharset() {
        return getAttr(Provisioning.A_zimbraPrefMailDefaultCharset, null, true);
    }

    /**
     * Default Charset for mail composing and parsing text
     *
     * @param zimbraPrefMailDefaultCharset new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=469)
    public void setPrefMailDefaultCharset(String zimbraPrefMailDefaultCharset) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailDefaultCharset, zimbraPrefMailDefaultCharset);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default Charset for mail composing and parsing text
     *
     * @param zimbraPrefMailDefaultCharset new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=469)
    public Map<String,Object> setPrefMailDefaultCharset(String zimbraPrefMailDefaultCharset, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailDefaultCharset, zimbraPrefMailDefaultCharset);
        return attrs;
    }

    /**
     * Default Charset for mail composing and parsing text
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=469)
    public void unsetPrefMailDefaultCharset() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailDefaultCharset, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default Charset for mail composing and parsing text
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=469)
    public Map<String,Object> unsetPrefMailDefaultCharset(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailDefaultCharset, "");
        return attrs;
    }

    /**
     * Flash icon when a new email arrives
     *
     * @return zimbraPrefMailFlashIcon, or false if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=681)
    public boolean isPrefMailFlashIcon() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMailFlashIcon, false, true);
    }

    /**
     * Flash icon when a new email arrives
     *
     * @param zimbraPrefMailFlashIcon new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=681)
    public void setPrefMailFlashIcon(boolean zimbraPrefMailFlashIcon) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFlashIcon, zimbraPrefMailFlashIcon ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flash icon when a new email arrives
     *
     * @param zimbraPrefMailFlashIcon new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=681)
    public Map<String,Object> setPrefMailFlashIcon(boolean zimbraPrefMailFlashIcon, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFlashIcon, zimbraPrefMailFlashIcon ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Flash icon when a new email arrives
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=681)
    public void unsetPrefMailFlashIcon() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFlashIcon, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flash icon when a new email arrives
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=681)
    public Map<String,Object> unsetPrefMailFlashIcon(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFlashIcon, "");
        return attrs;
    }

    /**
     * Flash title bar when a new email arrives
     *
     * @return zimbraPrefMailFlashTitle, or false if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=680)
    public boolean isPrefMailFlashTitle() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMailFlashTitle, false, true);
    }

    /**
     * Flash title bar when a new email arrives
     *
     * @param zimbraPrefMailFlashTitle new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=680)
    public void setPrefMailFlashTitle(boolean zimbraPrefMailFlashTitle) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFlashTitle, zimbraPrefMailFlashTitle ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flash title bar when a new email arrives
     *
     * @param zimbraPrefMailFlashTitle new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=680)
    public Map<String,Object> setPrefMailFlashTitle(boolean zimbraPrefMailFlashTitle, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFlashTitle, zimbraPrefMailFlashTitle ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Flash title bar when a new email arrives
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=680)
    public void unsetPrefMailFlashTitle() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFlashTitle, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Flash title bar when a new email arrives
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=680)
    public Map<String,Object> unsetPrefMailFlashTitle(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFlashTitle, "");
        return attrs;
    }

    /**
     * a list of comma separated folder ids of all folders used to count for
     * showing a new message indicator icon for the account, useful in UIs
     * managing multiple accounts: desktop and family mailboxes.
     *
     * @return zimbraPrefMailFoldersCheckedForNewMsgIndicator, or null if unset
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1072)
    public String getPrefMailFoldersCheckedForNewMsgIndicator() {
        return getAttr(Provisioning.A_zimbraPrefMailFoldersCheckedForNewMsgIndicator, null, true);
    }

    /**
     * a list of comma separated folder ids of all folders used to count for
     * showing a new message indicator icon for the account, useful in UIs
     * managing multiple accounts: desktop and family mailboxes.
     *
     * @param zimbraPrefMailFoldersCheckedForNewMsgIndicator new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1072)
    public void setPrefMailFoldersCheckedForNewMsgIndicator(String zimbraPrefMailFoldersCheckedForNewMsgIndicator) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFoldersCheckedForNewMsgIndicator, zimbraPrefMailFoldersCheckedForNewMsgIndicator);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * a list of comma separated folder ids of all folders used to count for
     * showing a new message indicator icon for the account, useful in UIs
     * managing multiple accounts: desktop and family mailboxes.
     *
     * @param zimbraPrefMailFoldersCheckedForNewMsgIndicator new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1072)
    public Map<String,Object> setPrefMailFoldersCheckedForNewMsgIndicator(String zimbraPrefMailFoldersCheckedForNewMsgIndicator, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFoldersCheckedForNewMsgIndicator, zimbraPrefMailFoldersCheckedForNewMsgIndicator);
        return attrs;
    }

    /**
     * a list of comma separated folder ids of all folders used to count for
     * showing a new message indicator icon for the account, useful in UIs
     * managing multiple accounts: desktop and family mailboxes.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1072)
    public void unsetPrefMailFoldersCheckedForNewMsgIndicator() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFoldersCheckedForNewMsgIndicator, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * a list of comma separated folder ids of all folders used to count for
     * showing a new message indicator icon for the account, useful in UIs
     * managing multiple accounts: desktop and family mailboxes.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1072)
    public Map<String,Object> unsetPrefMailFoldersCheckedForNewMsgIndicator(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailFoldersCheckedForNewMsgIndicator, "");
        return attrs;
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @return zimbraPrefMailForwardingAddress, or null if unset
     */
    @ZAttr(id=343)
    public String getPrefMailForwardingAddress() {
        return getAttr(Provisioning.A_zimbraPrefMailForwardingAddress, null, true);
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param zimbraPrefMailForwardingAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=343)
    public void setPrefMailForwardingAddress(String zimbraPrefMailForwardingAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailForwardingAddress, zimbraPrefMailForwardingAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param zimbraPrefMailForwardingAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=343)
    public Map<String,Object> setPrefMailForwardingAddress(String zimbraPrefMailForwardingAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailForwardingAddress, zimbraPrefMailForwardingAddress);
        return attrs;
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=343)
    public void unsetPrefMailForwardingAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailForwardingAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 forwarding address for an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=343)
    public Map<String,Object> unsetPrefMailForwardingAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailForwardingAddress, "");
        return attrs;
    }

    /**
     * initial search done by dhtml client
     *
     * @return zimbraPrefMailInitialSearch, or "in:inbox" if unset
     */
    @ZAttr(id=102)
    public String getPrefMailInitialSearch() {
        return getAttr(Provisioning.A_zimbraPrefMailInitialSearch, "in:inbox", true);
    }

    /**
     * initial search done by dhtml client
     *
     * @param zimbraPrefMailInitialSearch new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=102)
    public void setPrefMailInitialSearch(String zimbraPrefMailInitialSearch) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailInitialSearch, zimbraPrefMailInitialSearch);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * initial search done by dhtml client
     *
     * @param zimbraPrefMailInitialSearch new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=102)
    public Map<String,Object> setPrefMailInitialSearch(String zimbraPrefMailInitialSearch, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailInitialSearch, zimbraPrefMailInitialSearch);
        return attrs;
    }

    /**
     * initial search done by dhtml client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=102)
    public void unsetPrefMailInitialSearch() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailInitialSearch, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * initial search done by dhtml client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=102)
    public Map<String,Object> unsetPrefMailInitialSearch(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailInitialSearch, "");
        return attrs;
    }

    /**
     * number of messages/conversations per page
     *
     * @return zimbraPrefMailItemsPerPage, or 25 if unset
     */
    @ZAttr(id=57)
    public int getPrefMailItemsPerPage() {
        return getIntAttr(Provisioning.A_zimbraPrefMailItemsPerPage, 25, true);
    }

    /**
     * number of messages/conversations per page
     *
     * @param zimbraPrefMailItemsPerPage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=57)
    public void setPrefMailItemsPerPage(int zimbraPrefMailItemsPerPage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailItemsPerPage, Integer.toString(zimbraPrefMailItemsPerPage));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of messages/conversations per page
     *
     * @param zimbraPrefMailItemsPerPage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=57)
    public Map<String,Object> setPrefMailItemsPerPage(int zimbraPrefMailItemsPerPage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailItemsPerPage, Integer.toString(zimbraPrefMailItemsPerPage));
        return attrs;
    }

    /**
     * number of messages/conversations per page
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=57)
    public void unsetPrefMailItemsPerPage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailItemsPerPage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of messages/conversations per page
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=57)
    public Map<String,Object> unsetPrefMailItemsPerPage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailItemsPerPage, "");
        return attrs;
    }

    /**
     * whether or not to deliver mail locally
     *
     * @return zimbraPrefMailLocalDeliveryDisabled, or false if unset
     */
    @ZAttr(id=344)
    public boolean isPrefMailLocalDeliveryDisabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMailLocalDeliveryDisabled, false, true);
    }

    /**
     * whether or not to deliver mail locally
     *
     * @param zimbraPrefMailLocalDeliveryDisabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=344)
    public void setPrefMailLocalDeliveryDisabled(boolean zimbraPrefMailLocalDeliveryDisabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailLocalDeliveryDisabled, zimbraPrefMailLocalDeliveryDisabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to deliver mail locally
     *
     * @param zimbraPrefMailLocalDeliveryDisabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=344)
    public Map<String,Object> setPrefMailLocalDeliveryDisabled(boolean zimbraPrefMailLocalDeliveryDisabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailLocalDeliveryDisabled, zimbraPrefMailLocalDeliveryDisabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to deliver mail locally
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=344)
    public void unsetPrefMailLocalDeliveryDisabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailLocalDeliveryDisabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to deliver mail locally
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=344)
    public Map<String,Object> unsetPrefMailLocalDeliveryDisabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailLocalDeliveryDisabled, "");
        return attrs;
    }

    /**
     * interval at which the web client polls the server for new messages.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getPrefMailPollingIntervalAsString to access value as a string.
     *
     * @see #getPrefMailPollingIntervalAsString()
     *
     * @return zimbraPrefMailPollingInterval in millseconds, or 300000 (5m)  if unset
     */
    @ZAttr(id=111)
    public long getPrefMailPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraPrefMailPollingInterval, 300000L, true);
    }

    /**
     * interval at which the web client polls the server for new messages.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraPrefMailPollingInterval, or "5m" if unset
     */
    @ZAttr(id=111)
    public String getPrefMailPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraPrefMailPollingInterval, "5m", true);
    }

    /**
     * interval at which the web client polls the server for new messages.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraPrefMailPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=111)
    public void setPrefMailPollingInterval(String zimbraPrefMailPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailPollingInterval, zimbraPrefMailPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interval at which the web client polls the server for new messages.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraPrefMailPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=111)
    public Map<String,Object> setPrefMailPollingInterval(String zimbraPrefMailPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailPollingInterval, zimbraPrefMailPollingInterval);
        return attrs;
    }

    /**
     * interval at which the web client polls the server for new messages.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=111)
    public void unsetPrefMailPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interval at which the web client polls the server for new messages.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=111)
    public Map<String,Object> unsetPrefMailPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailPollingInterval, "");
        return attrs;
    }

    /**
     * whether web UI should always request read receipts for outgoing
     * messages
     *
     * @return zimbraPrefMailRequestReadReceipts, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1217)
    public boolean isPrefMailRequestReadReceipts() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMailRequestReadReceipts, false, true);
    }

    /**
     * whether web UI should always request read receipts for outgoing
     * messages
     *
     * @param zimbraPrefMailRequestReadReceipts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1217)
    public void setPrefMailRequestReadReceipts(boolean zimbraPrefMailRequestReadReceipts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailRequestReadReceipts, zimbraPrefMailRequestReadReceipts ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether web UI should always request read receipts for outgoing
     * messages
     *
     * @param zimbraPrefMailRequestReadReceipts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1217)
    public Map<String,Object> setPrefMailRequestReadReceipts(boolean zimbraPrefMailRequestReadReceipts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailRequestReadReceipts, zimbraPrefMailRequestReadReceipts ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether web UI should always request read receipts for outgoing
     * messages
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1217)
    public void unsetPrefMailRequestReadReceipts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailRequestReadReceipts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether web UI should always request read receipts for outgoing
     * messages
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1217)
    public Map<String,Object> unsetPrefMailRequestReadReceipts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailRequestReadReceipts, "");
        return attrs;
    }

    /**
     * Deprecated since: 7.1.1. deprecated in favor of userCertificate and
     * userSMIMECertificate. Orig desc: user&#039;s S/MIME public keys
     * (certificates)
     *
     * @return zimbraPrefMailSMIMECertificate, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1172)
    public String[] getPrefMailSMIMECertificateAsString() {
        return getMultiAttr(Provisioning.A_zimbraPrefMailSMIMECertificate, true, true);
    }

    /**
     * Deprecated since: 7.1.1. deprecated in favor of userCertificate and
     * userSMIMECertificate. Orig desc: user&#039;s S/MIME public keys
     * (certificates)
     *
     * @param zimbraPrefMailSMIMECertificate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1172)
    public void setPrefMailSMIMECertificate(byte[] zimbraPrefMailSMIMECertificate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSMIMECertificate, zimbraPrefMailSMIMECertificate==null ? "" : ByteUtil.encodeLDAPBase64(zimbraPrefMailSMIMECertificate));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 7.1.1. deprecated in favor of userCertificate and
     * userSMIMECertificate. Orig desc: user&#039;s S/MIME public keys
     * (certificates)
     *
     * @param zimbraPrefMailSMIMECertificate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1172)
    public Map<String,Object> setPrefMailSMIMECertificate(byte[] zimbraPrefMailSMIMECertificate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSMIMECertificate, zimbraPrefMailSMIMECertificate==null ? "" : ByteUtil.encodeLDAPBase64(zimbraPrefMailSMIMECertificate));
        return attrs;
    }

    /**
     * Deprecated since: 7.1.1. deprecated in favor of userCertificate and
     * userSMIMECertificate. Orig desc: user&#039;s S/MIME public keys
     * (certificates)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1172)
    public void unsetPrefMailSMIMECertificate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSMIMECertificate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 7.1.1. deprecated in favor of userCertificate and
     * userSMIMECertificate. Orig desc: user&#039;s S/MIME public keys
     * (certificates)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1172)
    public Map<String,Object> unsetPrefMailSMIMECertificate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSMIMECertificate, "");
        return attrs;
    }

    /**
     * After deleting a message in list, which message should be selected
     *
     * <p>Valid values: [next, previous, adaptive]
     *
     * @return zimbraPrefMailSelectAfterDelete, or ZAttrProvisioning.PrefMailSelectAfterDelete.next if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1046)
    public ZAttrProvisioning.PrefMailSelectAfterDelete getPrefMailSelectAfterDelete() {
        try { String v = getAttr(Provisioning.A_zimbraPrefMailSelectAfterDelete, true, true); return v == null ? ZAttrProvisioning.PrefMailSelectAfterDelete.next : ZAttrProvisioning.PrefMailSelectAfterDelete.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefMailSelectAfterDelete.next; }
    }

    /**
     * After deleting a message in list, which message should be selected
     *
     * <p>Valid values: [next, previous, adaptive]
     *
     * @return zimbraPrefMailSelectAfterDelete, or "next" if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1046)
    public String getPrefMailSelectAfterDeleteAsString() {
        return getAttr(Provisioning.A_zimbraPrefMailSelectAfterDelete, "next", true);
    }

    /**
     * After deleting a message in list, which message should be selected
     *
     * <p>Valid values: [next, previous, adaptive]
     *
     * @param zimbraPrefMailSelectAfterDelete new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1046)
    public void setPrefMailSelectAfterDelete(ZAttrProvisioning.PrefMailSelectAfterDelete zimbraPrefMailSelectAfterDelete) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSelectAfterDelete, zimbraPrefMailSelectAfterDelete.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * After deleting a message in list, which message should be selected
     *
     * <p>Valid values: [next, previous, adaptive]
     *
     * @param zimbraPrefMailSelectAfterDelete new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1046)
    public Map<String,Object> setPrefMailSelectAfterDelete(ZAttrProvisioning.PrefMailSelectAfterDelete zimbraPrefMailSelectAfterDelete, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSelectAfterDelete, zimbraPrefMailSelectAfterDelete.toString());
        return attrs;
    }

    /**
     * After deleting a message in list, which message should be selected
     *
     * <p>Valid values: [next, previous, adaptive]
     *
     * @param zimbraPrefMailSelectAfterDelete new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1046)
    public void setPrefMailSelectAfterDeleteAsString(String zimbraPrefMailSelectAfterDelete) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSelectAfterDelete, zimbraPrefMailSelectAfterDelete);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * After deleting a message in list, which message should be selected
     *
     * <p>Valid values: [next, previous, adaptive]
     *
     * @param zimbraPrefMailSelectAfterDelete new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1046)
    public Map<String,Object> setPrefMailSelectAfterDeleteAsString(String zimbraPrefMailSelectAfterDelete, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSelectAfterDelete, zimbraPrefMailSelectAfterDelete);
        return attrs;
    }

    /**
     * After deleting a message in list, which message should be selected
     *
     * <p>Valid values: [next, previous, adaptive]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1046)
    public void unsetPrefMailSelectAfterDelete() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSelectAfterDelete, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * After deleting a message in list, which message should be selected
     *
     * <p>Valid values: [next, previous, adaptive]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1046)
    public Map<String,Object> unsetPrefMailSelectAfterDelete(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSelectAfterDelete, "");
        return attrs;
    }

    /**
     * whether to send read receipt
     *
     * <p>Valid values: [always, never, prompt]
     *
     * @return zimbraPrefMailSendReadReceipts, or ZAttrProvisioning.PrefMailSendReadReceipts.prompt if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=822)
    public ZAttrProvisioning.PrefMailSendReadReceipts getPrefMailSendReadReceipts() {
        try { String v = getAttr(Provisioning.A_zimbraPrefMailSendReadReceipts, true, true); return v == null ? ZAttrProvisioning.PrefMailSendReadReceipts.prompt : ZAttrProvisioning.PrefMailSendReadReceipts.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefMailSendReadReceipts.prompt; }
    }

    /**
     * whether to send read receipt
     *
     * <p>Valid values: [always, never, prompt]
     *
     * @return zimbraPrefMailSendReadReceipts, or "prompt" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=822)
    public String getPrefMailSendReadReceiptsAsString() {
        return getAttr(Provisioning.A_zimbraPrefMailSendReadReceipts, "prompt", true);
    }

    /**
     * whether to send read receipt
     *
     * <p>Valid values: [always, never, prompt]
     *
     * @param zimbraPrefMailSendReadReceipts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=822)
    public void setPrefMailSendReadReceipts(ZAttrProvisioning.PrefMailSendReadReceipts zimbraPrefMailSendReadReceipts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSendReadReceipts, zimbraPrefMailSendReadReceipts.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to send read receipt
     *
     * <p>Valid values: [always, never, prompt]
     *
     * @param zimbraPrefMailSendReadReceipts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=822)
    public Map<String,Object> setPrefMailSendReadReceipts(ZAttrProvisioning.PrefMailSendReadReceipts zimbraPrefMailSendReadReceipts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSendReadReceipts, zimbraPrefMailSendReadReceipts.toString());
        return attrs;
    }

    /**
     * whether to send read receipt
     *
     * <p>Valid values: [always, never, prompt]
     *
     * @param zimbraPrefMailSendReadReceipts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=822)
    public void setPrefMailSendReadReceiptsAsString(String zimbraPrefMailSendReadReceipts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSendReadReceipts, zimbraPrefMailSendReadReceipts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to send read receipt
     *
     * <p>Valid values: [always, never, prompt]
     *
     * @param zimbraPrefMailSendReadReceipts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=822)
    public Map<String,Object> setPrefMailSendReadReceiptsAsString(String zimbraPrefMailSendReadReceipts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSendReadReceipts, zimbraPrefMailSendReadReceipts);
        return attrs;
    }

    /**
     * whether to send read receipt
     *
     * <p>Valid values: [always, never, prompt]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=822)
    public void unsetPrefMailSendReadReceipts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSendReadReceipts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to send read receipt
     *
     * <p>Valid values: [always, never, prompt]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=822)
    public Map<String,Object> unsetPrefMailSendReadReceipts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSendReadReceipts, "");
        return attrs;
    }

    /**
     * mail text signature (deprecatedSince 5.0 in identity)
     *
     * @return zimbraPrefMailSignature, or null if unset
     */
    @ZAttr(id=17)
    public String getPrefMailSignature() {
        return getAttr(Provisioning.A_zimbraPrefMailSignature, null, true);
    }

    /**
     * mail text signature (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefMailSignature new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=17)
    public void setPrefMailSignature(String zimbraPrefMailSignature) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignature, zimbraPrefMailSignature);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail text signature (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefMailSignature new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=17)
    public Map<String,Object> setPrefMailSignature(String zimbraPrefMailSignature, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignature, zimbraPrefMailSignature);
        return attrs;
    }

    /**
     * mail text signature (deprecatedSince 5.0 in identity)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=17)
    public void unsetPrefMailSignature() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignature, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail text signature (deprecatedSince 5.0 in identity)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=17)
    public Map<String,Object> unsetPrefMailSignature(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignature, "");
        return attrs;
    }

    /**
     * contact id associated with the signature
     *
     * @return zimbraPrefMailSignatureContactId, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1129)
    public String getPrefMailSignatureContactId() {
        return getAttr(Provisioning.A_zimbraPrefMailSignatureContactId, null, true);
    }

    /**
     * contact id associated with the signature
     *
     * @param zimbraPrefMailSignatureContactId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1129)
    public void setPrefMailSignatureContactId(String zimbraPrefMailSignatureContactId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureContactId, zimbraPrefMailSignatureContactId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * contact id associated with the signature
     *
     * @param zimbraPrefMailSignatureContactId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1129)
    public Map<String,Object> setPrefMailSignatureContactId(String zimbraPrefMailSignatureContactId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureContactId, zimbraPrefMailSignatureContactId);
        return attrs;
    }

    /**
     * contact id associated with the signature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1129)
    public void unsetPrefMailSignatureContactId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureContactId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * contact id associated with the signature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1129)
    public Map<String,Object> unsetPrefMailSignatureContactId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureContactId, "");
        return attrs;
    }

    /**
     * mail signature enabled (deprecatedSince 5.0 in identity)
     *
     * @return zimbraPrefMailSignatureEnabled, or false if unset
     */
    @ZAttr(id=18)
    public boolean isPrefMailSignatureEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMailSignatureEnabled, false, true);
    }

    /**
     * mail signature enabled (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefMailSignatureEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=18)
    public void setPrefMailSignatureEnabled(boolean zimbraPrefMailSignatureEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureEnabled, zimbraPrefMailSignatureEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail signature enabled (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefMailSignatureEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=18)
    public Map<String,Object> setPrefMailSignatureEnabled(boolean zimbraPrefMailSignatureEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureEnabled, zimbraPrefMailSignatureEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * mail signature enabled (deprecatedSince 5.0 in identity)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=18)
    public void unsetPrefMailSignatureEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail signature enabled (deprecatedSince 5.0 in identity)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=18)
    public Map<String,Object> unsetPrefMailSignatureEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureEnabled, "");
        return attrs;
    }

    /**
     * mail html signature
     *
     * @return zimbraPrefMailSignatureHTML, or null if unset
     */
    @ZAttr(id=516)
    public String getPrefMailSignatureHTML() {
        return getAttr(Provisioning.A_zimbraPrefMailSignatureHTML, null, true);
    }

    /**
     * mail html signature
     *
     * @param zimbraPrefMailSignatureHTML new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=516)
    public void setPrefMailSignatureHTML(String zimbraPrefMailSignatureHTML) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureHTML, zimbraPrefMailSignatureHTML);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail html signature
     *
     * @param zimbraPrefMailSignatureHTML new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=516)
    public Map<String,Object> setPrefMailSignatureHTML(String zimbraPrefMailSignatureHTML, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureHTML, zimbraPrefMailSignatureHTML);
        return attrs;
    }

    /**
     * mail html signature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=516)
    public void unsetPrefMailSignatureHTML() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureHTML, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail html signature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=516)
    public Map<String,Object> unsetPrefMailSignatureHTML(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureHTML, "");
        return attrs;
    }

    /**
     * mail signature style outlook|internet (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [outlook, internet]
     *
     * @return zimbraPrefMailSignatureStyle, or ZAttrProvisioning.PrefMailSignatureStyle.outlook if unset and/or has invalid value
     */
    @ZAttr(id=156)
    public ZAttrProvisioning.PrefMailSignatureStyle getPrefMailSignatureStyle() {
        try { String v = getAttr(Provisioning.A_zimbraPrefMailSignatureStyle, true, true); return v == null ? ZAttrProvisioning.PrefMailSignatureStyle.outlook : ZAttrProvisioning.PrefMailSignatureStyle.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefMailSignatureStyle.outlook; }
    }

    /**
     * mail signature style outlook|internet (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [outlook, internet]
     *
     * @return zimbraPrefMailSignatureStyle, or "outlook" if unset
     */
    @ZAttr(id=156)
    public String getPrefMailSignatureStyleAsString() {
        return getAttr(Provisioning.A_zimbraPrefMailSignatureStyle, "outlook", true);
    }

    /**
     * mail signature style outlook|internet (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [outlook, internet]
     *
     * @param zimbraPrefMailSignatureStyle new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=156)
    public void setPrefMailSignatureStyle(ZAttrProvisioning.PrefMailSignatureStyle zimbraPrefMailSignatureStyle) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureStyle, zimbraPrefMailSignatureStyle.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail signature style outlook|internet (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [outlook, internet]
     *
     * @param zimbraPrefMailSignatureStyle new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=156)
    public Map<String,Object> setPrefMailSignatureStyle(ZAttrProvisioning.PrefMailSignatureStyle zimbraPrefMailSignatureStyle, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureStyle, zimbraPrefMailSignatureStyle.toString());
        return attrs;
    }

    /**
     * mail signature style outlook|internet (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [outlook, internet]
     *
     * @param zimbraPrefMailSignatureStyle new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=156)
    public void setPrefMailSignatureStyleAsString(String zimbraPrefMailSignatureStyle) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureStyle, zimbraPrefMailSignatureStyle);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail signature style outlook|internet (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [outlook, internet]
     *
     * @param zimbraPrefMailSignatureStyle new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=156)
    public Map<String,Object> setPrefMailSignatureStyleAsString(String zimbraPrefMailSignatureStyle, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureStyle, zimbraPrefMailSignatureStyle);
        return attrs;
    }

    /**
     * mail signature style outlook|internet (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [outlook, internet]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=156)
    public void unsetPrefMailSignatureStyle() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureStyle, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail signature style outlook|internet (deprecatedSince 5.0 in
     * identity)
     *
     * <p>Valid values: [outlook, internet]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=156)
    public Map<String,Object> unsetPrefMailSignatureStyle(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSignatureStyle, "");
        return attrs;
    }

    /**
     * whether audible alert is enabled when a new email arrives
     *
     * @return zimbraPrefMailSoundsEnabled, or false if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=666)
    public boolean isPrefMailSoundsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMailSoundsEnabled, false, true);
    }

    /**
     * whether audible alert is enabled when a new email arrives
     *
     * @param zimbraPrefMailSoundsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=666)
    public void setPrefMailSoundsEnabled(boolean zimbraPrefMailSoundsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSoundsEnabled, zimbraPrefMailSoundsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether audible alert is enabled when a new email arrives
     *
     * @param zimbraPrefMailSoundsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=666)
    public Map<String,Object> setPrefMailSoundsEnabled(boolean zimbraPrefMailSoundsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSoundsEnabled, zimbraPrefMailSoundsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether audible alert is enabled when a new email arrives
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=666)
    public void unsetPrefMailSoundsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSoundsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether audible alert is enabled when a new email arrives
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=666)
    public Map<String,Object> unsetPrefMailSoundsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailSoundsEnabled, "");
        return attrs;
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @return zimbraPrefMailToasterEnabled, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=812)
    public boolean isPrefMailToasterEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMailToasterEnabled, false, true);
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @param zimbraPrefMailToasterEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=812)
    public void setPrefMailToasterEnabled(boolean zimbraPrefMailToasterEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailToasterEnabled, zimbraPrefMailToasterEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @param zimbraPrefMailToasterEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=812)
    public Map<String,Object> setPrefMailToasterEnabled(boolean zimbraPrefMailToasterEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailToasterEnabled, zimbraPrefMailToasterEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=812)
    public void unsetPrefMailToasterEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailToasterEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable toaster notification for new mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=812)
    public Map<String,Object> unsetPrefMailToasterEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailToasterEnabled, "");
        return attrs;
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @return zimbraPrefMailTrustedSenderList, or empty array if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public String[] getPrefMailTrustedSenderList() {
        return getMultiAttr(Provisioning.A_zimbraPrefMailTrustedSenderList, true, true);
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @param zimbraPrefMailTrustedSenderList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public void setPrefMailTrustedSenderList(String[] zimbraPrefMailTrustedSenderList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailTrustedSenderList, zimbraPrefMailTrustedSenderList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @param zimbraPrefMailTrustedSenderList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public Map<String,Object> setPrefMailTrustedSenderList(String[] zimbraPrefMailTrustedSenderList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailTrustedSenderList, zimbraPrefMailTrustedSenderList);
        return attrs;
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @param zimbraPrefMailTrustedSenderList new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public void addPrefMailTrustedSenderList(String zimbraPrefMailTrustedSenderList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefMailTrustedSenderList, zimbraPrefMailTrustedSenderList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @param zimbraPrefMailTrustedSenderList new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public Map<String,Object> addPrefMailTrustedSenderList(String zimbraPrefMailTrustedSenderList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefMailTrustedSenderList, zimbraPrefMailTrustedSenderList);
        return attrs;
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @param zimbraPrefMailTrustedSenderList existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public void removePrefMailTrustedSenderList(String zimbraPrefMailTrustedSenderList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefMailTrustedSenderList, zimbraPrefMailTrustedSenderList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @param zimbraPrefMailTrustedSenderList existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public Map<String,Object> removePrefMailTrustedSenderList(String zimbraPrefMailTrustedSenderList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefMailTrustedSenderList, zimbraPrefMailTrustedSenderList);
        return attrs;
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public void unsetPrefMailTrustedSenderList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailTrustedSenderList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Trusted sender email addresses or domains. External images in emails
     * sent by trusted senders are automatically loaded in the message view.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1138)
    public Map<String,Object> unsetPrefMailTrustedSenderList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMailTrustedSenderList, "");
        return attrs;
    }

    /**
     * whether mandatory spell check is enabled
     *
     * @return zimbraPrefMandatorySpellCheckEnabled, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=749)
    public boolean isPrefMandatorySpellCheckEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMandatorySpellCheckEnabled, false, true);
    }

    /**
     * whether mandatory spell check is enabled
     *
     * @param zimbraPrefMandatorySpellCheckEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=749)
    public void setPrefMandatorySpellCheckEnabled(boolean zimbraPrefMandatorySpellCheckEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMandatorySpellCheckEnabled, zimbraPrefMandatorySpellCheckEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mandatory spell check is enabled
     *
     * @param zimbraPrefMandatorySpellCheckEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=749)
    public Map<String,Object> setPrefMandatorySpellCheckEnabled(boolean zimbraPrefMandatorySpellCheckEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMandatorySpellCheckEnabled, zimbraPrefMandatorySpellCheckEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether mandatory spell check is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=749)
    public void unsetPrefMandatorySpellCheckEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMandatorySpellCheckEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mandatory spell check is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=749)
    public Map<String,Object> unsetPrefMandatorySpellCheckEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMandatorySpellCheckEnabled, "");
        return attrs;
    }

    /**
     * whether and mark a message as read -1: Do not mark read 0: Mark read
     * 1..n: Mark read after this many seconds
     *
     * @return zimbraPrefMarkMsgRead, or 0 if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=650)
    public int getPrefMarkMsgRead() {
        return getIntAttr(Provisioning.A_zimbraPrefMarkMsgRead, 0, true);
    }

    /**
     * whether and mark a message as read -1: Do not mark read 0: Mark read
     * 1..n: Mark read after this many seconds
     *
     * @param zimbraPrefMarkMsgRead new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=650)
    public void setPrefMarkMsgRead(int zimbraPrefMarkMsgRead) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMarkMsgRead, Integer.toString(zimbraPrefMarkMsgRead));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether and mark a message as read -1: Do not mark read 0: Mark read
     * 1..n: Mark read after this many seconds
     *
     * @param zimbraPrefMarkMsgRead new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=650)
    public Map<String,Object> setPrefMarkMsgRead(int zimbraPrefMarkMsgRead, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMarkMsgRead, Integer.toString(zimbraPrefMarkMsgRead));
        return attrs;
    }

    /**
     * whether and mark a message as read -1: Do not mark read 0: Mark read
     * 1..n: Mark read after this many seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=650)
    public void unsetPrefMarkMsgRead() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMarkMsgRead, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether and mark a message as read -1: Do not mark read 0: Mark read
     * 1..n: Mark read after this many seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=650)
    public Map<String,Object> unsetPrefMarkMsgRead(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMarkMsgRead, "");
        return attrs;
    }

    /**
     * Account-level switch that enables message deduping. See
     * zimbraMessageIdDedupeCacheSize for more details.
     *
     * @return zimbraPrefMessageIdDedupingEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1198)
    public boolean isPrefMessageIdDedupingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMessageIdDedupingEnabled, true, true);
    }

    /**
     * Account-level switch that enables message deduping. See
     * zimbraMessageIdDedupeCacheSize for more details.
     *
     * @param zimbraPrefMessageIdDedupingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1198)
    public void setPrefMessageIdDedupingEnabled(boolean zimbraPrefMessageIdDedupingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMessageIdDedupingEnabled, zimbraPrefMessageIdDedupingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account-level switch that enables message deduping. See
     * zimbraMessageIdDedupeCacheSize for more details.
     *
     * @param zimbraPrefMessageIdDedupingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1198)
    public Map<String,Object> setPrefMessageIdDedupingEnabled(boolean zimbraPrefMessageIdDedupingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMessageIdDedupingEnabled, zimbraPrefMessageIdDedupingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Account-level switch that enables message deduping. See
     * zimbraMessageIdDedupeCacheSize for more details.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1198)
    public void unsetPrefMessageIdDedupingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMessageIdDedupingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account-level switch that enables message deduping. See
     * zimbraMessageIdDedupeCacheSize for more details.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1198)
    public Map<String,Object> unsetPrefMessageIdDedupingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMessageIdDedupingEnabled, "");
        return attrs;
    }

    /**
     * whether client prefers text/html or text/plain
     *
     * @return zimbraPrefMessageViewHtmlPreferred, or true if unset
     */
    @ZAttr(id=145)
    public boolean isPrefMessageViewHtmlPreferred() {
        return getBooleanAttr(Provisioning.A_zimbraPrefMessageViewHtmlPreferred, true, true);
    }

    /**
     * whether client prefers text/html or text/plain
     *
     * @param zimbraPrefMessageViewHtmlPreferred new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=145)
    public void setPrefMessageViewHtmlPreferred(boolean zimbraPrefMessageViewHtmlPreferred) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMessageViewHtmlPreferred, zimbraPrefMessageViewHtmlPreferred ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether client prefers text/html or text/plain
     *
     * @param zimbraPrefMessageViewHtmlPreferred new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=145)
    public Map<String,Object> setPrefMessageViewHtmlPreferred(boolean zimbraPrefMessageViewHtmlPreferred, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMessageViewHtmlPreferred, zimbraPrefMessageViewHtmlPreferred ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether client prefers text/html or text/plain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=145)
    public void unsetPrefMessageViewHtmlPreferred() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMessageViewHtmlPreferred, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether client prefers text/html or text/plain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=145)
    public Map<String,Object> unsetPrefMessageViewHtmlPreferred(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefMessageViewHtmlPreferred, "");
        return attrs;
    }

    /**
     * RFC822 email address for email notifications
     *
     * @return zimbraPrefNewMailNotificationAddress, or null if unset
     */
    @ZAttr(id=127)
    public String getPrefNewMailNotificationAddress() {
        return getAttr(Provisioning.A_zimbraPrefNewMailNotificationAddress, null, true);
    }

    /**
     * RFC822 email address for email notifications
     *
     * @param zimbraPrefNewMailNotificationAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=127)
    public void setPrefNewMailNotificationAddress(String zimbraPrefNewMailNotificationAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefNewMailNotificationAddress, zimbraPrefNewMailNotificationAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address for email notifications
     *
     * @param zimbraPrefNewMailNotificationAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=127)
    public Map<String,Object> setPrefNewMailNotificationAddress(String zimbraPrefNewMailNotificationAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefNewMailNotificationAddress, zimbraPrefNewMailNotificationAddress);
        return attrs;
    }

    /**
     * RFC822 email address for email notifications
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=127)
    public void unsetPrefNewMailNotificationAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefNewMailNotificationAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 email address for email notifications
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=127)
    public Map<String,Object> unsetPrefNewMailNotificationAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefNewMailNotificationAddress, "");
        return attrs;
    }

    /**
     * whether or not new mail notification is enabled
     *
     * @return zimbraPrefNewMailNotificationEnabled, or false if unset
     */
    @ZAttr(id=126)
    public boolean isPrefNewMailNotificationEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefNewMailNotificationEnabled, false, true);
    }

    /**
     * whether or not new mail notification is enabled
     *
     * @param zimbraPrefNewMailNotificationEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=126)
    public void setPrefNewMailNotificationEnabled(boolean zimbraPrefNewMailNotificationEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefNewMailNotificationEnabled, zimbraPrefNewMailNotificationEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not new mail notification is enabled
     *
     * @param zimbraPrefNewMailNotificationEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=126)
    public Map<String,Object> setPrefNewMailNotificationEnabled(boolean zimbraPrefNewMailNotificationEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefNewMailNotificationEnabled, zimbraPrefNewMailNotificationEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not new mail notification is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=126)
    public void unsetPrefNewMailNotificationEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefNewMailNotificationEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not new mail notification is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=126)
    public Map<String,Object> unsetPrefNewMailNotificationEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefNewMailNotificationEnabled, "");
        return attrs;
    }

    /**
     * whether or not the client opens a new msg/conv in a new window (via
     * dbl-click)
     *
     * @return zimbraPrefOpenMailInNewWindow, or false if unset
     */
    @ZAttr(id=500)
    public boolean isPrefOpenMailInNewWindow() {
        return getBooleanAttr(Provisioning.A_zimbraPrefOpenMailInNewWindow, false, true);
    }

    /**
     * whether or not the client opens a new msg/conv in a new window (via
     * dbl-click)
     *
     * @param zimbraPrefOpenMailInNewWindow new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=500)
    public void setPrefOpenMailInNewWindow(boolean zimbraPrefOpenMailInNewWindow) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOpenMailInNewWindow, zimbraPrefOpenMailInNewWindow ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not the client opens a new msg/conv in a new window (via
     * dbl-click)
     *
     * @param zimbraPrefOpenMailInNewWindow new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=500)
    public Map<String,Object> setPrefOpenMailInNewWindow(boolean zimbraPrefOpenMailInNewWindow, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOpenMailInNewWindow, zimbraPrefOpenMailInNewWindow ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not the client opens a new msg/conv in a new window (via
     * dbl-click)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=500)
    public void unsetPrefOpenMailInNewWindow() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOpenMailInNewWindow, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not the client opens a new msg/conv in a new window (via
     * dbl-click)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=500)
    public Map<String,Object> unsetPrefOpenMailInNewWindow(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOpenMailInNewWindow, "");
        return attrs;
    }

    /**
     * server remembers addresses to which notifications have been sent for
     * this interval, and does not send duplicate notifications in this
     * interval. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getPrefOutOfOfficeCacheDurationAsString to access value as a string.
     *
     * @see #getPrefOutOfOfficeCacheDurationAsString()
     *
     * @return zimbraPrefOutOfOfficeCacheDuration in millseconds, or 604800000 (7d)  if unset
     */
    @ZAttr(id=386)
    public long getPrefOutOfOfficeCacheDuration() {
        return getTimeInterval(Provisioning.A_zimbraPrefOutOfOfficeCacheDuration, 604800000L, true);
    }

    /**
     * server remembers addresses to which notifications have been sent for
     * this interval, and does not send duplicate notifications in this
     * interval. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraPrefOutOfOfficeCacheDuration, or "7d" if unset
     */
    @ZAttr(id=386)
    public String getPrefOutOfOfficeCacheDurationAsString() {
        return getAttr(Provisioning.A_zimbraPrefOutOfOfficeCacheDuration, "7d", true);
    }

    /**
     * server remembers addresses to which notifications have been sent for
     * this interval, and does not send duplicate notifications in this
     * interval. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraPrefOutOfOfficeCacheDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=386)
    public void setPrefOutOfOfficeCacheDuration(String zimbraPrefOutOfOfficeCacheDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeCacheDuration, zimbraPrefOutOfOfficeCacheDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * server remembers addresses to which notifications have been sent for
     * this interval, and does not send duplicate notifications in this
     * interval. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraPrefOutOfOfficeCacheDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=386)
    public Map<String,Object> setPrefOutOfOfficeCacheDuration(String zimbraPrefOutOfOfficeCacheDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeCacheDuration, zimbraPrefOutOfOfficeCacheDuration);
        return attrs;
    }

    /**
     * server remembers addresses to which notifications have been sent for
     * this interval, and does not send duplicate notifications in this
     * interval. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=386)
    public void unsetPrefOutOfOfficeCacheDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeCacheDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * server remembers addresses to which notifications have been sent for
     * this interval, and does not send duplicate notifications in this
     * interval. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=386)
    public Map<String,Object> unsetPrefOutOfOfficeCacheDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeCacheDuration, "");
        return attrs;
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @return zimbraPrefOutOfOfficeDirectAddress, or empty array if unset
     */
    @ZAttr(id=387)
    public String[] getPrefOutOfOfficeDirectAddress() {
        return getMultiAttr(Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, true, true);
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @param zimbraPrefOutOfOfficeDirectAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=387)
    public void setPrefOutOfOfficeDirectAddress(String[] zimbraPrefOutOfOfficeDirectAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, zimbraPrefOutOfOfficeDirectAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @param zimbraPrefOutOfOfficeDirectAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=387)
    public Map<String,Object> setPrefOutOfOfficeDirectAddress(String[] zimbraPrefOutOfOfficeDirectAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, zimbraPrefOutOfOfficeDirectAddress);
        return attrs;
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @param zimbraPrefOutOfOfficeDirectAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=387)
    public void addPrefOutOfOfficeDirectAddress(String zimbraPrefOutOfOfficeDirectAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, zimbraPrefOutOfOfficeDirectAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @param zimbraPrefOutOfOfficeDirectAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=387)
    public Map<String,Object> addPrefOutOfOfficeDirectAddress(String zimbraPrefOutOfOfficeDirectAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, zimbraPrefOutOfOfficeDirectAddress);
        return attrs;
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @param zimbraPrefOutOfOfficeDirectAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=387)
    public void removePrefOutOfOfficeDirectAddress(String zimbraPrefOutOfOfficeDirectAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, zimbraPrefOutOfOfficeDirectAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @param zimbraPrefOutOfOfficeDirectAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=387)
    public Map<String,Object> removePrefOutOfOfficeDirectAddress(String zimbraPrefOutOfOfficeDirectAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, zimbraPrefOutOfOfficeDirectAddress);
        return attrs;
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=387)
    public void unsetPrefOutOfOfficeDirectAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * per RFC 3834 no out of office notifications are sent if recipients
     * address is not directly specified in the To/CC headers - for this
     * check, we check to see if To/CC contained accounts address, aliases,
     * canonical address. But when external accounts are forwarded to Zimbra,
     * and you want notifications sent to messages that contain their
     * external address in To/Cc, add those address, then you can specify
     * those external addresses here.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=387)
    public Map<String,Object> unsetPrefOutOfOfficeDirectAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeDirectAddress, "");
        return attrs;
    }

    /**
     * out of office message to external senders
     *
     * @return zimbraPrefOutOfOfficeExternalReply, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1317)
    public String getPrefOutOfOfficeExternalReply() {
        return getAttr(Provisioning.A_zimbraPrefOutOfOfficeExternalReply, null, true);
    }

    /**
     * out of office message to external senders
     *
     * @param zimbraPrefOutOfOfficeExternalReply new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1317)
    public void setPrefOutOfOfficeExternalReply(String zimbraPrefOutOfOfficeExternalReply) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeExternalReply, zimbraPrefOutOfOfficeExternalReply);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office message to external senders
     *
     * @param zimbraPrefOutOfOfficeExternalReply new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1317)
    public Map<String,Object> setPrefOutOfOfficeExternalReply(String zimbraPrefOutOfOfficeExternalReply, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeExternalReply, zimbraPrefOutOfOfficeExternalReply);
        return attrs;
    }

    /**
     * out of office message to external senders
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1317)
    public void unsetPrefOutOfOfficeExternalReply() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeExternalReply, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office message to external senders
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1317)
    public Map<String,Object> unsetPrefOutOfOfficeExternalReply(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeExternalReply, "");
        return attrs;
    }

    /**
     * If TRUE, send zimbraPrefOutOfOfficeExternalReply to external senders.
     * External senders are specified by zimbraInternalSendersDomain and
     * zimbraPrefExternalSendersType.
     *
     * @return zimbraPrefOutOfOfficeExternalReplyEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1318)
    public boolean isPrefOutOfOfficeExternalReplyEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefOutOfOfficeExternalReplyEnabled, false, true);
    }

    /**
     * If TRUE, send zimbraPrefOutOfOfficeExternalReply to external senders.
     * External senders are specified by zimbraInternalSendersDomain and
     * zimbraPrefExternalSendersType.
     *
     * @param zimbraPrefOutOfOfficeExternalReplyEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1318)
    public void setPrefOutOfOfficeExternalReplyEnabled(boolean zimbraPrefOutOfOfficeExternalReplyEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeExternalReplyEnabled, zimbraPrefOutOfOfficeExternalReplyEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, send zimbraPrefOutOfOfficeExternalReply to external senders.
     * External senders are specified by zimbraInternalSendersDomain and
     * zimbraPrefExternalSendersType.
     *
     * @param zimbraPrefOutOfOfficeExternalReplyEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1318)
    public Map<String,Object> setPrefOutOfOfficeExternalReplyEnabled(boolean zimbraPrefOutOfOfficeExternalReplyEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeExternalReplyEnabled, zimbraPrefOutOfOfficeExternalReplyEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, send zimbraPrefOutOfOfficeExternalReply to external senders.
     * External senders are specified by zimbraInternalSendersDomain and
     * zimbraPrefExternalSendersType.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1318)
    public void unsetPrefOutOfOfficeExternalReplyEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeExternalReplyEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, send zimbraPrefOutOfOfficeExternalReply to external senders.
     * External senders are specified by zimbraInternalSendersDomain and
     * zimbraPrefExternalSendersType.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1318)
    public Map<String,Object> unsetPrefOutOfOfficeExternalReplyEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeExternalReplyEnabled, "");
        return attrs;
    }

    /**
     * free/busy status while out of office
     *
     * <p>Valid values: [BUSY, OUTOFOFFICE]
     *
     * @return zimbraPrefOutOfOfficeFreeBusyStatus, or null if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1334)
    public ZAttrProvisioning.PrefOutOfOfficeFreeBusyStatus getPrefOutOfOfficeFreeBusyStatus() {
        try { String v = getAttr(Provisioning.A_zimbraPrefOutOfOfficeFreeBusyStatus, true, true); return v == null ? null : ZAttrProvisioning.PrefOutOfOfficeFreeBusyStatus.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * free/busy status while out of office
     *
     * <p>Valid values: [BUSY, OUTOFOFFICE]
     *
     * @return zimbraPrefOutOfOfficeFreeBusyStatus, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1334)
    public String getPrefOutOfOfficeFreeBusyStatusAsString() {
        return getAttr(Provisioning.A_zimbraPrefOutOfOfficeFreeBusyStatus, null, true);
    }

    /**
     * free/busy status while out of office
     *
     * <p>Valid values: [BUSY, OUTOFOFFICE]
     *
     * @param zimbraPrefOutOfOfficeFreeBusyStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1334)
    public void setPrefOutOfOfficeFreeBusyStatus(ZAttrProvisioning.PrefOutOfOfficeFreeBusyStatus zimbraPrefOutOfOfficeFreeBusyStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFreeBusyStatus, zimbraPrefOutOfOfficeFreeBusyStatus.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * free/busy status while out of office
     *
     * <p>Valid values: [BUSY, OUTOFOFFICE]
     *
     * @param zimbraPrefOutOfOfficeFreeBusyStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1334)
    public Map<String,Object> setPrefOutOfOfficeFreeBusyStatus(ZAttrProvisioning.PrefOutOfOfficeFreeBusyStatus zimbraPrefOutOfOfficeFreeBusyStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFreeBusyStatus, zimbraPrefOutOfOfficeFreeBusyStatus.toString());
        return attrs;
    }

    /**
     * free/busy status while out of office
     *
     * <p>Valid values: [BUSY, OUTOFOFFICE]
     *
     * @param zimbraPrefOutOfOfficeFreeBusyStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1334)
    public void setPrefOutOfOfficeFreeBusyStatusAsString(String zimbraPrefOutOfOfficeFreeBusyStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFreeBusyStatus, zimbraPrefOutOfOfficeFreeBusyStatus);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * free/busy status while out of office
     *
     * <p>Valid values: [BUSY, OUTOFOFFICE]
     *
     * @param zimbraPrefOutOfOfficeFreeBusyStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1334)
    public Map<String,Object> setPrefOutOfOfficeFreeBusyStatusAsString(String zimbraPrefOutOfOfficeFreeBusyStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFreeBusyStatus, zimbraPrefOutOfOfficeFreeBusyStatus);
        return attrs;
    }

    /**
     * free/busy status while out of office
     *
     * <p>Valid values: [BUSY, OUTOFOFFICE]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1334)
    public void unsetPrefOutOfOfficeFreeBusyStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFreeBusyStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * free/busy status while out of office
     *
     * <p>Valid values: [BUSY, OUTOFOFFICE]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1334)
    public Map<String,Object> unsetPrefOutOfOfficeFreeBusyStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFreeBusyStatus, "");
        return attrs;
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is after this date
     *
     * <p>Use getPrefOutOfOfficeFromDateAsString to access value as a string.
     *
     * @see #getPrefOutOfOfficeFromDateAsString()
     *
     * @return zimbraPrefOutOfOfficeFromDate as Date, null if unset or unable to parse
     */
    @ZAttr(id=384)
    public Date getPrefOutOfOfficeFromDate() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraPrefOutOfOfficeFromDate, null, true);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is after this date
     *
     * @return zimbraPrefOutOfOfficeFromDate, or null if unset
     */
    @ZAttr(id=384)
    public String getPrefOutOfOfficeFromDateAsString() {
        return getAttr(Provisioning.A_zimbraPrefOutOfOfficeFromDate, null, true);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is after this date
     *
     * @param zimbraPrefOutOfOfficeFromDate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=384)
    public void setPrefOutOfOfficeFromDate(Date zimbraPrefOutOfOfficeFromDate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFromDate, zimbraPrefOutOfOfficeFromDate==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPrefOutOfOfficeFromDate));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is after this date
     *
     * @param zimbraPrefOutOfOfficeFromDate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=384)
    public Map<String,Object> setPrefOutOfOfficeFromDate(Date zimbraPrefOutOfOfficeFromDate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFromDate, zimbraPrefOutOfOfficeFromDate==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPrefOutOfOfficeFromDate));
        return attrs;
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is after this date
     *
     * @param zimbraPrefOutOfOfficeFromDate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=384)
    public void setPrefOutOfOfficeFromDateAsString(String zimbraPrefOutOfOfficeFromDate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFromDate, zimbraPrefOutOfOfficeFromDate);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is after this date
     *
     * @param zimbraPrefOutOfOfficeFromDate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=384)
    public Map<String,Object> setPrefOutOfOfficeFromDateAsString(String zimbraPrefOutOfOfficeFromDate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFromDate, zimbraPrefOutOfOfficeFromDate);
        return attrs;
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is after this date
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=384)
    public void unsetPrefOutOfOfficeFromDate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFromDate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is after this date
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=384)
    public Map<String,Object> unsetPrefOutOfOfficeFromDate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeFromDate, "");
        return attrs;
    }

    /**
     * out of office message
     *
     * @return zimbraPrefOutOfOfficeReply, or null if unset
     */
    @ZAttr(id=58)
    public String getPrefOutOfOfficeReply() {
        return getAttr(Provisioning.A_zimbraPrefOutOfOfficeReply, null, true);
    }

    /**
     * out of office message
     *
     * @param zimbraPrefOutOfOfficeReply new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=58)
    public void setPrefOutOfOfficeReply(String zimbraPrefOutOfOfficeReply) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeReply, zimbraPrefOutOfOfficeReply);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office message
     *
     * @param zimbraPrefOutOfOfficeReply new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=58)
    public Map<String,Object> setPrefOutOfOfficeReply(String zimbraPrefOutOfOfficeReply, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeReply, zimbraPrefOutOfOfficeReply);
        return attrs;
    }

    /**
     * out of office message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=58)
    public void unsetPrefOutOfOfficeReply() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeReply, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=58)
    public Map<String,Object> unsetPrefOutOfOfficeReply(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeReply, "");
        return attrs;
    }

    /**
     * whether or not out of office reply is enabled
     *
     * @return zimbraPrefOutOfOfficeReplyEnabled, or false if unset
     */
    @ZAttr(id=59)
    public boolean isPrefOutOfOfficeReplyEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefOutOfOfficeReplyEnabled, false, true);
    }

    /**
     * whether or not out of office reply is enabled
     *
     * @param zimbraPrefOutOfOfficeReplyEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=59)
    public void setPrefOutOfOfficeReplyEnabled(boolean zimbraPrefOutOfOfficeReplyEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeReplyEnabled, zimbraPrefOutOfOfficeReplyEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not out of office reply is enabled
     *
     * @param zimbraPrefOutOfOfficeReplyEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=59)
    public Map<String,Object> setPrefOutOfOfficeReplyEnabled(boolean zimbraPrefOutOfOfficeReplyEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeReplyEnabled, zimbraPrefOutOfOfficeReplyEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not out of office reply is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=59)
    public void unsetPrefOutOfOfficeReplyEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeReplyEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not out of office reply is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=59)
    public Map<String,Object> unsetPrefOutOfOfficeReplyEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeReplyEnabled, "");
        return attrs;
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @return zimbraPrefOutOfOfficeSpecificDomains, or empty array if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public String[] getPrefOutOfOfficeSpecificDomains() {
        return getMultiAttr(Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, true, true);
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @param zimbraPrefOutOfOfficeSpecificDomains new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public void setPrefOutOfOfficeSpecificDomains(String[] zimbraPrefOutOfOfficeSpecificDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, zimbraPrefOutOfOfficeSpecificDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @param zimbraPrefOutOfOfficeSpecificDomains new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public Map<String,Object> setPrefOutOfOfficeSpecificDomains(String[] zimbraPrefOutOfOfficeSpecificDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, zimbraPrefOutOfOfficeSpecificDomains);
        return attrs;
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @param zimbraPrefOutOfOfficeSpecificDomains new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public void addPrefOutOfOfficeSpecificDomains(String zimbraPrefOutOfOfficeSpecificDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, zimbraPrefOutOfOfficeSpecificDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @param zimbraPrefOutOfOfficeSpecificDomains new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public Map<String,Object> addPrefOutOfOfficeSpecificDomains(String zimbraPrefOutOfOfficeSpecificDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, zimbraPrefOutOfOfficeSpecificDomains);
        return attrs;
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @param zimbraPrefOutOfOfficeSpecificDomains existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public void removePrefOutOfOfficeSpecificDomains(String zimbraPrefOutOfOfficeSpecificDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, zimbraPrefOutOfOfficeSpecificDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @param zimbraPrefOutOfOfficeSpecificDomains existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public Map<String,Object> removePrefOutOfOfficeSpecificDomains(String zimbraPrefOutOfOfficeSpecificDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, zimbraPrefOutOfOfficeSpecificDomains);
        return attrs;
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public void unsetPrefOutOfOfficeSpecificDomains() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specific domains to which custom out of office message is to be sent
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2132)
    public Map<String,Object> unsetPrefOutOfOfficeSpecificDomains(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeSpecificDomains, "");
        return attrs;
    }

    /**
     * when user has OOO message enabled, when they login into web client,
     * whether to alert the user that the OOO message is turned on and
     * provide the ability to turn it off
     *
     * @return zimbraPrefOutOfOfficeStatusAlertOnLogin, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1245)
    public boolean isPrefOutOfOfficeStatusAlertOnLogin() {
        return getBooleanAttr(Provisioning.A_zimbraPrefOutOfOfficeStatusAlertOnLogin, true, true);
    }

    /**
     * when user has OOO message enabled, when they login into web client,
     * whether to alert the user that the OOO message is turned on and
     * provide the ability to turn it off
     *
     * @param zimbraPrefOutOfOfficeStatusAlertOnLogin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1245)
    public void setPrefOutOfOfficeStatusAlertOnLogin(boolean zimbraPrefOutOfOfficeStatusAlertOnLogin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeStatusAlertOnLogin, zimbraPrefOutOfOfficeStatusAlertOnLogin ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * when user has OOO message enabled, when they login into web client,
     * whether to alert the user that the OOO message is turned on and
     * provide the ability to turn it off
     *
     * @param zimbraPrefOutOfOfficeStatusAlertOnLogin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1245)
    public Map<String,Object> setPrefOutOfOfficeStatusAlertOnLogin(boolean zimbraPrefOutOfOfficeStatusAlertOnLogin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeStatusAlertOnLogin, zimbraPrefOutOfOfficeStatusAlertOnLogin ? TRUE : FALSE);
        return attrs;
    }

    /**
     * when user has OOO message enabled, when they login into web client,
     * whether to alert the user that the OOO message is turned on and
     * provide the ability to turn it off
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1245)
    public void unsetPrefOutOfOfficeStatusAlertOnLogin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeStatusAlertOnLogin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * when user has OOO message enabled, when they login into web client,
     * whether to alert the user that the OOO message is turned on and
     * provide the ability to turn it off
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1245)
    public Map<String,Object> unsetPrefOutOfOfficeStatusAlertOnLogin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeStatusAlertOnLogin, "");
        return attrs;
    }

    /**
     * If TRUE, OOO reply is not sent to external senders, when the user
     * enables OOO for the account
     *
     * @return zimbraPrefOutOfOfficeSuppressExternalReply, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1576)
    public boolean isPrefOutOfOfficeSuppressExternalReply() {
        return getBooleanAttr(Provisioning.A_zimbraPrefOutOfOfficeSuppressExternalReply, false, true);
    }

    /**
     * If TRUE, OOO reply is not sent to external senders, when the user
     * enables OOO for the account
     *
     * @param zimbraPrefOutOfOfficeSuppressExternalReply new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1576)
    public void setPrefOutOfOfficeSuppressExternalReply(boolean zimbraPrefOutOfOfficeSuppressExternalReply) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeSuppressExternalReply, zimbraPrefOutOfOfficeSuppressExternalReply ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, OOO reply is not sent to external senders, when the user
     * enables OOO for the account
     *
     * @param zimbraPrefOutOfOfficeSuppressExternalReply new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1576)
    public Map<String,Object> setPrefOutOfOfficeSuppressExternalReply(boolean zimbraPrefOutOfOfficeSuppressExternalReply, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeSuppressExternalReply, zimbraPrefOutOfOfficeSuppressExternalReply ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, OOO reply is not sent to external senders, when the user
     * enables OOO for the account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1576)
    public void unsetPrefOutOfOfficeSuppressExternalReply() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeSuppressExternalReply, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, OOO reply is not sent to external senders, when the user
     * enables OOO for the account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1576)
    public Map<String,Object> unsetPrefOutOfOfficeSuppressExternalReply(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeSuppressExternalReply, "");
        return attrs;
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is before this date
     *
     * <p>Use getPrefOutOfOfficeUntilDateAsString to access value as a string.
     *
     * @see #getPrefOutOfOfficeUntilDateAsString()
     *
     * @return zimbraPrefOutOfOfficeUntilDate as Date, null if unset or unable to parse
     */
    @ZAttr(id=385)
    public Date getPrefOutOfOfficeUntilDate() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraPrefOutOfOfficeUntilDate, null, true);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is before this date
     *
     * @return zimbraPrefOutOfOfficeUntilDate, or null if unset
     */
    @ZAttr(id=385)
    public String getPrefOutOfOfficeUntilDateAsString() {
        return getAttr(Provisioning.A_zimbraPrefOutOfOfficeUntilDate, null, true);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is before this date
     *
     * @param zimbraPrefOutOfOfficeUntilDate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=385)
    public void setPrefOutOfOfficeUntilDate(Date zimbraPrefOutOfOfficeUntilDate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeUntilDate, zimbraPrefOutOfOfficeUntilDate==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPrefOutOfOfficeUntilDate));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is before this date
     *
     * @param zimbraPrefOutOfOfficeUntilDate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=385)
    public Map<String,Object> setPrefOutOfOfficeUntilDate(Date zimbraPrefOutOfOfficeUntilDate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeUntilDate, zimbraPrefOutOfOfficeUntilDate==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPrefOutOfOfficeUntilDate));
        return attrs;
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is before this date
     *
     * @param zimbraPrefOutOfOfficeUntilDate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=385)
    public void setPrefOutOfOfficeUntilDateAsString(String zimbraPrefOutOfOfficeUntilDate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeUntilDate, zimbraPrefOutOfOfficeUntilDate);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is before this date
     *
     * @param zimbraPrefOutOfOfficeUntilDate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=385)
    public Map<String,Object> setPrefOutOfOfficeUntilDateAsString(String zimbraPrefOutOfOfficeUntilDate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeUntilDate, zimbraPrefOutOfOfficeUntilDate);
        return attrs;
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is before this date
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=385)
    public void unsetPrefOutOfOfficeUntilDate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeUntilDate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * out of office notifications (if enabled) are sent only if current date
     * is before this date
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=385)
    public Map<String,Object> unsetPrefOutOfOfficeUntilDate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefOutOfOfficeUntilDate, "");
        return attrs;
    }

    /**
     * RFC822 recovery email address for an account
     *
     * @return zimbraPrefPasswordRecoveryAddress, or null if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2135)
    public String getPrefPasswordRecoveryAddress() {
        return getAttr(Provisioning.A_zimbraPrefPasswordRecoveryAddress, null, true);
    }

    /**
     * RFC822 recovery email address for an account
     *
     * @param zimbraPrefPasswordRecoveryAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2135)
    public void setPrefPasswordRecoveryAddress(String zimbraPrefPasswordRecoveryAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddress, zimbraPrefPasswordRecoveryAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 recovery email address for an account
     *
     * @param zimbraPrefPasswordRecoveryAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2135)
    public Map<String,Object> setPrefPasswordRecoveryAddress(String zimbraPrefPasswordRecoveryAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddress, zimbraPrefPasswordRecoveryAddress);
        return attrs;
    }

    /**
     * RFC822 recovery email address for an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2135)
    public void unsetPrefPasswordRecoveryAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC822 recovery email address for an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2135)
    public Map<String,Object> unsetPrefPasswordRecoveryAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddress, "");
        return attrs;
    }

    /**
     * End-user recovery email address verification status
     *
     * <p>Valid values: [verified, pending]
     *
     * @return zimbraPrefPasswordRecoveryAddressStatus, or null if unset and/or has invalid value
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2136)
    public ZAttrProvisioning.PrefPasswordRecoveryAddressStatus getPrefPasswordRecoveryAddressStatus() {
        try { String v = getAttr(Provisioning.A_zimbraPrefPasswordRecoveryAddressStatus, true, true); return v == null ? null : ZAttrProvisioning.PrefPasswordRecoveryAddressStatus.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * End-user recovery email address verification status
     *
     * <p>Valid values: [verified, pending]
     *
     * @return zimbraPrefPasswordRecoveryAddressStatus, or null if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2136)
    public String getPrefPasswordRecoveryAddressStatusAsString() {
        return getAttr(Provisioning.A_zimbraPrefPasswordRecoveryAddressStatus, null, true);
    }

    /**
     * End-user recovery email address verification status
     *
     * <p>Valid values: [verified, pending]
     *
     * @param zimbraPrefPasswordRecoveryAddressStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2136)
    public void setPrefPasswordRecoveryAddressStatus(ZAttrProvisioning.PrefPasswordRecoveryAddressStatus zimbraPrefPasswordRecoveryAddressStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddressStatus, zimbraPrefPasswordRecoveryAddressStatus.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * End-user recovery email address verification status
     *
     * <p>Valid values: [verified, pending]
     *
     * @param zimbraPrefPasswordRecoveryAddressStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2136)
    public Map<String,Object> setPrefPasswordRecoveryAddressStatus(ZAttrProvisioning.PrefPasswordRecoveryAddressStatus zimbraPrefPasswordRecoveryAddressStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddressStatus, zimbraPrefPasswordRecoveryAddressStatus.toString());
        return attrs;
    }

    /**
     * End-user recovery email address verification status
     *
     * <p>Valid values: [verified, pending]
     *
     * @param zimbraPrefPasswordRecoveryAddressStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2136)
    public void setPrefPasswordRecoveryAddressStatusAsString(String zimbraPrefPasswordRecoveryAddressStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddressStatus, zimbraPrefPasswordRecoveryAddressStatus);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * End-user recovery email address verification status
     *
     * <p>Valid values: [verified, pending]
     *
     * @param zimbraPrefPasswordRecoveryAddressStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2136)
    public Map<String,Object> setPrefPasswordRecoveryAddressStatusAsString(String zimbraPrefPasswordRecoveryAddressStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddressStatus, zimbraPrefPasswordRecoveryAddressStatus);
        return attrs;
    }

    /**
     * End-user recovery email address verification status
     *
     * <p>Valid values: [verified, pending]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2136)
    public void unsetPrefPasswordRecoveryAddressStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddressStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * End-user recovery email address verification status
     *
     * <p>Valid values: [verified, pending]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2136)
    public Map<String,Object> unsetPrefPasswordRecoveryAddressStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPasswordRecoveryAddressStatus, "");
        return attrs;
    }

    /**
     * When messages are accessed via POP3: - keep: Leave DELE&#039;ed
     * messages in Inbox. - read: Mark RETR&#039;ed messages as read, and
     * leave DELE&#039;ed messages in Inbox. - trash: Move DELE&#039;ed
     * messages to Trash, and mark them as read. - delete: Hard-delete
     * DELE&#039;ed messages. This is the straightforward POP3
     * implementation.
     *
     * <p>Valid values: [keep, read, trash, delete]
     *
     * @return zimbraPrefPop3DeleteOption, or ZAttrProvisioning.PrefPop3DeleteOption.delete if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1165)
    public ZAttrProvisioning.PrefPop3DeleteOption getPrefPop3DeleteOption() {
        try { String v = getAttr(Provisioning.A_zimbraPrefPop3DeleteOption, true, true); return v == null ? ZAttrProvisioning.PrefPop3DeleteOption.delete : ZAttrProvisioning.PrefPop3DeleteOption.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefPop3DeleteOption.delete; }
    }

    /**
     * When messages are accessed via POP3: - keep: Leave DELE&#039;ed
     * messages in Inbox. - read: Mark RETR&#039;ed messages as read, and
     * leave DELE&#039;ed messages in Inbox. - trash: Move DELE&#039;ed
     * messages to Trash, and mark them as read. - delete: Hard-delete
     * DELE&#039;ed messages. This is the straightforward POP3
     * implementation.
     *
     * <p>Valid values: [keep, read, trash, delete]
     *
     * @return zimbraPrefPop3DeleteOption, or "delete" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1165)
    public String getPrefPop3DeleteOptionAsString() {
        return getAttr(Provisioning.A_zimbraPrefPop3DeleteOption, "delete", true);
    }

    /**
     * When messages are accessed via POP3: - keep: Leave DELE&#039;ed
     * messages in Inbox. - read: Mark RETR&#039;ed messages as read, and
     * leave DELE&#039;ed messages in Inbox. - trash: Move DELE&#039;ed
     * messages to Trash, and mark them as read. - delete: Hard-delete
     * DELE&#039;ed messages. This is the straightforward POP3
     * implementation.
     *
     * <p>Valid values: [keep, read, trash, delete]
     *
     * @param zimbraPrefPop3DeleteOption new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1165)
    public void setPrefPop3DeleteOption(ZAttrProvisioning.PrefPop3DeleteOption zimbraPrefPop3DeleteOption) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DeleteOption, zimbraPrefPop3DeleteOption.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When messages are accessed via POP3: - keep: Leave DELE&#039;ed
     * messages in Inbox. - read: Mark RETR&#039;ed messages as read, and
     * leave DELE&#039;ed messages in Inbox. - trash: Move DELE&#039;ed
     * messages to Trash, and mark them as read. - delete: Hard-delete
     * DELE&#039;ed messages. This is the straightforward POP3
     * implementation.
     *
     * <p>Valid values: [keep, read, trash, delete]
     *
     * @param zimbraPrefPop3DeleteOption new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1165)
    public Map<String,Object> setPrefPop3DeleteOption(ZAttrProvisioning.PrefPop3DeleteOption zimbraPrefPop3DeleteOption, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DeleteOption, zimbraPrefPop3DeleteOption.toString());
        return attrs;
    }

    /**
     * When messages are accessed via POP3: - keep: Leave DELE&#039;ed
     * messages in Inbox. - read: Mark RETR&#039;ed messages as read, and
     * leave DELE&#039;ed messages in Inbox. - trash: Move DELE&#039;ed
     * messages to Trash, and mark them as read. - delete: Hard-delete
     * DELE&#039;ed messages. This is the straightforward POP3
     * implementation.
     *
     * <p>Valid values: [keep, read, trash, delete]
     *
     * @param zimbraPrefPop3DeleteOption new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1165)
    public void setPrefPop3DeleteOptionAsString(String zimbraPrefPop3DeleteOption) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DeleteOption, zimbraPrefPop3DeleteOption);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When messages are accessed via POP3: - keep: Leave DELE&#039;ed
     * messages in Inbox. - read: Mark RETR&#039;ed messages as read, and
     * leave DELE&#039;ed messages in Inbox. - trash: Move DELE&#039;ed
     * messages to Trash, and mark them as read. - delete: Hard-delete
     * DELE&#039;ed messages. This is the straightforward POP3
     * implementation.
     *
     * <p>Valid values: [keep, read, trash, delete]
     *
     * @param zimbraPrefPop3DeleteOption new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1165)
    public Map<String,Object> setPrefPop3DeleteOptionAsString(String zimbraPrefPop3DeleteOption, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DeleteOption, zimbraPrefPop3DeleteOption);
        return attrs;
    }

    /**
     * When messages are accessed via POP3: - keep: Leave DELE&#039;ed
     * messages in Inbox. - read: Mark RETR&#039;ed messages as read, and
     * leave DELE&#039;ed messages in Inbox. - trash: Move DELE&#039;ed
     * messages to Trash, and mark them as read. - delete: Hard-delete
     * DELE&#039;ed messages. This is the straightforward POP3
     * implementation.
     *
     * <p>Valid values: [keep, read, trash, delete]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1165)
    public void unsetPrefPop3DeleteOption() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DeleteOption, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When messages are accessed via POP3: - keep: Leave DELE&#039;ed
     * messages in Inbox. - read: Mark RETR&#039;ed messages as read, and
     * leave DELE&#039;ed messages in Inbox. - trash: Move DELE&#039;ed
     * messages to Trash, and mark them as read. - delete: Hard-delete
     * DELE&#039;ed messages. This is the straightforward POP3
     * implementation.
     *
     * <p>Valid values: [keep, read, trash, delete]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1165)
    public Map<String,Object> unsetPrefPop3DeleteOption(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DeleteOption, "");
        return attrs;
    }

    /**
     * download pop3 messages since
     *
     * <p>Use getPrefPop3DownloadSinceAsString to access value as a string.
     *
     * @see #getPrefPop3DownloadSinceAsString()
     *
     * @return zimbraPrefPop3DownloadSince as Date, null if unset or unable to parse
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=653)
    public Date getPrefPop3DownloadSince() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraPrefPop3DownloadSince, null, true);
    }

    /**
     * download pop3 messages since
     *
     * @return zimbraPrefPop3DownloadSince, or null if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=653)
    public String getPrefPop3DownloadSinceAsString() {
        return getAttr(Provisioning.A_zimbraPrefPop3DownloadSince, null, true);
    }

    /**
     * download pop3 messages since
     *
     * @param zimbraPrefPop3DownloadSince new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=653)
    public void setPrefPop3DownloadSince(Date zimbraPrefPop3DownloadSince) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DownloadSince, zimbraPrefPop3DownloadSince==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPrefPop3DownloadSince));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * download pop3 messages since
     *
     * @param zimbraPrefPop3DownloadSince new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=653)
    public Map<String,Object> setPrefPop3DownloadSince(Date zimbraPrefPop3DownloadSince, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DownloadSince, zimbraPrefPop3DownloadSince==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraPrefPop3DownloadSince));
        return attrs;
    }

    /**
     * download pop3 messages since
     *
     * @param zimbraPrefPop3DownloadSince new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=653)
    public void setPrefPop3DownloadSinceAsString(String zimbraPrefPop3DownloadSince) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DownloadSince, zimbraPrefPop3DownloadSince);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * download pop3 messages since
     *
     * @param zimbraPrefPop3DownloadSince new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=653)
    public Map<String,Object> setPrefPop3DownloadSinceAsString(String zimbraPrefPop3DownloadSince, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DownloadSince, zimbraPrefPop3DownloadSince);
        return attrs;
    }

    /**
     * download pop3 messages since
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=653)
    public void unsetPrefPop3DownloadSince() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DownloadSince, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * download pop3 messages since
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=653)
    public Map<String,Object> unsetPrefPop3DownloadSince(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3DownloadSince, "");
        return attrs;
    }

    /**
     * whether end user choose to use POP3 feature. If it is set to TRUE,
     * POP3 feature is available only when zimbraPop3Enabled is TRUE.
     *
     * @return zimbraPrefPop3Enabled, or true if unset
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3087)
    public boolean isPrefPop3Enabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefPop3Enabled, true, true);
    }

    /**
     * whether end user choose to use POP3 feature. If it is set to TRUE,
     * POP3 feature is available only when zimbraPop3Enabled is TRUE.
     *
     * @param zimbraPrefPop3Enabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3087)
    public void setPrefPop3Enabled(boolean zimbraPrefPop3Enabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3Enabled, zimbraPrefPop3Enabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end user choose to use POP3 feature. If it is set to TRUE,
     * POP3 feature is available only when zimbraPop3Enabled is TRUE.
     *
     * @param zimbraPrefPop3Enabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3087)
    public Map<String,Object> setPrefPop3Enabled(boolean zimbraPrefPop3Enabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3Enabled, zimbraPrefPop3Enabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether end user choose to use POP3 feature. If it is set to TRUE,
     * POP3 feature is available only when zimbraPop3Enabled is TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3087)
    public void unsetPrefPop3Enabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3Enabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end user choose to use POP3 feature. If it is set to TRUE,
     * POP3 feature is available only when zimbraPop3Enabled is TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 9.0.0
     */
    @ZAttr(id=3087)
    public Map<String,Object> unsetPrefPop3Enabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3Enabled, "");
        return attrs;
    }

    /**
     * whether or not to include spam messages in POP3 access
     *
     * @return zimbraPrefPop3IncludeSpam, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1166)
    public boolean isPrefPop3IncludeSpam() {
        return getBooleanAttr(Provisioning.A_zimbraPrefPop3IncludeSpam, false, true);
    }

    /**
     * whether or not to include spam messages in POP3 access
     *
     * @param zimbraPrefPop3IncludeSpam new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1166)
    public void setPrefPop3IncludeSpam(boolean zimbraPrefPop3IncludeSpam) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3IncludeSpam, zimbraPrefPop3IncludeSpam ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to include spam messages in POP3 access
     *
     * @param zimbraPrefPop3IncludeSpam new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1166)
    public Map<String,Object> setPrefPop3IncludeSpam(boolean zimbraPrefPop3IncludeSpam, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3IncludeSpam, zimbraPrefPop3IncludeSpam ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to include spam messages in POP3 access
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1166)
    public void unsetPrefPop3IncludeSpam() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3IncludeSpam, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to include spam messages in POP3 access
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1166)
    public Map<String,Object> unsetPrefPop3IncludeSpam(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefPop3IncludeSpam, "");
        return attrs;
    }

    /**
     * quick command encoded by the client
     *
     * @return zimbraPrefQuickCommand, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public String[] getPrefQuickCommand() {
        return getMultiAttr(Provisioning.A_zimbraPrefQuickCommand, true, true);
    }

    /**
     * quick command encoded by the client
     *
     * @param zimbraPrefQuickCommand new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public void setPrefQuickCommand(String[] zimbraPrefQuickCommand) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefQuickCommand, zimbraPrefQuickCommand);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * quick command encoded by the client
     *
     * @param zimbraPrefQuickCommand new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public Map<String,Object> setPrefQuickCommand(String[] zimbraPrefQuickCommand, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefQuickCommand, zimbraPrefQuickCommand);
        return attrs;
    }

    /**
     * quick command encoded by the client
     *
     * @param zimbraPrefQuickCommand new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public void addPrefQuickCommand(String zimbraPrefQuickCommand) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefQuickCommand, zimbraPrefQuickCommand);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * quick command encoded by the client
     *
     * @param zimbraPrefQuickCommand new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public Map<String,Object> addPrefQuickCommand(String zimbraPrefQuickCommand, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefQuickCommand, zimbraPrefQuickCommand);
        return attrs;
    }

    /**
     * quick command encoded by the client
     *
     * @param zimbraPrefQuickCommand existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public void removePrefQuickCommand(String zimbraPrefQuickCommand) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefQuickCommand, zimbraPrefQuickCommand);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * quick command encoded by the client
     *
     * @param zimbraPrefQuickCommand existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public Map<String,Object> removePrefQuickCommand(String zimbraPrefQuickCommand, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefQuickCommand, zimbraPrefQuickCommand);
        return attrs;
    }

    /**
     * quick command encoded by the client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public void unsetPrefQuickCommand() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefQuickCommand, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * quick command encoded by the client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1211)
    public Map<String,Object> unsetPrefQuickCommand(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefQuickCommand, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.8. Deprecated per bug 46988. This feature was
     * never fully implemented.. Orig desc: address to put in reply-to header
     * of read receipt messages, if it is not set, then the compose
     * identities primary email address is used.
     *
     * @return zimbraPrefReadReceiptsToAddress, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=823)
    public String getPrefReadReceiptsToAddress() {
        return getAttr(Provisioning.A_zimbraPrefReadReceiptsToAddress, null, true);
    }

    /**
     * Deprecated since: 6.0.8. Deprecated per bug 46988. This feature was
     * never fully implemented.. Orig desc: address to put in reply-to header
     * of read receipt messages, if it is not set, then the compose
     * identities primary email address is used.
     *
     * @param zimbraPrefReadReceiptsToAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=823)
    public void setPrefReadReceiptsToAddress(String zimbraPrefReadReceiptsToAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadReceiptsToAddress, zimbraPrefReadReceiptsToAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.8. Deprecated per bug 46988. This feature was
     * never fully implemented.. Orig desc: address to put in reply-to header
     * of read receipt messages, if it is not set, then the compose
     * identities primary email address is used.
     *
     * @param zimbraPrefReadReceiptsToAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=823)
    public Map<String,Object> setPrefReadReceiptsToAddress(String zimbraPrefReadReceiptsToAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadReceiptsToAddress, zimbraPrefReadReceiptsToAddress);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.8. Deprecated per bug 46988. This feature was
     * never fully implemented.. Orig desc: address to put in reply-to header
     * of read receipt messages, if it is not set, then the compose
     * identities primary email address is used.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=823)
    public void unsetPrefReadReceiptsToAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadReceiptsToAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.8. Deprecated per bug 46988. This feature was
     * never fully implemented.. Orig desc: address to put in reply-to header
     * of read receipt messages, if it is not set, then the compose
     * identities primary email address is used.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=823)
    public Map<String,Object> unsetPrefReadReceiptsToAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadReceiptsToAddress, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor of
     * zimbraPrefReadingPaneLocation and zimbraPrefConvReadingPaneLocation.
     * Orig desc: whether reading pane is shown by default
     *
     * @return zimbraPrefReadingPaneEnabled, or true if unset
     */
    @ZAttr(id=394)
    public boolean isPrefReadingPaneEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefReadingPaneEnabled, true, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor of
     * zimbraPrefReadingPaneLocation and zimbraPrefConvReadingPaneLocation.
     * Orig desc: whether reading pane is shown by default
     *
     * @param zimbraPrefReadingPaneEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=394)
    public void setPrefReadingPaneEnabled(boolean zimbraPrefReadingPaneEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneEnabled, zimbraPrefReadingPaneEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor of
     * zimbraPrefReadingPaneLocation and zimbraPrefConvReadingPaneLocation.
     * Orig desc: whether reading pane is shown by default
     *
     * @param zimbraPrefReadingPaneEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=394)
    public Map<String,Object> setPrefReadingPaneEnabled(boolean zimbraPrefReadingPaneEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneEnabled, zimbraPrefReadingPaneEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor of
     * zimbraPrefReadingPaneLocation and zimbraPrefConvReadingPaneLocation.
     * Orig desc: whether reading pane is shown by default
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=394)
    public void unsetPrefReadingPaneEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor of
     * zimbraPrefReadingPaneLocation and zimbraPrefConvReadingPaneLocation.
     * Orig desc: whether reading pane is shown by default
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=394)
    public Map<String,Object> unsetPrefReadingPaneEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneEnabled, "");
        return attrs;
    }

    /**
     * where the message reading pane is displayed in list views
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @return zimbraPrefReadingPaneLocation, or ZAttrProvisioning.PrefReadingPaneLocation.right if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=804)
    public ZAttrProvisioning.PrefReadingPaneLocation getPrefReadingPaneLocation() {
        try { String v = getAttr(Provisioning.A_zimbraPrefReadingPaneLocation, true, true); return v == null ? ZAttrProvisioning.PrefReadingPaneLocation.right : ZAttrProvisioning.PrefReadingPaneLocation.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefReadingPaneLocation.right; }
    }

    /**
     * where the message reading pane is displayed in list views
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @return zimbraPrefReadingPaneLocation, or "right" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=804)
    public String getPrefReadingPaneLocationAsString() {
        return getAttr(Provisioning.A_zimbraPrefReadingPaneLocation, "right", true);
    }

    /**
     * where the message reading pane is displayed in list views
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefReadingPaneLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=804)
    public void setPrefReadingPaneLocation(ZAttrProvisioning.PrefReadingPaneLocation zimbraPrefReadingPaneLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneLocation, zimbraPrefReadingPaneLocation.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the message reading pane is displayed in list views
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefReadingPaneLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=804)
    public Map<String,Object> setPrefReadingPaneLocation(ZAttrProvisioning.PrefReadingPaneLocation zimbraPrefReadingPaneLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneLocation, zimbraPrefReadingPaneLocation.toString());
        return attrs;
    }

    /**
     * where the message reading pane is displayed in list views
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefReadingPaneLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=804)
    public void setPrefReadingPaneLocationAsString(String zimbraPrefReadingPaneLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneLocation, zimbraPrefReadingPaneLocation);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the message reading pane is displayed in list views
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefReadingPaneLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=804)
    public Map<String,Object> setPrefReadingPaneLocationAsString(String zimbraPrefReadingPaneLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneLocation, zimbraPrefReadingPaneLocation);
        return attrs;
    }

    /**
     * where the message reading pane is displayed in list views
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=804)
    public void unsetPrefReadingPaneLocation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneLocation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the message reading pane is displayed in list views
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=804)
    public Map<String,Object> unsetPrefReadingPaneLocation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReadingPaneLocation, "");
        return attrs;
    }

    /**
     * what part of the original message to include during replies
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeNone, includeSmart, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeSmartWithPrefix, includeSmartAndHeaders, includeSmartAndHeadersWithPrefix, includeBodyOnly]
     *
     * @return zimbraPrefReplyIncludeOriginalText, or ZAttrProvisioning.PrefReplyIncludeOriginalText.includeBody if unset and/or has invalid value
     */
    @ZAttr(id=133)
    public ZAttrProvisioning.PrefReplyIncludeOriginalText getPrefReplyIncludeOriginalText() {
        try { String v = getAttr(Provisioning.A_zimbraPrefReplyIncludeOriginalText, true, true); return v == null ? ZAttrProvisioning.PrefReplyIncludeOriginalText.includeBody : ZAttrProvisioning.PrefReplyIncludeOriginalText.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefReplyIncludeOriginalText.includeBody; }
    }

    /**
     * what part of the original message to include during replies
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeNone, includeSmart, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeSmartWithPrefix, includeSmartAndHeaders, includeSmartAndHeadersWithPrefix, includeBodyOnly]
     *
     * @return zimbraPrefReplyIncludeOriginalText, or "includeBody" if unset
     */
    @ZAttr(id=133)
    public String getPrefReplyIncludeOriginalTextAsString() {
        return getAttr(Provisioning.A_zimbraPrefReplyIncludeOriginalText, "includeBody", true);
    }

    /**
     * what part of the original message to include during replies
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeNone, includeSmart, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeSmartWithPrefix, includeSmartAndHeaders, includeSmartAndHeadersWithPrefix, includeBodyOnly]
     *
     * @param zimbraPrefReplyIncludeOriginalText new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=133)
    public void setPrefReplyIncludeOriginalText(ZAttrProvisioning.PrefReplyIncludeOriginalText zimbraPrefReplyIncludeOriginalText) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyIncludeOriginalText, zimbraPrefReplyIncludeOriginalText.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what part of the original message to include during replies
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeNone, includeSmart, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeSmartWithPrefix, includeSmartAndHeaders, includeSmartAndHeadersWithPrefix, includeBodyOnly]
     *
     * @param zimbraPrefReplyIncludeOriginalText new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=133)
    public Map<String,Object> setPrefReplyIncludeOriginalText(ZAttrProvisioning.PrefReplyIncludeOriginalText zimbraPrefReplyIncludeOriginalText, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyIncludeOriginalText, zimbraPrefReplyIncludeOriginalText.toString());
        return attrs;
    }

    /**
     * what part of the original message to include during replies
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeNone, includeSmart, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeSmartWithPrefix, includeSmartAndHeaders, includeSmartAndHeadersWithPrefix, includeBodyOnly]
     *
     * @param zimbraPrefReplyIncludeOriginalText new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=133)
    public void setPrefReplyIncludeOriginalTextAsString(String zimbraPrefReplyIncludeOriginalText) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyIncludeOriginalText, zimbraPrefReplyIncludeOriginalText);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what part of the original message to include during replies
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeNone, includeSmart, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeSmartWithPrefix, includeSmartAndHeaders, includeSmartAndHeadersWithPrefix, includeBodyOnly]
     *
     * @param zimbraPrefReplyIncludeOriginalText new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=133)
    public Map<String,Object> setPrefReplyIncludeOriginalTextAsString(String zimbraPrefReplyIncludeOriginalText, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyIncludeOriginalText, zimbraPrefReplyIncludeOriginalText);
        return attrs;
    }

    /**
     * what part of the original message to include during replies
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeNone, includeSmart, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeSmartWithPrefix, includeSmartAndHeaders, includeSmartAndHeadersWithPrefix, includeBodyOnly]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=133)
    public void unsetPrefReplyIncludeOriginalText() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyIncludeOriginalText, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * what part of the original message to include during replies
     * (deprecatedSince 5.0 in identity). The value includeBody has been
     * deprecated since 6.0.6, use includeBodyAndHeaders instead.
     *
     * <p>Valid values: [includeAsAttachment, includeBody, includeBodyWithPrefix, includeNone, includeSmart, includeBodyAndHeadersWithPrefix, includeBodyAndHeaders, includeSmartWithPrefix, includeSmartAndHeaders, includeSmartAndHeadersWithPrefix, includeBodyOnly]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=133)
    public Map<String,Object> unsetPrefReplyIncludeOriginalText(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyIncludeOriginalText, "");
        return attrs;
    }

    /**
     * address to put in reply-to header
     *
     * @return zimbraPrefReplyToAddress, or null if unset
     */
    @ZAttr(id=60)
    public String getPrefReplyToAddress() {
        return getAttr(Provisioning.A_zimbraPrefReplyToAddress, null, true);
    }

    /**
     * address to put in reply-to header
     *
     * @param zimbraPrefReplyToAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=60)
    public void setPrefReplyToAddress(String zimbraPrefReplyToAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToAddress, zimbraPrefReplyToAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * address to put in reply-to header
     *
     * @param zimbraPrefReplyToAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=60)
    public Map<String,Object> setPrefReplyToAddress(String zimbraPrefReplyToAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToAddress, zimbraPrefReplyToAddress);
        return attrs;
    }

    /**
     * address to put in reply-to header
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=60)
    public void unsetPrefReplyToAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * address to put in reply-to header
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=60)
    public Map<String,Object> unsetPrefReplyToAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToAddress, "");
        return attrs;
    }

    /**
     * personal part of email address put in reply-to header
     *
     * @return zimbraPrefReplyToDisplay, or null if unset
     */
    @ZAttr(id=404)
    public String getPrefReplyToDisplay() {
        return getAttr(Provisioning.A_zimbraPrefReplyToDisplay, null, true);
    }

    /**
     * personal part of email address put in reply-to header
     *
     * @param zimbraPrefReplyToDisplay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=404)
    public void setPrefReplyToDisplay(String zimbraPrefReplyToDisplay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToDisplay, zimbraPrefReplyToDisplay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * personal part of email address put in reply-to header
     *
     * @param zimbraPrefReplyToDisplay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=404)
    public Map<String,Object> setPrefReplyToDisplay(String zimbraPrefReplyToDisplay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToDisplay, zimbraPrefReplyToDisplay);
        return attrs;
    }

    /**
     * personal part of email address put in reply-to header
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=404)
    public void unsetPrefReplyToDisplay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToDisplay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * personal part of email address put in reply-to header
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=404)
    public Map<String,Object> unsetPrefReplyToDisplay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToDisplay, "");
        return attrs;
    }

    /**
     * TRUE if we should set a reply-to header
     *
     * @return zimbraPrefReplyToEnabled, or false if unset
     */
    @ZAttr(id=405)
    public boolean isPrefReplyToEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefReplyToEnabled, false, true);
    }

    /**
     * TRUE if we should set a reply-to header
     *
     * @param zimbraPrefReplyToEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=405)
    public void setPrefReplyToEnabled(boolean zimbraPrefReplyToEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToEnabled, zimbraPrefReplyToEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * TRUE if we should set a reply-to header
     *
     * @param zimbraPrefReplyToEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=405)
    public Map<String,Object> setPrefReplyToEnabled(boolean zimbraPrefReplyToEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToEnabled, zimbraPrefReplyToEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * TRUE if we should set a reply-to header
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=405)
    public void unsetPrefReplyToEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * TRUE if we should set a reply-to header
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=405)
    public Map<String,Object> unsetPrefReplyToEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefReplyToEnabled, "");
        return attrs;
    }

    /**
     * whether or not to save outgoing mail (deprecatedSince 5.0 in identity)
     *
     * @return zimbraPrefSaveToSent, or true if unset
     */
    @ZAttr(id=22)
    public boolean isPrefSaveToSent() {
        return getBooleanAttr(Provisioning.A_zimbraPrefSaveToSent, true, true);
    }

    /**
     * whether or not to save outgoing mail (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefSaveToSent new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=22)
    public void setPrefSaveToSent(boolean zimbraPrefSaveToSent) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSaveToSent, zimbraPrefSaveToSent ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to save outgoing mail (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefSaveToSent new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=22)
    public Map<String,Object> setPrefSaveToSent(boolean zimbraPrefSaveToSent, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSaveToSent, zimbraPrefSaveToSent ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to save outgoing mail (deprecatedSince 5.0 in identity)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=22)
    public void unsetPrefSaveToSent() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSaveToSent, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to save outgoing mail (deprecatedSince 5.0 in identity)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=22)
    public Map<String,Object> unsetPrefSaveToSent(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSaveToSent, "");
        return attrs;
    }

    /**
     * whether or not search tree is expanded
     *
     * @return zimbraPrefSearchTreeOpen, or true if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=634)
    public boolean isPrefSearchTreeOpen() {
        return getBooleanAttr(Provisioning.A_zimbraPrefSearchTreeOpen, true, true);
    }

    /**
     * whether or not search tree is expanded
     *
     * @param zimbraPrefSearchTreeOpen new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=634)
    public void setPrefSearchTreeOpen(boolean zimbraPrefSearchTreeOpen) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSearchTreeOpen, zimbraPrefSearchTreeOpen ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not search tree is expanded
     *
     * @param zimbraPrefSearchTreeOpen new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=634)
    public Map<String,Object> setPrefSearchTreeOpen(boolean zimbraPrefSearchTreeOpen, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSearchTreeOpen, zimbraPrefSearchTreeOpen ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not search tree is expanded
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=634)
    public void unsetPrefSearchTreeOpen() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSearchTreeOpen, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not search tree is expanded
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=634)
    public Map<String,Object> unsetPrefSearchTreeOpen(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSearchTreeOpen, "");
        return attrs;
    }

    /**
     * Retention period of messages in the Sent folder. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPrefSentLifetimeAsString to access value as a string.
     *
     * @see #getPrefSentLifetimeAsString()
     *
     * @return zimbraPrefSentLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=539)
    public long getPrefSentLifetime() {
        return getTimeInterval(Provisioning.A_zimbraPrefSentLifetime, 0L, true);
    }

    /**
     * Retention period of messages in the Sent folder. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPrefSentLifetime, or "0" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=539)
    public String getPrefSentLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraPrefSentLifetime, "0", true);
    }

    /**
     * Retention period of messages in the Sent folder. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefSentLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=539)
    public void setPrefSentLifetime(String zimbraPrefSentLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSentLifetime, zimbraPrefSentLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Sent folder. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefSentLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=539)
    public Map<String,Object> setPrefSentLifetime(String zimbraPrefSentLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSentLifetime, zimbraPrefSentLifetime);
        return attrs;
    }

    /**
     * Retention period of messages in the Sent folder. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=539)
    public void unsetPrefSentLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSentLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Sent folder. 0 means that all
     * messages will be retained. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=539)
    public Map<String,Object> unsetPrefSentLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSentLifetime, "");
        return attrs;
    }

    /**
     * name of folder to save sent mail in (deprecatedSince 5.0 in identity)
     *
     * @return zimbraPrefSentMailFolder, or "sent" if unset
     */
    @ZAttr(id=103)
    public String getPrefSentMailFolder() {
        return getAttr(Provisioning.A_zimbraPrefSentMailFolder, "sent", true);
    }

    /**
     * name of folder to save sent mail in (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefSentMailFolder new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=103)
    public void setPrefSentMailFolder(String zimbraPrefSentMailFolder) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSentMailFolder, zimbraPrefSentMailFolder);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name of folder to save sent mail in (deprecatedSince 5.0 in identity)
     *
     * @param zimbraPrefSentMailFolder new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=103)
    public Map<String,Object> setPrefSentMailFolder(String zimbraPrefSentMailFolder, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSentMailFolder, zimbraPrefSentMailFolder);
        return attrs;
    }

    /**
     * name of folder to save sent mail in (deprecatedSince 5.0 in identity)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=103)
    public void unsetPrefSentMailFolder() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSentMailFolder, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name of folder to save sent mail in (deprecatedSince 5.0 in identity)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=103)
    public Map<String,Object> unsetPrefSentMailFolder(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSentMailFolder, "");
        return attrs;
    }

    /**
     * whether end-user wants auto-complete from shared address books.
     *
     * @return zimbraPrefSharedAddrBookAutoCompleteEnabled, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=759)
    public boolean isPrefSharedAddrBookAutoCompleteEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefSharedAddrBookAutoCompleteEnabled, false, true);
    }

    /**
     * whether end-user wants auto-complete from shared address books.
     *
     * @param zimbraPrefSharedAddrBookAutoCompleteEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=759)
    public void setPrefSharedAddrBookAutoCompleteEnabled(boolean zimbraPrefSharedAddrBookAutoCompleteEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSharedAddrBookAutoCompleteEnabled, zimbraPrefSharedAddrBookAutoCompleteEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end-user wants auto-complete from shared address books.
     *
     * @param zimbraPrefSharedAddrBookAutoCompleteEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=759)
    public Map<String,Object> setPrefSharedAddrBookAutoCompleteEnabled(boolean zimbraPrefSharedAddrBookAutoCompleteEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSharedAddrBookAutoCompleteEnabled, zimbraPrefSharedAddrBookAutoCompleteEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether end-user wants auto-complete from shared address books.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=759)
    public void unsetPrefSharedAddrBookAutoCompleteEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSharedAddrBookAutoCompleteEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether end-user wants auto-complete from shared address books.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=759)
    public Map<String,Object> unsetPrefSharedAddrBookAutoCompleteEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSharedAddrBookAutoCompleteEnabled, "");
        return attrs;
    }

    /**
     * show just the display name of email addresses in the message header
     * area and compose pane
     *
     * @return zimbraPrefShortEmailAddress, or false if unset
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1173)
    public boolean isPrefShortEmailAddress() {
        return getBooleanAttr(Provisioning.A_zimbraPrefShortEmailAddress, false, true);
    }

    /**
     * show just the display name of email addresses in the message header
     * area and compose pane
     *
     * @param zimbraPrefShortEmailAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1173)
    public void setPrefShortEmailAddress(boolean zimbraPrefShortEmailAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShortEmailAddress, zimbraPrefShortEmailAddress ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * show just the display name of email addresses in the message header
     * area and compose pane
     *
     * @param zimbraPrefShortEmailAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1173)
    public Map<String,Object> setPrefShortEmailAddress(boolean zimbraPrefShortEmailAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShortEmailAddress, zimbraPrefShortEmailAddress ? TRUE : FALSE);
        return attrs;
    }

    /**
     * show just the display name of email addresses in the message header
     * area and compose pane
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1173)
    public void unsetPrefShortEmailAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShortEmailAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * show just the display name of email addresses in the message header
     * area and compose pane
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1173)
    public Map<String,Object> unsetPrefShortEmailAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShortEmailAddress, "");
        return attrs;
    }

    /**
     * keyboard shortcuts
     *
     * @return zimbraPrefShortcuts, or null if unset
     */
    @ZAttr(id=396)
    public String getPrefShortcuts() {
        return getAttr(Provisioning.A_zimbraPrefShortcuts, null, true);
    }

    /**
     * keyboard shortcuts
     *
     * @param zimbraPrefShortcuts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=396)
    public void setPrefShortcuts(String zimbraPrefShortcuts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShortcuts, zimbraPrefShortcuts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * keyboard shortcuts
     *
     * @param zimbraPrefShortcuts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=396)
    public Map<String,Object> setPrefShortcuts(String zimbraPrefShortcuts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShortcuts, zimbraPrefShortcuts);
        return attrs;
    }

    /**
     * keyboard shortcuts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=396)
    public void unsetPrefShortcuts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShortcuts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * keyboard shortcuts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=396)
    public Map<String,Object> unsetPrefShortcuts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShortcuts, "");
        return attrs;
    }

    /**
     * By default, new mail notifications are only displayed for new items
     * placed in the inbox. To get new mail notifications for items filtered
     * to other folders as well, set this to TRUE
     *
     * @return zimbraPrefShowAllNewMailNotifications, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1904)
    public boolean isPrefShowAllNewMailNotifications() {
        return getBooleanAttr(Provisioning.A_zimbraPrefShowAllNewMailNotifications, false, true);
    }

    /**
     * By default, new mail notifications are only displayed for new items
     * placed in the inbox. To get new mail notifications for items filtered
     * to other folders as well, set this to TRUE
     *
     * @param zimbraPrefShowAllNewMailNotifications new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1904)
    public void setPrefShowAllNewMailNotifications(boolean zimbraPrefShowAllNewMailNotifications) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowAllNewMailNotifications, zimbraPrefShowAllNewMailNotifications ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * By default, new mail notifications are only displayed for new items
     * placed in the inbox. To get new mail notifications for items filtered
     * to other folders as well, set this to TRUE
     *
     * @param zimbraPrefShowAllNewMailNotifications new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1904)
    public Map<String,Object> setPrefShowAllNewMailNotifications(boolean zimbraPrefShowAllNewMailNotifications, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowAllNewMailNotifications, zimbraPrefShowAllNewMailNotifications ? TRUE : FALSE);
        return attrs;
    }

    /**
     * By default, new mail notifications are only displayed for new items
     * placed in the inbox. To get new mail notifications for items filtered
     * to other folders as well, set this to TRUE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1904)
    public void unsetPrefShowAllNewMailNotifications() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowAllNewMailNotifications, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * By default, new mail notifications are only displayed for new items
     * placed in the inbox. To get new mail notifications for items filtered
     * to other folders as well, set this to TRUE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1904)
    public Map<String,Object> unsetPrefShowAllNewMailNotifications(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowAllNewMailNotifications, "");
        return attrs;
    }

    /**
     * show calendar week in calendar views
     *
     * @return zimbraPrefShowCalendarWeek, or false if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1045)
    public boolean isPrefShowCalendarWeek() {
        return getBooleanAttr(Provisioning.A_zimbraPrefShowCalendarWeek, false, true);
    }

    /**
     * show calendar week in calendar views
     *
     * @param zimbraPrefShowCalendarWeek new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1045)
    public void setPrefShowCalendarWeek(boolean zimbraPrefShowCalendarWeek) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowCalendarWeek, zimbraPrefShowCalendarWeek ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * show calendar week in calendar views
     *
     * @param zimbraPrefShowCalendarWeek new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1045)
    public Map<String,Object> setPrefShowCalendarWeek(boolean zimbraPrefShowCalendarWeek, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowCalendarWeek, zimbraPrefShowCalendarWeek ? TRUE : FALSE);
        return attrs;
    }

    /**
     * show calendar week in calendar views
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1045)
    public void unsetPrefShowCalendarWeek() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowCalendarWeek, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * show calendar week in calendar views
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1045)
    public Map<String,Object> unsetPrefShowCalendarWeek(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowCalendarWeek, "");
        return attrs;
    }

    /**
     * Show Chats folder even if zimbraFeatureIMEnabled is false
     *
     * @return zimbraPrefShowChatsFolderInMail, or false if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1787)
    public boolean isPrefShowChatsFolderInMail() {
        return getBooleanAttr(Provisioning.A_zimbraPrefShowChatsFolderInMail, false, true);
    }

    /**
     * Show Chats folder even if zimbraFeatureIMEnabled is false
     *
     * @param zimbraPrefShowChatsFolderInMail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1787)
    public void setPrefShowChatsFolderInMail(boolean zimbraPrefShowChatsFolderInMail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowChatsFolderInMail, zimbraPrefShowChatsFolderInMail ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Show Chats folder even if zimbraFeatureIMEnabled is false
     *
     * @param zimbraPrefShowChatsFolderInMail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1787)
    public Map<String,Object> setPrefShowChatsFolderInMail(boolean zimbraPrefShowChatsFolderInMail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowChatsFolderInMail, zimbraPrefShowChatsFolderInMail ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Show Chats folder even if zimbraFeatureIMEnabled is false
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1787)
    public void unsetPrefShowChatsFolderInMail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowChatsFolderInMail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Show Chats folder even if zimbraFeatureIMEnabled is false
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1787)
    public Map<String,Object> unsetPrefShowChatsFolderInMail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowChatsFolderInMail, "");
        return attrs;
    }

    /**
     * whether or not to show direction buttons in compose toolbar
     *
     * @return zimbraPrefShowComposeDirection, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1274)
    public boolean isPrefShowComposeDirection() {
        return getBooleanAttr(Provisioning.A_zimbraPrefShowComposeDirection, false, true);
    }

    /**
     * whether or not to show direction buttons in compose toolbar
     *
     * @param zimbraPrefShowComposeDirection new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1274)
    public void setPrefShowComposeDirection(boolean zimbraPrefShowComposeDirection) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowComposeDirection, zimbraPrefShowComposeDirection ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to show direction buttons in compose toolbar
     *
     * @param zimbraPrefShowComposeDirection new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1274)
    public Map<String,Object> setPrefShowComposeDirection(boolean zimbraPrefShowComposeDirection, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowComposeDirection, zimbraPrefShowComposeDirection ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to show direction buttons in compose toolbar
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1274)
    public void unsetPrefShowComposeDirection() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowComposeDirection, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to show direction buttons in compose toolbar
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1274)
    public Map<String,Object> unsetPrefShowComposeDirection(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowComposeDirection, "");
        return attrs;
    }

    /**
     * show fragments in conversation and message lists
     *
     * @return zimbraPrefShowFragments, or true if unset
     */
    @ZAttr(id=192)
    public boolean isPrefShowFragments() {
        return getBooleanAttr(Provisioning.A_zimbraPrefShowFragments, true, true);
    }

    /**
     * show fragments in conversation and message lists
     *
     * @param zimbraPrefShowFragments new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=192)
    public void setPrefShowFragments(boolean zimbraPrefShowFragments) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowFragments, zimbraPrefShowFragments ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * show fragments in conversation and message lists
     *
     * @param zimbraPrefShowFragments new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=192)
    public Map<String,Object> setPrefShowFragments(boolean zimbraPrefShowFragments, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowFragments, zimbraPrefShowFragments ? TRUE : FALSE);
        return attrs;
    }

    /**
     * show fragments in conversation and message lists
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=192)
    public void unsetPrefShowFragments() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowFragments, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * show fragments in conversation and message lists
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=192)
    public Map<String,Object> unsetPrefShowFragments(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowFragments, "");
        return attrs;
    }

    /**
     * whether to show search box or not
     *
     * @return zimbraPrefShowSearchString, or false if unset
     */
    @ZAttr(id=222)
    public boolean isPrefShowSearchString() {
        return getBooleanAttr(Provisioning.A_zimbraPrefShowSearchString, false, true);
    }

    /**
     * whether to show search box or not
     *
     * @param zimbraPrefShowSearchString new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=222)
    public void setPrefShowSearchString(boolean zimbraPrefShowSearchString) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowSearchString, zimbraPrefShowSearchString ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to show search box or not
     *
     * @param zimbraPrefShowSearchString new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=222)
    public Map<String,Object> setPrefShowSearchString(boolean zimbraPrefShowSearchString, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowSearchString, zimbraPrefShowSearchString ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to show search box or not
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=222)
    public void unsetPrefShowSearchString() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowSearchString, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to show search box or not
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=222)
    public Map<String,Object> unsetPrefShowSearchString(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowSearchString, "");
        return attrs;
    }

    /**
     * show selection checkbox for selecting email, contact, voicemail items
     * in a list view for batch operations
     *
     * @return zimbraPrefShowSelectionCheckbox, or false if unset
     */
    @ZAttr(id=471)
    public boolean isPrefShowSelectionCheckbox() {
        return getBooleanAttr(Provisioning.A_zimbraPrefShowSelectionCheckbox, false, true);
    }

    /**
     * show selection checkbox for selecting email, contact, voicemail items
     * in a list view for batch operations
     *
     * @param zimbraPrefShowSelectionCheckbox new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=471)
    public void setPrefShowSelectionCheckbox(boolean zimbraPrefShowSelectionCheckbox) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowSelectionCheckbox, zimbraPrefShowSelectionCheckbox ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * show selection checkbox for selecting email, contact, voicemail items
     * in a list view for batch operations
     *
     * @param zimbraPrefShowSelectionCheckbox new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=471)
    public Map<String,Object> setPrefShowSelectionCheckbox(boolean zimbraPrefShowSelectionCheckbox, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowSelectionCheckbox, zimbraPrefShowSelectionCheckbox ? TRUE : FALSE);
        return attrs;
    }

    /**
     * show selection checkbox for selecting email, contact, voicemail items
     * in a list view for batch operations
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=471)
    public void unsetPrefShowSelectionCheckbox() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowSelectionCheckbox, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * show selection checkbox for selecting email, contact, voicemail items
     * in a list view for batch operations
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=471)
    public Map<String,Object> unsetPrefShowSelectionCheckbox(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefShowSelectionCheckbox, "");
        return attrs;
    }

    /**
     * Skin to use for this account
     *
     * @return zimbraPrefSkin, or "harmony" if unset
     */
    @ZAttr(id=355)
    public String getPrefSkin() {
        return getAttr(Provisioning.A_zimbraPrefSkin, "harmony", true);
    }

    /**
     * Skin to use for this account
     *
     * @param zimbraPrefSkin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=355)
    public void setPrefSkin(String zimbraPrefSkin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSkin, zimbraPrefSkin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Skin to use for this account
     *
     * @param zimbraPrefSkin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=355)
    public Map<String,Object> setPrefSkin(String zimbraPrefSkin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSkin, zimbraPrefSkin);
        return attrs;
    }

    /**
     * Skin to use for this account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=355)
    public void unsetPrefSkin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSkin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Skin to use for this account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=355)
    public Map<String,Object> unsetPrefSkin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSkin, "");
        return attrs;
    }

    /**
     * sort order for list view in the WEB UI
     *
     * @return zimbraPrefSortOrder, or null if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1188)
    public String getPrefSortOrder() {
        return getAttr(Provisioning.A_zimbraPrefSortOrder, null, true);
    }

    /**
     * sort order for list view in the WEB UI
     *
     * @param zimbraPrefSortOrder new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1188)
    public void setPrefSortOrder(String zimbraPrefSortOrder) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSortOrder, zimbraPrefSortOrder);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sort order for list view in the WEB UI
     *
     * @param zimbraPrefSortOrder new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1188)
    public Map<String,Object> setPrefSortOrder(String zimbraPrefSortOrder, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSortOrder, zimbraPrefSortOrder);
        return attrs;
    }

    /**
     * sort order for list view in the WEB UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1188)
    public void unsetPrefSortOrder() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSortOrder, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * sort order for list view in the WEB UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1188)
    public Map<String,Object> unsetPrefSortOrder(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSortOrder, "");
        return attrs;
    }

    /**
     * The name of the dictionary used for spell checking. If not set, the
     * locale is used.
     *
     * @return zimbraPrefSpellDictionary, or null if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1041)
    public String getPrefSpellDictionary() {
        return getAttr(Provisioning.A_zimbraPrefSpellDictionary, null, true);
    }

    /**
     * The name of the dictionary used for spell checking. If not set, the
     * locale is used.
     *
     * @param zimbraPrefSpellDictionary new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1041)
    public void setPrefSpellDictionary(String zimbraPrefSpellDictionary) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellDictionary, zimbraPrefSpellDictionary);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The name of the dictionary used for spell checking. If not set, the
     * locale is used.
     *
     * @param zimbraPrefSpellDictionary new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1041)
    public Map<String,Object> setPrefSpellDictionary(String zimbraPrefSpellDictionary, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellDictionary, zimbraPrefSpellDictionary);
        return attrs;
    }

    /**
     * The name of the dictionary used for spell checking. If not set, the
     * locale is used.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1041)
    public void unsetPrefSpellDictionary() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellDictionary, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The name of the dictionary used for spell checking. If not set, the
     * locale is used.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1041)
    public Map<String,Object> unsetPrefSpellDictionary(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellDictionary, "");
        return attrs;
    }

    /**
     * If TRUE, the spell checker ignores words that contain only upper-case
     * letters.
     *
     * @return zimbraPrefSpellIgnoreAllCaps, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1207)
    public boolean isPrefSpellIgnoreAllCaps() {
        return getBooleanAttr(Provisioning.A_zimbraPrefSpellIgnoreAllCaps, true, true);
    }

    /**
     * If TRUE, the spell checker ignores words that contain only upper-case
     * letters.
     *
     * @param zimbraPrefSpellIgnoreAllCaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1207)
    public void setPrefSpellIgnoreAllCaps(boolean zimbraPrefSpellIgnoreAllCaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnoreAllCaps, zimbraPrefSpellIgnoreAllCaps ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, the spell checker ignores words that contain only upper-case
     * letters.
     *
     * @param zimbraPrefSpellIgnoreAllCaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1207)
    public Map<String,Object> setPrefSpellIgnoreAllCaps(boolean zimbraPrefSpellIgnoreAllCaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnoreAllCaps, zimbraPrefSpellIgnoreAllCaps ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, the spell checker ignores words that contain only upper-case
     * letters.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1207)
    public void unsetPrefSpellIgnoreAllCaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnoreAllCaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, the spell checker ignores words that contain only upper-case
     * letters.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1207)
    public Map<String,Object> unsetPrefSpellIgnoreAllCaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnoreAllCaps, "");
        return attrs;
    }

    /**
     * Regular Expression for words to ignore during spell check.
     *
     * @return zimbraPrefSpellIgnorePattern, or null if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1432)
    public String getPrefSpellIgnorePattern() {
        return getAttr(Provisioning.A_zimbraPrefSpellIgnorePattern, null, true);
    }

    /**
     * Regular Expression for words to ignore during spell check.
     *
     * @param zimbraPrefSpellIgnorePattern new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1432)
    public void setPrefSpellIgnorePattern(String zimbraPrefSpellIgnorePattern) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnorePattern, zimbraPrefSpellIgnorePattern);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Regular Expression for words to ignore during spell check.
     *
     * @param zimbraPrefSpellIgnorePattern new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1432)
    public Map<String,Object> setPrefSpellIgnorePattern(String zimbraPrefSpellIgnorePattern, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnorePattern, zimbraPrefSpellIgnorePattern);
        return attrs;
    }

    /**
     * Regular Expression for words to ignore during spell check.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1432)
    public void unsetPrefSpellIgnorePattern() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnorePattern, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Regular Expression for words to ignore during spell check.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1432)
    public Map<String,Object> unsetPrefSpellIgnorePattern(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnorePattern, "");
        return attrs;
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @return zimbraPrefSpellIgnoreWord, or empty array if unset
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public String[] getPrefSpellIgnoreWord() {
        String[] value = getMultiAttr(Provisioning.A_zimbraPrefSpellIgnoreWord, true, true); return value.length > 0 ? value : new String[] {"blog"};
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @param zimbraPrefSpellIgnoreWord new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public void setPrefSpellIgnoreWord(String[] zimbraPrefSpellIgnoreWord) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnoreWord, zimbraPrefSpellIgnoreWord);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @param zimbraPrefSpellIgnoreWord new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public Map<String,Object> setPrefSpellIgnoreWord(String[] zimbraPrefSpellIgnoreWord, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnoreWord, zimbraPrefSpellIgnoreWord);
        return attrs;
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @param zimbraPrefSpellIgnoreWord new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public void addPrefSpellIgnoreWord(String zimbraPrefSpellIgnoreWord) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefSpellIgnoreWord, zimbraPrefSpellIgnoreWord);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @param zimbraPrefSpellIgnoreWord new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public Map<String,Object> addPrefSpellIgnoreWord(String zimbraPrefSpellIgnoreWord, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefSpellIgnoreWord, zimbraPrefSpellIgnoreWord);
        return attrs;
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @param zimbraPrefSpellIgnoreWord existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public void removePrefSpellIgnoreWord(String zimbraPrefSpellIgnoreWord) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefSpellIgnoreWord, zimbraPrefSpellIgnoreWord);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @param zimbraPrefSpellIgnoreWord existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public Map<String,Object> removePrefSpellIgnoreWord(String zimbraPrefSpellIgnoreWord, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefSpellIgnoreWord, zimbraPrefSpellIgnoreWord);
        return attrs;
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public void unsetPrefSpellIgnoreWord() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnoreWord, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of words to ignore when checking spelling. The word list of an
     * account includes the words specified for its cos and domain.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1073)
    public Map<String,Object> unsetPrefSpellIgnoreWord(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefSpellIgnoreWord, "");
        return attrs;
    }

    /**
     * whether standard client should operate in accessibility Mode
     *
     * @return zimbraPrefStandardClientAccessibilityMode, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=689)
    public boolean isPrefStandardClientAccessibilityMode() {
        return getBooleanAttr(Provisioning.A_zimbraPrefStandardClientAccessibilityMode, false, true);
    }

    /**
     * whether standard client should operate in accessibility Mode
     *
     * @param zimbraPrefStandardClientAccessibilityMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=689)
    public void setPrefStandardClientAccessibilityMode(boolean zimbraPrefStandardClientAccessibilityMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefStandardClientAccessibilityMode, zimbraPrefStandardClientAccessibilityMode ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether standard client should operate in accessibility Mode
     *
     * @param zimbraPrefStandardClientAccessibilityMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=689)
    public Map<String,Object> setPrefStandardClientAccessibilityMode(boolean zimbraPrefStandardClientAccessibilityMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefStandardClientAccessibilityMode, zimbraPrefStandardClientAccessibilityMode ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether standard client should operate in accessibility Mode
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=689)
    public void unsetPrefStandardClientAccessibilityMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefStandardClientAccessibilityMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether standard client should operate in accessibility Mode
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=689)
    public Map<String,Object> unsetPrefStandardClientAccessibilityMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefStandardClientAccessibilityMode, "");
        return attrs;
    }

    /**
     * If true, Tab key inserts a tab into the editor body. If false, it
     * moves focus.
     *
     * @return zimbraPrefTabInEditorEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1972)
    public boolean isPrefTabInEditorEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefTabInEditorEnabled, false, true);
    }

    /**
     * If true, Tab key inserts a tab into the editor body. If false, it
     * moves focus.
     *
     * @param zimbraPrefTabInEditorEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1972)
    public void setPrefTabInEditorEnabled(boolean zimbraPrefTabInEditorEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTabInEditorEnabled, zimbraPrefTabInEditorEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, Tab key inserts a tab into the editor body. If false, it
     * moves focus.
     *
     * @param zimbraPrefTabInEditorEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1972)
    public Map<String,Object> setPrefTabInEditorEnabled(boolean zimbraPrefTabInEditorEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTabInEditorEnabled, zimbraPrefTabInEditorEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If true, Tab key inserts a tab into the editor body. If false, it
     * moves focus.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1972)
    public void unsetPrefTabInEditorEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTabInEditorEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, Tab key inserts a tab into the editor body. If false, it
     * moves focus.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1972)
    public Map<String,Object> unsetPrefTabInEditorEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTabInEditorEnabled, "");
        return attrs;
    }

    /**
     * whether or not tag tree is expanded
     *
     * @return zimbraPrefTagTreeOpen, or true if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=633)
    public boolean isPrefTagTreeOpen() {
        return getBooleanAttr(Provisioning.A_zimbraPrefTagTreeOpen, true, true);
    }

    /**
     * whether or not tag tree is expanded
     *
     * @param zimbraPrefTagTreeOpen new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=633)
    public void setPrefTagTreeOpen(boolean zimbraPrefTagTreeOpen) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTagTreeOpen, zimbraPrefTagTreeOpen ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not tag tree is expanded
     *
     * @param zimbraPrefTagTreeOpen new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=633)
    public Map<String,Object> setPrefTagTreeOpen(boolean zimbraPrefTagTreeOpen, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTagTreeOpen, zimbraPrefTagTreeOpen ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not tag tree is expanded
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=633)
    public void unsetPrefTagTreeOpen() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTagTreeOpen, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not tag tree is expanded
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=633)
    public Map<String,Object> unsetPrefTagTreeOpen(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTagTreeOpen, "");
        return attrs;
    }

    /**
     * preferred task filtering option in UI
     *
     * <p>Valid values: [NOTSTARTED, COMPLETED, INPROGRESS, WAITING, DEFERRED, TODO]
     *
     * @return zimbraPrefTasksFilterBy, or null if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1323)
    public ZAttrProvisioning.PrefTasksFilterBy getPrefTasksFilterBy() {
        try { String v = getAttr(Provisioning.A_zimbraPrefTasksFilterBy, true, true); return v == null ? null : ZAttrProvisioning.PrefTasksFilterBy.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * preferred task filtering option in UI
     *
     * <p>Valid values: [NOTSTARTED, COMPLETED, INPROGRESS, WAITING, DEFERRED, TODO]
     *
     * @return zimbraPrefTasksFilterBy, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1323)
    public String getPrefTasksFilterByAsString() {
        return getAttr(Provisioning.A_zimbraPrefTasksFilterBy, null, true);
    }

    /**
     * preferred task filtering option in UI
     *
     * <p>Valid values: [NOTSTARTED, COMPLETED, INPROGRESS, WAITING, DEFERRED, TODO]
     *
     * @param zimbraPrefTasksFilterBy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1323)
    public void setPrefTasksFilterBy(ZAttrProvisioning.PrefTasksFilterBy zimbraPrefTasksFilterBy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksFilterBy, zimbraPrefTasksFilterBy.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * preferred task filtering option in UI
     *
     * <p>Valid values: [NOTSTARTED, COMPLETED, INPROGRESS, WAITING, DEFERRED, TODO]
     *
     * @param zimbraPrefTasksFilterBy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1323)
    public Map<String,Object> setPrefTasksFilterBy(ZAttrProvisioning.PrefTasksFilterBy zimbraPrefTasksFilterBy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksFilterBy, zimbraPrefTasksFilterBy.toString());
        return attrs;
    }

    /**
     * preferred task filtering option in UI
     *
     * <p>Valid values: [NOTSTARTED, COMPLETED, INPROGRESS, WAITING, DEFERRED, TODO]
     *
     * @param zimbraPrefTasksFilterBy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1323)
    public void setPrefTasksFilterByAsString(String zimbraPrefTasksFilterBy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksFilterBy, zimbraPrefTasksFilterBy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * preferred task filtering option in UI
     *
     * <p>Valid values: [NOTSTARTED, COMPLETED, INPROGRESS, WAITING, DEFERRED, TODO]
     *
     * @param zimbraPrefTasksFilterBy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1323)
    public Map<String,Object> setPrefTasksFilterByAsString(String zimbraPrefTasksFilterBy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksFilterBy, zimbraPrefTasksFilterBy);
        return attrs;
    }

    /**
     * preferred task filtering option in UI
     *
     * <p>Valid values: [NOTSTARTED, COMPLETED, INPROGRESS, WAITING, DEFERRED, TODO]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1323)
    public void unsetPrefTasksFilterBy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksFilterBy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * preferred task filtering option in UI
     *
     * <p>Valid values: [NOTSTARTED, COMPLETED, INPROGRESS, WAITING, DEFERRED, TODO]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1323)
    public Map<String,Object> unsetPrefTasksFilterBy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksFilterBy, "");
        return attrs;
    }

    /**
     * where the reading pane is displayed for tasks
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @return zimbraPrefTasksReadingPaneLocation, or ZAttrProvisioning.PrefTasksReadingPaneLocation.right if unset and/or has invalid value
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1151)
    public ZAttrProvisioning.PrefTasksReadingPaneLocation getPrefTasksReadingPaneLocation() {
        try { String v = getAttr(Provisioning.A_zimbraPrefTasksReadingPaneLocation, true, true); return v == null ? ZAttrProvisioning.PrefTasksReadingPaneLocation.right : ZAttrProvisioning.PrefTasksReadingPaneLocation.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.PrefTasksReadingPaneLocation.right; }
    }

    /**
     * where the reading pane is displayed for tasks
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @return zimbraPrefTasksReadingPaneLocation, or "right" if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1151)
    public String getPrefTasksReadingPaneLocationAsString() {
        return getAttr(Provisioning.A_zimbraPrefTasksReadingPaneLocation, "right", true);
    }

    /**
     * where the reading pane is displayed for tasks
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefTasksReadingPaneLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1151)
    public void setPrefTasksReadingPaneLocation(ZAttrProvisioning.PrefTasksReadingPaneLocation zimbraPrefTasksReadingPaneLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksReadingPaneLocation, zimbraPrefTasksReadingPaneLocation.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the reading pane is displayed for tasks
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefTasksReadingPaneLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1151)
    public Map<String,Object> setPrefTasksReadingPaneLocation(ZAttrProvisioning.PrefTasksReadingPaneLocation zimbraPrefTasksReadingPaneLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksReadingPaneLocation, zimbraPrefTasksReadingPaneLocation.toString());
        return attrs;
    }

    /**
     * where the reading pane is displayed for tasks
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefTasksReadingPaneLocation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1151)
    public void setPrefTasksReadingPaneLocationAsString(String zimbraPrefTasksReadingPaneLocation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksReadingPaneLocation, zimbraPrefTasksReadingPaneLocation);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the reading pane is displayed for tasks
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param zimbraPrefTasksReadingPaneLocation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1151)
    public Map<String,Object> setPrefTasksReadingPaneLocationAsString(String zimbraPrefTasksReadingPaneLocation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksReadingPaneLocation, zimbraPrefTasksReadingPaneLocation);
        return attrs;
    }

    /**
     * where the reading pane is displayed for tasks
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1151)
    public void unsetPrefTasksReadingPaneLocation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksReadingPaneLocation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * where the reading pane is displayed for tasks
     *
     * <p>Valid values: [bottom, right, off]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1151)
    public Map<String,Object> unsetPrefTasksReadingPaneLocation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTasksReadingPaneLocation, "");
        return attrs;
    }

    /**
     * time zone of user or COS
     *
     * @return zimbraPrefTimeZoneId, or empty array if unset
     */
    @ZAttr(id=235)
    public String[] getPrefTimeZoneId() {
        String[] value = getMultiAttr(Provisioning.A_zimbraPrefTimeZoneId, true, true); return value.length > 0 ? value : new String[] {"America/Los_Angeles"};
    }

    /**
     * time zone of user or COS
     *
     * @param zimbraPrefTimeZoneId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=235)
    public void setPrefTimeZoneId(String[] zimbraPrefTimeZoneId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTimeZoneId, zimbraPrefTimeZoneId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time zone of user or COS
     *
     * @param zimbraPrefTimeZoneId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=235)
    public Map<String,Object> setPrefTimeZoneId(String[] zimbraPrefTimeZoneId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTimeZoneId, zimbraPrefTimeZoneId);
        return attrs;
    }

    /**
     * time zone of user or COS
     *
     * @param zimbraPrefTimeZoneId new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=235)
    public void addPrefTimeZoneId(String zimbraPrefTimeZoneId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefTimeZoneId, zimbraPrefTimeZoneId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time zone of user or COS
     *
     * @param zimbraPrefTimeZoneId new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=235)
    public Map<String,Object> addPrefTimeZoneId(String zimbraPrefTimeZoneId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefTimeZoneId, zimbraPrefTimeZoneId);
        return attrs;
    }

    /**
     * time zone of user or COS
     *
     * @param zimbraPrefTimeZoneId existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=235)
    public void removePrefTimeZoneId(String zimbraPrefTimeZoneId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefTimeZoneId, zimbraPrefTimeZoneId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time zone of user or COS
     *
     * @param zimbraPrefTimeZoneId existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=235)
    public Map<String,Object> removePrefTimeZoneId(String zimbraPrefTimeZoneId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefTimeZoneId, zimbraPrefTimeZoneId);
        return attrs;
    }

    /**
     * time zone of user or COS
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=235)
    public void unsetPrefTimeZoneId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTimeZoneId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time zone of user or COS
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=235)
    public Map<String,Object> unsetPrefTimeZoneId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTimeZoneId, "");
        return attrs;
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailTrashLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getPrefTrashLifetimeAsString to access value as a string.
     *
     * @see #getPrefTrashLifetimeAsString()
     *
     * @return zimbraPrefTrashLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=541)
    public long getPrefTrashLifetime() {
        return getTimeInterval(Provisioning.A_zimbraPrefTrashLifetime, 0L, true);
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailTrashLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraPrefTrashLifetime, or "0" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=541)
    public String getPrefTrashLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraPrefTrashLifetime, "0", true);
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailTrashLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefTrashLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=541)
    public void setPrefTrashLifetime(String zimbraPrefTrashLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTrashLifetime, zimbraPrefTrashLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailTrashLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraPrefTrashLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=541)
    public Map<String,Object> setPrefTrashLifetime(String zimbraPrefTrashLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTrashLifetime, zimbraPrefTrashLifetime);
        return attrs;
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailTrashLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=541)
    public void unsetPrefTrashLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTrashLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention period of messages in the Trash folder. 0 means that all
     * messages will be retained. This user-modifiable attribute works in
     * conjunction with zimbraMailTrashLifetime, which is admin-modifiable.
     * The shorter duration is used. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=541)
    public Map<String,Object> unsetPrefTrashLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefTrashLifetime, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. no longer used in account or identity. Orig
     * desc: TRUE if we this identity should get settings from the default
     * identity
     *
     * @return zimbraPrefUseDefaultIdentitySettings, or false if unset
     */
    @ZAttr(id=410)
    public boolean isPrefUseDefaultIdentitySettings() {
        return getBooleanAttr(Provisioning.A_zimbraPrefUseDefaultIdentitySettings, false, true);
    }

    /**
     * Deprecated since: 5.0. no longer used in account or identity. Orig
     * desc: TRUE if we this identity should get settings from the default
     * identity
     *
     * @param zimbraPrefUseDefaultIdentitySettings new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=410)
    public void setPrefUseDefaultIdentitySettings(boolean zimbraPrefUseDefaultIdentitySettings) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseDefaultIdentitySettings, zimbraPrefUseDefaultIdentitySettings ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. no longer used in account or identity. Orig
     * desc: TRUE if we this identity should get settings from the default
     * identity
     *
     * @param zimbraPrefUseDefaultIdentitySettings new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=410)
    public Map<String,Object> setPrefUseDefaultIdentitySettings(boolean zimbraPrefUseDefaultIdentitySettings, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseDefaultIdentitySettings, zimbraPrefUseDefaultIdentitySettings ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. no longer used in account or identity. Orig
     * desc: TRUE if we this identity should get settings from the default
     * identity
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=410)
    public void unsetPrefUseDefaultIdentitySettings() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseDefaultIdentitySettings, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. no longer used in account or identity. Orig
     * desc: TRUE if we this identity should get settings from the default
     * identity
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=410)
    public Map<String,Object> unsetPrefUseDefaultIdentitySettings(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseDefaultIdentitySettings, "");
        return attrs;
    }

    /**
     * whether or not keyboard shortcuts are enabled
     *
     * @return zimbraPrefUseKeyboardShortcuts, or true if unset
     */
    @ZAttr(id=61)
    public boolean isPrefUseKeyboardShortcuts() {
        return getBooleanAttr(Provisioning.A_zimbraPrefUseKeyboardShortcuts, true, true);
    }

    /**
     * whether or not keyboard shortcuts are enabled
     *
     * @param zimbraPrefUseKeyboardShortcuts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=61)
    public void setPrefUseKeyboardShortcuts(boolean zimbraPrefUseKeyboardShortcuts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseKeyboardShortcuts, zimbraPrefUseKeyboardShortcuts ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not keyboard shortcuts are enabled
     *
     * @param zimbraPrefUseKeyboardShortcuts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=61)
    public Map<String,Object> setPrefUseKeyboardShortcuts(boolean zimbraPrefUseKeyboardShortcuts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseKeyboardShortcuts, zimbraPrefUseKeyboardShortcuts ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not keyboard shortcuts are enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=61)
    public void unsetPrefUseKeyboardShortcuts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseKeyboardShortcuts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not keyboard shortcuts are enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=61)
    public Map<String,Object> unsetPrefUseKeyboardShortcuts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseKeyboardShortcuts, "");
        return attrs;
    }

    /**
     * When composing and sending mail, whether to use RFC 2231 MIME
     * parameter value encoding. If set to FALSE, then RFC 2047 style
     * encoding is used.
     *
     * @return zimbraPrefUseRfc2231, or false if unset
     */
    @ZAttr(id=395)
    public boolean isPrefUseRfc2231() {
        return getBooleanAttr(Provisioning.A_zimbraPrefUseRfc2231, false, true);
    }

    /**
     * When composing and sending mail, whether to use RFC 2231 MIME
     * parameter value encoding. If set to FALSE, then RFC 2047 style
     * encoding is used.
     *
     * @param zimbraPrefUseRfc2231 new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=395)
    public void setPrefUseRfc2231(boolean zimbraPrefUseRfc2231) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseRfc2231, zimbraPrefUseRfc2231 ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When composing and sending mail, whether to use RFC 2231 MIME
     * parameter value encoding. If set to FALSE, then RFC 2047 style
     * encoding is used.
     *
     * @param zimbraPrefUseRfc2231 new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=395)
    public Map<String,Object> setPrefUseRfc2231(boolean zimbraPrefUseRfc2231, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseRfc2231, zimbraPrefUseRfc2231 ? TRUE : FALSE);
        return attrs;
    }

    /**
     * When composing and sending mail, whether to use RFC 2231 MIME
     * parameter value encoding. If set to FALSE, then RFC 2047 style
     * encoding is used.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=395)
    public void unsetPrefUseRfc2231() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseRfc2231, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When composing and sending mail, whether to use RFC 2231 MIME
     * parameter value encoding. If set to FALSE, then RFC 2047 style
     * encoding is used.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=395)
    public Map<String,Object> unsetPrefUseRfc2231(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseRfc2231, "");
        return attrs;
    }

    /**
     * Whether to allow the send message Control-Enter shortcut in the web
     * client UI
     *
     * @return zimbraPrefUseSendMsgShortcut, or true if unset
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1650)
    public boolean isPrefUseSendMsgShortcut() {
        return getBooleanAttr(Provisioning.A_zimbraPrefUseSendMsgShortcut, true, true);
    }

    /**
     * Whether to allow the send message Control-Enter shortcut in the web
     * client UI
     *
     * @param zimbraPrefUseSendMsgShortcut new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1650)
    public void setPrefUseSendMsgShortcut(boolean zimbraPrefUseSendMsgShortcut) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseSendMsgShortcut, zimbraPrefUseSendMsgShortcut ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow the send message Control-Enter shortcut in the web
     * client UI
     *
     * @param zimbraPrefUseSendMsgShortcut new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1650)
    public Map<String,Object> setPrefUseSendMsgShortcut(boolean zimbraPrefUseSendMsgShortcut, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseSendMsgShortcut, zimbraPrefUseSendMsgShortcut ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow the send message Control-Enter shortcut in the web
     * client UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1650)
    public void unsetPrefUseSendMsgShortcut() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseSendMsgShortcut, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow the send message Control-Enter shortcut in the web
     * client UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0,9.0.0
     */
    @ZAttr(id=1650)
    public Map<String,Object> unsetPrefUseSendMsgShortcut(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseSendMsgShortcut, "");
        return attrs;
    }

    /**
     * whether list of well known time zones is displayed in calendar UI
     *
     * @return zimbraPrefUseTimeZoneListInCalendar, or false if unset
     */
    @ZAttr(id=236)
    public boolean isPrefUseTimeZoneListInCalendar() {
        return getBooleanAttr(Provisioning.A_zimbraPrefUseTimeZoneListInCalendar, false, true);
    }

    /**
     * whether list of well known time zones is displayed in calendar UI
     *
     * @param zimbraPrefUseTimeZoneListInCalendar new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=236)
    public void setPrefUseTimeZoneListInCalendar(boolean zimbraPrefUseTimeZoneListInCalendar) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseTimeZoneListInCalendar, zimbraPrefUseTimeZoneListInCalendar ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether list of well known time zones is displayed in calendar UI
     *
     * @param zimbraPrefUseTimeZoneListInCalendar new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=236)
    public Map<String,Object> setPrefUseTimeZoneListInCalendar(boolean zimbraPrefUseTimeZoneListInCalendar, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseTimeZoneListInCalendar, zimbraPrefUseTimeZoneListInCalendar ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether list of well known time zones is displayed in calendar UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=236)
    public void unsetPrefUseTimeZoneListInCalendar() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseTimeZoneListInCalendar, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether list of well known time zones is displayed in calendar UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=236)
    public Map<String,Object> unsetPrefUseTimeZoneListInCalendar(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefUseTimeZoneListInCalendar, "");
        return attrs;
    }

    /**
     * number of voice messages/call logs per page
     *
     * @return zimbraPrefVoiceItemsPerPage, or 25 if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=526)
    public int getPrefVoiceItemsPerPage() {
        return getIntAttr(Provisioning.A_zimbraPrefVoiceItemsPerPage, 25, true);
    }

    /**
     * number of voice messages/call logs per page
     *
     * @param zimbraPrefVoiceItemsPerPage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=526)
    public void setPrefVoiceItemsPerPage(int zimbraPrefVoiceItemsPerPage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefVoiceItemsPerPage, Integer.toString(zimbraPrefVoiceItemsPerPage));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of voice messages/call logs per page
     *
     * @param zimbraPrefVoiceItemsPerPage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=526)
    public Map<String,Object> setPrefVoiceItemsPerPage(int zimbraPrefVoiceItemsPerPage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefVoiceItemsPerPage, Integer.toString(zimbraPrefVoiceItemsPerPage));
        return attrs;
    }

    /**
     * number of voice messages/call logs per page
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=526)
    public void unsetPrefVoiceItemsPerPage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefVoiceItemsPerPage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of voice messages/call logs per page
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=526)
    public Map<String,Object> unsetPrefVoiceItemsPerPage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefVoiceItemsPerPage, "");
        return attrs;
    }

    /**
     * whether to display a warning when users try to navigate away from ZCS
     *
     * @return zimbraPrefWarnOnExit, or true if unset
     */
    @ZAttr(id=456)
    public boolean isPrefWarnOnExit() {
        return getBooleanAttr(Provisioning.A_zimbraPrefWarnOnExit, true, true);
    }

    /**
     * whether to display a warning when users try to navigate away from ZCS
     *
     * @param zimbraPrefWarnOnExit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=456)
    public void setPrefWarnOnExit(boolean zimbraPrefWarnOnExit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWarnOnExit, zimbraPrefWarnOnExit ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display a warning when users try to navigate away from ZCS
     *
     * @param zimbraPrefWarnOnExit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=456)
    public Map<String,Object> setPrefWarnOnExit(boolean zimbraPrefWarnOnExit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWarnOnExit, zimbraPrefWarnOnExit ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to display a warning when users try to navigate away from ZCS
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=456)
    public void unsetPrefWarnOnExit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWarnOnExit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display a warning when users try to navigate away from ZCS
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=456)
    public Map<String,Object> unsetPrefWarnOnExit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWarnOnExit, "");
        return attrs;
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @return zimbraPrefWebClientOfflineBrowserKey, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public String[] getPrefWebClientOfflineBrowserKey() {
        return getMultiAttr(Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, true, true);
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @param zimbraPrefWebClientOfflineBrowserKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public void setPrefWebClientOfflineBrowserKey(String[] zimbraPrefWebClientOfflineBrowserKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, zimbraPrefWebClientOfflineBrowserKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @param zimbraPrefWebClientOfflineBrowserKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public Map<String,Object> setPrefWebClientOfflineBrowserKey(String[] zimbraPrefWebClientOfflineBrowserKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, zimbraPrefWebClientOfflineBrowserKey);
        return attrs;
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @param zimbraPrefWebClientOfflineBrowserKey new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public void addPrefWebClientOfflineBrowserKey(String zimbraPrefWebClientOfflineBrowserKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, zimbraPrefWebClientOfflineBrowserKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @param zimbraPrefWebClientOfflineBrowserKey new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public Map<String,Object> addPrefWebClientOfflineBrowserKey(String zimbraPrefWebClientOfflineBrowserKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, zimbraPrefWebClientOfflineBrowserKey);
        return attrs;
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @param zimbraPrefWebClientOfflineBrowserKey existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public void removePrefWebClientOfflineBrowserKey(String zimbraPrefWebClientOfflineBrowserKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, zimbraPrefWebClientOfflineBrowserKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @param zimbraPrefWebClientOfflineBrowserKey existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public Map<String,Object> removePrefWebClientOfflineBrowserKey(String zimbraPrefWebClientOfflineBrowserKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, zimbraPrefWebClientOfflineBrowserKey);
        return attrs;
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public void unsetPrefWebClientOfflineBrowserKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set of known keys corresponding to browsers used by the user for web
     * client offline access
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1571)
    public Map<String,Object> unsetPrefWebClientOfflineBrowserKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWebClientOfflineBrowserKey, "");
        return attrs;
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @return zimbraPrefWhenInFolderIds, or empty array if unset
     */
    @ZAttr(id=409)
    public String[] getPrefWhenInFolderIds() {
        return getMultiAttr(Provisioning.A_zimbraPrefWhenInFolderIds, true, true);
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenInFolderIds new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=409)
    public void setPrefWhenInFolderIds(String[] zimbraPrefWhenInFolderIds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenInFolderIds, zimbraPrefWhenInFolderIds);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenInFolderIds new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=409)
    public Map<String,Object> setPrefWhenInFolderIds(String[] zimbraPrefWhenInFolderIds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenInFolderIds, zimbraPrefWhenInFolderIds);
        return attrs;
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenInFolderIds new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=409)
    public void addPrefWhenInFolderIds(String zimbraPrefWhenInFolderIds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefWhenInFolderIds, zimbraPrefWhenInFolderIds);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenInFolderIds new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=409)
    public Map<String,Object> addPrefWhenInFolderIds(String zimbraPrefWhenInFolderIds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefWhenInFolderIds, zimbraPrefWhenInFolderIds);
        return attrs;
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenInFolderIds existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=409)
    public void removePrefWhenInFolderIds(String zimbraPrefWhenInFolderIds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefWhenInFolderIds, zimbraPrefWhenInFolderIds);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenInFolderIds existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=409)
    public Map<String,Object> removePrefWhenInFolderIds(String zimbraPrefWhenInFolderIds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefWhenInFolderIds, zimbraPrefWhenInFolderIds);
        return attrs;
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=409)
    public void unsetPrefWhenInFolderIds() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenInFolderIds, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if replying/forwarding a message in this folder, use this identity
     * (deprecatedSince 5.0 in account)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=409)
    public Map<String,Object> unsetPrefWhenInFolderIds(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenInFolderIds, "");
        return attrs;
    }

    /**
     * TRUE if we should look at zimbraPrefWhenInFolderIds (deprecatedSince
     * 5.0 in account)
     *
     * @return zimbraPrefWhenInFoldersEnabled, or false if unset
     */
    @ZAttr(id=408)
    public boolean isPrefWhenInFoldersEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefWhenInFoldersEnabled, false, true);
    }

    /**
     * TRUE if we should look at zimbraPrefWhenInFolderIds (deprecatedSince
     * 5.0 in account)
     *
     * @param zimbraPrefWhenInFoldersEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=408)
    public void setPrefWhenInFoldersEnabled(boolean zimbraPrefWhenInFoldersEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenInFoldersEnabled, zimbraPrefWhenInFoldersEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * TRUE if we should look at zimbraPrefWhenInFolderIds (deprecatedSince
     * 5.0 in account)
     *
     * @param zimbraPrefWhenInFoldersEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=408)
    public Map<String,Object> setPrefWhenInFoldersEnabled(boolean zimbraPrefWhenInFoldersEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenInFoldersEnabled, zimbraPrefWhenInFoldersEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * TRUE if we should look at zimbraPrefWhenInFolderIds (deprecatedSince
     * 5.0 in account)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=408)
    public void unsetPrefWhenInFoldersEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenInFoldersEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * TRUE if we should look at zimbraPrefWhenInFolderIds (deprecatedSince
     * 5.0 in account)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=408)
    public Map<String,Object> unsetPrefWhenInFoldersEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenInFoldersEnabled, "");
        return attrs;
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @return zimbraPrefWhenSentToAddresses, or empty array if unset
     */
    @ZAttr(id=407)
    public String[] getPrefWhenSentToAddresses() {
        return getMultiAttr(Provisioning.A_zimbraPrefWhenSentToAddresses, true, true);
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenSentToAddresses new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=407)
    public void setPrefWhenSentToAddresses(String[] zimbraPrefWhenSentToAddresses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenSentToAddresses, zimbraPrefWhenSentToAddresses);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenSentToAddresses new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=407)
    public Map<String,Object> setPrefWhenSentToAddresses(String[] zimbraPrefWhenSentToAddresses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenSentToAddresses, zimbraPrefWhenSentToAddresses);
        return attrs;
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenSentToAddresses new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=407)
    public void addPrefWhenSentToAddresses(String zimbraPrefWhenSentToAddresses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefWhenSentToAddresses, zimbraPrefWhenSentToAddresses);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenSentToAddresses new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=407)
    public Map<String,Object> addPrefWhenSentToAddresses(String zimbraPrefWhenSentToAddresses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefWhenSentToAddresses, zimbraPrefWhenSentToAddresses);
        return attrs;
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenSentToAddresses existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=407)
    public void removePrefWhenSentToAddresses(String zimbraPrefWhenSentToAddresses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefWhenSentToAddresses, zimbraPrefWhenSentToAddresses);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenSentToAddresses existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=407)
    public Map<String,Object> removePrefWhenSentToAddresses(String zimbraPrefWhenSentToAddresses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefWhenSentToAddresses, zimbraPrefWhenSentToAddresses);
        return attrs;
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=407)
    public void unsetPrefWhenSentToAddresses() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenSentToAddresses, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * addresses that we will look at to see if we should use an identity
     * (deprecatedSince 5.0 in account)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=407)
    public Map<String,Object> unsetPrefWhenSentToAddresses(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenSentToAddresses, "");
        return attrs;
    }

    /**
     * TRUE if we should look at zimbraPrefWhenSentToAddresses
     * (deprecatedSince 5.0 in account)
     *
     * @return zimbraPrefWhenSentToEnabled, or false if unset
     */
    @ZAttr(id=406)
    public boolean isPrefWhenSentToEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefWhenSentToEnabled, false, true);
    }

    /**
     * TRUE if we should look at zimbraPrefWhenSentToAddresses
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenSentToEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=406)
    public void setPrefWhenSentToEnabled(boolean zimbraPrefWhenSentToEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenSentToEnabled, zimbraPrefWhenSentToEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * TRUE if we should look at zimbraPrefWhenSentToAddresses
     * (deprecatedSince 5.0 in account)
     *
     * @param zimbraPrefWhenSentToEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=406)
    public Map<String,Object> setPrefWhenSentToEnabled(boolean zimbraPrefWhenSentToEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenSentToEnabled, zimbraPrefWhenSentToEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * TRUE if we should look at zimbraPrefWhenSentToAddresses
     * (deprecatedSince 5.0 in account)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=406)
    public void unsetPrefWhenSentToEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenSentToEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * TRUE if we should look at zimbraPrefWhenSentToAddresses
     * (deprecatedSince 5.0 in account)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=406)
    public Map<String,Object> unsetPrefWhenSentToEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefWhenSentToEnabled, "");
        return attrs;
    }

    /**
     * whether or not zimlet tree is expanded
     *
     * @return zimbraPrefZimletTreeOpen, or false if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=638)
    public boolean isPrefZimletTreeOpen() {
        return getBooleanAttr(Provisioning.A_zimbraPrefZimletTreeOpen, false, true);
    }

    /**
     * whether or not zimlet tree is expanded
     *
     * @param zimbraPrefZimletTreeOpen new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=638)
    public void setPrefZimletTreeOpen(boolean zimbraPrefZimletTreeOpen) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZimletTreeOpen, zimbraPrefZimletTreeOpen ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not zimlet tree is expanded
     *
     * @param zimbraPrefZimletTreeOpen new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=638)
    public Map<String,Object> setPrefZimletTreeOpen(boolean zimbraPrefZimletTreeOpen, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZimletTreeOpen, zimbraPrefZimletTreeOpen ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not zimlet tree is expanded
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=638)
    public void unsetPrefZimletTreeOpen() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZimletTreeOpen, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not zimlet tree is expanded
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=638)
    public Map<String,Object> unsetPrefZimletTreeOpen(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZimletTreeOpen, "");
        return attrs;
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @return zimbraPrefZimlets, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public String[] getPrefZimlets() {
        return getMultiAttr(Provisioning.A_zimbraPrefZimlets, true, true);
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @param zimbraPrefZimlets new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public void setPrefZimlets(String[] zimbraPrefZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZimlets, zimbraPrefZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @param zimbraPrefZimlets new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public Map<String,Object> setPrefZimlets(String[] zimbraPrefZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZimlets, zimbraPrefZimlets);
        return attrs;
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @param zimbraPrefZimlets new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public void addPrefZimlets(String zimbraPrefZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefZimlets, zimbraPrefZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @param zimbraPrefZimlets new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public Map<String,Object> addPrefZimlets(String zimbraPrefZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrefZimlets, zimbraPrefZimlets);
        return attrs;
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @param zimbraPrefZimlets existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public void removePrefZimlets(String zimbraPrefZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefZimlets, zimbraPrefZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @param zimbraPrefZimlets existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public Map<String,Object> removePrefZimlets(String zimbraPrefZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrefZimlets, zimbraPrefZimlets);
        return attrs;
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public void unsetPrefZimlets() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZimlets, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimlets user wants to see in the UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=765)
    public Map<String,Object> unsetPrefZimlets(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZimlets, "");
        return attrs;
    }

    /**
     * Option to turn on/off zimbra mobile gateway push notifications
     *
     * @return zimbraPrefZmgPushNotificationEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1952)
    public boolean isPrefZmgPushNotificationEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPrefZmgPushNotificationEnabled, false, true);
    }

    /**
     * Option to turn on/off zimbra mobile gateway push notifications
     *
     * @param zimbraPrefZmgPushNotificationEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1952)
    public void setPrefZmgPushNotificationEnabled(boolean zimbraPrefZmgPushNotificationEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZmgPushNotificationEnabled, zimbraPrefZmgPushNotificationEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Option to turn on/off zimbra mobile gateway push notifications
     *
     * @param zimbraPrefZmgPushNotificationEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1952)
    public Map<String,Object> setPrefZmgPushNotificationEnabled(boolean zimbraPrefZmgPushNotificationEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZmgPushNotificationEnabled, zimbraPrefZmgPushNotificationEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Option to turn on/off zimbra mobile gateway push notifications
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1952)
    public void unsetPrefZmgPushNotificationEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZmgPushNotificationEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Option to turn on/off zimbra mobile gateway push notifications
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1952)
    public Map<String,Object> unsetPrefZmgPushNotificationEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrefZmgPushNotificationEnabled, "");
        return attrs;
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @return zimbraPrimaryEmailChangeHistory, or empty array if unset
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public String[] getPrimaryEmailChangeHistory() {
        return getMultiAttr(Provisioning.A_zimbraPrimaryEmailChangeHistory, true, true);
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @param zimbraPrimaryEmailChangeHistory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public void setPrimaryEmailChangeHistory(String[] zimbraPrimaryEmailChangeHistory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrimaryEmailChangeHistory, zimbraPrimaryEmailChangeHistory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @param zimbraPrimaryEmailChangeHistory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public Map<String,Object> setPrimaryEmailChangeHistory(String[] zimbraPrimaryEmailChangeHistory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrimaryEmailChangeHistory, zimbraPrimaryEmailChangeHistory);
        return attrs;
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @param zimbraPrimaryEmailChangeHistory new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public void addPrimaryEmailChangeHistory(String zimbraPrimaryEmailChangeHistory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrimaryEmailChangeHistory, zimbraPrimaryEmailChangeHistory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @param zimbraPrimaryEmailChangeHistory new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public Map<String,Object> addPrimaryEmailChangeHistory(String zimbraPrimaryEmailChangeHistory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraPrimaryEmailChangeHistory, zimbraPrimaryEmailChangeHistory);
        return attrs;
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @param zimbraPrimaryEmailChangeHistory existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public void removePrimaryEmailChangeHistory(String zimbraPrimaryEmailChangeHistory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrimaryEmailChangeHistory, zimbraPrimaryEmailChangeHistory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @param zimbraPrimaryEmailChangeHistory existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public Map<String,Object> removePrimaryEmailChangeHistory(String zimbraPrimaryEmailChangeHistory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraPrimaryEmailChangeHistory, zimbraPrimaryEmailChangeHistory);
        return attrs;
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public void unsetPrimaryEmailChangeHistory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrimaryEmailChangeHistory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * timestamp of account rename and previous name of the account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=2144)
    public Map<String,Object> unsetPrimaryEmailChangeHistory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrimaryEmailChangeHistory, "");
        return attrs;
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @return zimbraProxyAllowedDomains, or empty array if unset
     */
    @ZAttr(id=294)
    public String[] getProxyAllowedDomains() {
        return getMultiAttr(Provisioning.A_zimbraProxyAllowedDomains, true, true);
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @param zimbraProxyAllowedDomains new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=294)
    public void setProxyAllowedDomains(String[] zimbraProxyAllowedDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProxyAllowedDomains, zimbraProxyAllowedDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @param zimbraProxyAllowedDomains new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=294)
    public Map<String,Object> setProxyAllowedDomains(String[] zimbraProxyAllowedDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProxyAllowedDomains, zimbraProxyAllowedDomains);
        return attrs;
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @param zimbraProxyAllowedDomains new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=294)
    public void addProxyAllowedDomains(String zimbraProxyAllowedDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraProxyAllowedDomains, zimbraProxyAllowedDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @param zimbraProxyAllowedDomains new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=294)
    public Map<String,Object> addProxyAllowedDomains(String zimbraProxyAllowedDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraProxyAllowedDomains, zimbraProxyAllowedDomains);
        return attrs;
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @param zimbraProxyAllowedDomains existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=294)
    public void removeProxyAllowedDomains(String zimbraProxyAllowedDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraProxyAllowedDomains, zimbraProxyAllowedDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @param zimbraProxyAllowedDomains existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=294)
    public Map<String,Object> removeProxyAllowedDomains(String zimbraProxyAllowedDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraProxyAllowedDomains, zimbraProxyAllowedDomains);
        return attrs;
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=294)
    public void unsetProxyAllowedDomains() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProxyAllowedDomains, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed domains for Proxy servlet
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=294)
    public Map<String,Object> unsetProxyAllowedDomains(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProxyAllowedDomains, "");
        return attrs;
    }

    /**
     * Maximum allowed lifetime of public shares. A value of 0 indicates that
     * there&#039;s no limit on a public share&#039;s lifetime. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getPublicShareLifetimeAsString to access value as a string.
     *
     * @see #getPublicShareLifetimeAsString()
     *
     * @return zimbraPublicShareLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1355)
    public long getPublicShareLifetime() {
        return getTimeInterval(Provisioning.A_zimbraPublicShareLifetime, 0L, true);
    }

    /**
     * Maximum allowed lifetime of public shares. A value of 0 indicates that
     * there&#039;s no limit on a public share&#039;s lifetime. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraPublicShareLifetime, or "0" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1355)
    public String getPublicShareLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraPublicShareLifetime, "0", true);
    }

    /**
     * Maximum allowed lifetime of public shares. A value of 0 indicates that
     * there&#039;s no limit on a public share&#039;s lifetime. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraPublicShareLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1355)
    public void setPublicShareLifetime(String zimbraPublicShareLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicShareLifetime, zimbraPublicShareLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of public shares. A value of 0 indicates that
     * there&#039;s no limit on a public share&#039;s lifetime. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraPublicShareLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1355)
    public Map<String,Object> setPublicShareLifetime(String zimbraPublicShareLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicShareLifetime, zimbraPublicShareLifetime);
        return attrs;
    }

    /**
     * Maximum allowed lifetime of public shares. A value of 0 indicates that
     * there&#039;s no limit on a public share&#039;s lifetime. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1355)
    public void unsetPublicShareLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicShareLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of public shares. A value of 0 indicates that
     * there&#039;s no limit on a public share&#039;s lifetime. . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1355)
    public Map<String,Object> unsetPublicShareLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicShareLifetime, "");
        return attrs;
    }

    /**
     * switch for turning public sharing on/off
     *
     * @return zimbraPublicSharingEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1351)
    public boolean isPublicSharingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPublicSharingEnabled, true, true);
    }

    /**
     * switch for turning public sharing on/off
     *
     * @param zimbraPublicSharingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1351)
    public void setPublicSharingEnabled(boolean zimbraPublicSharingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicSharingEnabled, zimbraPublicSharingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * switch for turning public sharing on/off
     *
     * @param zimbraPublicSharingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1351)
    public Map<String,Object> setPublicSharingEnabled(boolean zimbraPublicSharingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicSharingEnabled, zimbraPublicSharingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * switch for turning public sharing on/off
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1351)
    public void unsetPublicSharingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicSharingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * switch for turning public sharing on/off
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1351)
    public Map<String,Object> unsetPublicSharingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicSharingEnabled, "");
        return attrs;
    }

    /**
     * Last time a quota warning was sent.
     *
     * <p>Use getQuotaLastWarnTimeAsString to access value as a string.
     *
     * @see #getQuotaLastWarnTimeAsString()
     *
     * @return zimbraQuotaLastWarnTime as Date, null if unset or unable to parse
     */
    @ZAttr(id=484)
    public Date getQuotaLastWarnTime() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraQuotaLastWarnTime, null, true);
    }

    /**
     * Last time a quota warning was sent.
     *
     * @return zimbraQuotaLastWarnTime, or null if unset
     */
    @ZAttr(id=484)
    public String getQuotaLastWarnTimeAsString() {
        return getAttr(Provisioning.A_zimbraQuotaLastWarnTime, null, true);
    }

    /**
     * Last time a quota warning was sent.
     *
     * @param zimbraQuotaLastWarnTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=484)
    public void setQuotaLastWarnTime(Date zimbraQuotaLastWarnTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaLastWarnTime, zimbraQuotaLastWarnTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraQuotaLastWarnTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Last time a quota warning was sent.
     *
     * @param zimbraQuotaLastWarnTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=484)
    public Map<String,Object> setQuotaLastWarnTime(Date zimbraQuotaLastWarnTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaLastWarnTime, zimbraQuotaLastWarnTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraQuotaLastWarnTime));
        return attrs;
    }

    /**
     * Last time a quota warning was sent.
     *
     * @param zimbraQuotaLastWarnTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=484)
    public void setQuotaLastWarnTimeAsString(String zimbraQuotaLastWarnTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaLastWarnTime, zimbraQuotaLastWarnTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Last time a quota warning was sent.
     *
     * @param zimbraQuotaLastWarnTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=484)
    public Map<String,Object> setQuotaLastWarnTimeAsString(String zimbraQuotaLastWarnTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaLastWarnTime, zimbraQuotaLastWarnTime);
        return attrs;
    }

    /**
     * Last time a quota warning was sent.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=484)
    public void unsetQuotaLastWarnTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaLastWarnTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Last time a quota warning was sent.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=484)
    public Map<String,Object> unsetQuotaLastWarnTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaLastWarnTime, "");
        return attrs;
    }

    /**
     * Minimum duration of time between quota warnings.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getQuotaWarnIntervalAsString to access value as a string.
     *
     * @see #getQuotaWarnIntervalAsString()
     *
     * @return zimbraQuotaWarnInterval in millseconds, or 86400000 (1d)  if unset
     */
    @ZAttr(id=485)
    public long getQuotaWarnInterval() {
        return getTimeInterval(Provisioning.A_zimbraQuotaWarnInterval, 86400000L, true);
    }

    /**
     * Minimum duration of time between quota warnings.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraQuotaWarnInterval, or "1d" if unset
     */
    @ZAttr(id=485)
    public String getQuotaWarnIntervalAsString() {
        return getAttr(Provisioning.A_zimbraQuotaWarnInterval, "1d", true);
    }

    /**
     * Minimum duration of time between quota warnings.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraQuotaWarnInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=485)
    public void setQuotaWarnInterval(String zimbraQuotaWarnInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnInterval, zimbraQuotaWarnInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum duration of time between quota warnings.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraQuotaWarnInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=485)
    public Map<String,Object> setQuotaWarnInterval(String zimbraQuotaWarnInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnInterval, zimbraQuotaWarnInterval);
        return attrs;
    }

    /**
     * Minimum duration of time between quota warnings.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=485)
    public void unsetQuotaWarnInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum duration of time between quota warnings.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=485)
    public Map<String,Object> unsetQuotaWarnInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnInterval, "");
        return attrs;
    }

    /**
     * Quota warning message template.
     *
     * @return zimbraQuotaWarnMessage, or "From: Postmaster <postmaster@${RECIPIENT_DOMAIN}>${NEWLINE}To: ${RECIPIENT_NAME} <${RECIPIENT_ADDRESS}>${NEWLINE}Subject: Quota warning${NEWLINE}Date: ${DATE}${NEWLINE}Content-Type: text/plain${NEWLINE}${NEWLINE}Your mailbox size has reached ${MBOX_SIZE_MB}MB, which is over ${WARN_PERCENT}% of your ${QUOTA_MB}MB quota.${NEWLINE}Please delete some messages to avoid exceeding your quota.${NEWLINE}" if unset
     */
    @ZAttr(id=486)
    public String getQuotaWarnMessage() {
        return getAttr(Provisioning.A_zimbraQuotaWarnMessage, "From: Postmaster <postmaster@${RECIPIENT_DOMAIN}>${NEWLINE}To: ${RECIPIENT_NAME} <${RECIPIENT_ADDRESS}>${NEWLINE}Subject: Quota warning${NEWLINE}Date: ${DATE}${NEWLINE}Content-Type: text/plain${NEWLINE}${NEWLINE}Your mailbox size has reached ${MBOX_SIZE_MB}MB, which is over ${WARN_PERCENT}% of your ${QUOTA_MB}MB quota.${NEWLINE}Please delete some messages to avoid exceeding your quota.${NEWLINE}", true);
    }

    /**
     * Quota warning message template.
     *
     * @param zimbraQuotaWarnMessage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=486)
    public void setQuotaWarnMessage(String zimbraQuotaWarnMessage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnMessage, zimbraQuotaWarnMessage);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Quota warning message template.
     *
     * @param zimbraQuotaWarnMessage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=486)
    public Map<String,Object> setQuotaWarnMessage(String zimbraQuotaWarnMessage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnMessage, zimbraQuotaWarnMessage);
        return attrs;
    }

    /**
     * Quota warning message template.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=486)
    public void unsetQuotaWarnMessage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnMessage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Quota warning message template.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=486)
    public Map<String,Object> unsetQuotaWarnMessage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnMessage, "");
        return attrs;
    }

    /**
     * Threshold for quota warning messages.
     *
     * @return zimbraQuotaWarnPercent, or 90 if unset
     */
    @ZAttr(id=483)
    public int getQuotaWarnPercent() {
        return getIntAttr(Provisioning.A_zimbraQuotaWarnPercent, 90, true);
    }

    /**
     * Threshold for quota warning messages.
     *
     * @param zimbraQuotaWarnPercent new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=483)
    public void setQuotaWarnPercent(int zimbraQuotaWarnPercent) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnPercent, Integer.toString(zimbraQuotaWarnPercent));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Threshold for quota warning messages.
     *
     * @param zimbraQuotaWarnPercent new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=483)
    public Map<String,Object> setQuotaWarnPercent(int zimbraQuotaWarnPercent, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnPercent, Integer.toString(zimbraQuotaWarnPercent));
        return attrs;
    }

    /**
     * Threshold for quota warning messages.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=483)
    public void unsetQuotaWarnPercent() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnPercent, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Threshold for quota warning messages.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=483)
    public Map<String,Object> unsetQuotaWarnPercent(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraQuotaWarnPercent, "");
        return attrs;
    }

    /**
     * Expiry time for recovery email code verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getRecoveryAccountCodeValidityAsString to access value as a string.
     *
     * @see #getRecoveryAccountCodeValidityAsString()
     *
     * @return zimbraRecoveryAccountCodeValidity in millseconds, or 86400000 (1d)  if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2140)
    public long getRecoveryAccountCodeValidity() {
        return getTimeInterval(Provisioning.A_zimbraRecoveryAccountCodeValidity, 86400000L, true);
    }

    /**
     * Expiry time for recovery email code verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraRecoveryAccountCodeValidity, or "1d" if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2140)
    public String getRecoveryAccountCodeValidityAsString() {
        return getAttr(Provisioning.A_zimbraRecoveryAccountCodeValidity, "1d", true);
    }

    /**
     * Expiry time for recovery email code verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraRecoveryAccountCodeValidity new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2140)
    public void setRecoveryAccountCodeValidity(String zimbraRecoveryAccountCodeValidity) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRecoveryAccountCodeValidity, zimbraRecoveryAccountCodeValidity);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Expiry time for recovery email code verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraRecoveryAccountCodeValidity new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2140)
    public Map<String,Object> setRecoveryAccountCodeValidity(String zimbraRecoveryAccountCodeValidity, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRecoveryAccountCodeValidity, zimbraRecoveryAccountCodeValidity);
        return attrs;
    }

    /**
     * Expiry time for recovery email code verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2140)
    public void unsetRecoveryAccountCodeValidity() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRecoveryAccountCodeValidity, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Expiry time for recovery email code verification. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2140)
    public Map<String,Object> unsetRecoveryAccountCodeValidity(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRecoveryAccountCodeValidity, "");
        return attrs;
    }

    /**
     * Recovery email verification data
     *
     * @return zimbraRecoveryAccountVerificationData, or null if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2139)
    public String getRecoveryAccountVerificationData() {
        return getAttr(Provisioning.A_zimbraRecoveryAccountVerificationData, null, true);
    }

    /**
     * Recovery email verification data
     *
     * @param zimbraRecoveryAccountVerificationData new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2139)
    public void setRecoveryAccountVerificationData(String zimbraRecoveryAccountVerificationData) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRecoveryAccountVerificationData, zimbraRecoveryAccountVerificationData);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Recovery email verification data
     *
     * @param zimbraRecoveryAccountVerificationData new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2139)
    public Map<String,Object> setRecoveryAccountVerificationData(String zimbraRecoveryAccountVerificationData, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRecoveryAccountVerificationData, zimbraRecoveryAccountVerificationData);
        return attrs;
    }

    /**
     * Recovery email verification data
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2139)
    public void unsetRecoveryAccountVerificationData() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRecoveryAccountVerificationData, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Recovery email verification data
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2139)
    public Map<String,Object> unsetRecoveryAccountVerificationData(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRecoveryAccountVerificationData, "");
        return attrs;
    }

    /**
     * Recovery code sent to recovery email address
     *
     * @return zimbraResetPasswordRecoveryCode, or null if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2137)
    public String getResetPasswordRecoveryCode() {
        return getAttr(Provisioning.A_zimbraResetPasswordRecoveryCode, null, true);
    }

    /**
     * Recovery code sent to recovery email address
     *
     * @param zimbraResetPasswordRecoveryCode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2137)
    public void setResetPasswordRecoveryCode(String zimbraResetPasswordRecoveryCode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResetPasswordRecoveryCode, zimbraResetPasswordRecoveryCode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Recovery code sent to recovery email address
     *
     * @param zimbraResetPasswordRecoveryCode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2137)
    public Map<String,Object> setResetPasswordRecoveryCode(String zimbraResetPasswordRecoveryCode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResetPasswordRecoveryCode, zimbraResetPasswordRecoveryCode);
        return attrs;
    }

    /**
     * Recovery code sent to recovery email address
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2137)
    public void unsetResetPasswordRecoveryCode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResetPasswordRecoveryCode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Recovery code sent to recovery email address
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2137)
    public Map<String,Object> unsetResetPasswordRecoveryCode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResetPasswordRecoveryCode, "");
        return attrs;
    }

    /**
     * Expiry time for password reset recovery code. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getResetPasswordRecoveryCodeExpiryAsString to access value as a string.
     *
     * @see #getResetPasswordRecoveryCodeExpiryAsString()
     *
     * @return zimbraResetPasswordRecoveryCodeExpiry in millseconds, or 600000 (10m)  if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2138)
    public long getResetPasswordRecoveryCodeExpiry() {
        return getTimeInterval(Provisioning.A_zimbraResetPasswordRecoveryCodeExpiry, 600000L, true);
    }

    /**
     * Expiry time for password reset recovery code. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraResetPasswordRecoveryCodeExpiry, or "10m" if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2138)
    public String getResetPasswordRecoveryCodeExpiryAsString() {
        return getAttr(Provisioning.A_zimbraResetPasswordRecoveryCodeExpiry, "10m", true);
    }

    /**
     * Expiry time for password reset recovery code. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraResetPasswordRecoveryCodeExpiry new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2138)
    public void setResetPasswordRecoveryCodeExpiry(String zimbraResetPasswordRecoveryCodeExpiry) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResetPasswordRecoveryCodeExpiry, zimbraResetPasswordRecoveryCodeExpiry);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Expiry time for password reset recovery code. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraResetPasswordRecoveryCodeExpiry new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2138)
    public Map<String,Object> setResetPasswordRecoveryCodeExpiry(String zimbraResetPasswordRecoveryCodeExpiry, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResetPasswordRecoveryCodeExpiry, zimbraResetPasswordRecoveryCodeExpiry);
        return attrs;
    }

    /**
     * Expiry time for password reset recovery code. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2138)
    public void unsetResetPasswordRecoveryCodeExpiry() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResetPasswordRecoveryCodeExpiry, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Expiry time for password reset recovery code. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=2138)
    public Map<String,Object> unsetResetPasswordRecoveryCodeExpiry(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResetPasswordRecoveryCodeExpiry, "");
        return attrs;
    }

    /**
     * There is a deployment scenario for migrations where all of the
     * customers users are pointed at the zimbra POP IMAP reverse proxy. We
     * then want their connections proxied back to the legacy system for
     * not-yet-non-migrated users. If this attribute is TRUE, reverse proxy
     * lookup servlet should check to see if zimbraExternal* is set on the
     * domain. If so it is used. If not, lookup proceeds as usual.
     *
     * @return zimbraReverseProxyUseExternalRoute, or false if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=779)
    public boolean isReverseProxyUseExternalRoute() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyUseExternalRoute, false, true);
    }

    /**
     * There is a deployment scenario for migrations where all of the
     * customers users are pointed at the zimbra POP IMAP reverse proxy. We
     * then want their connections proxied back to the legacy system for
     * not-yet-non-migrated users. If this attribute is TRUE, reverse proxy
     * lookup servlet should check to see if zimbraExternal* is set on the
     * domain. If so it is used. If not, lookup proceeds as usual.
     *
     * @param zimbraReverseProxyUseExternalRoute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=779)
    public void setReverseProxyUseExternalRoute(boolean zimbraReverseProxyUseExternalRoute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUseExternalRoute, zimbraReverseProxyUseExternalRoute ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * There is a deployment scenario for migrations where all of the
     * customers users are pointed at the zimbra POP IMAP reverse proxy. We
     * then want their connections proxied back to the legacy system for
     * not-yet-non-migrated users. If this attribute is TRUE, reverse proxy
     * lookup servlet should check to see if zimbraExternal* is set on the
     * domain. If so it is used. If not, lookup proceeds as usual.
     *
     * @param zimbraReverseProxyUseExternalRoute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=779)
    public Map<String,Object> setReverseProxyUseExternalRoute(boolean zimbraReverseProxyUseExternalRoute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUseExternalRoute, zimbraReverseProxyUseExternalRoute ? TRUE : FALSE);
        return attrs;
    }

    /**
     * There is a deployment scenario for migrations where all of the
     * customers users are pointed at the zimbra POP IMAP reverse proxy. We
     * then want their connections proxied back to the legacy system for
     * not-yet-non-migrated users. If this attribute is TRUE, reverse proxy
     * lookup servlet should check to see if zimbraExternal* is set on the
     * domain. If so it is used. If not, lookup proceeds as usual.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=779)
    public void unsetReverseProxyUseExternalRoute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUseExternalRoute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * There is a deployment scenario for migrations where all of the
     * customers users are pointed at the zimbra POP IMAP reverse proxy. We
     * then want their connections proxied back to the legacy system for
     * not-yet-non-migrated users. If this attribute is TRUE, reverse proxy
     * lookup servlet should check to see if zimbraExternal* is set on the
     * domain. If so it is used. If not, lookup proceeds as usual.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=779)
    public Map<String,Object> unsetReverseProxyUseExternalRoute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUseExternalRoute, "");
        return attrs;
    }

    /**
     * whether or not to revoke app-specific passwords when the main password
     * is changed
     *
     * @return zimbraRevokeAppSpecificPasswordsOnPasswordChange, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1838)
    public boolean isRevokeAppSpecificPasswordsOnPasswordChange() {
        return getBooleanAttr(Provisioning.A_zimbraRevokeAppSpecificPasswordsOnPasswordChange, true, true);
    }

    /**
     * whether or not to revoke app-specific passwords when the main password
     * is changed
     *
     * @param zimbraRevokeAppSpecificPasswordsOnPasswordChange new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1838)
    public void setRevokeAppSpecificPasswordsOnPasswordChange(boolean zimbraRevokeAppSpecificPasswordsOnPasswordChange) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRevokeAppSpecificPasswordsOnPasswordChange, zimbraRevokeAppSpecificPasswordsOnPasswordChange ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to revoke app-specific passwords when the main password
     * is changed
     *
     * @param zimbraRevokeAppSpecificPasswordsOnPasswordChange new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1838)
    public Map<String,Object> setRevokeAppSpecificPasswordsOnPasswordChange(boolean zimbraRevokeAppSpecificPasswordsOnPasswordChange, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRevokeAppSpecificPasswordsOnPasswordChange, zimbraRevokeAppSpecificPasswordsOnPasswordChange ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to revoke app-specific passwords when the main password
     * is changed
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1838)
    public void unsetRevokeAppSpecificPasswordsOnPasswordChange() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRevokeAppSpecificPasswordsOnPasswordChange, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to revoke app-specific passwords when the main password
     * is changed
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1838)
    public Map<String,Object> unsetRevokeAppSpecificPasswordsOnPasswordChange(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRevokeAppSpecificPasswordsOnPasswordChange, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @return zimbraShareInfo, or empty array if unset
     */
    @ZAttr(id=357)
    public String[] getShareInfo() {
        return getMultiAttr(Provisioning.A_zimbraShareInfo, true, true);
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @param zimbraShareInfo new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=357)
    public void setShareInfo(String[] zimbraShareInfo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareInfo, zimbraShareInfo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @param zimbraShareInfo new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=357)
    public Map<String,Object> setShareInfo(String[] zimbraShareInfo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareInfo, zimbraShareInfo);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @param zimbraShareInfo new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=357)
    public void addShareInfo(String zimbraShareInfo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraShareInfo, zimbraShareInfo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @param zimbraShareInfo new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=357)
    public Map<String,Object> addShareInfo(String zimbraShareInfo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraShareInfo, zimbraShareInfo);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @param zimbraShareInfo existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=357)
    public void removeShareInfo(String zimbraShareInfo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraShareInfo, zimbraShareInfo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @param zimbraShareInfo existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=357)
    public Map<String,Object> removeShareInfo(String zimbraShareInfo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraShareInfo, zimbraShareInfo);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=357)
    public void unsetShareInfo() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareInfo, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Manual publishing of shares by admin is no
     * longer required since now automated publishing of sharing info updates
     * to LDAP is supported. Orig desc: items an account or group has shared
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=357)
    public Map<String,Object> unsetShareInfo(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareInfo, "");
        return attrs;
    }

    /**
     * Maximum allowed lifetime of shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getShareLifetimeAsString to access value as a string.
     *
     * @see #getShareLifetimeAsString()
     *
     * @return zimbraShareLifetime in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1348)
    public long getShareLifetime() {
        return getTimeInterval(Provisioning.A_zimbraShareLifetime, 0L, true);
    }

    /**
     * Maximum allowed lifetime of shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraShareLifetime, or "0" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1348)
    public String getShareLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraShareLifetime, "0", true);
    }

    /**
     * Maximum allowed lifetime of shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraShareLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1348)
    public void setShareLifetime(String zimbraShareLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareLifetime, zimbraShareLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraShareLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1348)
    public Map<String,Object> setShareLifetime(String zimbraShareLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareLifetime, zimbraShareLifetime);
        return attrs;
    }

    /**
     * Maximum allowed lifetime of shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1348)
    public void unsetShareLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum allowed lifetime of shares to internal users or groups. A
     * value of 0 indicates that there&#039;s no limit on an internal
     * share&#039;s lifetime. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1348)
    public Map<String,Object> unsetShareLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareLifetime, "");
        return attrs;
    }

    /**
     * All items an account has shared
     *
     * @return zimbraSharedItem, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public String[] getSharedItem() {
        return getMultiAttr(Provisioning.A_zimbraSharedItem, true, true);
    }

    /**
     * All items an account has shared
     *
     * @param zimbraSharedItem new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public void setSharedItem(String[] zimbraSharedItem) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharedItem, zimbraSharedItem);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * All items an account has shared
     *
     * @param zimbraSharedItem new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public Map<String,Object> setSharedItem(String[] zimbraSharedItem, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharedItem, zimbraSharedItem);
        return attrs;
    }

    /**
     * All items an account has shared
     *
     * @param zimbraSharedItem new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public void addSharedItem(String zimbraSharedItem) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSharedItem, zimbraSharedItem);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * All items an account has shared
     *
     * @param zimbraSharedItem new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public Map<String,Object> addSharedItem(String zimbraSharedItem, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSharedItem, zimbraSharedItem);
        return attrs;
    }

    /**
     * All items an account has shared
     *
     * @param zimbraSharedItem existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public void removeSharedItem(String zimbraSharedItem) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSharedItem, zimbraSharedItem);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * All items an account has shared
     *
     * @param zimbraSharedItem existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public Map<String,Object> removeSharedItem(String zimbraSharedItem, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSharedItem, zimbraSharedItem);
        return attrs;
    }

    /**
     * All items an account has shared
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public void unsetSharedItem() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharedItem, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * All items an account has shared
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1219)
    public Map<String,Object> unsetSharedItem(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharedItem, "");
        return attrs;
    }

    /**
     * whether or not to show client Terms of Service
     *
     * @return zimbraShowClientTOS, or false if unset
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3067)
    public boolean isShowClientTOS() {
        return getBooleanAttr(Provisioning.A_zimbraShowClientTOS, false, true);
    }

    /**
     * whether or not to show client Terms of Service
     *
     * @param zimbraShowClientTOS new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3067)
    public void setShowClientTOS(boolean zimbraShowClientTOS) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShowClientTOS, zimbraShowClientTOS ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to show client Terms of Service
     *
     * @param zimbraShowClientTOS new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3067)
    public Map<String,Object> setShowClientTOS(boolean zimbraShowClientTOS, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShowClientTOS, zimbraShowClientTOS ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to show client Terms of Service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3067)
    public void unsetShowClientTOS() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShowClientTOS, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to show client Terms of Service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3067)
    public Map<String,Object> unsetShowClientTOS(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShowClientTOS, "");
        return attrs;
    }

    /**
     * Whether edit header commands in admin sieve scripts are enabled or
     * disabled. If TRUE, the addheader, deleteheader and replaceheader
     * commands will be executed during admin sieve script execution.
     *
     * @return zimbraSieveEditHeaderEnabled, or false if unset
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2121)
    public boolean isSieveEditHeaderEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraSieveEditHeaderEnabled, false, true);
    }

    /**
     * Whether edit header commands in admin sieve scripts are enabled or
     * disabled. If TRUE, the addheader, deleteheader and replaceheader
     * commands will be executed during admin sieve script execution.
     *
     * @param zimbraSieveEditHeaderEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2121)
    public void setSieveEditHeaderEnabled(boolean zimbraSieveEditHeaderEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveEditHeaderEnabled, zimbraSieveEditHeaderEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether edit header commands in admin sieve scripts are enabled or
     * disabled. If TRUE, the addheader, deleteheader and replaceheader
     * commands will be executed during admin sieve script execution.
     *
     * @param zimbraSieveEditHeaderEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2121)
    public Map<String,Object> setSieveEditHeaderEnabled(boolean zimbraSieveEditHeaderEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveEditHeaderEnabled, zimbraSieveEditHeaderEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether edit header commands in admin sieve scripts are enabled or
     * disabled. If TRUE, the addheader, deleteheader and replaceheader
     * commands will be executed during admin sieve script execution.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2121)
    public void unsetSieveEditHeaderEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveEditHeaderEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether edit header commands in admin sieve scripts are enabled or
     * disabled. If TRUE, the addheader, deleteheader and replaceheader
     * commands will be executed during admin sieve script execution.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2121)
    public Map<String,Object> unsetSieveEditHeaderEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveEditHeaderEnabled, "");
        return attrs;
    }

    /**
     * Comma separated list of sieve immutable headers
     *
     * @return zimbraSieveImmutableHeaders, or "Received,DKIM-Signature,Authentication-Results,Received-SPF,Message-ID,Content-Type,Content-Disposition,Content-Transfer-Encoding,MIME-Version,Auto-Submitted" if unset
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2122)
    public String getSieveImmutableHeaders() {
        return getAttr(Provisioning.A_zimbraSieveImmutableHeaders, "Received,DKIM-Signature,Authentication-Results,Received-SPF,Message-ID,Content-Type,Content-Disposition,Content-Transfer-Encoding,MIME-Version,Auto-Submitted", true);
    }

    /**
     * Comma separated list of sieve immutable headers
     *
     * @param zimbraSieveImmutableHeaders new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2122)
    public void setSieveImmutableHeaders(String zimbraSieveImmutableHeaders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveImmutableHeaders, zimbraSieveImmutableHeaders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Comma separated list of sieve immutable headers
     *
     * @param zimbraSieveImmutableHeaders new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2122)
    public Map<String,Object> setSieveImmutableHeaders(String zimbraSieveImmutableHeaders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveImmutableHeaders, zimbraSieveImmutableHeaders);
        return attrs;
    }

    /**
     * Comma separated list of sieve immutable headers
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2122)
    public void unsetSieveImmutableHeaders() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveImmutableHeaders, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Comma separated list of sieve immutable headers
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2122)
    public Map<String,Object> unsetSieveImmutableHeaders(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveImmutableHeaders, "");
        return attrs;
    }

    /**
     * Whether the RFC compliant &#039;notify&#039; is used. If TRUE, ZCS
     * parses the &#039;notify&#039; action parameters based on the syntax
     * defined by the RFC 5435 and 5436. If FALSE, ZCS treats the
     * &#039;notify&#039; action parameters with Zimbra specific format
     *
     * @return zimbraSieveNotifyActionRFCCompliant, or false if unset
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2112)
    public boolean isSieveNotifyActionRFCCompliant() {
        return getBooleanAttr(Provisioning.A_zimbraSieveNotifyActionRFCCompliant, false, true);
    }

    /**
     * Whether the RFC compliant &#039;notify&#039; is used. If TRUE, ZCS
     * parses the &#039;notify&#039; action parameters based on the syntax
     * defined by the RFC 5435 and 5436. If FALSE, ZCS treats the
     * &#039;notify&#039; action parameters with Zimbra specific format
     *
     * @param zimbraSieveNotifyActionRFCCompliant new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2112)
    public void setSieveNotifyActionRFCCompliant(boolean zimbraSieveNotifyActionRFCCompliant) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveNotifyActionRFCCompliant, zimbraSieveNotifyActionRFCCompliant ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the RFC compliant &#039;notify&#039; is used. If TRUE, ZCS
     * parses the &#039;notify&#039; action parameters based on the syntax
     * defined by the RFC 5435 and 5436. If FALSE, ZCS treats the
     * &#039;notify&#039; action parameters with Zimbra specific format
     *
     * @param zimbraSieveNotifyActionRFCCompliant new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2112)
    public Map<String,Object> setSieveNotifyActionRFCCompliant(boolean zimbraSieveNotifyActionRFCCompliant, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveNotifyActionRFCCompliant, zimbraSieveNotifyActionRFCCompliant ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether the RFC compliant &#039;notify&#039; is used. If TRUE, ZCS
     * parses the &#039;notify&#039; action parameters based on the syntax
     * defined by the RFC 5435 and 5436. If FALSE, ZCS treats the
     * &#039;notify&#039; action parameters with Zimbra specific format
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2112)
    public void unsetSieveNotifyActionRFCCompliant() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveNotifyActionRFCCompliant, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the RFC compliant &#039;notify&#039; is used. If TRUE, ZCS
     * parses the &#039;notify&#039; action parameters based on the syntax
     * defined by the RFC 5435 and 5436. If FALSE, ZCS treats the
     * &#039;notify&#039; action parameters with Zimbra specific format
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2112)
    public Map<String,Object> unsetSieveNotifyActionRFCCompliant(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveNotifyActionRFCCompliant, "");
        return attrs;
    }

    /**
     * Whether to enable the Sieve &quot;reject&quot; action defined in RFC
     * 5429.
     *
     * @return zimbraSieveRejectMailEnabled, or true if unset
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2111)
    public boolean isSieveRejectMailEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraSieveRejectMailEnabled, true, true);
    }

    /**
     * Whether to enable the Sieve &quot;reject&quot; action defined in RFC
     * 5429.
     *
     * @param zimbraSieveRejectMailEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2111)
    public void setSieveRejectMailEnabled(boolean zimbraSieveRejectMailEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRejectMailEnabled, zimbraSieveRejectMailEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable the Sieve &quot;reject&quot; action defined in RFC
     * 5429.
     *
     * @param zimbraSieveRejectMailEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2111)
    public Map<String,Object> setSieveRejectMailEnabled(boolean zimbraSieveRejectMailEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRejectMailEnabled, zimbraSieveRejectMailEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable the Sieve &quot;reject&quot; action defined in RFC
     * 5429.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2111)
    public void unsetSieveRejectMailEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRejectMailEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable the Sieve &quot;reject&quot; action defined in RFC
     * 5429.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.8
     */
    @ZAttr(id=2111)
    public Map<String,Object> unsetSieveRejectMailEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRejectMailEnabled, "");
        return attrs;
    }

    /**
     * Whether the declaration of the Sieve extension feature is mandatory by
     * the &#039;require&#039; control. If TRUE, before ZCS evaluates a Sieve
     * extension test or action, it checks the corresponding capability
     * string at &#039;require&#039; control; and if the capability string is
     * not declared in the &#039;require&#039;, the entire Sieve filter
     * execution will be failed. If FALSE, any Sieve extensions can be used
     * without declaring the capability string in the &#039;require&#039;
     * control.
     *
     * @return zimbraSieveRequireControlEnabled, or true if unset
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2120)
    public boolean isSieveRequireControlEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraSieveRequireControlEnabled, true, true);
    }

    /**
     * Whether the declaration of the Sieve extension feature is mandatory by
     * the &#039;require&#039; control. If TRUE, before ZCS evaluates a Sieve
     * extension test or action, it checks the corresponding capability
     * string at &#039;require&#039; control; and if the capability string is
     * not declared in the &#039;require&#039;, the entire Sieve filter
     * execution will be failed. If FALSE, any Sieve extensions can be used
     * without declaring the capability string in the &#039;require&#039;
     * control.
     *
     * @param zimbraSieveRequireControlEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2120)
    public void setSieveRequireControlEnabled(boolean zimbraSieveRequireControlEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRequireControlEnabled, zimbraSieveRequireControlEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the declaration of the Sieve extension feature is mandatory by
     * the &#039;require&#039; control. If TRUE, before ZCS evaluates a Sieve
     * extension test or action, it checks the corresponding capability
     * string at &#039;require&#039; control; and if the capability string is
     * not declared in the &#039;require&#039;, the entire Sieve filter
     * execution will be failed. If FALSE, any Sieve extensions can be used
     * without declaring the capability string in the &#039;require&#039;
     * control.
     *
     * @param zimbraSieveRequireControlEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2120)
    public Map<String,Object> setSieveRequireControlEnabled(boolean zimbraSieveRequireControlEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRequireControlEnabled, zimbraSieveRequireControlEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether the declaration of the Sieve extension feature is mandatory by
     * the &#039;require&#039; control. If TRUE, before ZCS evaluates a Sieve
     * extension test or action, it checks the corresponding capability
     * string at &#039;require&#039; control; and if the capability string is
     * not declared in the &#039;require&#039;, the entire Sieve filter
     * execution will be failed. If FALSE, any Sieve extensions can be used
     * without declaring the capability string in the &#039;require&#039;
     * control.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2120)
    public void unsetSieveRequireControlEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRequireControlEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the declaration of the Sieve extension feature is mandatory by
     * the &#039;require&#039; control. If TRUE, before ZCS evaluates a Sieve
     * extension test or action, it checks the corresponding capability
     * string at &#039;require&#039; control; and if the capability string is
     * not declared in the &#039;require&#039;, the entire Sieve filter
     * execution will be failed. If FALSE, any Sieve extensions can be used
     * without declaring the capability string in the &#039;require&#039;
     * control.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.4
     */
    @ZAttr(id=2120)
    public Map<String,Object> unsetSieveRequireControlEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRequireControlEnabled, "");
        return attrs;
    }

    /**
     * Unique ID for an signature
     *
     * @return zimbraSignatureId, or null if unset
     */
    @ZAttr(id=490)
    public String getSignatureId() {
        return getAttr(Provisioning.A_zimbraSignatureId, null, true);
    }

    /**
     * Unique ID for an signature
     *
     * @param zimbraSignatureId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=490)
    public void setSignatureId(String zimbraSignatureId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureId, zimbraSignatureId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Unique ID for an signature
     *
     * @param zimbraSignatureId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=490)
    public Map<String,Object> setSignatureId(String zimbraSignatureId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureId, zimbraSignatureId);
        return attrs;
    }

    /**
     * Unique ID for an signature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=490)
    public void unsetSignatureId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Unique ID for an signature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=490)
    public Map<String,Object> unsetSignatureId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureId, "");
        return attrs;
    }

    /**
     * maximum number of signatures allowed on an account
     *
     * @return zimbraSignatureMaxNumEntries, or 20 if unset
     */
    @ZAttr(id=493)
    public int getSignatureMaxNumEntries() {
        return getIntAttr(Provisioning.A_zimbraSignatureMaxNumEntries, 20, true);
    }

    /**
     * maximum number of signatures allowed on an account
     *
     * @param zimbraSignatureMaxNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=493)
    public void setSignatureMaxNumEntries(int zimbraSignatureMaxNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureMaxNumEntries, Integer.toString(zimbraSignatureMaxNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of signatures allowed on an account
     *
     * @param zimbraSignatureMaxNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=493)
    public Map<String,Object> setSignatureMaxNumEntries(int zimbraSignatureMaxNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureMaxNumEntries, Integer.toString(zimbraSignatureMaxNumEntries));
        return attrs;
    }

    /**
     * maximum number of signatures allowed on an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=493)
    public void unsetSignatureMaxNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureMaxNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of signatures allowed on an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=493)
    public Map<String,Object> unsetSignatureMaxNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureMaxNumEntries, "");
        return attrs;
    }

    /**
     * minimum number of signatures allowed on an account, this is only used
     * in the client
     *
     * @return zimbraSignatureMinNumEntries, or 1 if unset
     */
    @ZAttr(id=523)
    public int getSignatureMinNumEntries() {
        return getIntAttr(Provisioning.A_zimbraSignatureMinNumEntries, 1, true);
    }

    /**
     * minimum number of signatures allowed on an account, this is only used
     * in the client
     *
     * @param zimbraSignatureMinNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=523)
    public void setSignatureMinNumEntries(int zimbraSignatureMinNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureMinNumEntries, Integer.toString(zimbraSignatureMinNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of signatures allowed on an account, this is only used
     * in the client
     *
     * @param zimbraSignatureMinNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=523)
    public Map<String,Object> setSignatureMinNumEntries(int zimbraSignatureMinNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureMinNumEntries, Integer.toString(zimbraSignatureMinNumEntries));
        return attrs;
    }

    /**
     * minimum number of signatures allowed on an account, this is only used
     * in the client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=523)
    public void unsetSignatureMinNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureMinNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum number of signatures allowed on an account, this is only used
     * in the client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=523)
    public Map<String,Object> unsetSignatureMinNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureMinNumEntries, "");
        return attrs;
    }

    /**
     * name of the signature
     *
     * @return zimbraSignatureName, or null if unset
     */
    @ZAttr(id=491)
    public String getSignatureName() {
        return getAttr(Provisioning.A_zimbraSignatureName, null, true);
    }

    /**
     * name of the signature
     *
     * @param zimbraSignatureName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=491)
    public void setSignatureName(String zimbraSignatureName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureName, zimbraSignatureName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name of the signature
     *
     * @param zimbraSignatureName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=491)
    public Map<String,Object> setSignatureName(String zimbraSignatureName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureName, zimbraSignatureName);
        return attrs;
    }

    /**
     * name of the signature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=491)
    public void unsetSignatureName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name of the signature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=491)
    public Map<String,Object> unsetSignatureName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSignatureName, "");
        return attrs;
    }

    /**
     * Whether to enable smtp debug trace
     *
     * @return zimbraSmtpEnableTrace, or false if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=793)
    public boolean isSmtpEnableTrace() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpEnableTrace, false, true);
    }

    /**
     * Whether to enable smtp debug trace
     *
     * @param zimbraSmtpEnableTrace new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=793)
    public void setSmtpEnableTrace(boolean zimbraSmtpEnableTrace) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableTrace, zimbraSmtpEnableTrace ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable smtp debug trace
     *
     * @param zimbraSmtpEnableTrace new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=793)
    public Map<String,Object> setSmtpEnableTrace(boolean zimbraSmtpEnableTrace, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableTrace, zimbraSmtpEnableTrace ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable smtp debug trace
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=793)
    public void unsetSmtpEnableTrace() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableTrace, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable smtp debug trace
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=793)
    public Map<String,Object> unsetSmtpEnableTrace(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpEnableTrace, "");
        return attrs;
    }

    /**
     * If TRUE, the address for MAIL FROM in the SMTP session will always be
     * set to the email address of the account. If FALSE, the address will be
     * the value of the Sender or From header in the outgoing message, in
     * that order.
     *
     * @return zimbraSmtpRestrictEnvelopeFrom, or true if unset
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1077)
    public boolean isSmtpRestrictEnvelopeFrom() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpRestrictEnvelopeFrom, true, true);
    }

    /**
     * If TRUE, the address for MAIL FROM in the SMTP session will always be
     * set to the email address of the account. If FALSE, the address will be
     * the value of the Sender or From header in the outgoing message, in
     * that order.
     *
     * @param zimbraSmtpRestrictEnvelopeFrom new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1077)
    public void setSmtpRestrictEnvelopeFrom(boolean zimbraSmtpRestrictEnvelopeFrom) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpRestrictEnvelopeFrom, zimbraSmtpRestrictEnvelopeFrom ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, the address for MAIL FROM in the SMTP session will always be
     * set to the email address of the account. If FALSE, the address will be
     * the value of the Sender or From header in the outgoing message, in
     * that order.
     *
     * @param zimbraSmtpRestrictEnvelopeFrom new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1077)
    public Map<String,Object> setSmtpRestrictEnvelopeFrom(boolean zimbraSmtpRestrictEnvelopeFrom, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpRestrictEnvelopeFrom, zimbraSmtpRestrictEnvelopeFrom ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, the address for MAIL FROM in the SMTP session will always be
     * set to the email address of the account. If FALSE, the address will be
     * the value of the Sender or From header in the outgoing message, in
     * that order.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1077)
    public void unsetSmtpRestrictEnvelopeFrom() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpRestrictEnvelopeFrom, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, the address for MAIL FROM in the SMTP session will always be
     * set to the email address of the account. If FALSE, the address will be
     * the value of the Sender or From header in the outgoing message, in
     * that order.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1077)
    public Map<String,Object> unsetSmtpRestrictEnvelopeFrom(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpRestrictEnvelopeFrom, "");
        return attrs;
    }

    /**
     * URL for Socialcast integration
     *
     * @return zimbraSocialcastURL, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1389)
    public String getSocialcastURL() {
        return getAttr(Provisioning.A_zimbraSocialcastURL, null, true);
    }

    /**
     * URL for Socialcast integration
     *
     * @param zimbraSocialcastURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1389)
    public void setSocialcastURL(String zimbraSocialcastURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSocialcastURL, zimbraSocialcastURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL for Socialcast integration
     *
     * @param zimbraSocialcastURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1389)
    public Map<String,Object> setSocialcastURL(String zimbraSocialcastURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSocialcastURL, zimbraSocialcastURL);
        return attrs;
    }

    /**
     * URL for Socialcast integration
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1389)
    public void unsetSocialcastURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSocialcastURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL for Socialcast integration
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1389)
    public Map<String,Object> unsetSocialcastURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSocialcastURL, "");
        return attrs;
    }

    /**
     * If TRUE, spam messages will be affected by user and admin mail filters
     * instead of being automatically filed into the Junk folder.
     *
     * @return zimbraSpamApplyUserFilters, or false if unset
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=604)
    public boolean isSpamApplyUserFilters() {
        return getBooleanAttr(Provisioning.A_zimbraSpamApplyUserFilters, false, true);
    }

    /**
     * If TRUE, spam messages will be affected by user and admin mail filters
     * instead of being automatically filed into the Junk folder.
     *
     * @param zimbraSpamApplyUserFilters new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=604)
    public void setSpamApplyUserFilters(boolean zimbraSpamApplyUserFilters) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamApplyUserFilters, zimbraSpamApplyUserFilters ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, spam messages will be affected by user and admin mail filters
     * instead of being automatically filed into the Junk folder.
     *
     * @param zimbraSpamApplyUserFilters new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=604)
    public Map<String,Object> setSpamApplyUserFilters(boolean zimbraSpamApplyUserFilters, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamApplyUserFilters, zimbraSpamApplyUserFilters ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, spam messages will be affected by user and admin mail filters
     * instead of being automatically filed into the Junk folder.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=604)
    public void unsetSpamApplyUserFilters() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamApplyUserFilters, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, spam messages will be affected by user and admin mail filters
     * instead of being automatically filed into the Junk folder.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=604)
    public Map<String,Object> unsetSpamApplyUserFilters(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamApplyUserFilters, "");
        return attrs;
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @return zimbraStandardClientCustomPrefTab, or empty array if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public String[] getStandardClientCustomPrefTab() {
        return getMultiAttr(Provisioning.A_zimbraStandardClientCustomPrefTab, true, true);
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @param zimbraStandardClientCustomPrefTab new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public void setStandardClientCustomPrefTab(String[] zimbraStandardClientCustomPrefTab) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStandardClientCustomPrefTab, zimbraStandardClientCustomPrefTab);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @param zimbraStandardClientCustomPrefTab new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public Map<String,Object> setStandardClientCustomPrefTab(String[] zimbraStandardClientCustomPrefTab, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStandardClientCustomPrefTab, zimbraStandardClientCustomPrefTab);
        return attrs;
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @param zimbraStandardClientCustomPrefTab new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public void addStandardClientCustomPrefTab(String zimbraStandardClientCustomPrefTab) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraStandardClientCustomPrefTab, zimbraStandardClientCustomPrefTab);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @param zimbraStandardClientCustomPrefTab new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public Map<String,Object> addStandardClientCustomPrefTab(String zimbraStandardClientCustomPrefTab, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraStandardClientCustomPrefTab, zimbraStandardClientCustomPrefTab);
        return attrs;
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @param zimbraStandardClientCustomPrefTab existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public void removeStandardClientCustomPrefTab(String zimbraStandardClientCustomPrefTab) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraStandardClientCustomPrefTab, zimbraStandardClientCustomPrefTab);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @param zimbraStandardClientCustomPrefTab existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public Map<String,Object> removeStandardClientCustomPrefTab(String zimbraStandardClientCustomPrefTab, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraStandardClientCustomPrefTab, zimbraStandardClientCustomPrefTab);
        return attrs;
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public void unsetStandardClientCustomPrefTab() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStandardClientCustomPrefTab, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * description of the custom tab in the Preferences page in HTML client
     * in the format {tab-name},{associated-URL}
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1267)
    public Map<String,Object> unsetStandardClientCustomPrefTab(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStandardClientCustomPrefTab, "");
        return attrs;
    }

    /**
     * whether extra custom tabs in the Preferences page in HTML client are
     * enabled
     *
     * @return zimbraStandardClientCustomPrefTabsEnabled, or false if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1266)
    public boolean isStandardClientCustomPrefTabsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraStandardClientCustomPrefTabsEnabled, false, true);
    }

    /**
     * whether extra custom tabs in the Preferences page in HTML client are
     * enabled
     *
     * @param zimbraStandardClientCustomPrefTabsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1266)
    public void setStandardClientCustomPrefTabsEnabled(boolean zimbraStandardClientCustomPrefTabsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStandardClientCustomPrefTabsEnabled, zimbraStandardClientCustomPrefTabsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether extra custom tabs in the Preferences page in HTML client are
     * enabled
     *
     * @param zimbraStandardClientCustomPrefTabsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1266)
    public Map<String,Object> setStandardClientCustomPrefTabsEnabled(boolean zimbraStandardClientCustomPrefTabsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStandardClientCustomPrefTabsEnabled, zimbraStandardClientCustomPrefTabsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether extra custom tabs in the Preferences page in HTML client are
     * enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1266)
    public void unsetStandardClientCustomPrefTabsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStandardClientCustomPrefTabsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether extra custom tabs in the Preferences page in HTML client are
     * enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1266)
    public Map<String,Object> unsetStandardClientCustomPrefTabsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStandardClientCustomPrefTabsEnabled, "");
        return attrs;
    }

    /**
     * The maximum batch size for each ZimbraSync transaction. Default value
     * of 0 means to follow client requested size. If set to any positive
     * integer, the value will be the maximum number of items to sync even if
     * client requests more. This setting affects all sync categories
     * including email, contacts, calendar and tasks.
     *
     * @return zimbraSyncWindowSize, or 0 if unset
     */
    @ZAttr(id=437)
    public int getSyncWindowSize() {
        return getIntAttr(Provisioning.A_zimbraSyncWindowSize, 0, true);
    }

    /**
     * The maximum batch size for each ZimbraSync transaction. Default value
     * of 0 means to follow client requested size. If set to any positive
     * integer, the value will be the maximum number of items to sync even if
     * client requests more. This setting affects all sync categories
     * including email, contacts, calendar and tasks.
     *
     * @param zimbraSyncWindowSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=437)
    public void setSyncWindowSize(int zimbraSyncWindowSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSyncWindowSize, Integer.toString(zimbraSyncWindowSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum batch size for each ZimbraSync transaction. Default value
     * of 0 means to follow client requested size. If set to any positive
     * integer, the value will be the maximum number of items to sync even if
     * client requests more. This setting affects all sync categories
     * including email, contacts, calendar and tasks.
     *
     * @param zimbraSyncWindowSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=437)
    public Map<String,Object> setSyncWindowSize(int zimbraSyncWindowSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSyncWindowSize, Integer.toString(zimbraSyncWindowSize));
        return attrs;
    }

    /**
     * The maximum batch size for each ZimbraSync transaction. Default value
     * of 0 means to follow client requested size. If set to any positive
     * integer, the value will be the maximum number of items to sync even if
     * client requests more. This setting affects all sync categories
     * including email, contacts, calendar and tasks.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=437)
    public void unsetSyncWindowSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSyncWindowSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum batch size for each ZimbraSync transaction. Default value
     * of 0 means to follow client requested size. If set to any positive
     * integer, the value will be the maximum number of items to sync even if
     * client requests more. This setting affects all sync categories
     * including email, contacts, calendar and tasks.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=437)
    public Map<String,Object> unsetSyncWindowSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSyncWindowSize, "");
        return attrs;
    }

    /**
     * The registered name of the Zimbra Analyzer Extension for this account
     * to use
     *
     * @return zimbraTextAnalyzer, or null if unset
     */
    @ZAttr(id=393)
    public String getTextAnalyzer() {
        return getAttr(Provisioning.A_zimbraTextAnalyzer, null, true);
    }

    /**
     * The registered name of the Zimbra Analyzer Extension for this account
     * to use
     *
     * @param zimbraTextAnalyzer new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=393)
    public void setTextAnalyzer(String zimbraTextAnalyzer) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTextAnalyzer, zimbraTextAnalyzer);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The registered name of the Zimbra Analyzer Extension for this account
     * to use
     *
     * @param zimbraTextAnalyzer new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=393)
    public Map<String,Object> setTextAnalyzer(String zimbraTextAnalyzer, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTextAnalyzer, zimbraTextAnalyzer);
        return attrs;
    }

    /**
     * The registered name of the Zimbra Analyzer Extension for this account
     * to use
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=393)
    public void unsetTextAnalyzer() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTextAnalyzer, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The registered name of the Zimbra Analyzer Extension for this account
     * to use
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=393)
    public Map<String,Object> unsetTextAnalyzer(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTextAnalyzer, "");
        return attrs;
    }

    /**
     * whether JavaScript error tracking via third party service is enabled
     *
     * @return zimbraTouchJSErrorTrackingEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1433)
    public boolean isTouchJSErrorTrackingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraTouchJSErrorTrackingEnabled, false, true);
    }

    /**
     * whether JavaScript error tracking via third party service is enabled
     *
     * @param zimbraTouchJSErrorTrackingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1433)
    public void setTouchJSErrorTrackingEnabled(boolean zimbraTouchJSErrorTrackingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTouchJSErrorTrackingEnabled, zimbraTouchJSErrorTrackingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether JavaScript error tracking via third party service is enabled
     *
     * @param zimbraTouchJSErrorTrackingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1433)
    public Map<String,Object> setTouchJSErrorTrackingEnabled(boolean zimbraTouchJSErrorTrackingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTouchJSErrorTrackingEnabled, zimbraTouchJSErrorTrackingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether JavaScript error tracking via third party service is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1433)
    public void unsetTouchJSErrorTrackingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTouchJSErrorTrackingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether JavaScript error tracking via third party service is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1433)
    public Map<String,Object> unsetTouchJSErrorTrackingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTouchJSErrorTrackingEnabled, "");
        return attrs;
    }

    /**
     * Key to be used for JavaScript error tracking via third party service
     *
     * @return zimbraTouchJSErrorTrackingKey, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1434)
    public String getTouchJSErrorTrackingKey() {
        return getAttr(Provisioning.A_zimbraTouchJSErrorTrackingKey, null, true);
    }

    /**
     * Key to be used for JavaScript error tracking via third party service
     *
     * @param zimbraTouchJSErrorTrackingKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1434)
    public void setTouchJSErrorTrackingKey(String zimbraTouchJSErrorTrackingKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTouchJSErrorTrackingKey, zimbraTouchJSErrorTrackingKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Key to be used for JavaScript error tracking via third party service
     *
     * @param zimbraTouchJSErrorTrackingKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1434)
    public Map<String,Object> setTouchJSErrorTrackingKey(String zimbraTouchJSErrorTrackingKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTouchJSErrorTrackingKey, zimbraTouchJSErrorTrackingKey);
        return attrs;
    }

    /**
     * Key to be used for JavaScript error tracking via third party service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1434)
    public void unsetTouchJSErrorTrackingKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTouchJSErrorTrackingKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Key to be used for JavaScript error tracking via third party service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1434)
    public Map<String,Object> unsetTouchJSErrorTrackingKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTouchJSErrorTrackingKey, "");
        return attrs;
    }

    /**
     * whether two-factor authentication is enabled by the user
     *
     * @return zimbraTwoFactorAuthEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1819)
    public boolean isTwoFactorAuthEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraTwoFactorAuthEnabled, false, true);
    }

    /**
     * whether two-factor authentication is enabled by the user
     *
     * @param zimbraTwoFactorAuthEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1819)
    public void setTwoFactorAuthEnabled(boolean zimbraTwoFactorAuthEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthEnabled, zimbraTwoFactorAuthEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether two-factor authentication is enabled by the user
     *
     * @param zimbraTwoFactorAuthEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1819)
    public Map<String,Object> setTwoFactorAuthEnabled(boolean zimbraTwoFactorAuthEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthEnabled, zimbraTwoFactorAuthEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether two-factor authentication is enabled by the user
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1819)
    public void unsetTwoFactorAuthEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether two-factor authentication is enabled by the user
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1819)
    public Map<String,Object> unsetTwoFactorAuthEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthEnabled, "");
        return attrs;
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * enabling two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getTwoFactorAuthEnablementTokenLifetimeAsString to access value as a string.
     *
     * @see #getTwoFactorAuthEnablementTokenLifetimeAsString()
     *
     * @return zimbraTwoFactorAuthEnablementTokenLifetime in millseconds, or 3600000 (1h)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2026)
    public long getTwoFactorAuthEnablementTokenLifetime() {
        return getTimeInterval(Provisioning.A_zimbraTwoFactorAuthEnablementTokenLifetime, 3600000L, true);
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * enabling two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraTwoFactorAuthEnablementTokenLifetime, or "1h" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2026)
    public String getTwoFactorAuthEnablementTokenLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraTwoFactorAuthEnablementTokenLifetime, "1h", true);
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * enabling two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraTwoFactorAuthEnablementTokenLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2026)
    public void setTwoFactorAuthEnablementTokenLifetime(String zimbraTwoFactorAuthEnablementTokenLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthEnablementTokenLifetime, zimbraTwoFactorAuthEnablementTokenLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * enabling two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraTwoFactorAuthEnablementTokenLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2026)
    public Map<String,Object> setTwoFactorAuthEnablementTokenLifetime(String zimbraTwoFactorAuthEnablementTokenLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthEnablementTokenLifetime, zimbraTwoFactorAuthEnablementTokenLifetime);
        return attrs;
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * enabling two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2026)
    public void unsetTwoFactorAuthEnablementTokenLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthEnablementTokenLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * enabling two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2026)
    public Map<String,Object> unsetTwoFactorAuthEnablementTokenLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthEnablementTokenLifetime, "");
        return attrs;
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * second factor authentication failures made on an account
     *
     * @return zimbraTwoFactorAuthLockoutFailureTime, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2061)
    public String[] getTwoFactorAuthLockoutFailureTimeAsString() {
        return getMultiAttr(Provisioning.A_zimbraTwoFactorAuthLockoutFailureTime, true, true);
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * second factor authentication failures made on an account
     *
     * @param zimbraTwoFactorAuthLockoutFailureTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2061)
    public void setTwoFactorAuthLockoutFailureTime(Date zimbraTwoFactorAuthLockoutFailureTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutFailureTime, zimbraTwoFactorAuthLockoutFailureTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraTwoFactorAuthLockoutFailureTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * second factor authentication failures made on an account
     *
     * @param zimbraTwoFactorAuthLockoutFailureTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2061)
    public Map<String,Object> setTwoFactorAuthLockoutFailureTime(Date zimbraTwoFactorAuthLockoutFailureTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutFailureTime, zimbraTwoFactorAuthLockoutFailureTime==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraTwoFactorAuthLockoutFailureTime));
        return attrs;
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * second factor authentication failures made on an account
     *
     * @param zimbraTwoFactorAuthLockoutFailureTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2061)
    public void setTwoFactorAuthLockoutFailureTimeAsString(String[] zimbraTwoFactorAuthLockoutFailureTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutFailureTime, zimbraTwoFactorAuthLockoutFailureTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * second factor authentication failures made on an account
     *
     * @param zimbraTwoFactorAuthLockoutFailureTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2061)
    public Map<String,Object> setTwoFactorAuthLockoutFailureTimeAsString(String[] zimbraTwoFactorAuthLockoutFailureTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutFailureTime, zimbraTwoFactorAuthLockoutFailureTime);
        return attrs;
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * second factor authentication failures made on an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2061)
    public void unsetTwoFactorAuthLockoutFailureTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutFailureTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * this attribute contains the timestamps of each of the consecutive
     * second factor authentication failures made on an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2061)
    public Map<String,Object> unsetTwoFactorAuthLockoutFailureTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutFailureTime, "");
        return attrs;
    }

    /**
     * number of consecutive failed second factor login attempts until an
     * account is locked out
     *
     * @return zimbraTwoFactorAuthLockoutMaxFailures, or 10 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2060)
    public int getTwoFactorAuthLockoutMaxFailures() {
        return getIntAttr(Provisioning.A_zimbraTwoFactorAuthLockoutMaxFailures, 10, true);
    }

    /**
     * number of consecutive failed second factor login attempts until an
     * account is locked out
     *
     * @param zimbraTwoFactorAuthLockoutMaxFailures new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2060)
    public void setTwoFactorAuthLockoutMaxFailures(int zimbraTwoFactorAuthLockoutMaxFailures) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutMaxFailures, Integer.toString(zimbraTwoFactorAuthLockoutMaxFailures));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of consecutive failed second factor login attempts until an
     * account is locked out
     *
     * @param zimbraTwoFactorAuthLockoutMaxFailures new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2060)
    public Map<String,Object> setTwoFactorAuthLockoutMaxFailures(int zimbraTwoFactorAuthLockoutMaxFailures, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutMaxFailures, Integer.toString(zimbraTwoFactorAuthLockoutMaxFailures));
        return attrs;
    }

    /**
     * number of consecutive failed second factor login attempts until an
     * account is locked out
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2060)
    public void unsetTwoFactorAuthLockoutMaxFailures() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutMaxFailures, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of consecutive failed second factor login attempts until an
     * account is locked out
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2060)
    public Map<String,Object> unsetTwoFactorAuthLockoutMaxFailures(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthLockoutMaxFailures, "");
        return attrs;
    }

    /**
     * number of scratch codes to generate for two-factor auth
     *
     * @return zimbraTwoFactorAuthNumScratchCodes, or 10 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1823)
    public int getTwoFactorAuthNumScratchCodes() {
        return getIntAttr(Provisioning.A_zimbraTwoFactorAuthNumScratchCodes, 10, true);
    }

    /**
     * number of scratch codes to generate for two-factor auth
     *
     * @param zimbraTwoFactorAuthNumScratchCodes new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1823)
    public void setTwoFactorAuthNumScratchCodes(int zimbraTwoFactorAuthNumScratchCodes) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthNumScratchCodes, Integer.toString(zimbraTwoFactorAuthNumScratchCodes));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of scratch codes to generate for two-factor auth
     *
     * @param zimbraTwoFactorAuthNumScratchCodes new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1823)
    public Map<String,Object> setTwoFactorAuthNumScratchCodes(int zimbraTwoFactorAuthNumScratchCodes, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthNumScratchCodes, Integer.toString(zimbraTwoFactorAuthNumScratchCodes));
        return attrs;
    }

    /**
     * number of scratch codes to generate for two-factor auth
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1823)
    public void unsetTwoFactorAuthNumScratchCodes() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthNumScratchCodes, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of scratch codes to generate for two-factor auth
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1823)
    public Map<String,Object> unsetTwoFactorAuthNumScratchCodes(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthNumScratchCodes, "");
        return attrs;
    }

    /**
     * encrypted comma-separated list of valid scratch codes
     *
     * @return zimbraTwoFactorAuthScratchCodes, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1822)
    public String getTwoFactorAuthScratchCodes() {
        return getAttr(Provisioning.A_zimbraTwoFactorAuthScratchCodes, null, true);
    }

    /**
     * encrypted comma-separated list of valid scratch codes
     *
     * @param zimbraTwoFactorAuthScratchCodes new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1822)
    public void setTwoFactorAuthScratchCodes(String zimbraTwoFactorAuthScratchCodes) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodes, zimbraTwoFactorAuthScratchCodes);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * encrypted comma-separated list of valid scratch codes
     *
     * @param zimbraTwoFactorAuthScratchCodes new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1822)
    public Map<String,Object> setTwoFactorAuthScratchCodes(String zimbraTwoFactorAuthScratchCodes, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodes, zimbraTwoFactorAuthScratchCodes);
        return attrs;
    }

    /**
     * encrypted comma-separated list of valid scratch codes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1822)
    public void unsetTwoFactorAuthScratchCodes() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodes, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * encrypted comma-separated list of valid scratch codes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1822)
    public Map<String,Object> unsetTwoFactorAuthScratchCodes(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodes, "");
        return attrs;
    }

    /**
     * encrypted shared secret
     *
     * @return zimbraTwoFactorAuthSecret, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1821)
    public String getTwoFactorAuthSecret() {
        return getAttr(Provisioning.A_zimbraTwoFactorAuthSecret, null, true);
    }

    /**
     * encrypted shared secret
     *
     * @param zimbraTwoFactorAuthSecret new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1821)
    public void setTwoFactorAuthSecret(String zimbraTwoFactorAuthSecret) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecret, zimbraTwoFactorAuthSecret);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * encrypted shared secret
     *
     * @param zimbraTwoFactorAuthSecret new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1821)
    public Map<String,Object> setTwoFactorAuthSecret(String zimbraTwoFactorAuthSecret, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecret, zimbraTwoFactorAuthSecret);
        return attrs;
    }

    /**
     * encrypted shared secret
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1821)
    public void unsetTwoFactorAuthSecret() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecret, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * encrypted shared secret
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1821)
    public Map<String,Object> unsetTwoFactorAuthSecret(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecret, "");
        return attrs;
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getTwoFactorAuthTokenLifetimeAsString to access value as a string.
     *
     * @see #getTwoFactorAuthTokenLifetimeAsString()
     *
     * @return zimbraTwoFactorAuthTokenLifetime in millseconds, or 3600000 (1h)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2025)
    public long getTwoFactorAuthTokenLifetime() {
        return getTimeInterval(Provisioning.A_zimbraTwoFactorAuthTokenLifetime, 3600000L, true);
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraTwoFactorAuthTokenLifetime, or "1h" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2025)
    public String getTwoFactorAuthTokenLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraTwoFactorAuthTokenLifetime, "1h", true);
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraTwoFactorAuthTokenLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2025)
    public void setTwoFactorAuthTokenLifetime(String zimbraTwoFactorAuthTokenLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTokenLifetime, zimbraTwoFactorAuthTokenLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraTwoFactorAuthTokenLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2025)
    public Map<String,Object> setTwoFactorAuthTokenLifetime(String zimbraTwoFactorAuthTokenLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTokenLifetime, zimbraTwoFactorAuthTokenLifetime);
        return attrs;
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2025)
    public void unsetTwoFactorAuthTokenLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTokenLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lifetime of auth tokens provisioned for completing the 2nd stage of
     * two-factor authentication. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2025)
    public Map<String,Object> unsetTwoFactorAuthTokenLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTokenLifetime, "");
        return attrs;
    }

    /**
     * Lifetime of a trusted device token. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getTwoFactorAuthTrustedDeviceTokenLifetimeAsString to access value as a string.
     *
     * @see #getTwoFactorAuthTrustedDeviceTokenLifetimeAsString()
     *
     * @return zimbraTwoFactorAuthTrustedDeviceTokenLifetime in millseconds, or 2592000000 (30d)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1947)
    public long getTwoFactorAuthTrustedDeviceTokenLifetime() {
        return getTimeInterval(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenLifetime, 2592000000L, true);
    }

    /**
     * Lifetime of a trusted device token. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraTwoFactorAuthTrustedDeviceTokenLifetime, or "30d" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1947)
    public String getTwoFactorAuthTrustedDeviceTokenLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenLifetime, "30d", true);
    }

    /**
     * Lifetime of a trusted device token. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraTwoFactorAuthTrustedDeviceTokenLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1947)
    public void setTwoFactorAuthTrustedDeviceTokenLifetime(String zimbraTwoFactorAuthTrustedDeviceTokenLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenLifetime, zimbraTwoFactorAuthTrustedDeviceTokenLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lifetime of a trusted device token. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraTwoFactorAuthTrustedDeviceTokenLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1947)
    public Map<String,Object> setTwoFactorAuthTrustedDeviceTokenLifetime(String zimbraTwoFactorAuthTrustedDeviceTokenLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenLifetime, zimbraTwoFactorAuthTrustedDeviceTokenLifetime);
        return attrs;
    }

    /**
     * Lifetime of a trusted device token. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1947)
    public void unsetTwoFactorAuthTrustedDeviceTokenLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lifetime of a trusted device token. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1947)
    public Map<String,Object> unsetTwoFactorAuthTrustedDeviceTokenLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenLifetime, "");
        return attrs;
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @return zimbraTwoFactorAuthTrustedDevices, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public String[] getTwoFactorAuthTrustedDevices() {
        return getMultiAttr(Provisioning.A_zimbraTwoFactorAuthTrustedDevices, true, true);
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @param zimbraTwoFactorAuthTrustedDevices new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public void setTwoFactorAuthTrustedDevices(String[] zimbraTwoFactorAuthTrustedDevices) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDevices, zimbraTwoFactorAuthTrustedDevices);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @param zimbraTwoFactorAuthTrustedDevices new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public Map<String,Object> setTwoFactorAuthTrustedDevices(String[] zimbraTwoFactorAuthTrustedDevices, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDevices, zimbraTwoFactorAuthTrustedDevices);
        return attrs;
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @param zimbraTwoFactorAuthTrustedDevices new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public void addTwoFactorAuthTrustedDevices(String zimbraTwoFactorAuthTrustedDevices) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraTwoFactorAuthTrustedDevices, zimbraTwoFactorAuthTrustedDevices);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @param zimbraTwoFactorAuthTrustedDevices new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public Map<String,Object> addTwoFactorAuthTrustedDevices(String zimbraTwoFactorAuthTrustedDevices, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraTwoFactorAuthTrustedDevices, zimbraTwoFactorAuthTrustedDevices);
        return attrs;
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @param zimbraTwoFactorAuthTrustedDevices existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public void removeTwoFactorAuthTrustedDevices(String zimbraTwoFactorAuthTrustedDevices) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraTwoFactorAuthTrustedDevices, zimbraTwoFactorAuthTrustedDevices);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @param zimbraTwoFactorAuthTrustedDevices existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public Map<String,Object> removeTwoFactorAuthTrustedDevices(String zimbraTwoFactorAuthTrustedDevices, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraTwoFactorAuthTrustedDevices, zimbraTwoFactorAuthTrustedDevices);
        return attrs;
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public void unsetTwoFactorAuthTrustedDevices() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDevices, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Trusted devices currently registered on the account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1949)
    public Map<String,Object> unsetTwoFactorAuthTrustedDevices(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDevices, "");
        return attrs;
    }

    /**
     * password for the user&#039;s UC service
     *
     * @return zimbraUCPassword, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1409)
    public String getUCPassword() {
        return getAttr(Provisioning.A_zimbraUCPassword, null, true);
    }

    /**
     * password for the user&#039;s UC service
     *
     * @param zimbraUCPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1409)
    public void setUCPassword(String zimbraUCPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCPassword, zimbraUCPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * password for the user&#039;s UC service
     *
     * @param zimbraUCPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1409)
    public Map<String,Object> setUCPassword(String zimbraUCPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCPassword, zimbraUCPassword);
        return attrs;
    }

    /**
     * password for the user&#039;s UC service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1409)
    public void unsetUCPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * password for the user&#039;s UC service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1409)
    public Map<String,Object> unsetUCPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCPassword, "");
        return attrs;
    }

    /**
     * UC service zimbraId
     *
     * @return zimbraUCServiceId, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1401)
    public String getUCServiceId() {
        return getAttr(Provisioning.A_zimbraUCServiceId, null, true);
    }

    /**
     * UC service zimbraId
     *
     * @param zimbraUCServiceId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1401)
    public void setUCServiceId(String zimbraUCServiceId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCServiceId, zimbraUCServiceId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * UC service zimbraId
     *
     * @param zimbraUCServiceId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1401)
    public Map<String,Object> setUCServiceId(String zimbraUCServiceId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCServiceId, zimbraUCServiceId);
        return attrs;
    }

    /**
     * UC service zimbraId
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1401)
    public void unsetUCServiceId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCServiceId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * UC service zimbraId
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1401)
    public Map<String,Object> unsetUCServiceId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCServiceId, "");
        return attrs;
    }

    /**
     * username for the user&#039;s UC service
     *
     * @return zimbraUCUsername, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1408)
    public String getUCUsername() {
        return getAttr(Provisioning.A_zimbraUCUsername, null, true);
    }

    /**
     * username for the user&#039;s UC service
     *
     * @param zimbraUCUsername new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1408)
    public void setUCUsername(String zimbraUCUsername) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCUsername, zimbraUCUsername);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * username for the user&#039;s UC service
     *
     * @param zimbraUCUsername new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1408)
    public Map<String,Object> setUCUsername(String zimbraUCUsername, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCUsername, zimbraUCUsername);
        return attrs;
    }

    /**
     * username for the user&#039;s UC service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1408)
    public void unsetUCUsername() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCUsername, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * username for the user&#039;s UC service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1408)
    public Map<String,Object> unsetUCUsername(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCUsername, "");
        return attrs;
    }

    /**
     * account version information
     *
     * @return zimbraVersion, or -1 if unset
     */
    @ZAttr(id=399)
    public int getVersion() {
        return getIntAttr(Provisioning.A_zimbraVersion, -1, true);
    }

    /**
     * account version information
     *
     * @param zimbraVersion new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=399)
    public void setVersion(int zimbraVersion) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersion, Integer.toString(zimbraVersion));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * account version information
     *
     * @param zimbraVersion new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=399)
    public Map<String,Object> setVersion(int zimbraVersion, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersion, Integer.toString(zimbraVersion));
        return attrs;
    }

    /**
     * account version information
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=399)
    public void unsetVersion() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersion, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * account version information
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=399)
    public Map<String,Object> unsetVersion(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersion, "");
        return attrs;
    }

    /**
     * Whether virtual user set/changed his password after an external
     * virtual account for him is provisioned. This attribute is applicable
     * for accounts having zimbraIsExternalVirtualAccount set to TRUE.
     *
     * @return zimbraVirtualAccountInitialPasswordSet, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1414)
    public boolean isVirtualAccountInitialPasswordSet() {
        return getBooleanAttr(Provisioning.A_zimbraVirtualAccountInitialPasswordSet, false, true);
    }

    /**
     * Whether virtual user set/changed his password after an external
     * virtual account for him is provisioned. This attribute is applicable
     * for accounts having zimbraIsExternalVirtualAccount set to TRUE.
     *
     * @param zimbraVirtualAccountInitialPasswordSet new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1414)
    public void setVirtualAccountInitialPasswordSet(boolean zimbraVirtualAccountInitialPasswordSet) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirtualAccountInitialPasswordSet, zimbraVirtualAccountInitialPasswordSet ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether virtual user set/changed his password after an external
     * virtual account for him is provisioned. This attribute is applicable
     * for accounts having zimbraIsExternalVirtualAccount set to TRUE.
     *
     * @param zimbraVirtualAccountInitialPasswordSet new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1414)
    public Map<String,Object> setVirtualAccountInitialPasswordSet(boolean zimbraVirtualAccountInitialPasswordSet, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirtualAccountInitialPasswordSet, zimbraVirtualAccountInitialPasswordSet ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether virtual user set/changed his password after an external
     * virtual account for him is provisioned. This attribute is applicable
     * for accounts having zimbraIsExternalVirtualAccount set to TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1414)
    public void unsetVirtualAccountInitialPasswordSet() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirtualAccountInitialPasswordSet, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether virtual user set/changed his password after an external
     * virtual account for him is provisioned. This attribute is applicable
     * for accounts having zimbraIsExternalVirtualAccount set to TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1414)
    public Map<String,Object> unsetVirtualAccountInitialPasswordSet(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirtualAccountInitialPasswordSet, "");
        return attrs;
    }

    /**
     * limit for the number of days that the web client would use to sync any
     * mail folder&#039;s data for offline use
     *
     * @return zimbraWebClientOfflineSyncMaxDays, or 30 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1452)
    public int getWebClientOfflineSyncMaxDays() {
        return getIntAttr(Provisioning.A_zimbraWebClientOfflineSyncMaxDays, 30, true);
    }

    /**
     * limit for the number of days that the web client would use to sync any
     * mail folder&#039;s data for offline use
     *
     * @param zimbraWebClientOfflineSyncMaxDays new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1452)
    public void setWebClientOfflineSyncMaxDays(int zimbraWebClientOfflineSyncMaxDays) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientOfflineSyncMaxDays, Integer.toString(zimbraWebClientOfflineSyncMaxDays));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * limit for the number of days that the web client would use to sync any
     * mail folder&#039;s data for offline use
     *
     * @param zimbraWebClientOfflineSyncMaxDays new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1452)
    public Map<String,Object> setWebClientOfflineSyncMaxDays(int zimbraWebClientOfflineSyncMaxDays, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientOfflineSyncMaxDays, Integer.toString(zimbraWebClientOfflineSyncMaxDays));
        return attrs;
    }

    /**
     * limit for the number of days that the web client would use to sync any
     * mail folder&#039;s data for offline use
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1452)
    public void unsetWebClientOfflineSyncMaxDays() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientOfflineSyncMaxDays, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * limit for the number of days that the web client would use to sync any
     * mail folder&#039;s data for offline use
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1452)
    public Map<String,Object> unsetWebClientOfflineSyncMaxDays(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientOfflineSyncMaxDays, "");
        return attrs;
    }

    /**
     * whether or not to show link to offline version in the web UI top bar
     *
     * @return zimbraWebClientShowOfflineLink, or true if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1047)
    public boolean isWebClientShowOfflineLink() {
        return getBooleanAttr(Provisioning.A_zimbraWebClientShowOfflineLink, true, true);
    }

    /**
     * whether or not to show link to offline version in the web UI top bar
     *
     * @param zimbraWebClientShowOfflineLink new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1047)
    public void setWebClientShowOfflineLink(boolean zimbraWebClientShowOfflineLink) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientShowOfflineLink, zimbraWebClientShowOfflineLink ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to show link to offline version in the web UI top bar
     *
     * @param zimbraWebClientShowOfflineLink new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1047)
    public Map<String,Object> setWebClientShowOfflineLink(boolean zimbraWebClientShowOfflineLink, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientShowOfflineLink, zimbraWebClientShowOfflineLink ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to show link to offline version in the web UI top bar
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1047)
    public void unsetWebClientShowOfflineLink() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientShowOfflineLink, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to show link to offline version in the web UI top bar
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1047)
    public Map<String,Object> unsetWebClientShowOfflineLink(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientShowOfflineLink, "");
        return attrs;
    }

    /**
     * Yahoo ID
     *
     * @return zimbraYahooId, or null if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=658)
    public String getYahooId() {
        return getAttr(Provisioning.A_zimbraYahooId, null, true);
    }

    /**
     * Yahoo ID
     *
     * @param zimbraYahooId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=658)
    public void setYahooId(String zimbraYahooId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraYahooId, zimbraYahooId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Yahoo ID
     *
     * @param zimbraYahooId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=658)
    public Map<String,Object> setYahooId(String zimbraYahooId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraYahooId, zimbraYahooId);
        return attrs;
    }

    /**
     * Yahoo ID
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=658)
    public void unsetYahooId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraYahooId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Yahoo ID
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=658)
    public Map<String,Object> unsetYahooId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraYahooId, "");
        return attrs;
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @return zimbraZimletAvailableZimlets, or empty array if unset
     */
    @ZAttr(id=291)
    public String[] getZimletAvailableZimlets() {
        return getMultiAttr(Provisioning.A_zimbraZimletAvailableZimlets, true, true);
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @param zimbraZimletAvailableZimlets new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=291)
    public void setZimletAvailableZimlets(String[] zimbraZimletAvailableZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletAvailableZimlets, zimbraZimletAvailableZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @param zimbraZimletAvailableZimlets new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=291)
    public Map<String,Object> setZimletAvailableZimlets(String[] zimbraZimletAvailableZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletAvailableZimlets, zimbraZimletAvailableZimlets);
        return attrs;
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @param zimbraZimletAvailableZimlets new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=291)
    public void addZimletAvailableZimlets(String zimbraZimletAvailableZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZimletAvailableZimlets, zimbraZimletAvailableZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @param zimbraZimletAvailableZimlets new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=291)
    public Map<String,Object> addZimletAvailableZimlets(String zimbraZimletAvailableZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZimletAvailableZimlets, zimbraZimletAvailableZimlets);
        return attrs;
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @param zimbraZimletAvailableZimlets existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=291)
    public void removeZimletAvailableZimlets(String zimbraZimletAvailableZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZimletAvailableZimlets, zimbraZimletAvailableZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @param zimbraZimletAvailableZimlets existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=291)
    public Map<String,Object> removeZimletAvailableZimlets(String zimbraZimletAvailableZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZimletAvailableZimlets, zimbraZimletAvailableZimlets);
        return attrs;
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=291)
    public void unsetZimletAvailableZimlets() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletAvailableZimlets, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of Zimlets available to this COS Values can be prefixed with ! or
     * + or - !: mandatory + (or no prefix): enabled by default -: disabled
     * by default
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=291)
    public Map<String,Object> unsetZimletAvailableZimlets(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletAvailableZimlets, "");
        return attrs;
    }

    /**
     * Whether to load zimlets synchronously in the web client. If set to
     * TRUE, users are not allowed to use the core app before zimlets are
     * loaded. If set to FALSE, zimlets are loaded in the background and
     * users are allowed to use the core app before all zimlets finish
     * loading.
     *
     * @return zimbraZimletLoadSynchronously, or false if unset
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1391)
    public boolean isZimletLoadSynchronously() {
        return getBooleanAttr(Provisioning.A_zimbraZimletLoadSynchronously, false, true);
    }

    /**
     * Whether to load zimlets synchronously in the web client. If set to
     * TRUE, users are not allowed to use the core app before zimlets are
     * loaded. If set to FALSE, zimlets are loaded in the background and
     * users are allowed to use the core app before all zimlets finish
     * loading.
     *
     * @param zimbraZimletLoadSynchronously new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1391)
    public void setZimletLoadSynchronously(boolean zimbraZimletLoadSynchronously) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletLoadSynchronously, zimbraZimletLoadSynchronously ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to load zimlets synchronously in the web client. If set to
     * TRUE, users are not allowed to use the core app before zimlets are
     * loaded. If set to FALSE, zimlets are loaded in the background and
     * users are allowed to use the core app before all zimlets finish
     * loading.
     *
     * @param zimbraZimletLoadSynchronously new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1391)
    public Map<String,Object> setZimletLoadSynchronously(boolean zimbraZimletLoadSynchronously, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletLoadSynchronously, zimbraZimletLoadSynchronously ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to load zimlets synchronously in the web client. If set to
     * TRUE, users are not allowed to use the core app before zimlets are
     * loaded. If set to FALSE, zimlets are loaded in the background and
     * users are allowed to use the core app before all zimlets finish
     * loading.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1391)
    public void unsetZimletLoadSynchronously() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletLoadSynchronously, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to load zimlets synchronously in the web client. If set to
     * TRUE, users are not allowed to use the core app before zimlets are
     * loaded. If set to FALSE, zimlets are loaded in the background and
     * users are allowed to use the core app before all zimlets finish
     * loading.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1391)
    public Map<String,Object> unsetZimletLoadSynchronously(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletLoadSynchronously, "");
        return attrs;
    }

    /**
     * User properties for Zimlets
     *
     * @return zimbraZimletUserProperties, or empty array if unset
     */
    @ZAttr(id=296)
    public String[] getZimletUserProperties() {
        return getMultiAttr(Provisioning.A_zimbraZimletUserProperties, true, true);
    }

    /**
     * User properties for Zimlets
     *
     * @param zimbraZimletUserProperties new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=296)
    public void setZimletUserProperties(String[] zimbraZimletUserProperties) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletUserProperties, zimbraZimletUserProperties);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User properties for Zimlets
     *
     * @param zimbraZimletUserProperties new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=296)
    public Map<String,Object> setZimletUserProperties(String[] zimbraZimletUserProperties, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletUserProperties, zimbraZimletUserProperties);
        return attrs;
    }

    /**
     * User properties for Zimlets
     *
     * @param zimbraZimletUserProperties new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=296)
    public void addZimletUserProperties(String zimbraZimletUserProperties) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZimletUserProperties, zimbraZimletUserProperties);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User properties for Zimlets
     *
     * @param zimbraZimletUserProperties new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=296)
    public Map<String,Object> addZimletUserProperties(String zimbraZimletUserProperties, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZimletUserProperties, zimbraZimletUserProperties);
        return attrs;
    }

    /**
     * User properties for Zimlets
     *
     * @param zimbraZimletUserProperties existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=296)
    public void removeZimletUserProperties(String zimbraZimletUserProperties) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZimletUserProperties, zimbraZimletUserProperties);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User properties for Zimlets
     *
     * @param zimbraZimletUserProperties existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=296)
    public Map<String,Object> removeZimletUserProperties(String zimbraZimletUserProperties, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZimletUserProperties, zimbraZimletUserProperties);
        return attrs;
    }

    /**
     * User properties for Zimlets
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=296)
    public void unsetZimletUserProperties() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletUserProperties, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * User properties for Zimlets
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=296)
    public Map<String,Object> unsetZimletUserProperties(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletUserProperties, "");
        return attrs;
    }

    /**
     * maximum number of user properties for zimlet allowed on an account
     *
     * @return zimbraZimletUserPropertiesMaxNumEntries, or 150 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2027)
    public int getZimletUserPropertiesMaxNumEntries() {
        return getIntAttr(Provisioning.A_zimbraZimletUserPropertiesMaxNumEntries, 150, true);
    }

    /**
     * maximum number of user properties for zimlet allowed on an account
     *
     * @param zimbraZimletUserPropertiesMaxNumEntries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2027)
    public void setZimletUserPropertiesMaxNumEntries(int zimbraZimletUserPropertiesMaxNumEntries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletUserPropertiesMaxNumEntries, Integer.toString(zimbraZimletUserPropertiesMaxNumEntries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of user properties for zimlet allowed on an account
     *
     * @param zimbraZimletUserPropertiesMaxNumEntries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2027)
    public Map<String,Object> setZimletUserPropertiesMaxNumEntries(int zimbraZimletUserPropertiesMaxNumEntries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletUserPropertiesMaxNumEntries, Integer.toString(zimbraZimletUserPropertiesMaxNumEntries));
        return attrs;
    }

    /**
     * maximum number of user properties for zimlet allowed on an account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2027)
    public void unsetZimletUserPropertiesMaxNumEntries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletUserPropertiesMaxNumEntries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of user properties for zimlet allowed on an account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2027)
    public Map<String,Object> unsetZimletUserPropertiesMaxNumEntries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletUserPropertiesMaxNumEntries, "");
        return attrs;
    }

    ///// END-AUTO-GEN-REPLACE

}
