/*
 * ***** BEGIN LICENSE BLOCK *****
 * Zimbra Collaboration Suite Server
 * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 Synacor, Inc.
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software Foundation,
 * version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 * ***** END LICENSE BLOCK *****
 */

/*
 * Created on Sep 23, 2004
 *
 * Window - Preferences - Java - Code Style - Code Templates
 */
package com.zimbra.cs.account;

import static com.zimbra.common.account.ProvisioningConstants.FALSE;
import static com.zimbra.common.account.ProvisioningConstants.TRUE;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.zimbra.common.account.ZAttr;
import com.zimbra.common.account.ZAttrProvisioning;
import com.zimbra.common.util.ByteUtil;
import com.zimbra.common.util.StringUtil;
import com.zimbra.cs.ldap.LdapDateUtil;


/**
 * AUTO-GENERATED. DO NOT EDIT.
 *
 */
public abstract class ZAttrConfig extends Entry {

    public ZAttrConfig(Map<String, Object> attrs, Provisioning provisioning) {
        super(attrs, null, provisioning);
    }

    ///// BEGIN-AUTO-GEN-REPLACE

    /**
     * RFC2256: descriptive information
     *
     * @return description, or empty array if unset
     */
    @ZAttr(id=-1)
    public String[] getDescription() {
        return getMultiAttr(Provisioning.A_description, true, true);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void setDescription(String[] description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> setDescription(String[] description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void addDescription(String description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> addDescription(String description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void removeDescription(String description) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_description, description);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param description existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> removeDescription(String description, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_description, description);
        return attrs;
    }

    /**
     * RFC2256: descriptive information
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=-1)
    public void unsetDescription() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * RFC2256: descriptive information
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=-1)
    public Map<String,Object> unsetDescription(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_description, "");
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @return zimbraACE, or empty array if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public String[] getACE() {
        return getMultiAttr(Provisioning.A_zimbraACE, true, true);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void setACE(String[] zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> setACE(String[] zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void addACE(String zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> addACE(String zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void removeACE(String zimbraACE) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraACE, zimbraACE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param zimbraACE existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> removeACE(String zimbraACE, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraACE, zimbraACE);
        return attrs;
    }

    /**
     * Zimbra access control list
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public void unsetACE() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Zimbra access control list
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=659)
    public Map<String,Object> unsetACE(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraACE, "");
        return attrs;
    }

    /**
     * Certificate for Apple Push Notification Service
     *
     * @return zimbraAPNSCertificate, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1975)
    public byte[] getAPNSCertificate() {
        return getBinaryAttr(Provisioning.A_zimbraAPNSCertificate, true);
    }

    /**
     * Certificate for Apple Push Notification Service
     *
     * @return zimbraAPNSCertificate, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1975)
    public String getAPNSCertificateAsString() {
        return getAttr(Provisioning.A_zimbraAPNSCertificate, null, true);
    }

    /**
     * Certificate for Apple Push Notification Service
     *
     * @param zimbraAPNSCertificate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1975)
    public void setAPNSCertificate(byte[] zimbraAPNSCertificate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSCertificate, zimbraAPNSCertificate==null ? "" : ByteUtil.encodeLDAPBase64(zimbraAPNSCertificate));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Certificate for Apple Push Notification Service
     *
     * @param zimbraAPNSCertificate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1975)
    public Map<String,Object> setAPNSCertificate(byte[] zimbraAPNSCertificate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSCertificate, zimbraAPNSCertificate==null ? "" : ByteUtil.encodeLDAPBase64(zimbraAPNSCertificate));
        return attrs;
    }

    /**
     * Certificate for Apple Push Notification Service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1975)
    public void unsetAPNSCertificate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSCertificate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Certificate for Apple Push Notification Service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1975)
    public Map<String,Object> unsetAPNSCertificate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSCertificate, "");
        return attrs;
    }

    /**
     * Password for APNS certificate
     *
     * @return zimbraAPNSCertificatePassword, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1976)
    public String getAPNSCertificatePassword() {
        return getAttr(Provisioning.A_zimbraAPNSCertificatePassword, null, true);
    }

    /**
     * Password for APNS certificate
     *
     * @param zimbraAPNSCertificatePassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1976)
    public void setAPNSCertificatePassword(String zimbraAPNSCertificatePassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSCertificatePassword, zimbraAPNSCertificatePassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Password for APNS certificate
     *
     * @param zimbraAPNSCertificatePassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1976)
    public Map<String,Object> setAPNSCertificatePassword(String zimbraAPNSCertificatePassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSCertificatePassword, zimbraAPNSCertificatePassword);
        return attrs;
    }

    /**
     * Password for APNS certificate
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1976)
    public void unsetAPNSCertificatePassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSCertificatePassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Password for APNS certificate
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1976)
    public Map<String,Object> unsetAPNSCertificatePassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSCertificatePassword, "");
        return attrs;
    }

    /**
     * Boolean to decide whether APNS is being used for production or
     * development
     *
     * @return zimbraAPNSProduction, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1977)
    public boolean isAPNSProduction() {
        return getBooleanAttr(Provisioning.A_zimbraAPNSProduction, true, true);
    }

    /**
     * Boolean to decide whether APNS is being used for production or
     * development
     *
     * @param zimbraAPNSProduction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1977)
    public void setAPNSProduction(boolean zimbraAPNSProduction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSProduction, zimbraAPNSProduction ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Boolean to decide whether APNS is being used for production or
     * development
     *
     * @param zimbraAPNSProduction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1977)
    public Map<String,Object> setAPNSProduction(boolean zimbraAPNSProduction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSProduction, zimbraAPNSProduction ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Boolean to decide whether APNS is being used for production or
     * development
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1977)
    public void unsetAPNSProduction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSProduction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Boolean to decide whether APNS is being used for production or
     * development
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1977)
    public Map<String,Object> unsetAPNSProduction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAPNSProduction, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @return zimbraAccountClientAttr, or empty array if unset
     */
    @ZAttr(id=112)
    public String[] getAccountClientAttr() {
        return getMultiAttr(Provisioning.A_zimbraAccountClientAttr, true, true);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @param zimbraAccountClientAttr new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=112)
    public void setAccountClientAttr(String[] zimbraAccountClientAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountClientAttr, zimbraAccountClientAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @param zimbraAccountClientAttr new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=112)
    public Map<String,Object> setAccountClientAttr(String[] zimbraAccountClientAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountClientAttr, zimbraAccountClientAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @param zimbraAccountClientAttr new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=112)
    public void addAccountClientAttr(String zimbraAccountClientAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAccountClientAttr, zimbraAccountClientAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @param zimbraAccountClientAttr new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=112)
    public Map<String,Object> addAccountClientAttr(String zimbraAccountClientAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAccountClientAttr, zimbraAccountClientAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @param zimbraAccountClientAttr existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=112)
    public void removeAccountClientAttr(String zimbraAccountClientAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAccountClientAttr, zimbraAccountClientAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @param zimbraAccountClientAttr existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=112)
    public Map<String,Object> removeAccountClientAttr(String zimbraAccountClientAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAccountClientAttr, zimbraAccountClientAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=112)
    public void unsetAccountClientAttr() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountClientAttr, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInfo flag.
     * Orig desc: additional account attrs that get returned to a client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=112)
    public Map<String,Object> unsetAccountClientAttr(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountClientAttr, "");
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @return zimbraAccountExtraObjectClass, or empty array if unset
     */
    @ZAttr(id=438)
    public String[] getAccountExtraObjectClass() {
        String[] value = getMultiAttr(Provisioning.A_zimbraAccountExtraObjectClass, true, true); return value.length > 0 ? value : new String[] {"amavisAccount"};
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @param zimbraAccountExtraObjectClass new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=438)
    public void setAccountExtraObjectClass(String[] zimbraAccountExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountExtraObjectClass, zimbraAccountExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @param zimbraAccountExtraObjectClass new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=438)
    public Map<String,Object> setAccountExtraObjectClass(String[] zimbraAccountExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountExtraObjectClass, zimbraAccountExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @param zimbraAccountExtraObjectClass new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=438)
    public void addAccountExtraObjectClass(String zimbraAccountExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAccountExtraObjectClass, zimbraAccountExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @param zimbraAccountExtraObjectClass new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=438)
    public Map<String,Object> addAccountExtraObjectClass(String zimbraAccountExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAccountExtraObjectClass, zimbraAccountExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @param zimbraAccountExtraObjectClass existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=438)
    public void removeAccountExtraObjectClass(String zimbraAccountExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAccountExtraObjectClass, zimbraAccountExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @param zimbraAccountExtraObjectClass existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=438)
    public Map<String,Object> removeAccountExtraObjectClass(String zimbraAccountExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAccountExtraObjectClass, zimbraAccountExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=438)
    public void unsetAccountExtraObjectClass() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountExtraObjectClass, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra account object. Useful if
     * you want to add sambaSamAccount etc to zimbra accounts.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=438)
    public Map<String,Object> unsetAccountExtraObjectClass(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAccountExtraObjectClass, "");
        return attrs;
    }

    /**
     * Ehcache: default expiration time for activesync cache values; default
     * is 5 minutes. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getActiveSyncEhcacheExpirationAsString to access value as a string.
     *
     * @see #getActiveSyncEhcacheExpirationAsString()
     *
     * @return zimbraActiveSyncEhcacheExpiration in millseconds, or 300000 (5m)  if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3003)
    public long getActiveSyncEhcacheExpiration() {
        return getTimeInterval(Provisioning.A_zimbraActiveSyncEhcacheExpiration, 300000L, true);
    }

    /**
     * Ehcache: default expiration time for activesync cache values; default
     * is 5 minutes. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraActiveSyncEhcacheExpiration, or "5m" if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3003)
    public String getActiveSyncEhcacheExpirationAsString() {
        return getAttr(Provisioning.A_zimbraActiveSyncEhcacheExpiration, "5m", true);
    }

    /**
     * Ehcache: default expiration time for activesync cache values; default
     * is 5 minutes. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraActiveSyncEhcacheExpiration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3003)
    public void setActiveSyncEhcacheExpiration(String zimbraActiveSyncEhcacheExpiration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheExpiration, zimbraActiveSyncEhcacheExpiration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: default expiration time for activesync cache values; default
     * is 5 minutes. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraActiveSyncEhcacheExpiration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3003)
    public Map<String,Object> setActiveSyncEhcacheExpiration(String zimbraActiveSyncEhcacheExpiration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheExpiration, zimbraActiveSyncEhcacheExpiration);
        return attrs;
    }

    /**
     * Ehcache: default expiration time for activesync cache values; default
     * is 5 minutes. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3003)
    public void unsetActiveSyncEhcacheExpiration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheExpiration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: default expiration time for activesync cache values; default
     * is 5 minutes. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3003)
    public Map<String,Object> unsetActiveSyncEhcacheExpiration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheExpiration, "");
        return attrs;
    }

    /**
     * Ehcache: the maximum heap size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10MB. This is a rough limit,Due to
     * internals of ehcache actual size in memory will often exceed this
     * limit by a modest margin.
     *
     * @return zimbraActiveSyncEhcacheHeapSize, or 10485760 if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3001)
    public long getActiveSyncEhcacheHeapSize() {
        return getLongAttr(Provisioning.A_zimbraActiveSyncEhcacheHeapSize, 10485760L, true);
    }

    /**
     * Ehcache: the maximum heap size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10MB. This is a rough limit,Due to
     * internals of ehcache actual size in memory will often exceed this
     * limit by a modest margin.
     *
     * @param zimbraActiveSyncEhcacheHeapSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3001)
    public void setActiveSyncEhcacheHeapSize(long zimbraActiveSyncEhcacheHeapSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheHeapSize, Long.toString(zimbraActiveSyncEhcacheHeapSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum heap size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10MB. This is a rough limit,Due to
     * internals of ehcache actual size in memory will often exceed this
     * limit by a modest margin.
     *
     * @param zimbraActiveSyncEhcacheHeapSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3001)
    public Map<String,Object> setActiveSyncEhcacheHeapSize(long zimbraActiveSyncEhcacheHeapSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheHeapSize, Long.toString(zimbraActiveSyncEhcacheHeapSize));
        return attrs;
    }

    /**
     * Ehcache: the maximum heap size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10MB. This is a rough limit,Due to
     * internals of ehcache actual size in memory will often exceed this
     * limit by a modest margin.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3001)
    public void unsetActiveSyncEhcacheHeapSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheHeapSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum heap size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10MB. This is a rough limit,Due to
     * internals of ehcache actual size in memory will often exceed this
     * limit by a modest margin.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3001)
    public Map<String,Object> unsetActiveSyncEhcacheHeapSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheHeapSize, "");
        return attrs;
    }

    /**
     * Ehcache: the maximum disk size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10GB. This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @return zimbraActiveSyncEhcacheMaxDiskSize, or 10737418240 if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3002)
    public long getActiveSyncEhcacheMaxDiskSize() {
        return getLongAttr(Provisioning.A_zimbraActiveSyncEhcacheMaxDiskSize, 10737418240L, true);
    }

    /**
     * Ehcache: the maximum disk size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10GB. This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param zimbraActiveSyncEhcacheMaxDiskSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3002)
    public void setActiveSyncEhcacheMaxDiskSize(long zimbraActiveSyncEhcacheMaxDiskSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheMaxDiskSize, Long.toString(zimbraActiveSyncEhcacheMaxDiskSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum disk size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10GB. This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param zimbraActiveSyncEhcacheMaxDiskSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3002)
    public Map<String,Object> setActiveSyncEhcacheMaxDiskSize(long zimbraActiveSyncEhcacheMaxDiskSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheMaxDiskSize, Long.toString(zimbraActiveSyncEhcacheMaxDiskSize));
        return attrs;
    }

    /**
     * Ehcache: the maximum disk size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10GB. This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3002)
    public void unsetActiveSyncEhcacheMaxDiskSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheMaxDiskSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum disk size of the ActiveSync cache in Bytes before
     * eviction. By default this value is 10GB. This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3002)
    public Map<String,Object> unsetActiveSyncEhcacheMaxDiskSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraActiveSyncEhcacheMaxDiskSize, "");
        return attrs;
    }

    /**
     * access control mechanism for admin access acl: ACL based access
     * control (a.k.a. delegated admin). global: allows only global admins.
     *
     * <p>Valid values: [acl, global]
     *
     * @return zimbraAdminAccessControlMech, or ZAttrProvisioning.AdminAccessControlMech.acl if unset and/or has invalid value
     *
     * @since ZCS 6.0.9
     */
    @ZAttr(id=1101)
    public ZAttrProvisioning.AdminAccessControlMech getAdminAccessControlMech() {
        try { String v = getAttr(Provisioning.A_zimbraAdminAccessControlMech, true, true); return v == null ? ZAttrProvisioning.AdminAccessControlMech.acl : ZAttrProvisioning.AdminAccessControlMech.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.AdminAccessControlMech.acl; }
    }

    /**
     * access control mechanism for admin access acl: ACL based access
     * control (a.k.a. delegated admin). global: allows only global admins.
     *
     * <p>Valid values: [acl, global]
     *
     * @return zimbraAdminAccessControlMech, or "acl" if unset
     *
     * @since ZCS 6.0.9
     */
    @ZAttr(id=1101)
    public String getAdminAccessControlMechAsString() {
        return getAttr(Provisioning.A_zimbraAdminAccessControlMech, "acl", true);
    }

    /**
     * access control mechanism for admin access acl: ACL based access
     * control (a.k.a. delegated admin). global: allows only global admins.
     *
     * <p>Valid values: [acl, global]
     *
     * @param zimbraAdminAccessControlMech new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.9
     */
    @ZAttr(id=1101)
    public void setAdminAccessControlMech(ZAttrProvisioning.AdminAccessControlMech zimbraAdminAccessControlMech) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAccessControlMech, zimbraAdminAccessControlMech.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * access control mechanism for admin access acl: ACL based access
     * control (a.k.a. delegated admin). global: allows only global admins.
     *
     * <p>Valid values: [acl, global]
     *
     * @param zimbraAdminAccessControlMech new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.9
     */
    @ZAttr(id=1101)
    public Map<String,Object> setAdminAccessControlMech(ZAttrProvisioning.AdminAccessControlMech zimbraAdminAccessControlMech, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAccessControlMech, zimbraAdminAccessControlMech.toString());
        return attrs;
    }

    /**
     * access control mechanism for admin access acl: ACL based access
     * control (a.k.a. delegated admin). global: allows only global admins.
     *
     * <p>Valid values: [acl, global]
     *
     * @param zimbraAdminAccessControlMech new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.9
     */
    @ZAttr(id=1101)
    public void setAdminAccessControlMechAsString(String zimbraAdminAccessControlMech) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAccessControlMech, zimbraAdminAccessControlMech);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * access control mechanism for admin access acl: ACL based access
     * control (a.k.a. delegated admin). global: allows only global admins.
     *
     * <p>Valid values: [acl, global]
     *
     * @param zimbraAdminAccessControlMech new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.9
     */
    @ZAttr(id=1101)
    public Map<String,Object> setAdminAccessControlMechAsString(String zimbraAdminAccessControlMech, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAccessControlMech, zimbraAdminAccessControlMech);
        return attrs;
    }

    /**
     * access control mechanism for admin access acl: ACL based access
     * control (a.k.a. delegated admin). global: allows only global admins.
     *
     * <p>Valid values: [acl, global]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.9
     */
    @ZAttr(id=1101)
    public void unsetAdminAccessControlMech() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAccessControlMech, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * access control mechanism for admin access acl: ACL based access
     * control (a.k.a. delegated admin). global: allows only global admins.
     *
     * <p>Valid values: [acl, global]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.9
     */
    @ZAttr(id=1101)
    public Map<String,Object> unsetAdminAccessControlMech(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminAccessControlMech, "");
        return attrs;
    }

    /**
     * whether to show catchall addresses in admin console
     *
     * @return zimbraAdminConsoleCatchAllAddressEnabled, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=746)
    public boolean isAdminConsoleCatchAllAddressEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAdminConsoleCatchAllAddressEnabled, false, true);
    }

    /**
     * whether to show catchall addresses in admin console
     *
     * @param zimbraAdminConsoleCatchAllAddressEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=746)
    public void setAdminConsoleCatchAllAddressEnabled(boolean zimbraAdminConsoleCatchAllAddressEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleCatchAllAddressEnabled, zimbraAdminConsoleCatchAllAddressEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to show catchall addresses in admin console
     *
     * @param zimbraAdminConsoleCatchAllAddressEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=746)
    public Map<String,Object> setAdminConsoleCatchAllAddressEnabled(boolean zimbraAdminConsoleCatchAllAddressEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleCatchAllAddressEnabled, zimbraAdminConsoleCatchAllAddressEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to show catchall addresses in admin console
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=746)
    public void unsetAdminConsoleCatchAllAddressEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleCatchAllAddressEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to show catchall addresses in admin console
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=746)
    public Map<String,Object> unsetAdminConsoleCatchAllAddressEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleCatchAllAddressEnabled, "");
        return attrs;
    }

    /**
     * enable MX check feature for domain
     *
     * @return zimbraAdminConsoleDNSCheckEnabled, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=743)
    public boolean isAdminConsoleDNSCheckEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAdminConsoleDNSCheckEnabled, false, true);
    }

    /**
     * enable MX check feature for domain
     *
     * @param zimbraAdminConsoleDNSCheckEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=743)
    public void setAdminConsoleDNSCheckEnabled(boolean zimbraAdminConsoleDNSCheckEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleDNSCheckEnabled, zimbraAdminConsoleDNSCheckEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable MX check feature for domain
     *
     * @param zimbraAdminConsoleDNSCheckEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=743)
    public Map<String,Object> setAdminConsoleDNSCheckEnabled(boolean zimbraAdminConsoleDNSCheckEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleDNSCheckEnabled, zimbraAdminConsoleDNSCheckEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable MX check feature for domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=743)
    public void unsetAdminConsoleDNSCheckEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleDNSCheckEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable MX check feature for domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=743)
    public Map<String,Object> unsetAdminConsoleDNSCheckEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleDNSCheckEnabled, "");
        return attrs;
    }

    /**
     * whether configuring external LDAP auth is enabled in admin console
     *
     * @return zimbraAdminConsoleLDAPAuthEnabled, or false if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=774)
    public boolean isAdminConsoleLDAPAuthEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAdminConsoleLDAPAuthEnabled, false, true);
    }

    /**
     * whether configuring external LDAP auth is enabled in admin console
     *
     * @param zimbraAdminConsoleLDAPAuthEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=774)
    public void setAdminConsoleLDAPAuthEnabled(boolean zimbraAdminConsoleLDAPAuthEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLDAPAuthEnabled, zimbraAdminConsoleLDAPAuthEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether configuring external LDAP auth is enabled in admin console
     *
     * @param zimbraAdminConsoleLDAPAuthEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=774)
    public Map<String,Object> setAdminConsoleLDAPAuthEnabled(boolean zimbraAdminConsoleLDAPAuthEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLDAPAuthEnabled, zimbraAdminConsoleLDAPAuthEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether configuring external LDAP auth is enabled in admin console
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=774)
    public void unsetAdminConsoleLDAPAuthEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLDAPAuthEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether configuring external LDAP auth is enabled in admin console
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=774)
    public Map<String,Object> unsetAdminConsoleLDAPAuthEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLDAPAuthEnabled, "");
        return attrs;
    }

    /**
     * admin console login message
     *
     * @return zimbraAdminConsoleLoginMessage, or empty array if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public String[] getAdminConsoleLoginMessage() {
        return getMultiAttr(Provisioning.A_zimbraAdminConsoleLoginMessage, true, true);
    }

    /**
     * admin console login message
     *
     * @param zimbraAdminConsoleLoginMessage new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public void setAdminConsoleLoginMessage(String[] zimbraAdminConsoleLoginMessage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLoginMessage, zimbraAdminConsoleLoginMessage);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin console login message
     *
     * @param zimbraAdminConsoleLoginMessage new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public Map<String,Object> setAdminConsoleLoginMessage(String[] zimbraAdminConsoleLoginMessage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLoginMessage, zimbraAdminConsoleLoginMessage);
        return attrs;
    }

    /**
     * admin console login message
     *
     * @param zimbraAdminConsoleLoginMessage new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public void addAdminConsoleLoginMessage(String zimbraAdminConsoleLoginMessage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAdminConsoleLoginMessage, zimbraAdminConsoleLoginMessage);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin console login message
     *
     * @param zimbraAdminConsoleLoginMessage new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public Map<String,Object> addAdminConsoleLoginMessage(String zimbraAdminConsoleLoginMessage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAdminConsoleLoginMessage, zimbraAdminConsoleLoginMessage);
        return attrs;
    }

    /**
     * admin console login message
     *
     * @param zimbraAdminConsoleLoginMessage existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public void removeAdminConsoleLoginMessage(String zimbraAdminConsoleLoginMessage) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAdminConsoleLoginMessage, zimbraAdminConsoleLoginMessage);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin console login message
     *
     * @param zimbraAdminConsoleLoginMessage existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public Map<String,Object> removeAdminConsoleLoginMessage(String zimbraAdminConsoleLoginMessage, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAdminConsoleLoginMessage, zimbraAdminConsoleLoginMessage);
        return attrs;
    }

    /**
     * admin console login message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public void unsetAdminConsoleLoginMessage() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLoginMessage, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * admin console login message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=772)
    public Map<String,Object> unsetAdminConsoleLoginMessage(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLoginMessage, "");
        return attrs;
    }

    /**
     * login URL for admin console to send the user to upon explicit logging
     * in
     *
     * @return zimbraAdminConsoleLoginURL, or null if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=696)
    public String getAdminConsoleLoginURL() {
        return getAttr(Provisioning.A_zimbraAdminConsoleLoginURL, null, true);
    }

    /**
     * login URL for admin console to send the user to upon explicit logging
     * in
     *
     * @param zimbraAdminConsoleLoginURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=696)
    public void setAdminConsoleLoginURL(String zimbraAdminConsoleLoginURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLoginURL, zimbraAdminConsoleLoginURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * login URL for admin console to send the user to upon explicit logging
     * in
     *
     * @param zimbraAdminConsoleLoginURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=696)
    public Map<String,Object> setAdminConsoleLoginURL(String zimbraAdminConsoleLoginURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLoginURL, zimbraAdminConsoleLoginURL);
        return attrs;
    }

    /**
     * login URL for admin console to send the user to upon explicit logging
     * in
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=696)
    public void unsetAdminConsoleLoginURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLoginURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * login URL for admin console to send the user to upon explicit logging
     * in
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=696)
    public Map<String,Object> unsetAdminConsoleLoginURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLoginURL, "");
        return attrs;
    }

    /**
     * logout URL for admin console to send the user to upon explicit logging
     * out
     *
     * @return zimbraAdminConsoleLogoutURL, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=684)
    public String getAdminConsoleLogoutURL() {
        return getAttr(Provisioning.A_zimbraAdminConsoleLogoutURL, null, true);
    }

    /**
     * logout URL for admin console to send the user to upon explicit logging
     * out
     *
     * @param zimbraAdminConsoleLogoutURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=684)
    public void setAdminConsoleLogoutURL(String zimbraAdminConsoleLogoutURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLogoutURL, zimbraAdminConsoleLogoutURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * logout URL for admin console to send the user to upon explicit logging
     * out
     *
     * @param zimbraAdminConsoleLogoutURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=684)
    public Map<String,Object> setAdminConsoleLogoutURL(String zimbraAdminConsoleLogoutURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLogoutURL, zimbraAdminConsoleLogoutURL);
        return attrs;
    }

    /**
     * logout URL for admin console to send the user to upon explicit logging
     * out
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=684)
    public void unsetAdminConsoleLogoutURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLogoutURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * logout URL for admin console to send the user to upon explicit logging
     * out
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=684)
    public Map<String,Object> unsetAdminConsoleLogoutURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleLogoutURL, "");
        return attrs;
    }

    /**
     * whether to allow skin management in admin console
     *
     * @return zimbraAdminConsoleSkinEnabled, or false if unset
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=751)
    public boolean isAdminConsoleSkinEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAdminConsoleSkinEnabled, false, true);
    }

    /**
     * whether to allow skin management in admin console
     *
     * @param zimbraAdminConsoleSkinEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=751)
    public void setAdminConsoleSkinEnabled(boolean zimbraAdminConsoleSkinEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleSkinEnabled, zimbraAdminConsoleSkinEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow skin management in admin console
     *
     * @param zimbraAdminConsoleSkinEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=751)
    public Map<String,Object> setAdminConsoleSkinEnabled(boolean zimbraAdminConsoleSkinEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleSkinEnabled, zimbraAdminConsoleSkinEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to allow skin management in admin console
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=751)
    public void unsetAdminConsoleSkinEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleSkinEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to allow skin management in admin console
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.11
     */
    @ZAttr(id=751)
    public Map<String,Object> unsetAdminConsoleSkinEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminConsoleSkinEnabled, "");
        return attrs;
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @return zimbraAdminImapImportNumThreads, or 20 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public int getAdminImapImportNumThreads() {
        return getIntAttr(Provisioning.A_zimbraAdminImapImportNumThreads, 20, true);
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @param zimbraAdminImapImportNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public void setAdminImapImportNumThreads(int zimbraAdminImapImportNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminImapImportNumThreads, Integer.toString(zimbraAdminImapImportNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @param zimbraAdminImapImportNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public Map<String,Object> setAdminImapImportNumThreads(int zimbraAdminImapImportNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminImapImportNumThreads, Integer.toString(zimbraAdminImapImportNumThreads));
        return attrs;
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public void unsetAdminImapImportNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminImapImportNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of admin initiated imap import handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1113)
    public Map<String,Object> unsetAdminImapImportNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminImapImportNumThreads, "");
        return attrs;
    }

    /**
     * SSL port for admin UI
     *
     * <p>Use getAdminPortAsString to access value as a string.
     *
     * @see #getAdminPortAsString()
     *
     * @return zimbraAdminPort, or 7071 if unset
     */
    @ZAttr(id=155)
    public int getAdminPort() {
        return getIntAttr(Provisioning.A_zimbraAdminPort, 7071, true);
    }

    /**
     * SSL port for admin UI
     *
     * @return zimbraAdminPort, or "7071" if unset
     */
    @ZAttr(id=155)
    public String getAdminPortAsString() {
        return getAttr(Provisioning.A_zimbraAdminPort, "7071", true);
    }

    /**
     * SSL port for admin UI
     *
     * @param zimbraAdminPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=155)
    public void setAdminPort(int zimbraAdminPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, Integer.toString(zimbraAdminPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for admin UI
     *
     * @param zimbraAdminPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=155)
    public Map<String,Object> setAdminPort(int zimbraAdminPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, Integer.toString(zimbraAdminPort));
        return attrs;
    }

    /**
     * SSL port for admin UI
     *
     * @param zimbraAdminPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=155)
    public void setAdminPortAsString(String zimbraAdminPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, zimbraAdminPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for admin UI
     *
     * @param zimbraAdminPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=155)
    public Map<String,Object> setAdminPortAsString(String zimbraAdminPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, zimbraAdminPort);
        return attrs;
    }

    /**
     * SSL port for admin UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=155)
    public void unsetAdminPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for admin UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=155)
    public Map<String,Object> unsetAdminPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminPort, "");
        return attrs;
    }

    /**
     * SSL proxy port for admin console UI
     *
     * <p>Use getAdminProxyPortAsString to access value as a string.
     *
     * @see #getAdminProxyPortAsString()
     *
     * @return zimbraAdminProxyPort, or 9071 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public int getAdminProxyPort() {
        return getIntAttr(Provisioning.A_zimbraAdminProxyPort, 9071, true);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @return zimbraAdminProxyPort, or "9071" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public String getAdminProxyPortAsString() {
        return getAttr(Provisioning.A_zimbraAdminProxyPort, "9071", true);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param zimbraAdminProxyPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public void setAdminProxyPort(int zimbraAdminProxyPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, Integer.toString(zimbraAdminProxyPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param zimbraAdminProxyPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public Map<String,Object> setAdminProxyPort(int zimbraAdminProxyPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, Integer.toString(zimbraAdminProxyPort));
        return attrs;
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param zimbraAdminProxyPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public void setAdminProxyPortAsString(String zimbraAdminProxyPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, zimbraAdminProxyPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param zimbraAdminProxyPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public Map<String,Object> setAdminProxyPortAsString(String zimbraAdminProxyPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, zimbraAdminProxyPort);
        return attrs;
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public void unsetAdminProxyPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL proxy port for admin console UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1322)
    public Map<String,Object> unsetAdminProxyPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminProxyPort, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * admin-defined sieve rules.
     *
     * @return zimbraAdminSieveFeatureVariablesEnabled, or true if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2098)
    public boolean isAdminSieveFeatureVariablesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAdminSieveFeatureVariablesEnabled, true, true);
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * admin-defined sieve rules.
     *
     * @param zimbraAdminSieveFeatureVariablesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2098)
    public void setAdminSieveFeatureVariablesEnabled(boolean zimbraAdminSieveFeatureVariablesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveFeatureVariablesEnabled, zimbraAdminSieveFeatureVariablesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * admin-defined sieve rules.
     *
     * @param zimbraAdminSieveFeatureVariablesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2098)
    public Map<String,Object> setAdminSieveFeatureVariablesEnabled(boolean zimbraAdminSieveFeatureVariablesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveFeatureVariablesEnabled, zimbraAdminSieveFeatureVariablesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * admin-defined sieve rules.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2098)
    public void unsetAdminSieveFeatureVariablesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveFeatureVariablesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * admin-defined sieve rules.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2098)
    public Map<String,Object> unsetAdminSieveFeatureVariablesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminSieveFeatureVariablesEnabled, "");
        return attrs;
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @return zimbraAdminURL, or "/zimbraAdmin" if unset
     */
    @ZAttr(id=497)
    public String getAdminURL() {
        return getAttr(Provisioning.A_zimbraAdminURL, "/zimbraAdmin", true);
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @param zimbraAdminURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=497)
    public void setAdminURL(String zimbraAdminURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminURL, zimbraAdminURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @param zimbraAdminURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=497)
    public Map<String,Object> setAdminURL(String zimbraAdminURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminURL, zimbraAdminURL);
        return attrs;
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=497)
    public void unsetAdminURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefix for where the zimbraAdmin app resides on this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=497)
    public Map<String,Object> unsetAdminURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAdminURL, "");
        return attrs;
    }

    /**
     * whether creating domains, and renaming domains to a name, containing
     * non-LDH (letter, digit, hyphen) characters is allowed
     *
     * @return zimbraAllowNonLDHCharsInDomain, or true if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1052)
    public boolean isAllowNonLDHCharsInDomain() {
        return getBooleanAttr(Provisioning.A_zimbraAllowNonLDHCharsInDomain, true, true);
    }

    /**
     * whether creating domains, and renaming domains to a name, containing
     * non-LDH (letter, digit, hyphen) characters is allowed
     *
     * @param zimbraAllowNonLDHCharsInDomain new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1052)
    public void setAllowNonLDHCharsInDomain(boolean zimbraAllowNonLDHCharsInDomain) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowNonLDHCharsInDomain, zimbraAllowNonLDHCharsInDomain ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether creating domains, and renaming domains to a name, containing
     * non-LDH (letter, digit, hyphen) characters is allowed
     *
     * @param zimbraAllowNonLDHCharsInDomain new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1052)
    public Map<String,Object> setAllowNonLDHCharsInDomain(boolean zimbraAllowNonLDHCharsInDomain, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowNonLDHCharsInDomain, zimbraAllowNonLDHCharsInDomain ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether creating domains, and renaming domains to a name, containing
     * non-LDH (letter, digit, hyphen) characters is allowed
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1052)
    public void unsetAllowNonLDHCharsInDomain() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowNonLDHCharsInDomain, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether creating domains, and renaming domains to a name, containing
     * non-LDH (letter, digit, hyphen) characters is allowed
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1052)
    public Map<String,Object> unsetAllowNonLDHCharsInDomain(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAllowNonLDHCharsInDomain, "");
        return attrs;
    }

    /**
     * AlwaysOn cluster-id to which this server belongs to. If empty,
     * it&#039;s not part of AlwaysOn and is a stand-alone server.
     *
     * @return zimbraAlwaysOnClusterId, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1446)
    public String getAlwaysOnClusterId() {
        return getAttr(Provisioning.A_zimbraAlwaysOnClusterId, null, true);
    }

    /**
     * AlwaysOn cluster-id to which this server belongs to. If empty,
     * it&#039;s not part of AlwaysOn and is a stand-alone server.
     *
     * @param zimbraAlwaysOnClusterId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1446)
    public void setAlwaysOnClusterId(String zimbraAlwaysOnClusterId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAlwaysOnClusterId, zimbraAlwaysOnClusterId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * AlwaysOn cluster-id to which this server belongs to. If empty,
     * it&#039;s not part of AlwaysOn and is a stand-alone server.
     *
     * @param zimbraAlwaysOnClusterId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1446)
    public Map<String,Object> setAlwaysOnClusterId(String zimbraAlwaysOnClusterId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAlwaysOnClusterId, zimbraAlwaysOnClusterId);
        return attrs;
    }

    /**
     * AlwaysOn cluster-id to which this server belongs to. If empty,
     * it&#039;s not part of AlwaysOn and is a stand-alone server.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1446)
    public void unsetAlwaysOnClusterId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAlwaysOnClusterId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * AlwaysOn cluster-id to which this server belongs to. If empty,
     * it&#039;s not part of AlwaysOn and is a stand-alone server.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1446)
    public Map<String,Object> unsetAlwaysOnClusterId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAlwaysOnClusterId, "");
        return attrs;
    }

    /**
     * Whether or not Amavis should use DSPAM as an additional score factor
     * for SPAM. Defaults to FALSE
     *
     * @return zimbraAmavisDSPAMEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public boolean isAmavisDSPAMEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAmavisDSPAMEnabled, false, true);
    }

    /**
     * Whether or not Amavis should use DSPAM as an additional score factor
     * for SPAM. Defaults to FALSE
     *
     * @param zimbraAmavisDSPAMEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public void setAmavisDSPAMEnabled(boolean zimbraAmavisDSPAMEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisDSPAMEnabled, zimbraAmavisDSPAMEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should use DSPAM as an additional score factor
     * for SPAM. Defaults to FALSE
     *
     * @param zimbraAmavisDSPAMEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public Map<String,Object> setAmavisDSPAMEnabled(boolean zimbraAmavisDSPAMEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisDSPAMEnabled, zimbraAmavisDSPAMEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not Amavis should use DSPAM as an additional score factor
     * for SPAM. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public void unsetAmavisDSPAMEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisDSPAMEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should use DSPAM as an additional score factor
     * for SPAM. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1465)
    public Map<String,Object> unsetAmavisDSPAMEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisDSPAMEnabled, "");
        return attrs;
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @return zimbraAmavisEnableDKIMVerification, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public boolean isAmavisEnableDKIMVerification() {
        return getBooleanAttr(Provisioning.A_zimbraAmavisEnableDKIMVerification, true, true);
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @param zimbraAmavisEnableDKIMVerification new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public void setAmavisEnableDKIMVerification(boolean zimbraAmavisEnableDKIMVerification) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisEnableDKIMVerification, zimbraAmavisEnableDKIMVerification ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @param zimbraAmavisEnableDKIMVerification new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public Map<String,Object> setAmavisEnableDKIMVerification(boolean zimbraAmavisEnableDKIMVerification, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisEnableDKIMVerification, zimbraAmavisEnableDKIMVerification ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public void unsetAmavisEnableDKIMVerification() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisEnableDKIMVerification, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should verify DKIM keys. Defaults to TRUE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1463)
    public Map<String,Object> unsetAmavisEnableDKIMVerification(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisEnableDKIMVerification, "");
        return attrs;
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_PASS, D_BOUNCE, D_REJECT, D_DISCARD]
     *
     * @return zimbraAmavisFinalSpamDestiny, or ZAttrProvisioning.AmavisFinalSpamDestiny.D_DISCARD if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public ZAttrProvisioning.AmavisFinalSpamDestiny getAmavisFinalSpamDestiny() {
        try { String v = getAttr(Provisioning.A_zimbraAmavisFinalSpamDestiny, true, true); return v == null ? ZAttrProvisioning.AmavisFinalSpamDestiny.D_DISCARD : ZAttrProvisioning.AmavisFinalSpamDestiny.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.AmavisFinalSpamDestiny.D_DISCARD; }
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_PASS, D_BOUNCE, D_REJECT, D_DISCARD]
     *
     * @return zimbraAmavisFinalSpamDestiny, or "D_DISCARD" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public String getAmavisFinalSpamDestinyAsString() {
        return getAttr(Provisioning.A_zimbraAmavisFinalSpamDestiny, "D_DISCARD", true);
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_PASS, D_BOUNCE, D_REJECT, D_DISCARD]
     *
     * @param zimbraAmavisFinalSpamDestiny new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public void setAmavisFinalSpamDestiny(ZAttrProvisioning.AmavisFinalSpamDestiny zimbraAmavisFinalSpamDestiny) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, zimbraAmavisFinalSpamDestiny.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_PASS, D_BOUNCE, D_REJECT, D_DISCARD]
     *
     * @param zimbraAmavisFinalSpamDestiny new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public Map<String,Object> setAmavisFinalSpamDestiny(ZAttrProvisioning.AmavisFinalSpamDestiny zimbraAmavisFinalSpamDestiny, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, zimbraAmavisFinalSpamDestiny.toString());
        return attrs;
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_PASS, D_BOUNCE, D_REJECT, D_DISCARD]
     *
     * @param zimbraAmavisFinalSpamDestiny new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public void setAmavisFinalSpamDestinyAsString(String zimbraAmavisFinalSpamDestiny) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, zimbraAmavisFinalSpamDestiny);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_PASS, D_BOUNCE, D_REJECT, D_DISCARD]
     *
     * @param zimbraAmavisFinalSpamDestiny new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public Map<String,Object> setAmavisFinalSpamDestinyAsString(String zimbraAmavisFinalSpamDestiny, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, zimbraAmavisFinalSpamDestiny);
        return attrs;
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_PASS, D_BOUNCE, D_REJECT, D_DISCARD]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public void unsetAmavisFinalSpamDestiny() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Amavis final destination for Spam. Default is to discard it
     *
     * <p>Valid values: [D_PASS, D_BOUNCE, D_REJECT, D_DISCARD]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1460)
    public Map<String,Object> unsetAmavisFinalSpamDestiny(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisFinalSpamDestiny, "");
        return attrs;
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @return zimbraAmavisLogLevel, or 1 if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public int getAmavisLogLevel() {
        return getIntAttr(Provisioning.A_zimbraAmavisLogLevel, 1, true);
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @param zimbraAmavisLogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public void setAmavisLogLevel(int zimbraAmavisLogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisLogLevel, Integer.toString(zimbraAmavisLogLevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @param zimbraAmavisLogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public Map<String,Object> setAmavisLogLevel(int zimbraAmavisLogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisLogLevel, Integer.toString(zimbraAmavisLogLevel));
        return attrs;
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public void unsetAmavisLogLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisLogLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Loglevel for Amavis. Defaults to 1. Valid range is 0-5
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1488)
    public Map<String,Object> unsetAmavisLogLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisLogLevel, "");
        return attrs;
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @return zimbraAmavisMaxServers, or 10 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public int getAmavisMaxServers() {
        return getIntAttr(Provisioning.A_zimbraAmavisMaxServers, 10, true);
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @param zimbraAmavisMaxServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public void setAmavisMaxServers(int zimbraAmavisMaxServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisMaxServers, Integer.toString(zimbraAmavisMaxServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @param zimbraAmavisMaxServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public Map<String,Object> setAmavisMaxServers(int zimbraAmavisMaxServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisMaxServers, Integer.toString(zimbraAmavisMaxServers));
        return attrs;
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public void unsetAmavisMaxServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisMaxServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of Amavis servers to run. Default is 10
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1461)
    public Map<String,Object> unsetAmavisMaxServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisMaxServers, "");
        return attrs;
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @return zimbraAmavisOriginatingBypassSA, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public boolean isAmavisOriginatingBypassSA() {
        return getBooleanAttr(Provisioning.A_zimbraAmavisOriginatingBypassSA, false, true);
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @param zimbraAmavisOriginatingBypassSA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public void setAmavisOriginatingBypassSA(boolean zimbraAmavisOriginatingBypassSA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOriginatingBypassSA, zimbraAmavisOriginatingBypassSA ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @param zimbraAmavisOriginatingBypassSA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public Map<String,Object> setAmavisOriginatingBypassSA(boolean zimbraAmavisOriginatingBypassSA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOriginatingBypassSA, zimbraAmavisOriginatingBypassSA ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public void unsetAmavisOriginatingBypassSA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOriginatingBypassSA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis should Bypass SpamAsassin for originating email.
     * Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1464)
    public Map<String,Object> unsetAmavisOriginatingBypassSA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOriginatingBypassSA, "");
        return attrs;
    }

    /**
     * Whether or not Amavis disclaimers should only be attached to outbound
     * emails. Defaults to FALSE (Always attach a disclaimer)
     *
     * @return zimbraAmavisOutboundDisclaimersOnly, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1577)
    public boolean isAmavisOutboundDisclaimersOnly() {
        return getBooleanAttr(Provisioning.A_zimbraAmavisOutboundDisclaimersOnly, false, true);
    }

    /**
     * Whether or not Amavis disclaimers should only be attached to outbound
     * emails. Defaults to FALSE (Always attach a disclaimer)
     *
     * @param zimbraAmavisOutboundDisclaimersOnly new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1577)
    public void setAmavisOutboundDisclaimersOnly(boolean zimbraAmavisOutboundDisclaimersOnly) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOutboundDisclaimersOnly, zimbraAmavisOutboundDisclaimersOnly ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis disclaimers should only be attached to outbound
     * emails. Defaults to FALSE (Always attach a disclaimer)
     *
     * @param zimbraAmavisOutboundDisclaimersOnly new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1577)
    public Map<String,Object> setAmavisOutboundDisclaimersOnly(boolean zimbraAmavisOutboundDisclaimersOnly, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOutboundDisclaimersOnly, zimbraAmavisOutboundDisclaimersOnly ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not Amavis disclaimers should only be attached to outbound
     * emails. Defaults to FALSE (Always attach a disclaimer)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1577)
    public void unsetAmavisOutboundDisclaimersOnly() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOutboundDisclaimersOnly, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Amavis disclaimers should only be attached to outbound
     * emails. Defaults to FALSE (Always attach a disclaimer)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1577)
    public Map<String,Object> unsetAmavisOutboundDisclaimersOnly(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisOutboundDisclaimersOnly, "");
        return attrs;
    }

    /**
     * When a virus is detected quarantine message to this account
     *
     * @return zimbraAmavisQuarantineAccount, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1100)
    public String getAmavisQuarantineAccount() {
        return getAttr(Provisioning.A_zimbraAmavisQuarantineAccount, null, true);
    }

    /**
     * When a virus is detected quarantine message to this account
     *
     * @param zimbraAmavisQuarantineAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1100)
    public void setAmavisQuarantineAccount(String zimbraAmavisQuarantineAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisQuarantineAccount, zimbraAmavisQuarantineAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When a virus is detected quarantine message to this account
     *
     * @param zimbraAmavisQuarantineAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1100)
    public Map<String,Object> setAmavisQuarantineAccount(String zimbraAmavisQuarantineAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisQuarantineAccount, zimbraAmavisQuarantineAccount);
        return attrs;
    }

    /**
     * When a virus is detected quarantine message to this account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1100)
    public void unsetAmavisQuarantineAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisQuarantineAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When a virus is detected quarantine message to this account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1100)
    public Map<String,Object> unsetAmavisQuarantineAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisQuarantineAccount, "");
        return attrs;
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @return zimbraAmavisSALogLevel, or 0 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public int getAmavisSALogLevel() {
        return getIntAttr(Provisioning.A_zimbraAmavisSALogLevel, 0, true);
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @param zimbraAmavisSALogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public void setAmavisSALogLevel(int zimbraAmavisSALogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisSALogLevel, Integer.toString(zimbraAmavisSALogLevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @param zimbraAmavisSALogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public Map<String,Object> setAmavisSALogLevel(int zimbraAmavisSALogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisSALogLevel, Integer.toString(zimbraAmavisSALogLevel));
        return attrs;
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public void unsetAmavisSALogLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisSALogLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Loglevel for SpamAssassin when called via Amavis. Defaults to 0
     * (info). Can be 0 or 1 (info, all)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1578)
    public Map<String,Object> unsetAmavisSALogLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAmavisSALogLevel, "");
        return attrs;
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @return zimbraAntispamExtractionBatchDelay, or 100 if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public int getAntispamExtractionBatchDelay() {
        return getIntAttr(Provisioning.A_zimbraAntispamExtractionBatchDelay, 100, true);
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @param zimbraAntispamExtractionBatchDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public void setAntispamExtractionBatchDelay(int zimbraAntispamExtractionBatchDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchDelay, Integer.toString(zimbraAntispamExtractionBatchDelay));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @param zimbraAntispamExtractionBatchDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public Map<String,Object> setAntispamExtractionBatchDelay(int zimbraAntispamExtractionBatchDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchDelay, Integer.toString(zimbraAntispamExtractionBatchDelay));
        return attrs;
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public void unsetAntispamExtractionBatchDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * delay between each batch for zmspamextract
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1457)
    public Map<String,Object> unsetAntispamExtractionBatchDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchDelay, "");
        return attrs;
    }

    /**
     * batch size for zmspamextract
     *
     * @return zimbraAntispamExtractionBatchSize, or 25 if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public int getAntispamExtractionBatchSize() {
        return getIntAttr(Provisioning.A_zimbraAntispamExtractionBatchSize, 25, true);
    }

    /**
     * batch size for zmspamextract
     *
     * @param zimbraAntispamExtractionBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public void setAntispamExtractionBatchSize(int zimbraAntispamExtractionBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchSize, Integer.toString(zimbraAntispamExtractionBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * batch size for zmspamextract
     *
     * @param zimbraAntispamExtractionBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public Map<String,Object> setAntispamExtractionBatchSize(int zimbraAntispamExtractionBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchSize, Integer.toString(zimbraAntispamExtractionBatchSize));
        return attrs;
    }

    /**
     * batch size for zmspamextract
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public void unsetAntispamExtractionBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * batch size for zmspamextract
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1456)
    public Map<String,Object> unsetAntispamExtractionBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAntispamExtractionBatchSize, "");
        return attrs;
    }

    /**
     * length of app-specific passwords
     *
     * @return zimbraAppSpecificPasswordLength, or 16 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1840)
    public int getAppSpecificPasswordLength() {
        return getIntAttr(Provisioning.A_zimbraAppSpecificPasswordLength, 16, true);
    }

    /**
     * length of app-specific passwords
     *
     * @param zimbraAppSpecificPasswordLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1840)
    public void setAppSpecificPasswordLength(int zimbraAppSpecificPasswordLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPasswordLength, Integer.toString(zimbraAppSpecificPasswordLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of app-specific passwords
     *
     * @param zimbraAppSpecificPasswordLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1840)
    public Map<String,Object> setAppSpecificPasswordLength(int zimbraAppSpecificPasswordLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPasswordLength, Integer.toString(zimbraAppSpecificPasswordLength));
        return attrs;
    }

    /**
     * length of app-specific passwords
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1840)
    public void unsetAppSpecificPasswordLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPasswordLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of app-specific passwords
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1840)
    public Map<String,Object> unsetAppSpecificPasswordLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAppSpecificPasswordLength, "");
        return attrs;
    }

    /**
     * whether account archiving is enabled
     *
     * @return zimbraArchiveEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public boolean isArchiveEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraArchiveEnabled, false, true);
    }

    /**
     * whether account archiving is enabled
     *
     * @param zimbraArchiveEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public void setArchiveEnabled(boolean zimbraArchiveEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveEnabled, zimbraArchiveEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether account archiving is enabled
     *
     * @param zimbraArchiveEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public Map<String,Object> setArchiveEnabled(boolean zimbraArchiveEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveEnabled, zimbraArchiveEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether account archiving is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public void unsetArchiveEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether account archiving is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1206)
    public Map<String,Object> unsetArchiveEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveEnabled, "");
        return attrs;
    }

    /**
     * Address to which archive message bounces should be sent. Typically
     * could be an admin account. This is global across all domains.
     *
     * @return zimbraArchiveMailFrom, or null if unset
     */
    @ZAttr(id=430)
    public String getArchiveMailFrom() {
        return getAttr(Provisioning.A_zimbraArchiveMailFrom, null, true);
    }

    /**
     * Address to which archive message bounces should be sent. Typically
     * could be an admin account. This is global across all domains.
     *
     * @param zimbraArchiveMailFrom new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=430)
    public void setArchiveMailFrom(String zimbraArchiveMailFrom) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveMailFrom, zimbraArchiveMailFrom);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Address to which archive message bounces should be sent. Typically
     * could be an admin account. This is global across all domains.
     *
     * @param zimbraArchiveMailFrom new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=430)
    public Map<String,Object> setArchiveMailFrom(String zimbraArchiveMailFrom, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveMailFrom, zimbraArchiveMailFrom);
        return attrs;
    }

    /**
     * Address to which archive message bounces should be sent. Typically
     * could be an admin account. This is global across all domains.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=430)
    public void unsetArchiveMailFrom() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveMailFrom, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Address to which archive message bounces should be sent. Typically
     * could be an admin account. This is global across all domains.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=430)
    public Map<String,Object> unsetArchiveMailFrom(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraArchiveMailFrom, "");
        return attrs;
    }

    /**
     * block all attachment downloading
     *
     * @return zimbraAttachmentsBlocked, or false if unset
     */
    @ZAttr(id=115)
    public boolean isAttachmentsBlocked() {
        return getBooleanAttr(Provisioning.A_zimbraAttachmentsBlocked, false, true);
    }

    /**
     * block all attachment downloading
     *
     * @param zimbraAttachmentsBlocked new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=115)
    public void setAttachmentsBlocked(boolean zimbraAttachmentsBlocked) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsBlocked, zimbraAttachmentsBlocked ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * block all attachment downloading
     *
     * @param zimbraAttachmentsBlocked new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=115)
    public Map<String,Object> setAttachmentsBlocked(boolean zimbraAttachmentsBlocked, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsBlocked, zimbraAttachmentsBlocked ? TRUE : FALSE);
        return attrs;
    }

    /**
     * block all attachment downloading
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=115)
    public void unsetAttachmentsBlocked() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsBlocked, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * block all attachment downloading
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=115)
    public Map<String,Object> unsetAttachmentsBlocked(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsBlocked, "");
        return attrs;
    }

    /**
     * Maximum number of characters that will be indexed for a given MIME
     * part.
     *
     * @return zimbraAttachmentsIndexedTextLimit, or 1048576 if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=582)
    public int getAttachmentsIndexedTextLimit() {
        return getIntAttr(Provisioning.A_zimbraAttachmentsIndexedTextLimit, 1048576, true);
    }

    /**
     * Maximum number of characters that will be indexed for a given MIME
     * part.
     *
     * @param zimbraAttachmentsIndexedTextLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=582)
    public void setAttachmentsIndexedTextLimit(int zimbraAttachmentsIndexedTextLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsIndexedTextLimit, Integer.toString(zimbraAttachmentsIndexedTextLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of characters that will be indexed for a given MIME
     * part.
     *
     * @param zimbraAttachmentsIndexedTextLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=582)
    public Map<String,Object> setAttachmentsIndexedTextLimit(int zimbraAttachmentsIndexedTextLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsIndexedTextLimit, Integer.toString(zimbraAttachmentsIndexedTextLimit));
        return attrs;
    }

    /**
     * Maximum number of characters that will be indexed for a given MIME
     * part.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=582)
    public void unsetAttachmentsIndexedTextLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsIndexedTextLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of characters that will be indexed for a given MIME
     * part.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=582)
    public Map<String,Object> unsetAttachmentsIndexedTextLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsIndexedTextLimit, "");
        return attrs;
    }

    /**
     * Class to use to scan attachments during compose
     *
     * @return zimbraAttachmentsScanClass, or "com.zimbra.cs.scan.ClamScanner" if unset
     */
    @ZAttr(id=238)
    public String getAttachmentsScanClass() {
        return getAttr(Provisioning.A_zimbraAttachmentsScanClass, "com.zimbra.cs.scan.ClamScanner", true);
    }

    /**
     * Class to use to scan attachments during compose
     *
     * @param zimbraAttachmentsScanClass new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=238)
    public void setAttachmentsScanClass(String zimbraAttachmentsScanClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanClass, zimbraAttachmentsScanClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Class to use to scan attachments during compose
     *
     * @param zimbraAttachmentsScanClass new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=238)
    public Map<String,Object> setAttachmentsScanClass(String zimbraAttachmentsScanClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanClass, zimbraAttachmentsScanClass);
        return attrs;
    }

    /**
     * Class to use to scan attachments during compose
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=238)
    public void unsetAttachmentsScanClass() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanClass, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Class to use to scan attachments during compose
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=238)
    public Map<String,Object> unsetAttachmentsScanClass(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanClass, "");
        return attrs;
    }

    /**
     * Whether to scan attachments during compose
     *
     * @return zimbraAttachmentsScanEnabled, or false if unset
     */
    @ZAttr(id=237)
    public boolean isAttachmentsScanEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAttachmentsScanEnabled, false, true);
    }

    /**
     * Whether to scan attachments during compose
     *
     * @param zimbraAttachmentsScanEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=237)
    public void setAttachmentsScanEnabled(boolean zimbraAttachmentsScanEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanEnabled, zimbraAttachmentsScanEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to scan attachments during compose
     *
     * @param zimbraAttachmentsScanEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=237)
    public Map<String,Object> setAttachmentsScanEnabled(boolean zimbraAttachmentsScanEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanEnabled, zimbraAttachmentsScanEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to scan attachments during compose
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=237)
    public void unsetAttachmentsScanEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to scan attachments during compose
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=237)
    public Map<String,Object> unsetAttachmentsScanEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanEnabled, "");
        return attrs;
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @return zimbraAttachmentsScanURL, or empty array if unset
     */
    @ZAttr(id=239)
    public String[] getAttachmentsScanURL() {
        return getMultiAttr(Provisioning.A_zimbraAttachmentsScanURL, true, true);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=239)
    public void setAttachmentsScanURL(String[] zimbraAttachmentsScanURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=239)
    public Map<String,Object> setAttachmentsScanURL(String[] zimbraAttachmentsScanURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        return attrs;
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=239)
    public void addAttachmentsScanURL(String zimbraAttachmentsScanURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=239)
    public Map<String,Object> addAttachmentsScanURL(String zimbraAttachmentsScanURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        return attrs;
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=239)
    public void removeAttachmentsScanURL(String zimbraAttachmentsScanURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param zimbraAttachmentsScanURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=239)
    public Map<String,Object> removeAttachmentsScanURL(String zimbraAttachmentsScanURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAttachmentsScanURL, zimbraAttachmentsScanURL);
        return attrs;
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=239)
    public void unsetAttachmentsScanURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Data for class that scans attachments during compose
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=239)
    public Map<String,Object> unsetAttachmentsScanURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsScanURL, "");
        return attrs;
    }

    /**
     * view all attachments in html only
     *
     * @return zimbraAttachmentsViewInHtmlOnly, or false if unset
     */
    @ZAttr(id=116)
    public boolean isAttachmentsViewInHtmlOnly() {
        return getBooleanAttr(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, false, true);
    }

    /**
     * view all attachments in html only
     *
     * @param zimbraAttachmentsViewInHtmlOnly new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=116)
    public void setAttachmentsViewInHtmlOnly(boolean zimbraAttachmentsViewInHtmlOnly) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, zimbraAttachmentsViewInHtmlOnly ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * view all attachments in html only
     *
     * @param zimbraAttachmentsViewInHtmlOnly new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=116)
    public Map<String,Object> setAttachmentsViewInHtmlOnly(boolean zimbraAttachmentsViewInHtmlOnly, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, zimbraAttachmentsViewInHtmlOnly ? TRUE : FALSE);
        return attrs;
    }

    /**
     * view all attachments in html only
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=116)
    public void unsetAttachmentsViewInHtmlOnly() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * view all attachments in html only
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=116)
    public Map<String,Object> unsetAttachmentsViewInHtmlOnly(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttachmentsViewInHtmlOnly, "");
        return attrs;
    }

    /**
     * Information about the latest run of zmmigrateattrs. Includes the URL
     * of the destination ephemeral store and the state of the migration (in
     * progress, completed, failed)
     *
     * @return zimbraAttributeMigrationInfo, or null if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3019)
    public String getAttributeMigrationInfo() {
        return getAttr(Provisioning.A_zimbraAttributeMigrationInfo, null, true);
    }

    /**
     * Information about the latest run of zmmigrateattrs. Includes the URL
     * of the destination ephemeral store and the state of the migration (in
     * progress, completed, failed)
     *
     * @param zimbraAttributeMigrationInfo new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3019)
    public void setAttributeMigrationInfo(String zimbraAttributeMigrationInfo) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttributeMigrationInfo, zimbraAttributeMigrationInfo);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Information about the latest run of zmmigrateattrs. Includes the URL
     * of the destination ephemeral store and the state of the migration (in
     * progress, completed, failed)
     *
     * @param zimbraAttributeMigrationInfo new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3019)
    public Map<String,Object> setAttributeMigrationInfo(String zimbraAttributeMigrationInfo, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttributeMigrationInfo, zimbraAttributeMigrationInfo);
        return attrs;
    }

    /**
     * Information about the latest run of zmmigrateattrs. Includes the URL
     * of the destination ephemeral store and the state of the migration (in
     * progress, completed, failed)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3019)
    public void unsetAttributeMigrationInfo() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttributeMigrationInfo, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Information about the latest run of zmmigrateattrs. Includes the URL
     * of the destination ephemeral store and the state of the migration (in
     * progress, completed, failed)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3019)
    public Map<String,Object> unsetAttributeMigrationInfo(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAttributeMigrationInfo, "");
        return attrs;
    }

    /**
     * auth token secret key
     *
     * @return zimbraAuthTokenKey, or empty array if unset
     */
    @ZAttr(id=100)
    public String[] getAuthTokenKey() {
        return getMultiAttr(Provisioning.A_zimbraAuthTokenKey, true, true);
    }

    /**
     * auth token secret key
     *
     * @param zimbraAuthTokenKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=100)
    public void setAuthTokenKey(String[] zimbraAuthTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenKey, zimbraAuthTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth token secret key
     *
     * @param zimbraAuthTokenKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=100)
    public Map<String,Object> setAuthTokenKey(String[] zimbraAuthTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenKey, zimbraAuthTokenKey);
        return attrs;
    }

    /**
     * auth token secret key
     *
     * @param zimbraAuthTokenKey new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=100)
    public void addAuthTokenKey(String zimbraAuthTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAuthTokenKey, zimbraAuthTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth token secret key
     *
     * @param zimbraAuthTokenKey new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=100)
    public Map<String,Object> addAuthTokenKey(String zimbraAuthTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraAuthTokenKey, zimbraAuthTokenKey);
        return attrs;
    }

    /**
     * auth token secret key
     *
     * @param zimbraAuthTokenKey existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=100)
    public void removeAuthTokenKey(String zimbraAuthTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAuthTokenKey, zimbraAuthTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth token secret key
     *
     * @param zimbraAuthTokenKey existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=100)
    public Map<String,Object> removeAuthTokenKey(String zimbraAuthTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraAuthTokenKey, zimbraAuthTokenKey);
        return attrs;
    }

    /**
     * auth token secret key
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=100)
    public void unsetAuthTokenKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth token secret key
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=100)
    public Map<String,Object> unsetAuthTokenKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenKey, "");
        return attrs;
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @return zimbraAuthTokenNotificationInterval, or 60000 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public int getAuthTokenNotificationInterval() {
        return getIntAttr(Provisioning.A_zimbraAuthTokenNotificationInterval, 60000, true);
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @param zimbraAuthTokenNotificationInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public void setAuthTokenNotificationInterval(int zimbraAuthTokenNotificationInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenNotificationInterval, Integer.toString(zimbraAuthTokenNotificationInterval));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @param zimbraAuthTokenNotificationInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public Map<String,Object> setAuthTokenNotificationInterval(int zimbraAuthTokenNotificationInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenNotificationInterval, Integer.toString(zimbraAuthTokenNotificationInterval));
        return attrs;
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public void unsetAuthTokenNotificationInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenNotificationInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used to configure the interval with which servers
     * will send a list of invalidated tokens to each other. When an account
     * logs out of a server, the account&#039;s authtoken is added to a queue
     * of invalidated tokens on the server. Each server will send it&#039;s
     * queue of invalidated tokens to all other servers with frequency
     * configurable by this attribute. See zimbraLogOutFromAllServers for
     * more info on configuring authtoken invalidation on Accounts and
     * Classes of Service. Set to higher value to reduce network chatter. Set
     * to lower value to decrease the window during which a stolen cookie may
     * be reused to access an account.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1635)
    public Map<String,Object> unsetAuthTokenNotificationInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenNotificationInterval, "");
        return attrs;
    }

    /**
     * Whether auth token validity value checking should be performed during
     * auth token validation. See description for
     * zimbraAuthTokenValidityValue.
     *
     * @return zimbraAuthTokenValidityValueEnabled, or true if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1094)
    public boolean isAuthTokenValidityValueEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraAuthTokenValidityValueEnabled, true, true);
    }

    /**
     * Whether auth token validity value checking should be performed during
     * auth token validation. See description for
     * zimbraAuthTokenValidityValue.
     *
     * @param zimbraAuthTokenValidityValueEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1094)
    public void setAuthTokenValidityValueEnabled(boolean zimbraAuthTokenValidityValueEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenValidityValueEnabled, zimbraAuthTokenValidityValueEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether auth token validity value checking should be performed during
     * auth token validation. See description for
     * zimbraAuthTokenValidityValue.
     *
     * @param zimbraAuthTokenValidityValueEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1094)
    public Map<String,Object> setAuthTokenValidityValueEnabled(boolean zimbraAuthTokenValidityValueEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenValidityValueEnabled, zimbraAuthTokenValidityValueEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether auth token validity value checking should be performed during
     * auth token validation. See description for
     * zimbraAuthTokenValidityValue.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1094)
    public void unsetAuthTokenValidityValueEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenValidityValueEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether auth token validity value checking should be performed during
     * auth token validation. See description for
     * zimbraAuthTokenValidityValue.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1094)
    public Map<String,Object> unsetAuthTokenValidityValueEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAuthTokenValidityValueEnabled, "");
        return attrs;
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Max number of
     * accounts to process in each interval for EAGER auto provision.
     *
     * @return zimbraAutoProvBatchSize, or 20 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1234)
    public int getAutoProvBatchSize() {
        return getIntAttr(Provisioning.A_zimbraAutoProvBatchSize, 20, true);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Max number of
     * accounts to process in each interval for EAGER auto provision.
     *
     * @param zimbraAutoProvBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1234)
    public void setAutoProvBatchSize(int zimbraAutoProvBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvBatchSize, Integer.toString(zimbraAutoProvBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Max number of
     * accounts to process in each interval for EAGER auto provision.
     *
     * @param zimbraAutoProvBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1234)
    public Map<String,Object> setAutoProvBatchSize(int zimbraAutoProvBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvBatchSize, Integer.toString(zimbraAutoProvBatchSize));
        return attrs;
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Max number of
     * accounts to process in each interval for EAGER auto provision.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1234)
    public void unsetAutoProvBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Max number of
     * accounts to process in each interval for EAGER auto provision.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1234)
    public Map<String,Object> unsetAutoProvBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvBatchSize, "");
        return attrs;
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @return zimbraAutoProvNotificationBody, or "Your account has been auto provisioned.  Your email address is ${ACCOUNT_ADDRESS}." if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1357)
    public String getAutoProvNotificationBody() {
        return getAttr(Provisioning.A_zimbraAutoProvNotificationBody, "Your account has been auto provisioned.  Your email address is ${ACCOUNT_ADDRESS}.", true);
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @param zimbraAutoProvNotificationBody new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1357)
    public void setAutoProvNotificationBody(String zimbraAutoProvNotificationBody) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvNotificationBody, zimbraAutoProvNotificationBody);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @param zimbraAutoProvNotificationBody new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1357)
    public Map<String,Object> setAutoProvNotificationBody(String zimbraAutoProvNotificationBody, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvNotificationBody, zimbraAutoProvNotificationBody);
        return attrs;
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1357)
    public void unsetAutoProvNotificationBody() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvNotificationBody, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1357)
    public Map<String,Object> unsetAutoProvNotificationBody(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvNotificationBody, "");
        return attrs;
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @return zimbraAutoProvNotificationSubject, or "New account auto provisioned" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1356)
    public String getAutoProvNotificationSubject() {
        return getAttr(Provisioning.A_zimbraAutoProvNotificationSubject, "New account auto provisioned", true);
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @param zimbraAutoProvNotificationSubject new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1356)
    public void setAutoProvNotificationSubject(String zimbraAutoProvNotificationSubject) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvNotificationSubject, zimbraAutoProvNotificationSubject);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @param zimbraAutoProvNotificationSubject new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1356)
    public Map<String,Object> setAutoProvNotificationSubject(String zimbraAutoProvNotificationSubject, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvNotificationSubject, zimbraAutoProvNotificationSubject);
        return attrs;
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1356)
    public void unsetAutoProvNotificationSubject() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvNotificationSubject, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Template used to construct the subject of the notification message
     * sent to the user when the user&#039;s account is auto provisioned.
     * Supported variables: ${ACCOUNT_ADDRESS}, ${ACCOUNT_DISPLAY_NAME}
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1356)
    public Map<String,Object> unsetAutoProvNotificationSubject(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvNotificationSubject, "");
        return attrs;
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getAutoProvPollingIntervalAsString to access value as a string.
     *
     * @see #getAutoProvPollingIntervalAsString()
     *
     * @return zimbraAutoProvPollingInterval in millseconds, or 900000 (15m)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public long getAutoProvPollingInterval() {
        return getTimeInterval(Provisioning.A_zimbraAutoProvPollingInterval, 900000L, true);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraAutoProvPollingInterval, or "15m" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public String getAutoProvPollingIntervalAsString() {
        return getAttr(Provisioning.A_zimbraAutoProvPollingInterval, "15m", true);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAutoProvPollingInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public void setAutoProvPollingInterval(String zimbraAutoProvPollingInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvPollingInterval, zimbraAutoProvPollingInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraAutoProvPollingInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public Map<String,Object> setAutoProvPollingInterval(String zimbraAutoProvPollingInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvPollingInterval, zimbraAutoProvPollingInterval);
        return attrs;
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public void unsetAutoProvPollingInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvPollingInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EAGER mode: required LAZY mode: N/A MANUAL mode: N/A Interval between
     * successive polling and provisioning accounts in EAGER mode. The actual
     * interval may take longer since it can be affected by two other
     * factors: zimbraAutoProvBatchSize and number of domains configured in
     * zimbraAutoProvScheduledDomains. At each interval, the auto provision
     * thread iterates through all domains in zimbraAutoProvScheduledDomains
     * and auto creates up to domain.zimbraAutoProvBatchSize accounts. If
     * that process takes longer than zimbraAutoProvPollingInterval then the
     * next iteration will start immediately instead of waiting for
     * zimbraAutoProvPollingInterval amount of time. If set to 0 when server
     * starts up, the auto provision thread will not start. If changed from a
     * non-0 value to 0 while server is running, the auto provision thread
     * will be shutdown. If changed from 0 to a non-0 value while server is
     * running, the auto provision thread will be started. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1238)
    public Map<String,Object> unsetAutoProvPollingInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoProvPollingInterval, "");
        return attrs;
    }

    /**
     * If TRUE, use a null return path for envelope MAIL FROM when sending
     * out of office and new mail notifications. If FALSE, the account
     * address is used for the return path. Note that setting the value to
     * TRUE may cause failed delivery of some out of office or new mail
     * notifications because some agents require a valid sender.
     *
     * @return zimbraAutoSubmittedNullReturnPath, or false if unset
     */
    @ZAttr(id=502)
    public boolean isAutoSubmittedNullReturnPath() {
        return getBooleanAttr(Provisioning.A_zimbraAutoSubmittedNullReturnPath, false, true);
    }

    /**
     * If TRUE, use a null return path for envelope MAIL FROM when sending
     * out of office and new mail notifications. If FALSE, the account
     * address is used for the return path. Note that setting the value to
     * TRUE may cause failed delivery of some out of office or new mail
     * notifications because some agents require a valid sender.
     *
     * @param zimbraAutoSubmittedNullReturnPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=502)
    public void setAutoSubmittedNullReturnPath(boolean zimbraAutoSubmittedNullReturnPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoSubmittedNullReturnPath, zimbraAutoSubmittedNullReturnPath ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, use a null return path for envelope MAIL FROM when sending
     * out of office and new mail notifications. If FALSE, the account
     * address is used for the return path. Note that setting the value to
     * TRUE may cause failed delivery of some out of office or new mail
     * notifications because some agents require a valid sender.
     *
     * @param zimbraAutoSubmittedNullReturnPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=502)
    public Map<String,Object> setAutoSubmittedNullReturnPath(boolean zimbraAutoSubmittedNullReturnPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoSubmittedNullReturnPath, zimbraAutoSubmittedNullReturnPath ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, use a null return path for envelope MAIL FROM when sending
     * out of office and new mail notifications. If FALSE, the account
     * address is used for the return path. Note that setting the value to
     * TRUE may cause failed delivery of some out of office or new mail
     * notifications because some agents require a valid sender.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=502)
    public void unsetAutoSubmittedNullReturnPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoSubmittedNullReturnPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, use a null return path for envelope MAIL FROM when sending
     * out of office and new mail notifications. If FALSE, the account
     * address is used for the return path. Note that setting the value to
     * TRUE may cause failed delivery of some out of office or new mail
     * notifications because some agents require a valid sender.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=502)
    public Map<String,Object> unsetAutoSubmittedNullReturnPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraAutoSubmittedNullReturnPath, "");
        return attrs;
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @return zimbraBackupAutoGroupedInterval, or "1d" if unset
     */
    @ZAttr(id=513)
    public String getBackupAutoGroupedInterval() {
        return getAttr(Provisioning.A_zimbraBackupAutoGroupedInterval, "1d", true);
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @param zimbraBackupAutoGroupedInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=513)
    public void setBackupAutoGroupedInterval(String zimbraBackupAutoGroupedInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedInterval, zimbraBackupAutoGroupedInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @param zimbraBackupAutoGroupedInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=513)
    public Map<String,Object> setBackupAutoGroupedInterval(String zimbraBackupAutoGroupedInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedInterval, zimbraBackupAutoGroupedInterval);
        return attrs;
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=513)
    public void unsetBackupAutoGroupedInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of each interval in auto-grouped backup
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=513)
    public Map<String,Object> unsetBackupAutoGroupedInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedInterval, "");
        return attrs;
    }

    /**
     * number of groups to auto-group backups over
     *
     * @return zimbraBackupAutoGroupedNumGroups, or 7 if unset
     */
    @ZAttr(id=514)
    public int getBackupAutoGroupedNumGroups() {
        return getIntAttr(Provisioning.A_zimbraBackupAutoGroupedNumGroups, 7, true);
    }

    /**
     * number of groups to auto-group backups over
     *
     * @param zimbraBackupAutoGroupedNumGroups new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=514)
    public void setBackupAutoGroupedNumGroups(int zimbraBackupAutoGroupedNumGroups) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedNumGroups, Integer.toString(zimbraBackupAutoGroupedNumGroups));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of groups to auto-group backups over
     *
     * @param zimbraBackupAutoGroupedNumGroups new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=514)
    public Map<String,Object> setBackupAutoGroupedNumGroups(int zimbraBackupAutoGroupedNumGroups, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedNumGroups, Integer.toString(zimbraBackupAutoGroupedNumGroups));
        return attrs;
    }

    /**
     * number of groups to auto-group backups over
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=514)
    public void unsetBackupAutoGroupedNumGroups() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedNumGroups, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of groups to auto-group backups over
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=514)
    public Map<String,Object> unsetBackupAutoGroupedNumGroups(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedNumGroups, "");
        return attrs;
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @return zimbraBackupAutoGroupedThrottled, or false if unset
     */
    @ZAttr(id=515)
    public boolean isBackupAutoGroupedThrottled() {
        return getBooleanAttr(Provisioning.A_zimbraBackupAutoGroupedThrottled, false, true);
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @param zimbraBackupAutoGroupedThrottled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=515)
    public void setBackupAutoGroupedThrottled(boolean zimbraBackupAutoGroupedThrottled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedThrottled, zimbraBackupAutoGroupedThrottled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @param zimbraBackupAutoGroupedThrottled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=515)
    public Map<String,Object> setBackupAutoGroupedThrottled(boolean zimbraBackupAutoGroupedThrottled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedThrottled, zimbraBackupAutoGroupedThrottled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=515)
    public void unsetBackupAutoGroupedThrottled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedThrottled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, limit the number of mailboxes in auto-grouped backup to total
     * mailboxes divided by auto-group days
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=515)
    public Map<String,Object> unsetBackupAutoGroupedThrottled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupAutoGroupedThrottled, "");
        return attrs;
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @return zimbraBackupMinFreeSpace, or "0" if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public String getBackupMinFreeSpace() {
        return getAttr(Provisioning.A_zimbraBackupMinFreeSpace, "0", true);
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @param zimbraBackupMinFreeSpace new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public void setBackupMinFreeSpace(String zimbraBackupMinFreeSpace) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMinFreeSpace, zimbraBackupMinFreeSpace);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @param zimbraBackupMinFreeSpace new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public Map<String,Object> setBackupMinFreeSpace(String zimbraBackupMinFreeSpace, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMinFreeSpace, zimbraBackupMinFreeSpace);
        return attrs;
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public void unsetBackupMinFreeSpace() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMinFreeSpace, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum percentage or TB/GB/MB/KB/bytes of free space on backup target
     * to allow a full or auto-grouped backup to start; 0 = no minimum is
     * enforced. Examples: 25%, 10GB
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1111)
    public Map<String,Object> unsetBackupMinFreeSpace(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMinFreeSpace, "");
        return attrs;
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @return zimbraBackupMode, or ZAttrProvisioning.BackupMode.Standard if unset and/or has invalid value
     */
    @ZAttr(id=512)
    public ZAttrProvisioning.BackupMode getBackupMode() {
        try { String v = getAttr(Provisioning.A_zimbraBackupMode, true, true); return v == null ? ZAttrProvisioning.BackupMode.Standard : ZAttrProvisioning.BackupMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.BackupMode.Standard; }
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @return zimbraBackupMode, or "Standard" if unset
     */
    @ZAttr(id=512)
    public String getBackupModeAsString() {
        return getAttr(Provisioning.A_zimbraBackupMode, "Standard", true);
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param zimbraBackupMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=512)
    public void setBackupMode(ZAttrProvisioning.BackupMode zimbraBackupMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, zimbraBackupMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param zimbraBackupMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=512)
    public Map<String,Object> setBackupMode(ZAttrProvisioning.BackupMode zimbraBackupMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, zimbraBackupMode.toString());
        return attrs;
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param zimbraBackupMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=512)
    public void setBackupModeAsString(String zimbraBackupMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, zimbraBackupMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param zimbraBackupMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=512)
    public Map<String,Object> setBackupModeAsString(String zimbraBackupMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, zimbraBackupMode);
        return attrs;
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=512)
    public void unsetBackupMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * backup mode
     *
     * <p>Valid values: [Standard, Auto-Grouped]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=512)
    public Map<String,Object> unsetBackupMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupMode, "");
        return attrs;
    }

    /**
     * Backup report email recipients
     *
     * @return zimbraBackupReportEmailRecipients, or empty array if unset
     */
    @ZAttr(id=459)
    public String[] getBackupReportEmailRecipients() {
        return getMultiAttr(Provisioning.A_zimbraBackupReportEmailRecipients, true, true);
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=459)
    public void setBackupReportEmailRecipients(String[] zimbraBackupReportEmailRecipients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=459)
    public Map<String,Object> setBackupReportEmailRecipients(String[] zimbraBackupReportEmailRecipients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        return attrs;
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=459)
    public void addBackupReportEmailRecipients(String zimbraBackupReportEmailRecipients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=459)
    public Map<String,Object> addBackupReportEmailRecipients(String zimbraBackupReportEmailRecipients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        return attrs;
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=459)
    public void removeBackupReportEmailRecipients(String zimbraBackupReportEmailRecipients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email recipients
     *
     * @param zimbraBackupReportEmailRecipients existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=459)
    public Map<String,Object> removeBackupReportEmailRecipients(String zimbraBackupReportEmailRecipients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraBackupReportEmailRecipients, zimbraBackupReportEmailRecipients);
        return attrs;
    }

    /**
     * Backup report email recipients
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=459)
    public void unsetBackupReportEmailRecipients() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailRecipients, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email recipients
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=459)
    public Map<String,Object> unsetBackupReportEmailRecipients(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailRecipients, "");
        return attrs;
    }

    /**
     * Backup report email From address
     *
     * @return zimbraBackupReportEmailSender, or null if unset
     */
    @ZAttr(id=460)
    public String getBackupReportEmailSender() {
        return getAttr(Provisioning.A_zimbraBackupReportEmailSender, null, true);
    }

    /**
     * Backup report email From address
     *
     * @param zimbraBackupReportEmailSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=460)
    public void setBackupReportEmailSender(String zimbraBackupReportEmailSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSender, zimbraBackupReportEmailSender);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email From address
     *
     * @param zimbraBackupReportEmailSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=460)
    public Map<String,Object> setBackupReportEmailSender(String zimbraBackupReportEmailSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSender, zimbraBackupReportEmailSender);
        return attrs;
    }

    /**
     * Backup report email From address
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=460)
    public void unsetBackupReportEmailSender() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSender, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email From address
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=460)
    public Map<String,Object> unsetBackupReportEmailSender(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSender, "");
        return attrs;
    }

    /**
     * Backup report email subject prefix
     *
     * @return zimbraBackupReportEmailSubjectPrefix, or "ZCS Backup Report" if unset
     */
    @ZAttr(id=461)
    public String getBackupReportEmailSubjectPrefix() {
        return getAttr(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, "ZCS Backup Report", true);
    }

    /**
     * Backup report email subject prefix
     *
     * @param zimbraBackupReportEmailSubjectPrefix new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=461)
    public void setBackupReportEmailSubjectPrefix(String zimbraBackupReportEmailSubjectPrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, zimbraBackupReportEmailSubjectPrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email subject prefix
     *
     * @param zimbraBackupReportEmailSubjectPrefix new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=461)
    public Map<String,Object> setBackupReportEmailSubjectPrefix(String zimbraBackupReportEmailSubjectPrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, zimbraBackupReportEmailSubjectPrefix);
        return attrs;
    }

    /**
     * Backup report email subject prefix
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=461)
    public void unsetBackupReportEmailSubjectPrefix() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Backup report email subject prefix
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=461)
    public Map<String,Object> unsetBackupReportEmailSubjectPrefix(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupReportEmailSubjectPrefix, "");
        return attrs;
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @return zimbraBackupSkipBlobs, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public boolean isBackupSkipBlobs() {
        return getBooleanAttr(Provisioning.A_zimbraBackupSkipBlobs, false, true);
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @param zimbraBackupSkipBlobs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public void setBackupSkipBlobs(boolean zimbraBackupSkipBlobs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipBlobs, zimbraBackupSkipBlobs ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @param zimbraBackupSkipBlobs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public Map<String,Object> setBackupSkipBlobs(boolean zimbraBackupSkipBlobs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipBlobs, zimbraBackupSkipBlobs ? TRUE : FALSE);
        return attrs;
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public void unsetBackupSkipBlobs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipBlobs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup blobs (HSM or not) during a full backup
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1004)
    public Map<String,Object> unsetBackupSkipBlobs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipBlobs, "");
        return attrs;
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @return zimbraBackupSkipHsmBlobs, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public boolean isBackupSkipHsmBlobs() {
        return getBooleanAttr(Provisioning.A_zimbraBackupSkipHsmBlobs, false, true);
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @param zimbraBackupSkipHsmBlobs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public void setBackupSkipHsmBlobs(boolean zimbraBackupSkipHsmBlobs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipHsmBlobs, zimbraBackupSkipHsmBlobs ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @param zimbraBackupSkipHsmBlobs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public Map<String,Object> setBackupSkipHsmBlobs(boolean zimbraBackupSkipHsmBlobs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipHsmBlobs, zimbraBackupSkipHsmBlobs ? TRUE : FALSE);
        return attrs;
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public void unsetBackupSkipHsmBlobs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipHsmBlobs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup blobs on secondary (HSM) volumes during a full
     * backup
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1005)
    public Map<String,Object> unsetBackupSkipHsmBlobs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipHsmBlobs, "");
        return attrs;
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @return zimbraBackupSkipSearchIndex, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public boolean isBackupSkipSearchIndex() {
        return getBooleanAttr(Provisioning.A_zimbraBackupSkipSearchIndex, false, true);
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @param zimbraBackupSkipSearchIndex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public void setBackupSkipSearchIndex(boolean zimbraBackupSkipSearchIndex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipSearchIndex, zimbraBackupSkipSearchIndex ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @param zimbraBackupSkipSearchIndex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public Map<String,Object> setBackupSkipSearchIndex(boolean zimbraBackupSkipSearchIndex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipSearchIndex, zimbraBackupSkipSearchIndex ? TRUE : FALSE);
        return attrs;
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public void unsetBackupSkipSearchIndex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipSearchIndex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, do not backup search index during a full backup
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1003)
    public Map<String,Object> unsetBackupSkipSearchIndex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupSkipSearchIndex, "");
        return attrs;
    }

    /**
     * Default backup target path
     *
     * @return zimbraBackupTarget, or "/opt/zimbra/backup" if unset
     */
    @ZAttr(id=458)
    public String getBackupTarget() {
        return getAttr(Provisioning.A_zimbraBackupTarget, "/opt/zimbra/backup", true);
    }

    /**
     * Default backup target path
     *
     * @param zimbraBackupTarget new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=458)
    public void setBackupTarget(String zimbraBackupTarget) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupTarget, zimbraBackupTarget);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default backup target path
     *
     * @param zimbraBackupTarget new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=458)
    public Map<String,Object> setBackupTarget(String zimbraBackupTarget, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupTarget, zimbraBackupTarget);
        return attrs;
    }

    /**
     * Default backup target path
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=458)
    public void unsetBackupTarget() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupTarget, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default backup target path
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=458)
    public Map<String,Object> unsetBackupTarget(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBackupTarget, "");
        return attrs;
    }

    /**
     * Realm for the basic auth challenge (WWW-Authenticate) header
     *
     * @return zimbraBasicAuthRealm, or "Zimbra" if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1098)
    public String getBasicAuthRealm() {
        return getAttr(Provisioning.A_zimbraBasicAuthRealm, "Zimbra", true);
    }

    /**
     * Realm for the basic auth challenge (WWW-Authenticate) header
     *
     * @param zimbraBasicAuthRealm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1098)
    public void setBasicAuthRealm(String zimbraBasicAuthRealm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBasicAuthRealm, zimbraBasicAuthRealm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Realm for the basic auth challenge (WWW-Authenticate) header
     *
     * @param zimbraBasicAuthRealm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1098)
    public Map<String,Object> setBasicAuthRealm(String zimbraBasicAuthRealm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBasicAuthRealm, zimbraBasicAuthRealm);
        return attrs;
    }

    /**
     * Realm for the basic auth challenge (WWW-Authenticate) header
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1098)
    public void unsetBasicAuthRealm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBasicAuthRealm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Realm for the basic auth challenge (WWW-Authenticate) header
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1098)
    public Map<String,Object> unsetBasicAuthRealm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraBasicAuthRealm, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @return zimbraCBPolicydAccessControlEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public boolean isCBPolicydAccessControlEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydAccessControlEnabled, false, true);
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydAccessControlEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public void setCBPolicydAccessControlEnabled(boolean zimbraCBPolicydAccessControlEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccessControlEnabled, zimbraCBPolicydAccessControlEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydAccessControlEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public Map<String,Object> setCBPolicydAccessControlEnabled(boolean zimbraCBPolicydAccessControlEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccessControlEnabled, zimbraCBPolicydAccessControlEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public void unsetCBPolicydAccessControlEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccessControlEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Access Control module. Defaults to
     * FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1469)
    public Map<String,Object> unsetCBPolicydAccessControlEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccessControlEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @return zimbraCBPolicydAccountingEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public boolean isCBPolicydAccountingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydAccountingEnabled, false, true);
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydAccountingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public void setCBPolicydAccountingEnabled(boolean zimbraCBPolicydAccountingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccountingEnabled, zimbraCBPolicydAccountingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydAccountingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public Map<String,Object> setCBPolicydAccountingEnabled(boolean zimbraCBPolicydAccountingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccountingEnabled, zimbraCBPolicydAccountingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public void unsetCBPolicydAccountingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccountingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Accounting module. Defaults to
     * FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1470)
    public Map<String,Object> unsetCBPolicydAccountingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAccountingEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @return zimbraCBPolicydAmavisEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public boolean isCBPolicydAmavisEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydAmavisEnabled, false, true);
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @param zimbraCBPolicydAmavisEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public void setCBPolicydAmavisEnabled(boolean zimbraCBPolicydAmavisEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAmavisEnabled, zimbraCBPolicydAmavisEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @param zimbraCBPolicydAmavisEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public Map<String,Object> setCBPolicydAmavisEnabled(boolean zimbraCBPolicydAmavisEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAmavisEnabled, zimbraCBPolicydAmavisEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public void unsetCBPolicydAmavisEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAmavisEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Amavis module. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1471)
    public Map<String,Object> unsetCBPolicydAmavisEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydAmavisEnabled, "");
        return attrs;
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @return zimbraCBPolicydBindPort, or 10031 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public int getCBPolicydBindPort() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydBindPort, 10031, true);
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @param zimbraCBPolicydBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public void setCBPolicydBindPort(int zimbraCBPolicydBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBindPort, Integer.toString(zimbraCBPolicydBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @param zimbraCBPolicydBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public Map<String,Object> setCBPolicydBindPort(int zimbraCBPolicydBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBindPort, Integer.toString(zimbraCBPolicydBindPort));
        return attrs;
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public void unsetCBPolicydBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port for CBPolicyd to bind to. Defaults to 10031
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1561)
    public Map<String,Object> unsetCBPolicydBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBindPort, "");
        return attrs;
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [tempfail, pass]
     *
     * @return zimbraCBPolicydBypassMode, or ZAttrProvisioning.CBPolicydBypassMode.tempfail if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public ZAttrProvisioning.CBPolicydBypassMode getCBPolicydBypassMode() {
        try { String v = getAttr(Provisioning.A_zimbraCBPolicydBypassMode, true, true); return v == null ? ZAttrProvisioning.CBPolicydBypassMode.tempfail : ZAttrProvisioning.CBPolicydBypassMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.CBPolicydBypassMode.tempfail; }
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [tempfail, pass]
     *
     * @return zimbraCBPolicydBypassMode, or "tempfail" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public String getCBPolicydBypassModeAsString() {
        return getAttr(Provisioning.A_zimbraCBPolicydBypassMode, "tempfail", true);
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [tempfail, pass]
     *
     * @param zimbraCBPolicydBypassMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public void setCBPolicydBypassMode(ZAttrProvisioning.CBPolicydBypassMode zimbraCBPolicydBypassMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, zimbraCBPolicydBypassMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [tempfail, pass]
     *
     * @param zimbraCBPolicydBypassMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public Map<String,Object> setCBPolicydBypassMode(ZAttrProvisioning.CBPolicydBypassMode zimbraCBPolicydBypassMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, zimbraCBPolicydBypassMode.toString());
        return attrs;
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [tempfail, pass]
     *
     * @param zimbraCBPolicydBypassMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public void setCBPolicydBypassModeAsString(String zimbraCBPolicydBypassMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, zimbraCBPolicydBypassMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [tempfail, pass]
     *
     * @param zimbraCBPolicydBypassMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public Map<String,Object> setCBPolicydBypassModeAsString(String zimbraCBPolicydBypassMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, zimbraCBPolicydBypassMode);
        return attrs;
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [tempfail, pass]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public void unsetCBPolicydBypassMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass fail mode. Default is tempfail
     *
     * <p>Valid values: [tempfail, pass]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1485)
    public Map<String,Object> unsetCBPolicydBypassMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassMode, "");
        return attrs;
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @return zimbraCBPolicydBypassTimeout, or 30 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public int getCBPolicydBypassTimeout() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydBypassTimeout, 30, true);
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @param zimbraCBPolicydBypassTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public void setCBPolicydBypassTimeout(int zimbraCBPolicydBypassTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassTimeout, Integer.toString(zimbraCBPolicydBypassTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @param zimbraCBPolicydBypassTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public Map<String,Object> setCBPolicydBypassTimeout(int zimbraCBPolicydBypassTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassTimeout, Integer.toString(zimbraCBPolicydBypassTimeout));
        return attrs;
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public void unsetCBPolicydBypassTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Bypass timeout. Defaults to 30 seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1484)
    public Map<String,Object> unsetCBPolicydBypassTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydBypassTimeout, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @return zimbraCBPolicydCheckHeloEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public boolean isCBPolicydCheckHeloEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, false, true);
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydCheckHeloEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public void setCBPolicydCheckHeloEnabled(boolean zimbraCBPolicydCheckHeloEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, zimbraCBPolicydCheckHeloEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydCheckHeloEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public Map<String,Object> setCBPolicydCheckHeloEnabled(boolean zimbraCBPolicydCheckHeloEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, zimbraCBPolicydCheckHeloEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public void unsetCBPolicydCheckHeloEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Check Helo module. Defaults to
     * FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1472)
    public Map<String,Object> unsetCBPolicydCheckHeloEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckHeloEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @return zimbraCBPolicydCheckSPFEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public boolean isCBPolicydCheckSPFEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, false, true);
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @param zimbraCBPolicydCheckSPFEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public void setCBPolicydCheckSPFEnabled(boolean zimbraCBPolicydCheckSPFEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, zimbraCBPolicydCheckSPFEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @param zimbraCBPolicydCheckSPFEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public Map<String,Object> setCBPolicydCheckSPFEnabled(boolean zimbraCBPolicydCheckSPFEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, zimbraCBPolicydCheckSPFEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public void unsetCBPolicydCheckSPFEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd CheckSPF module. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1473)
    public Map<String,Object> unsetCBPolicydCheckSPFEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydCheckSPFEnabled, "");
        return attrs;
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @return zimbraCBPolicydGreylistingBlacklistMsg, or "Greylisting in effect, sending server blacklisted" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public String getCBPolicydGreylistingBlacklistMsg() {
        return getAttr(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, "Greylisting in effect, sending server blacklisted", true);
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @param zimbraCBPolicydGreylistingBlacklistMsg new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public void setCBPolicydGreylistingBlacklistMsg(String zimbraCBPolicydGreylistingBlacklistMsg) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, zimbraCBPolicydGreylistingBlacklistMsg);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @param zimbraCBPolicydGreylistingBlacklistMsg new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public Map<String,Object> setCBPolicydGreylistingBlacklistMsg(String zimbraCBPolicydGreylistingBlacklistMsg, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, zimbraCBPolicydGreylistingBlacklistMsg);
        return attrs;
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public void unsetCBPolicydGreylistingBlacklistMsg() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Message to give when client is on blacklist. Default is Greylisting in
     * effect, sending server blacklisted
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1487)
    public Map<String,Object> unsetCBPolicydGreylistingBlacklistMsg(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingBlacklistMsg, "");
        return attrs;
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @return zimbraCBPolicydGreylistingDeferMsg, or "Greylisting in effect, please come back later" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public String getCBPolicydGreylistingDeferMsg() {
        return getAttr(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, "Greylisting in effect, please come back later", true);
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @param zimbraCBPolicydGreylistingDeferMsg new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public void setCBPolicydGreylistingDeferMsg(String zimbraCBPolicydGreylistingDeferMsg) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, zimbraCBPolicydGreylistingDeferMsg);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @param zimbraCBPolicydGreylistingDeferMsg new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public Map<String,Object> setCBPolicydGreylistingDeferMsg(String zimbraCBPolicydGreylistingDeferMsg, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, zimbraCBPolicydGreylistingDeferMsg);
        return attrs;
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public void unsetCBPolicydGreylistingDeferMsg() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Message to give when deferring email. Default is Greylisting in
     * effect, please come back later
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1486)
    public Map<String,Object> unsetCBPolicydGreylistingDeferMsg(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingDeferMsg, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @return zimbraCBPolicydGreylistingEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public boolean isCBPolicydGreylistingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydGreylistingEnabled, false, true);
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydGreylistingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public void setCBPolicydGreylistingEnabled(boolean zimbraCBPolicydGreylistingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingEnabled, zimbraCBPolicydGreylistingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @param zimbraCBPolicydGreylistingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public Map<String,Object> setCBPolicydGreylistingEnabled(boolean zimbraCBPolicydGreylistingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingEnabled, zimbraCBPolicydGreylistingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public void unsetCBPolicydGreylistingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Greylisting module. Defaults to
     * FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1474)
    public Map<String,Object> unsetCBPolicydGreylistingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @return zimbraCBPolicydGreylistingTrainingEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public boolean isCBPolicydGreylistingTrainingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, false, true);
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @param zimbraCBPolicydGreylistingTrainingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public void setCBPolicydGreylistingTrainingEnabled(boolean zimbraCBPolicydGreylistingTrainingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, zimbraCBPolicydGreylistingTrainingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @param zimbraCBPolicydGreylistingTrainingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public Map<String,Object> setCBPolicydGreylistingTrainingEnabled(boolean zimbraCBPolicydGreylistingTrainingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, zimbraCBPolicydGreylistingTrainingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public void unsetCBPolicydGreylistingTrainingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to put CBPolicyd Greylisting module in training only
     * mode. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1475)
    public Map<String,Object> unsetCBPolicydGreylistingTrainingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydGreylistingTrainingEnabled, "");
        return attrs;
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @return zimbraCBPolicydLogLevel, or 3 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public int getCBPolicydLogLevel() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydLogLevel, 3, true);
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @param zimbraCBPolicydLogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public void setCBPolicydLogLevel(int zimbraCBPolicydLogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydLogLevel, Integer.toString(zimbraCBPolicydLogLevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @param zimbraCBPolicydLogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public Map<String,Object> setCBPolicydLogLevel(int zimbraCBPolicydLogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydLogLevel, Integer.toString(zimbraCBPolicydLogLevel));
        return attrs;
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public void unsetCBPolicydLogLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydLogLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Logging level for CBPolicyd. Defaults to 3. Valid range is 0-4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1562)
    public Map<String,Object> unsetCBPolicydLogLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydLogLevel, "");
        return attrs;
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @return zimbraCBPolicydMaxRequests, or 1000 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public int getCBPolicydMaxRequests() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMaxRequests, 1000, true);
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @param zimbraCBPolicydMaxRequests new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public void setCBPolicydMaxRequests(int zimbraCBPolicydMaxRequests) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxRequests, Integer.toString(zimbraCBPolicydMaxRequests));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @param zimbraCBPolicydMaxRequests new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public Map<String,Object> setCBPolicydMaxRequests(int zimbraCBPolicydMaxRequests, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxRequests, Integer.toString(zimbraCBPolicydMaxRequests));
        return attrs;
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public void unsetCBPolicydMaxRequests() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxRequests, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of requests to process per server. Defaults to 1000
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1481)
    public Map<String,Object> unsetCBPolicydMaxRequests(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxRequests, "");
        return attrs;
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @return zimbraCBPolicydMaxServers, or 25 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public int getCBPolicydMaxServers() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMaxServers, 25, true);
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @param zimbraCBPolicydMaxServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public void setCBPolicydMaxServers(int zimbraCBPolicydMaxServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxServers, Integer.toString(zimbraCBPolicydMaxServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @param zimbraCBPolicydMaxServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public Map<String,Object> setCBPolicydMaxServers(int zimbraCBPolicydMaxServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxServers, Integer.toString(zimbraCBPolicydMaxServers));
        return attrs;
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public void unsetCBPolicydMaxServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of servers to allow. Defaults to 25
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1480)
    public Map<String,Object> unsetCBPolicydMaxServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxServers, "");
        return attrs;
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @return zimbraCBPolicydMaxSpareServers, or 12 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public int getCBPolicydMaxSpareServers() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMaxSpareServers, 12, true);
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @param zimbraCBPolicydMaxSpareServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public void setCBPolicydMaxSpareServers(int zimbraCBPolicydMaxSpareServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxSpareServers, Integer.toString(zimbraCBPolicydMaxSpareServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @param zimbraCBPolicydMaxSpareServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public Map<String,Object> setCBPolicydMaxSpareServers(int zimbraCBPolicydMaxSpareServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxSpareServers, Integer.toString(zimbraCBPolicydMaxSpareServers));
        return attrs;
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public void unsetCBPolicydMaxSpareServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxSpareServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of spare servers to have on hand that are idle.
     * Defaults to 12
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1479)
    public Map<String,Object> unsetCBPolicydMaxSpareServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMaxSpareServers, "");
        return attrs;
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @return zimbraCBPolicydMinServers, or 4 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public int getCBPolicydMinServers() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMinServers, 4, true);
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @param zimbraCBPolicydMinServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public void setCBPolicydMinServers(int zimbraCBPolicydMinServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinServers, Integer.toString(zimbraCBPolicydMinServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @param zimbraCBPolicydMinServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public Map<String,Object> setCBPolicydMinServers(int zimbraCBPolicydMinServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinServers, Integer.toString(zimbraCBPolicydMinServers));
        return attrs;
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public void unsetCBPolicydMinServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum number of CBPolicyd servers to have running. Defaults to 4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1477)
    public Map<String,Object> unsetCBPolicydMinServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinServers, "");
        return attrs;
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @return zimbraCBPolicydMinSpareServers, or 4 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public int getCBPolicydMinSpareServers() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydMinSpareServers, 4, true);
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @param zimbraCBPolicydMinSpareServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public void setCBPolicydMinSpareServers(int zimbraCBPolicydMinSpareServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinSpareServers, Integer.toString(zimbraCBPolicydMinSpareServers));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @param zimbraCBPolicydMinSpareServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public Map<String,Object> setCBPolicydMinSpareServers(int zimbraCBPolicydMinSpareServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinSpareServers, Integer.toString(zimbraCBPolicydMinSpareServers));
        return attrs;
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public void unsetCBPolicydMinSpareServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinSpareServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Minimum number of spare servers to have on hand. Defaults to 4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1478)
    public Map<String,Object> unsetCBPolicydMinSpareServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydMinSpareServers, "");
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @return zimbraCBPolicydQuotasEnabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public boolean isCBPolicydQuotasEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCBPolicydQuotasEnabled, true, true);
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @param zimbraCBPolicydQuotasEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public void setCBPolicydQuotasEnabled(boolean zimbraCBPolicydQuotasEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydQuotasEnabled, zimbraCBPolicydQuotasEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @param zimbraCBPolicydQuotasEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public Map<String,Object> setCBPolicydQuotasEnabled(boolean zimbraCBPolicydQuotasEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydQuotasEnabled, zimbraCBPolicydQuotasEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public void unsetCBPolicydQuotasEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydQuotasEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable CBPolicyd Quotas module. Defaults to TRUE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1476)
    public Map<String,Object> unsetCBPolicydQuotasEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydQuotasEnabled, "");
        return attrs;
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @return zimbraCBPolicydTimeoutBusy, or 120 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public int getCBPolicydTimeoutBusy() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydTimeoutBusy, 120, true);
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @param zimbraCBPolicydTimeoutBusy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public void setCBPolicydTimeoutBusy(int zimbraCBPolicydTimeoutBusy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutBusy, Integer.toString(zimbraCBPolicydTimeoutBusy));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @param zimbraCBPolicydTimeoutBusy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public Map<String,Object> setCBPolicydTimeoutBusy(int zimbraCBPolicydTimeoutBusy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutBusy, Integer.toString(zimbraCBPolicydTimeoutBusy));
        return attrs;
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public void unsetCBPolicydTimeoutBusy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutBusy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout when talking to clients and servers are busy. Defaults to 120
     * seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1483)
    public Map<String,Object> unsetCBPolicydTimeoutBusy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutBusy, "");
        return attrs;
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @return zimbraCBPolicydTimeoutIdle, or 1020 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public int getCBPolicydTimeoutIdle() {
        return getIntAttr(Provisioning.A_zimbraCBPolicydTimeoutIdle, 1020, true);
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @param zimbraCBPolicydTimeoutIdle new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public void setCBPolicydTimeoutIdle(int zimbraCBPolicydTimeoutIdle) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutIdle, Integer.toString(zimbraCBPolicydTimeoutIdle));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @param zimbraCBPolicydTimeoutIdle new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public Map<String,Object> setCBPolicydTimeoutIdle(int zimbraCBPolicydTimeoutIdle, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutIdle, Integer.toString(zimbraCBPolicydTimeoutIdle));
        return attrs;
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public void unsetCBPolicydTimeoutIdle() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutIdle, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout when talking to clients and servers are idle. Defaults to 1020
     * seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1482)
    public Map<String,Object> unsetCBPolicydTimeoutIdle(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCBPolicydTimeoutIdle, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @return zimbraCOSInheritedAttr, or empty array if unset
     */
    @ZAttr(id=21)
    public String[] getCOSInheritedAttr() {
        return getMultiAttr(Provisioning.A_zimbraCOSInheritedAttr, true, true);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @param zimbraCOSInheritedAttr new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=21)
    public void setCOSInheritedAttr(String[] zimbraCOSInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCOSInheritedAttr, zimbraCOSInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @param zimbraCOSInheritedAttr new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=21)
    public Map<String,Object> setCOSInheritedAttr(String[] zimbraCOSInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCOSInheritedAttr, zimbraCOSInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @param zimbraCOSInheritedAttr new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=21)
    public void addCOSInheritedAttr(String zimbraCOSInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCOSInheritedAttr, zimbraCOSInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @param zimbraCOSInheritedAttr new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=21)
    public Map<String,Object> addCOSInheritedAttr(String zimbraCOSInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCOSInheritedAttr, zimbraCOSInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @param zimbraCOSInheritedAttr existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=21)
    public void removeCOSInheritedAttr(String zimbraCOSInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCOSInheritedAttr, zimbraCOSInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @param zimbraCOSInheritedAttr existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=21)
    public Map<String,Object> removeCOSInheritedAttr(String zimbraCOSInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCOSInheritedAttr, zimbraCOSInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=21)
    public void unsetCOSInheritedAttr() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCOSInheritedAttr, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the accountInherited
     * flag. Orig desc: zimbraCOS attrs that get inherited in a zimbraAccount
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=21)
    public Map<String,Object> unsetCOSInheritedAttr(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCOSInheritedAttr, "");
        return attrs;
    }

    /**
     * alternate location for calendar and task folders
     *
     * @return zimbraCalendarCalDavAlternateCalendarHomeSet, or empty array if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public String[] getCalendarCalDavAlternateCalendarHomeSet() {
        return getMultiAttr(Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, true, true);
    }

    /**
     * alternate location for calendar and task folders
     *
     * @param zimbraCalendarCalDavAlternateCalendarHomeSet new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public void setCalendarCalDavAlternateCalendarHomeSet(String[] zimbraCalendarCalDavAlternateCalendarHomeSet) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, zimbraCalendarCalDavAlternateCalendarHomeSet);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * alternate location for calendar and task folders
     *
     * @param zimbraCalendarCalDavAlternateCalendarHomeSet new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public Map<String,Object> setCalendarCalDavAlternateCalendarHomeSet(String[] zimbraCalendarCalDavAlternateCalendarHomeSet, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, zimbraCalendarCalDavAlternateCalendarHomeSet);
        return attrs;
    }

    /**
     * alternate location for calendar and task folders
     *
     * @param zimbraCalendarCalDavAlternateCalendarHomeSet new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public void addCalendarCalDavAlternateCalendarHomeSet(String zimbraCalendarCalDavAlternateCalendarHomeSet) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, zimbraCalendarCalDavAlternateCalendarHomeSet);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * alternate location for calendar and task folders
     *
     * @param zimbraCalendarCalDavAlternateCalendarHomeSet new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public Map<String,Object> addCalendarCalDavAlternateCalendarHomeSet(String zimbraCalendarCalDavAlternateCalendarHomeSet, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, zimbraCalendarCalDavAlternateCalendarHomeSet);
        return attrs;
    }

    /**
     * alternate location for calendar and task folders
     *
     * @param zimbraCalendarCalDavAlternateCalendarHomeSet existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public void removeCalendarCalDavAlternateCalendarHomeSet(String zimbraCalendarCalDavAlternateCalendarHomeSet) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, zimbraCalendarCalDavAlternateCalendarHomeSet);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * alternate location for calendar and task folders
     *
     * @param zimbraCalendarCalDavAlternateCalendarHomeSet existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public Map<String,Object> removeCalendarCalDavAlternateCalendarHomeSet(String zimbraCalendarCalDavAlternateCalendarHomeSet, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, zimbraCalendarCalDavAlternateCalendarHomeSet);
        return attrs;
    }

    /**
     * alternate location for calendar and task folders
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public void unsetCalendarCalDavAlternateCalendarHomeSet() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * alternate location for calendar and task folders
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=651)
    public Map<String,Object> unsetCalendarCalDavAlternateCalendarHomeSet(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavAlternateCalendarHomeSet, "");
        return attrs;
    }

    /**
     * Enable support for the the &quot;calendar-auto-schedule&quot; feature
     * of CalDAV - see RFC6638. If FALSE, the &quot;calendar-schedule&quot;
     * feature of CalDAV is advertised instead - see
     * draft-desruisseaux-caldav-sched-03. Note that the value of
     * &quot;zimbraCalendarCalDavDisableScheduling&quot; takes precedence
     * over this attribute.
     *
     * @return zimbraCalendarCalDavCalendarAutoScheduleEnabled, or true if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1655)
    public boolean isCalendarCalDavCalendarAutoScheduleEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarCalDavCalendarAutoScheduleEnabled, true, true);
    }

    /**
     * Enable support for the the &quot;calendar-auto-schedule&quot; feature
     * of CalDAV - see RFC6638. If FALSE, the &quot;calendar-schedule&quot;
     * feature of CalDAV is advertised instead - see
     * draft-desruisseaux-caldav-sched-03. Note that the value of
     * &quot;zimbraCalendarCalDavDisableScheduling&quot; takes precedence
     * over this attribute.
     *
     * @param zimbraCalendarCalDavCalendarAutoScheduleEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1655)
    public void setCalendarCalDavCalendarAutoScheduleEnabled(boolean zimbraCalendarCalDavCalendarAutoScheduleEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavCalendarAutoScheduleEnabled, zimbraCalendarCalDavCalendarAutoScheduleEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable support for the the &quot;calendar-auto-schedule&quot; feature
     * of CalDAV - see RFC6638. If FALSE, the &quot;calendar-schedule&quot;
     * feature of CalDAV is advertised instead - see
     * draft-desruisseaux-caldav-sched-03. Note that the value of
     * &quot;zimbraCalendarCalDavDisableScheduling&quot; takes precedence
     * over this attribute.
     *
     * @param zimbraCalendarCalDavCalendarAutoScheduleEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1655)
    public Map<String,Object> setCalendarCalDavCalendarAutoScheduleEnabled(boolean zimbraCalendarCalDavCalendarAutoScheduleEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavCalendarAutoScheduleEnabled, zimbraCalendarCalDavCalendarAutoScheduleEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Enable support for the the &quot;calendar-auto-schedule&quot; feature
     * of CalDAV - see RFC6638. If FALSE, the &quot;calendar-schedule&quot;
     * feature of CalDAV is advertised instead - see
     * draft-desruisseaux-caldav-sched-03. Note that the value of
     * &quot;zimbraCalendarCalDavDisableScheduling&quot; takes precedence
     * over this attribute.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1655)
    public void unsetCalendarCalDavCalendarAutoScheduleEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavCalendarAutoScheduleEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable support for the the &quot;calendar-auto-schedule&quot; feature
     * of CalDAV - see RFC6638. If FALSE, the &quot;calendar-schedule&quot;
     * feature of CalDAV is advertised instead - see
     * draft-desruisseaux-caldav-sched-03. Note that the value of
     * &quot;zimbraCalendarCalDavDisableScheduling&quot; takes precedence
     * over this attribute.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1655)
    public Map<String,Object> unsetCalendarCalDavCalendarAutoScheduleEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavCalendarAutoScheduleEnabled, "");
        return attrs;
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @return zimbraCalendarCalDavClearTextPasswordEnabled, or true if unset
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public boolean isCalendarCalDavClearTextPasswordEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, true, true);
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @param zimbraCalendarCalDavClearTextPasswordEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public void setCalendarCalDavClearTextPasswordEnabled(boolean zimbraCalendarCalDavClearTextPasswordEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, zimbraCalendarCalDavClearTextPasswordEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @param zimbraCalendarCalDavClearTextPasswordEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public Map<String,Object> setCalendarCalDavClearTextPasswordEnabled(boolean zimbraCalendarCalDavClearTextPasswordEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, zimbraCalendarCalDavClearTextPasswordEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public void unsetCalendarCalDavClearTextPasswordEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow password sent to non-secured port from CalDAV
     * clients. If it set to TRUE the server will allow access from CalDAV
     * client to zimbraMailPort. If it set to FALSE the server will return an
     * error if a request is made from CalDAV client to zimbraMailPort.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.14
     */
    @ZAttr(id=820)
    public Map<String,Object> unsetCalendarCalDavClearTextPasswordEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavClearTextPasswordEnabled, "");
        return attrs;
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @return zimbraCalendarCalDavDefaultCalendarId, or 10 if unset
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public int getCalendarCalDavDefaultCalendarId() {
        return getIntAttr(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, 10, true);
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @param zimbraCalendarCalDavDefaultCalendarId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public void setCalendarCalDavDefaultCalendarId(int zimbraCalendarCalDavDefaultCalendarId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, Integer.toString(zimbraCalendarCalDavDefaultCalendarId));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @param zimbraCalendarCalDavDefaultCalendarId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public Map<String,Object> setCalendarCalDavDefaultCalendarId(int zimbraCalendarCalDavDefaultCalendarId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, Integer.toString(zimbraCalendarCalDavDefaultCalendarId));
        return attrs;
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public void unsetCalendarCalDavDefaultCalendarId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Id of calendar folder to advertise as the default calendar to CalDAV
     * client.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1078)
    public Map<String,Object> unsetCalendarCalDavDefaultCalendarId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDefaultCalendarId, "");
        return attrs;
    }

    /**
     * set true to turn off handling free/busy lookup for CalDAV
     *
     * @return zimbraCalendarCalDavDisableFreebusy, or false if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=690)
    public boolean isCalendarCalDavDisableFreebusy() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarCalDavDisableFreebusy, false, true);
    }

    /**
     * set true to turn off handling free/busy lookup for CalDAV
     *
     * @param zimbraCalendarCalDavDisableFreebusy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=690)
    public void setCalendarCalDavDisableFreebusy(boolean zimbraCalendarCalDavDisableFreebusy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDisableFreebusy, zimbraCalendarCalDavDisableFreebusy ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set true to turn off handling free/busy lookup for CalDAV
     *
     * @param zimbraCalendarCalDavDisableFreebusy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=690)
    public Map<String,Object> setCalendarCalDavDisableFreebusy(boolean zimbraCalendarCalDavDisableFreebusy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDisableFreebusy, zimbraCalendarCalDavDisableFreebusy ? TRUE : FALSE);
        return attrs;
    }

    /**
     * set true to turn off handling free/busy lookup for CalDAV
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=690)
    public void unsetCalendarCalDavDisableFreebusy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDisableFreebusy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set true to turn off handling free/busy lookup for CalDAV
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=690)
    public Map<String,Object> unsetCalendarCalDavDisableFreebusy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDisableFreebusy, "");
        return attrs;
    }

    /**
     * set true to turn off handling scheduling message for CalDAV
     *
     * @return zimbraCalendarCalDavDisableScheduling, or false if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=652)
    public boolean isCalendarCalDavDisableScheduling() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarCalDavDisableScheduling, false, true);
    }

    /**
     * set true to turn off handling scheduling message for CalDAV
     *
     * @param zimbraCalendarCalDavDisableScheduling new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=652)
    public void setCalendarCalDavDisableScheduling(boolean zimbraCalendarCalDavDisableScheduling) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDisableScheduling, zimbraCalendarCalDavDisableScheduling ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set true to turn off handling scheduling message for CalDAV
     *
     * @param zimbraCalendarCalDavDisableScheduling new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=652)
    public Map<String,Object> setCalendarCalDavDisableScheduling(boolean zimbraCalendarCalDavDisableScheduling, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDisableScheduling, zimbraCalendarCalDavDisableScheduling ? TRUE : FALSE);
        return attrs;
    }

    /**
     * set true to turn off handling scheduling message for CalDAV
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=652)
    public void unsetCalendarCalDavDisableScheduling() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDisableScheduling, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * set true to turn off handling scheduling message for CalDAV
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=652)
    public Map<String,Object> unsetCalendarCalDavDisableScheduling(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavDisableScheduling, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 69886.. Orig desc: When
     * set to TRUE, Calendar folders and Todo folders in Zimbra will be
     * advertised as Calendar only and Todo only via CalDAV. When set to
     * FALSE, Calendar folders will be able to store both appointments and
     * tasks, and Todo folders will not be advertised as CalDAV enabled.
     *
     * @return zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection, or false if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=794)
    public boolean isCalendarCalDavUseDistinctAppointmentAndToDoCollection() {
        return getBooleanAttr(Provisioning.A_zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection, false, true);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 69886.. Orig desc: When
     * set to TRUE, Calendar folders and Todo folders in Zimbra will be
     * advertised as Calendar only and Todo only via CalDAV. When set to
     * FALSE, Calendar folders will be able to store both appointments and
     * tasks, and Todo folders will not be advertised as CalDAV enabled.
     *
     * @param zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=794)
    public void setCalendarCalDavUseDistinctAppointmentAndToDoCollection(boolean zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection, zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 69886.. Orig desc: When
     * set to TRUE, Calendar folders and Todo folders in Zimbra will be
     * advertised as Calendar only and Todo only via CalDAV. When set to
     * FALSE, Calendar folders will be able to store both appointments and
     * tasks, and Todo folders will not be advertised as CalDAV enabled.
     *
     * @param zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=794)
    public Map<String,Object> setCalendarCalDavUseDistinctAppointmentAndToDoCollection(boolean zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection, zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 69886.. Orig desc: When
     * set to TRUE, Calendar folders and Todo folders in Zimbra will be
     * advertised as Calendar only and Todo only via CalDAV. When set to
     * FALSE, Calendar folders will be able to store both appointments and
     * tasks, and Todo folders will not be advertised as CalDAV enabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=794)
    public void unsetCalendarCalDavUseDistinctAppointmentAndToDoCollection() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Deprecated per bug 69886.. Orig desc: When
     * set to TRUE, Calendar folders and Todo folders in Zimbra will be
     * advertised as Calendar only and Todo only via CalDAV. When set to
     * FALSE, Calendar folders will be able to store both appointments and
     * tasks, and Todo folders will not be advertised as CalDAV enabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=794)
    public Map<String,Object> unsetCalendarCalDavUseDistinctAppointmentAndToDoCollection(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCalDavUseDistinctAppointmentAndToDoCollection, "");
        return attrs;
    }

    /**
     * compatibility mode for calendar server
     *
     * <p>Valid values: [standard, exchange]
     *
     * @return zimbraCalendarCompatibilityMode, or ZAttrProvisioning.CalendarCompatibilityMode.standard if unset and/or has invalid value
     */
    @ZAttr(id=243)
    public ZAttrProvisioning.CalendarCompatibilityMode getCalendarCompatibilityMode() {
        try { String v = getAttr(Provisioning.A_zimbraCalendarCompatibilityMode, true, true); return v == null ? ZAttrProvisioning.CalendarCompatibilityMode.standard : ZAttrProvisioning.CalendarCompatibilityMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.CalendarCompatibilityMode.standard; }
    }

    /**
     * compatibility mode for calendar server
     *
     * <p>Valid values: [standard, exchange]
     *
     * @return zimbraCalendarCompatibilityMode, or "standard" if unset
     */
    @ZAttr(id=243)
    public String getCalendarCompatibilityModeAsString() {
        return getAttr(Provisioning.A_zimbraCalendarCompatibilityMode, "standard", true);
    }

    /**
     * compatibility mode for calendar server
     *
     * <p>Valid values: [standard, exchange]
     *
     * @param zimbraCalendarCompatibilityMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=243)
    public void setCalendarCompatibilityMode(ZAttrProvisioning.CalendarCompatibilityMode zimbraCalendarCompatibilityMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCompatibilityMode, zimbraCalendarCompatibilityMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * compatibility mode for calendar server
     *
     * <p>Valid values: [standard, exchange]
     *
     * @param zimbraCalendarCompatibilityMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=243)
    public Map<String,Object> setCalendarCompatibilityMode(ZAttrProvisioning.CalendarCompatibilityMode zimbraCalendarCompatibilityMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCompatibilityMode, zimbraCalendarCompatibilityMode.toString());
        return attrs;
    }

    /**
     * compatibility mode for calendar server
     *
     * <p>Valid values: [standard, exchange]
     *
     * @param zimbraCalendarCompatibilityMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=243)
    public void setCalendarCompatibilityModeAsString(String zimbraCalendarCompatibilityMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCompatibilityMode, zimbraCalendarCompatibilityMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * compatibility mode for calendar server
     *
     * <p>Valid values: [standard, exchange]
     *
     * @param zimbraCalendarCompatibilityMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=243)
    public Map<String,Object> setCalendarCompatibilityModeAsString(String zimbraCalendarCompatibilityMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCompatibilityMode, zimbraCalendarCompatibilityMode);
        return attrs;
    }

    /**
     * compatibility mode for calendar server
     *
     * <p>Valid values: [standard, exchange]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=243)
    public void unsetCalendarCompatibilityMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCompatibilityMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * compatibility mode for calendar server
     *
     * <p>Valid values: [standard, exchange]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=243)
    public Map<String,Object> unsetCalendarCompatibilityMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarCompatibilityMode, "");
        return attrs;
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceDailyMaxDays, or 730 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public int getCalendarRecurrenceDailyMaxDays() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, 730, true);
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceDailyMaxDays new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public void setCalendarRecurrenceDailyMaxDays(int zimbraCalendarRecurrenceDailyMaxDays) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, Integer.toString(zimbraCalendarRecurrenceDailyMaxDays));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceDailyMaxDays new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public Map<String,Object> setCalendarRecurrenceDailyMaxDays(int zimbraCalendarRecurrenceDailyMaxDays, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, Integer.toString(zimbraCalendarRecurrenceDailyMaxDays));
        return attrs;
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public void unsetCalendarRecurrenceDailyMaxDays() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of days a DAILY recurrence rule can span; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=661)
    public Map<String,Object> unsetCalendarRecurrenceDailyMaxDays(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceDailyMaxDays, "");
        return attrs;
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceMaxInstances, or 0 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public int getCalendarRecurrenceMaxInstances() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, 0, true);
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceMaxInstances new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public void setCalendarRecurrenceMaxInstances(int zimbraCalendarRecurrenceMaxInstances) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, Integer.toString(zimbraCalendarRecurrenceMaxInstances));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceMaxInstances new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public Map<String,Object> setCalendarRecurrenceMaxInstances(int zimbraCalendarRecurrenceMaxInstances, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, Integer.toString(zimbraCalendarRecurrenceMaxInstances));
        return attrs;
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public void unsetCalendarRecurrenceMaxInstances() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of instances expanded per recurrence rule; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=660)
    public Map<String,Object> unsetCalendarRecurrenceMaxInstances(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMaxInstances, "");
        return attrs;
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceMonthlyMaxMonths, or 360 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public int getCalendarRecurrenceMonthlyMaxMonths() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, 360, true);
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceMonthlyMaxMonths new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public void setCalendarRecurrenceMonthlyMaxMonths(int zimbraCalendarRecurrenceMonthlyMaxMonths) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, Integer.toString(zimbraCalendarRecurrenceMonthlyMaxMonths));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceMonthlyMaxMonths new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public Map<String,Object> setCalendarRecurrenceMonthlyMaxMonths(int zimbraCalendarRecurrenceMonthlyMaxMonths, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, Integer.toString(zimbraCalendarRecurrenceMonthlyMaxMonths));
        return attrs;
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public void unsetCalendarRecurrenceMonthlyMaxMonths() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of months a MONTHLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=663)
    public Map<String,Object> unsetCalendarRecurrenceMonthlyMaxMonths(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceMonthlyMaxMonths, "");
        return attrs;
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @return zimbraCalendarRecurrenceOtherFrequencyMaxYears, or 1 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public int getCalendarRecurrenceOtherFrequencyMaxYears() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, 1, true);
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @param zimbraCalendarRecurrenceOtherFrequencyMaxYears new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public void setCalendarRecurrenceOtherFrequencyMaxYears(int zimbraCalendarRecurrenceOtherFrequencyMaxYears) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, Integer.toString(zimbraCalendarRecurrenceOtherFrequencyMaxYears));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @param zimbraCalendarRecurrenceOtherFrequencyMaxYears new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public Map<String,Object> setCalendarRecurrenceOtherFrequencyMaxYears(int zimbraCalendarRecurrenceOtherFrequencyMaxYears, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, Integer.toString(zimbraCalendarRecurrenceOtherFrequencyMaxYears));
        return attrs;
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public void unsetCalendarRecurrenceOtherFrequencyMaxYears() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of years a recurrence rule can span for frequencies
     * other than DAILY/WEEKLY/MONTHLY/YEARLY; 0 means unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=665)
    public Map<String,Object> unsetCalendarRecurrenceOtherFrequencyMaxYears(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceOtherFrequencyMaxYears, "");
        return attrs;
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceWeeklyMaxWeeks, or 520 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public int getCalendarRecurrenceWeeklyMaxWeeks() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, 520, true);
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceWeeklyMaxWeeks new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public void setCalendarRecurrenceWeeklyMaxWeeks(int zimbraCalendarRecurrenceWeeklyMaxWeeks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, Integer.toString(zimbraCalendarRecurrenceWeeklyMaxWeeks));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceWeeklyMaxWeeks new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public Map<String,Object> setCalendarRecurrenceWeeklyMaxWeeks(int zimbraCalendarRecurrenceWeeklyMaxWeeks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, Integer.toString(zimbraCalendarRecurrenceWeeklyMaxWeeks));
        return attrs;
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public void unsetCalendarRecurrenceWeeklyMaxWeeks() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of weeks a WEEKLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=662)
    public Map<String,Object> unsetCalendarRecurrenceWeeklyMaxWeeks(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceWeeklyMaxWeeks, "");
        return attrs;
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @return zimbraCalendarRecurrenceYearlyMaxYears, or 100 if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public int getCalendarRecurrenceYearlyMaxYears() {
        return getIntAttr(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, 100, true);
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceYearlyMaxYears new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public void setCalendarRecurrenceYearlyMaxYears(int zimbraCalendarRecurrenceYearlyMaxYears) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, Integer.toString(zimbraCalendarRecurrenceYearlyMaxYears));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param zimbraCalendarRecurrenceYearlyMaxYears new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public Map<String,Object> setCalendarRecurrenceYearlyMaxYears(int zimbraCalendarRecurrenceYearlyMaxYears, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, Integer.toString(zimbraCalendarRecurrenceYearlyMaxYears));
        return attrs;
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public void unsetCalendarRecurrenceYearlyMaxYears() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of years a YEARLY recurrence rule can span; 0 means
     * unlimited
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=664)
    public Map<String,Object> unsetCalendarRecurrenceYearlyMaxYears(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarRecurrenceYearlyMaxYears, "");
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @return zimbraCalendarResourceExtraObjectClass, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public String[] getCalendarResourceExtraObjectClass() {
        String[] value = getMultiAttr(Provisioning.A_zimbraCalendarResourceExtraObjectClass, true, true); return value.length > 0 ? value : new String[] {"amavisAccount"};
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @param zimbraCalendarResourceExtraObjectClass new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public void setCalendarResourceExtraObjectClass(String[] zimbraCalendarResourceExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceExtraObjectClass, zimbraCalendarResourceExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @param zimbraCalendarResourceExtraObjectClass new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public Map<String,Object> setCalendarResourceExtraObjectClass(String[] zimbraCalendarResourceExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceExtraObjectClass, zimbraCalendarResourceExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @param zimbraCalendarResourceExtraObjectClass new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public void addCalendarResourceExtraObjectClass(String zimbraCalendarResourceExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCalendarResourceExtraObjectClass, zimbraCalendarResourceExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @param zimbraCalendarResourceExtraObjectClass new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public Map<String,Object> addCalendarResourceExtraObjectClass(String zimbraCalendarResourceExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCalendarResourceExtraObjectClass, zimbraCalendarResourceExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @param zimbraCalendarResourceExtraObjectClass existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public void removeCalendarResourceExtraObjectClass(String zimbraCalendarResourceExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCalendarResourceExtraObjectClass, zimbraCalendarResourceExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @param zimbraCalendarResourceExtraObjectClass existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public Map<String,Object> removeCalendarResourceExtraObjectClass(String zimbraCalendarResourceExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCalendarResourceExtraObjectClass, zimbraCalendarResourceExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public void unsetCalendarResourceExtraObjectClass() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceExtraObjectClass, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra calendar resource object.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=753)
    public Map<String,Object> unsetCalendarResourceExtraObjectClass(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCalendarResourceExtraObjectClass, "");
        return attrs;
    }

    /**
     * When creating self-signed SSL certs during an install, we also create
     * a local Certificate Authority (CA) to sign these SSL certs. This local
     * CA-s own cert is then added to different applications &quot;trusted
     * CA-s&quot; list/store. This attribute should not be used in a system
     * with real certs issued by well known CAs.
     *
     * @return zimbraCertAuthorityCertSelfSigned, or null if unset
     */
    @ZAttr(id=280)
    public String getCertAuthorityCertSelfSigned() {
        return getAttr(Provisioning.A_zimbraCertAuthorityCertSelfSigned, null, true);
    }

    /**
     * When creating self-signed SSL certs during an install, we also create
     * a local Certificate Authority (CA) to sign these SSL certs. This local
     * CA-s own cert is then added to different applications &quot;trusted
     * CA-s&quot; list/store. This attribute should not be used in a system
     * with real certs issued by well known CAs.
     *
     * @param zimbraCertAuthorityCertSelfSigned new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=280)
    public void setCertAuthorityCertSelfSigned(String zimbraCertAuthorityCertSelfSigned) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCertAuthorityCertSelfSigned, zimbraCertAuthorityCertSelfSigned);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When creating self-signed SSL certs during an install, we also create
     * a local Certificate Authority (CA) to sign these SSL certs. This local
     * CA-s own cert is then added to different applications &quot;trusted
     * CA-s&quot; list/store. This attribute should not be used in a system
     * with real certs issued by well known CAs.
     *
     * @param zimbraCertAuthorityCertSelfSigned new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=280)
    public Map<String,Object> setCertAuthorityCertSelfSigned(String zimbraCertAuthorityCertSelfSigned, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCertAuthorityCertSelfSigned, zimbraCertAuthorityCertSelfSigned);
        return attrs;
    }

    /**
     * When creating self-signed SSL certs during an install, we also create
     * a local Certificate Authority (CA) to sign these SSL certs. This local
     * CA-s own cert is then added to different applications &quot;trusted
     * CA-s&quot; list/store. This attribute should not be used in a system
     * with real certs issued by well known CAs.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=280)
    public void unsetCertAuthorityCertSelfSigned() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCertAuthorityCertSelfSigned, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When creating self-signed SSL certs during an install, we also create
     * a local Certificate Authority (CA) to sign these SSL certs. This local
     * CA-s own cert is then added to different applications &quot;trusted
     * CA-s&quot; list/store. This attribute should not be used in a system
     * with real certs issued by well known CAs.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=280)
    public Map<String,Object> unsetCertAuthorityCertSelfSigned(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCertAuthorityCertSelfSigned, "");
        return attrs;
    }

    /**
     * Please see the documentation for the attribute
     * zimbraCertAuthorityCertSelfSigned. In addition, please note that this
     * attribute is provided at install for convenience during a test install
     * without real certs issued by well known CAs. If you choose to create
     * your own CA for your production uses, please note that it is a bad
     * idea to store your CA-s private key in LDAP, as this data maybe read
     * from zimbraGlobalConfig in the clear.
     *
     * @return zimbraCertAuthorityKeySelfSigned, or null if unset
     */
    @ZAttr(id=279)
    public String getCertAuthorityKeySelfSigned() {
        return getAttr(Provisioning.A_zimbraCertAuthorityKeySelfSigned, null, true);
    }

    /**
     * Please see the documentation for the attribute
     * zimbraCertAuthorityCertSelfSigned. In addition, please note that this
     * attribute is provided at install for convenience during a test install
     * without real certs issued by well known CAs. If you choose to create
     * your own CA for your production uses, please note that it is a bad
     * idea to store your CA-s private key in LDAP, as this data maybe read
     * from zimbraGlobalConfig in the clear.
     *
     * @param zimbraCertAuthorityKeySelfSigned new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=279)
    public void setCertAuthorityKeySelfSigned(String zimbraCertAuthorityKeySelfSigned) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCertAuthorityKeySelfSigned, zimbraCertAuthorityKeySelfSigned);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Please see the documentation for the attribute
     * zimbraCertAuthorityCertSelfSigned. In addition, please note that this
     * attribute is provided at install for convenience during a test install
     * without real certs issued by well known CAs. If you choose to create
     * your own CA for your production uses, please note that it is a bad
     * idea to store your CA-s private key in LDAP, as this data maybe read
     * from zimbraGlobalConfig in the clear.
     *
     * @param zimbraCertAuthorityKeySelfSigned new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=279)
    public Map<String,Object> setCertAuthorityKeySelfSigned(String zimbraCertAuthorityKeySelfSigned, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCertAuthorityKeySelfSigned, zimbraCertAuthorityKeySelfSigned);
        return attrs;
    }

    /**
     * Please see the documentation for the attribute
     * zimbraCertAuthorityCertSelfSigned. In addition, please note that this
     * attribute is provided at install for convenience during a test install
     * without real certs issued by well known CAs. If you choose to create
     * your own CA for your production uses, please note that it is a bad
     * idea to store your CA-s private key in LDAP, as this data maybe read
     * from zimbraGlobalConfig in the clear.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=279)
    public void unsetCertAuthorityKeySelfSigned() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCertAuthorityKeySelfSigned, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Please see the documentation for the attribute
     * zimbraCertAuthorityCertSelfSigned. In addition, please note that this
     * attribute is provided at install for convenience during a test install
     * without real certs issued by well known CAs. If you choose to create
     * your own CA for your production uses, please note that it is a bad
     * idea to store your CA-s private key in LDAP, as this data maybe read
     * from zimbraGlobalConfig in the clear.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=279)
    public Map<String,Object> unsetCertAuthorityKeySelfSigned(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCertAuthorityKeySelfSigned, "");
        return attrs;
    }

    /**
     * change password URL
     *
     * @return zimbraChangePasswordURL, or null if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=777)
    public String getChangePasswordURL() {
        return getAttr(Provisioning.A_zimbraChangePasswordURL, null, true);
    }

    /**
     * change password URL
     *
     * @param zimbraChangePasswordURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=777)
    public void setChangePasswordURL(String zimbraChangePasswordURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChangePasswordURL, zimbraChangePasswordURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * change password URL
     *
     * @param zimbraChangePasswordURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=777)
    public Map<String,Object> setChangePasswordURL(String zimbraChangePasswordURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChangePasswordURL, zimbraChangePasswordURL);
        return attrs;
    }

    /**
     * change password URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=777)
    public void unsetChangePasswordURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChangePasswordURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * change password URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=777)
    public Map<String,Object> unsetChangePasswordURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChangePasswordURL, "");
        return attrs;
    }

    /**
     * allow unencrypted password login via XMPP
     *
     * @return zimbraChatAllowUnencryptedPassword, or false if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2106)
    public boolean isChatAllowUnencryptedPassword() {
        return getBooleanAttr(Provisioning.A_zimbraChatAllowUnencryptedPassword, false, true);
    }

    /**
     * allow unencrypted password login via XMPP
     *
     * @param zimbraChatAllowUnencryptedPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2106)
    public void setChatAllowUnencryptedPassword(boolean zimbraChatAllowUnencryptedPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatAllowUnencryptedPassword, zimbraChatAllowUnencryptedPassword ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * allow unencrypted password login via XMPP
     *
     * @param zimbraChatAllowUnencryptedPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2106)
    public Map<String,Object> setChatAllowUnencryptedPassword(boolean zimbraChatAllowUnencryptedPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatAllowUnencryptedPassword, zimbraChatAllowUnencryptedPassword ? TRUE : FALSE);
        return attrs;
    }

    /**
     * allow unencrypted password login via XMPP
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2106)
    public void unsetChatAllowUnencryptedPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatAllowUnencryptedPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * allow unencrypted password login via XMPP
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2106)
    public Map<String,Object> unsetChatAllowUnencryptedPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatAllowUnencryptedPassword, "");
        return attrs;
    }

    /**
     * enable dedicated log for the chat conversation (needed by some
     * jurisdictions)
     *
     * @return zimbraChatConversationAuditEnabled, or false if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2104)
    public boolean isChatConversationAuditEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraChatConversationAuditEnabled, false, true);
    }

    /**
     * enable dedicated log for the chat conversation (needed by some
     * jurisdictions)
     *
     * @param zimbraChatConversationAuditEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2104)
    public void setChatConversationAuditEnabled(boolean zimbraChatConversationAuditEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatConversationAuditEnabled, zimbraChatConversationAuditEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable dedicated log for the chat conversation (needed by some
     * jurisdictions)
     *
     * @param zimbraChatConversationAuditEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2104)
    public Map<String,Object> setChatConversationAuditEnabled(boolean zimbraChatConversationAuditEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatConversationAuditEnabled, zimbraChatConversationAuditEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable dedicated log for the chat conversation (needed by some
     * jurisdictions)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2104)
    public void unsetChatConversationAuditEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatConversationAuditEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable dedicated log for the chat conversation (needed by some
     * jurisdictions)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2104)
    public Map<String,Object> unsetChatConversationAuditEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatConversationAuditEnabled, "");
        return attrs;
    }

    /**
     * enable XMPP server
     *
     * @return zimbraChatServiceEnabled, or true if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2102)
    public boolean isChatServiceEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraChatServiceEnabled, true, true);
    }

    /**
     * enable XMPP server
     *
     * @param zimbraChatServiceEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2102)
    public void setChatServiceEnabled(boolean zimbraChatServiceEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatServiceEnabled, zimbraChatServiceEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable XMPP server
     *
     * @param zimbraChatServiceEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2102)
    public Map<String,Object> setChatServiceEnabled(boolean zimbraChatServiceEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatServiceEnabled, zimbraChatServiceEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable XMPP server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2102)
    public void unsetChatServiceEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatServiceEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable XMPP server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2102)
    public Map<String,Object> unsetChatServiceEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatServiceEnabled, "");
        return attrs;
    }

    /**
     * XMPP plain port, usually used with startTLS
     *
     * <p>Use getChatXmppPortAsString to access value as a string.
     *
     * @see #getChatXmppPortAsString()
     *
     * @return zimbraChatXmppPort, or 5222 if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2107)
    public int getChatXmppPort() {
        return getIntAttr(Provisioning.A_zimbraChatXmppPort, 5222, true);
    }

    /**
     * XMPP plain port, usually used with startTLS
     *
     * @return zimbraChatXmppPort, or "5222" if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2107)
    public String getChatXmppPortAsString() {
        return getAttr(Provisioning.A_zimbraChatXmppPort, "5222", true);
    }

    /**
     * XMPP plain port, usually used with startTLS
     *
     * @param zimbraChatXmppPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2107)
    public void setChatXmppPort(int zimbraChatXmppPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppPort, Integer.toString(zimbraChatXmppPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * XMPP plain port, usually used with startTLS
     *
     * @param zimbraChatXmppPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2107)
    public Map<String,Object> setChatXmppPort(int zimbraChatXmppPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppPort, Integer.toString(zimbraChatXmppPort));
        return attrs;
    }

    /**
     * XMPP plain port, usually used with startTLS
     *
     * @param zimbraChatXmppPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2107)
    public void setChatXmppPortAsString(String zimbraChatXmppPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppPort, zimbraChatXmppPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * XMPP plain port, usually used with startTLS
     *
     * @param zimbraChatXmppPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2107)
    public Map<String,Object> setChatXmppPortAsString(String zimbraChatXmppPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppPort, zimbraChatXmppPort);
        return attrs;
    }

    /**
     * XMPP plain port, usually used with startTLS
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2107)
    public void unsetChatXmppPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * XMPP plain port, usually used with startTLS
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2107)
    public Map<String,Object> unsetChatXmppPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppPort, "");
        return attrs;
    }

    /**
     * XMPP legacy SSL port
     *
     * <p>Use getChatXmppSslPortAsString to access value as a string.
     *
     * @see #getChatXmppSslPortAsString()
     *
     * @return zimbraChatXmppSslPort, or 5223 if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2108)
    public int getChatXmppSslPort() {
        return getIntAttr(Provisioning.A_zimbraChatXmppSslPort, 5223, true);
    }

    /**
     * XMPP legacy SSL port
     *
     * @return zimbraChatXmppSslPort, or "5223" if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2108)
    public String getChatXmppSslPortAsString() {
        return getAttr(Provisioning.A_zimbraChatXmppSslPort, "5223", true);
    }

    /**
     * XMPP legacy SSL port
     *
     * @param zimbraChatXmppSslPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2108)
    public void setChatXmppSslPort(int zimbraChatXmppSslPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPort, Integer.toString(zimbraChatXmppSslPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * XMPP legacy SSL port
     *
     * @param zimbraChatXmppSslPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2108)
    public Map<String,Object> setChatXmppSslPort(int zimbraChatXmppSslPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPort, Integer.toString(zimbraChatXmppSslPort));
        return attrs;
    }

    /**
     * XMPP legacy SSL port
     *
     * @param zimbraChatXmppSslPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2108)
    public void setChatXmppSslPortAsString(String zimbraChatXmppSslPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPort, zimbraChatXmppSslPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * XMPP legacy SSL port
     *
     * @param zimbraChatXmppSslPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2108)
    public Map<String,Object> setChatXmppSslPortAsString(String zimbraChatXmppSslPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPort, zimbraChatXmppSslPort);
        return attrs;
    }

    /**
     * XMPP legacy SSL port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2108)
    public void unsetChatXmppSslPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * XMPP legacy SSL port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2108)
    public Map<String,Object> unsetChatXmppSslPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPort, "");
        return attrs;
    }

    /**
     * enable XMPP legacy SSL port
     *
     * @return zimbraChatXmppSslPortEnabled, or false if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2105)
    public boolean isChatXmppSslPortEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraChatXmppSslPortEnabled, false, true);
    }

    /**
     * enable XMPP legacy SSL port
     *
     * @param zimbraChatXmppSslPortEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2105)
    public void setChatXmppSslPortEnabled(boolean zimbraChatXmppSslPortEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPortEnabled, zimbraChatXmppSslPortEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable XMPP legacy SSL port
     *
     * @param zimbraChatXmppSslPortEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2105)
    public Map<String,Object> setChatXmppSslPortEnabled(boolean zimbraChatXmppSslPortEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPortEnabled, zimbraChatXmppSslPortEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable XMPP legacy SSL port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2105)
    public void unsetChatXmppSslPortEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPortEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable XMPP legacy SSL port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2105)
    public Map<String,Object> unsetChatXmppSslPortEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraChatXmppSslPortEnabled, "");
        return attrs;
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @return zimbraClamAVBindAddress, or "localhost" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public String getClamAVBindAddress() {
        return getAttr(Provisioning.A_zimbraClamAVBindAddress, "localhost", true);
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @param zimbraClamAVBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public void setClamAVBindAddress(String zimbraClamAVBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVBindAddress, zimbraClamAVBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @param zimbraClamAVBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public Map<String,Object> setClamAVBindAddress(String zimbraClamAVBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVBindAddress, zimbraClamAVBindAddress);
        return attrs;
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public void unsetClamAVBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address/hostname for ClamAV to bind to for attachment scanning.
     * Default is localhost
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1619)
    public Map<String,Object> unsetClamAVBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVBindAddress, "");
        return attrs;
    }

    /**
     * Default database mirror for freshclam to use for virus and other
     * updates. Defaults to the United States mirror. See
     * http://www.iana.org/cctld/cctld-whois.htm for a list of mirrors.
     *
     * @return zimbraClamAVDatabaseMirror, or "db.us.clamav.net" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2073)
    public String getClamAVDatabaseMirror() {
        return getAttr(Provisioning.A_zimbraClamAVDatabaseMirror, "db.us.clamav.net", true);
    }

    /**
     * Default database mirror for freshclam to use for virus and other
     * updates. Defaults to the United States mirror. See
     * http://www.iana.org/cctld/cctld-whois.htm for a list of mirrors.
     *
     * @param zimbraClamAVDatabaseMirror new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2073)
    public void setClamAVDatabaseMirror(String zimbraClamAVDatabaseMirror) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVDatabaseMirror, zimbraClamAVDatabaseMirror);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default database mirror for freshclam to use for virus and other
     * updates. Defaults to the United States mirror. See
     * http://www.iana.org/cctld/cctld-whois.htm for a list of mirrors.
     *
     * @param zimbraClamAVDatabaseMirror new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2073)
    public Map<String,Object> setClamAVDatabaseMirror(String zimbraClamAVDatabaseMirror, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVDatabaseMirror, zimbraClamAVDatabaseMirror);
        return attrs;
    }

    /**
     * Default database mirror for freshclam to use for virus and other
     * updates. Defaults to the United States mirror. See
     * http://www.iana.org/cctld/cctld-whois.htm for a list of mirrors.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2073)
    public void unsetClamAVDatabaseMirror() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVDatabaseMirror, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Default database mirror for freshclam to use for virus and other
     * updates. Defaults to the United States mirror. See
     * http://www.iana.org/cctld/cctld-whois.htm for a list of mirrors.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2073)
    public Map<String,Object> unsetClamAVDatabaseMirror(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVDatabaseMirror, "");
        return attrs;
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @return zimbraClamAVListenPort, or 3310 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public int getClamAVListenPort() {
        return getIntAttr(Provisioning.A_zimbraClamAVListenPort, 3310, true);
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @param zimbraClamAVListenPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public void setClamAVListenPort(int zimbraClamAVListenPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVListenPort, Integer.toString(zimbraClamAVListenPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @param zimbraClamAVListenPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public Map<String,Object> setClamAVListenPort(int zimbraClamAVListenPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVListenPort, Integer.toString(zimbraClamAVListenPort));
        return attrs;
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public void unsetClamAVListenPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVListenPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port to bind to for attachment scanning. Default is 3310
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1620)
    public Map<String,Object> unsetClamAVListenPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVListenPort, "");
        return attrs;
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @return zimbraClamAVMaxThreads, or 10 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public int getClamAVMaxThreads() {
        return getIntAttr(Provisioning.A_zimbraClamAVMaxThreads, 10, true);
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @param zimbraClamAVMaxThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public void setClamAVMaxThreads(int zimbraClamAVMaxThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVMaxThreads, Integer.toString(zimbraClamAVMaxThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @param zimbraClamAVMaxThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public Map<String,Object> setClamAVMaxThreads(int zimbraClamAVMaxThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVMaxThreads, Integer.toString(zimbraClamAVMaxThreads));
        return attrs;
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public void unsetClamAVMaxThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVMaxThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of ClamAV servers to run. Default is 10
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1462)
    public Map<String,Object> unsetClamAVMaxThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVMaxThreads, "");
        return attrs;
    }

    /**
     * Whether or not to enable the Safe Browsing feature. If enabled,
     * freshclam will download Google&#039;s safe browsing database. See
     * http://www.google.com/transparencyreport/safebrowsing and
     * http://www.clamav.net/documentation.html#safebrowsing for more
     * information about this service.
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraClamAVSafeBrowsing, or ZAttrProvisioning.ClamAVSafeBrowsing.no if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2074)
    public ZAttrProvisioning.ClamAVSafeBrowsing getClamAVSafeBrowsing() {
        try { String v = getAttr(Provisioning.A_zimbraClamAVSafeBrowsing, true, true); return v == null ? ZAttrProvisioning.ClamAVSafeBrowsing.no : ZAttrProvisioning.ClamAVSafeBrowsing.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ClamAVSafeBrowsing.no; }
    }

    /**
     * Whether or not to enable the Safe Browsing feature. If enabled,
     * freshclam will download Google&#039;s safe browsing database. See
     * http://www.google.com/transparencyreport/safebrowsing and
     * http://www.clamav.net/documentation.html#safebrowsing for more
     * information about this service.
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraClamAVSafeBrowsing, or "no" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2074)
    public String getClamAVSafeBrowsingAsString() {
        return getAttr(Provisioning.A_zimbraClamAVSafeBrowsing, "no", true);
    }

    /**
     * Whether or not to enable the Safe Browsing feature. If enabled,
     * freshclam will download Google&#039;s safe browsing database. See
     * http://www.google.com/transparencyreport/safebrowsing and
     * http://www.clamav.net/documentation.html#safebrowsing for more
     * information about this service.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraClamAVSafeBrowsing new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2074)
    public void setClamAVSafeBrowsing(ZAttrProvisioning.ClamAVSafeBrowsing zimbraClamAVSafeBrowsing) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVSafeBrowsing, zimbraClamAVSafeBrowsing.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable the Safe Browsing feature. If enabled,
     * freshclam will download Google&#039;s safe browsing database. See
     * http://www.google.com/transparencyreport/safebrowsing and
     * http://www.clamav.net/documentation.html#safebrowsing for more
     * information about this service.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraClamAVSafeBrowsing new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2074)
    public Map<String,Object> setClamAVSafeBrowsing(ZAttrProvisioning.ClamAVSafeBrowsing zimbraClamAVSafeBrowsing, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVSafeBrowsing, zimbraClamAVSafeBrowsing.toString());
        return attrs;
    }

    /**
     * Whether or not to enable the Safe Browsing feature. If enabled,
     * freshclam will download Google&#039;s safe browsing database. See
     * http://www.google.com/transparencyreport/safebrowsing and
     * http://www.clamav.net/documentation.html#safebrowsing for more
     * information about this service.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraClamAVSafeBrowsing new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2074)
    public void setClamAVSafeBrowsingAsString(String zimbraClamAVSafeBrowsing) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVSafeBrowsing, zimbraClamAVSafeBrowsing);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable the Safe Browsing feature. If enabled,
     * freshclam will download Google&#039;s safe browsing database. See
     * http://www.google.com/transparencyreport/safebrowsing and
     * http://www.clamav.net/documentation.html#safebrowsing for more
     * information about this service.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraClamAVSafeBrowsing new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2074)
    public Map<String,Object> setClamAVSafeBrowsingAsString(String zimbraClamAVSafeBrowsing, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVSafeBrowsing, zimbraClamAVSafeBrowsing);
        return attrs;
    }

    /**
     * Whether or not to enable the Safe Browsing feature. If enabled,
     * freshclam will download Google&#039;s safe browsing database. See
     * http://www.google.com/transparencyreport/safebrowsing and
     * http://www.clamav.net/documentation.html#safebrowsing for more
     * information about this service.
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2074)
    public void unsetClamAVSafeBrowsing() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVSafeBrowsing, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable the Safe Browsing feature. If enabled,
     * freshclam will download Google&#039;s safe browsing database. See
     * http://www.google.com/transparencyreport/safebrowsing and
     * http://www.clamav.net/documentation.html#safebrowsing for more
     * information about this service.
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2074)
    public Map<String,Object> unsetClamAVSafeBrowsing(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClamAVSafeBrowsing, "");
        return attrs;
    }

    /**
     * Regex for identifying client types
     *
     * @return zimbraClientTypeRegex, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public String[] getClientTypeRegex() {
        String[] value = getMultiAttr(Provisioning.A_zimbraClientTypeRegex, true, true); return value.length > 0 ? value : new String[] {"Web UI:(.*)ZimbraWebClient(.*)","ipad:(.*)iPad(.*)","iphone:(.*)iPhone(.*)","Android:(.*)Android(.*)","SyncClient:(.*)\\((.*)\\)$"};
    }

    /**
     * Regex for identifying client types
     *
     * @param zimbraClientTypeRegex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public void setClientTypeRegex(String[] zimbraClientTypeRegex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClientTypeRegex, zimbraClientTypeRegex);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Regex for identifying client types
     *
     * @param zimbraClientTypeRegex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public Map<String,Object> setClientTypeRegex(String[] zimbraClientTypeRegex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClientTypeRegex, zimbraClientTypeRegex);
        return attrs;
    }

    /**
     * Regex for identifying client types
     *
     * @param zimbraClientTypeRegex new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public void addClientTypeRegex(String zimbraClientTypeRegex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraClientTypeRegex, zimbraClientTypeRegex);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Regex for identifying client types
     *
     * @param zimbraClientTypeRegex new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public Map<String,Object> addClientTypeRegex(String zimbraClientTypeRegex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraClientTypeRegex, zimbraClientTypeRegex);
        return attrs;
    }

    /**
     * Regex for identifying client types
     *
     * @param zimbraClientTypeRegex existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public void removeClientTypeRegex(String zimbraClientTypeRegex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraClientTypeRegex, zimbraClientTypeRegex);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Regex for identifying client types
     *
     * @param zimbraClientTypeRegex existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public Map<String,Object> removeClientTypeRegex(String zimbraClientTypeRegex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraClientTypeRegex, zimbraClientTypeRegex);
        return attrs;
    }

    /**
     * Regex for identifying client types
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public void unsetClientTypeRegex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClientTypeRegex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Regex for identifying client types
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1416)
    public Map<String,Object> unsetClientTypeRegex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClientTypeRegex, "");
        return attrs;
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [none, RedHat, Veritas]
     *
     * @return zimbraClusterType, or ZAttrProvisioning.ClusterType.none if unset and/or has invalid value
     */
    @ZAttr(id=508)
    public ZAttrProvisioning.ClusterType getClusterType() {
        try { String v = getAttr(Provisioning.A_zimbraClusterType, true, true); return v == null ? ZAttrProvisioning.ClusterType.none : ZAttrProvisioning.ClusterType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ClusterType.none; }
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [none, RedHat, Veritas]
     *
     * @return zimbraClusterType, or "none" if unset
     */
    @ZAttr(id=508)
    public String getClusterTypeAsString() {
        return getAttr(Provisioning.A_zimbraClusterType, "none", true);
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [none, RedHat, Veritas]
     *
     * @param zimbraClusterType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=508)
    public void setClusterType(ZAttrProvisioning.ClusterType zimbraClusterType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, zimbraClusterType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [none, RedHat, Veritas]
     *
     * @param zimbraClusterType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=508)
    public Map<String,Object> setClusterType(ZAttrProvisioning.ClusterType zimbraClusterType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, zimbraClusterType.toString());
        return attrs;
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [none, RedHat, Veritas]
     *
     * @param zimbraClusterType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=508)
    public void setClusterTypeAsString(String zimbraClusterType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, zimbraClusterType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [none, RedHat, Veritas]
     *
     * @param zimbraClusterType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=508)
    public Map<String,Object> setClusterTypeAsString(String zimbraClusterType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, zimbraClusterType);
        return attrs;
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [none, RedHat, Veritas]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=508)
    public void unsetClusterType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Type of HA cluster software in use; &quot;none&quot; by default,
     * &quot;RedHat&quot; for Red Hat cluster or &quot;Veritas&quot; for
     * Veritas Cluster Server from Symantec
     *
     * <p>Valid values: [none, RedHat, Veritas]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=508)
    public Map<String,Object> unsetClusterType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraClusterType, "");
        return attrs;
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @return zimbraCommunityAPIClientID, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public String getCommunityAPIClientID() {
        return getAttr(Provisioning.A_zimbraCommunityAPIClientID, null, true);
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @param zimbraCommunityAPIClientID new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public void setCommunityAPIClientID(String zimbraCommunityAPIClientID) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientID, zimbraCommunityAPIClientID);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @param zimbraCommunityAPIClientID new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public Map<String,Object> setCommunityAPIClientID(String zimbraCommunityAPIClientID, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientID, zimbraCommunityAPIClientID);
        return attrs;
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public void unsetCommunityAPIClientID() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientID, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * API Client ID for accessing with Zimbra Community API
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1637)
    public Map<String,Object> unsetCommunityAPIClientID(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientID, "");
        return attrs;
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @return zimbraCommunityAPIClientSecret, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public String getCommunityAPIClientSecret() {
        return getAttr(Provisioning.A_zimbraCommunityAPIClientSecret, null, true);
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @param zimbraCommunityAPIClientSecret new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public void setCommunityAPIClientSecret(String zimbraCommunityAPIClientSecret) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientSecret, zimbraCommunityAPIClientSecret);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @param zimbraCommunityAPIClientSecret new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public Map<String,Object> setCommunityAPIClientSecret(String zimbraCommunityAPIClientSecret, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientSecret, zimbraCommunityAPIClientSecret);
        return attrs;
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public void unsetCommunityAPIClientSecret() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientSecret, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * API Client Secret for accessing with Zimbra Community API
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1638)
    public Map<String,Object> unsetCommunityAPIClientSecret(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityAPIClientSecret, "");
        return attrs;
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @return zimbraCommunityBaseURL, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public String getCommunityBaseURL() {
        return getAttr(Provisioning.A_zimbraCommunityBaseURL, null, true);
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @param zimbraCommunityBaseURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public void setCommunityBaseURL(String zimbraCommunityBaseURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityBaseURL, zimbraCommunityBaseURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @param zimbraCommunityBaseURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public Map<String,Object> setCommunityBaseURL(String zimbraCommunityBaseURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityBaseURL, zimbraCommunityBaseURL);
        return attrs;
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public void unsetCommunityBaseURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityBaseURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Base URL where Zimbra Community is deployed. Do not include / symbol
     * at the end
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1640)
    public Map<String,Object> unsetCommunityBaseURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityBaseURL, "");
        return attrs;
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @return zimbraCommunityHomeURL, or "/integration/zimbracollaboration" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public String getCommunityHomeURL() {
        return getAttr(Provisioning.A_zimbraCommunityHomeURL, "/integration/zimbracollaboration", true);
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @param zimbraCommunityHomeURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public void setCommunityHomeURL(String zimbraCommunityHomeURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityHomeURL, zimbraCommunityHomeURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @param zimbraCommunityHomeURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public Map<String,Object> setCommunityHomeURL(String zimbraCommunityHomeURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityHomeURL, zimbraCommunityHomeURL);
        return attrs;
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public void unsetCommunityHomeURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityHomeURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL to be loaded in Zimbra Community tab relative to
     * zimbraCommunityBaseURL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1641)
    public Map<String,Object> unsetCommunityHomeURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityHomeURL, "");
        return attrs;
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @return zimbraCommunityUsernameMapping, or "uid" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public String getCommunityUsernameMapping() {
        return getAttr(Provisioning.A_zimbraCommunityUsernameMapping, "uid", true);
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @param zimbraCommunityUsernameMapping new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public void setCommunityUsernameMapping(String zimbraCommunityUsernameMapping) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityUsernameMapping, zimbraCommunityUsernameMapping);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @param zimbraCommunityUsernameMapping new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public Map<String,Object> setCommunityUsernameMapping(String zimbraCommunityUsernameMapping, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityUsernameMapping, zimbraCommunityUsernameMapping);
        return attrs;
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public void unsetCommunityUsernameMapping() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityUsernameMapping, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account attribute to be used as a username for Zimbra Community
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1639)
    public Map<String,Object> unsetCommunityUsernameMapping(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCommunityUsernameMapping, "");
        return attrs;
    }

    /**
     * Names of additional components that have been installed
     *
     * @return zimbraComponentAvailable, or empty array if unset
     */
    @ZAttr(id=242)
    public String[] getComponentAvailable() {
        return getMultiAttr(Provisioning.A_zimbraComponentAvailable, true, true);
    }

    /**
     * Names of additional components that have been installed
     *
     * @param zimbraComponentAvailable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=242)
    public void setComponentAvailable(String[] zimbraComponentAvailable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraComponentAvailable, zimbraComponentAvailable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Names of additional components that have been installed
     *
     * @param zimbraComponentAvailable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=242)
    public Map<String,Object> setComponentAvailable(String[] zimbraComponentAvailable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraComponentAvailable, zimbraComponentAvailable);
        return attrs;
    }

    /**
     * Names of additional components that have been installed
     *
     * @param zimbraComponentAvailable new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=242)
    public void addComponentAvailable(String zimbraComponentAvailable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraComponentAvailable, zimbraComponentAvailable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Names of additional components that have been installed
     *
     * @param zimbraComponentAvailable new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=242)
    public Map<String,Object> addComponentAvailable(String zimbraComponentAvailable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraComponentAvailable, zimbraComponentAvailable);
        return attrs;
    }

    /**
     * Names of additional components that have been installed
     *
     * @param zimbraComponentAvailable existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=242)
    public void removeComponentAvailable(String zimbraComponentAvailable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraComponentAvailable, zimbraComponentAvailable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Names of additional components that have been installed
     *
     * @param zimbraComponentAvailable existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=242)
    public Map<String,Object> removeComponentAvailable(String zimbraComponentAvailable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraComponentAvailable, zimbraComponentAvailable);
        return attrs;
    }

    /**
     * Names of additional components that have been installed
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=242)
    public void unsetComponentAvailable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraComponentAvailable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Names of additional components that have been installed
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=242)
    public Map<String,Object> unsetComponentAvailable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraComponentAvailable, "");
        return attrs;
    }

    /**
     * Enabled using the configured server ID for blob dir
     *
     * @return zimbraConfiguredServerIDForBlobDirEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public boolean isConfiguredServerIDForBlobDirEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, false, true);
    }

    /**
     * Enabled using the configured server ID for blob dir
     *
     * @param zimbraConfiguredServerIDForBlobDirEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public void setConfiguredServerIDForBlobDirEnabled(boolean zimbraConfiguredServerIDForBlobDirEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, zimbraConfiguredServerIDForBlobDirEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enabled using the configured server ID for blob dir
     *
     * @param zimbraConfiguredServerIDForBlobDirEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public Map<String,Object> setConfiguredServerIDForBlobDirEnabled(boolean zimbraConfiguredServerIDForBlobDirEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, zimbraConfiguredServerIDForBlobDirEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Enabled using the configured server ID for blob dir
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public void unsetConfiguredServerIDForBlobDirEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enabled using the configured server ID for blob dir
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1551)
    public Map<String,Object> unsetConfiguredServerIDForBlobDirEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConfiguredServerIDForBlobDirEnabled, "");
        return attrs;
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @return zimbraConstraint, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public String[] getConstraint() {
        return getMultiAttr(Provisioning.A_zimbraConstraint, true, true);
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @param zimbraConstraint new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public void setConstraint(String[] zimbraConstraint) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConstraint, zimbraConstraint);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @param zimbraConstraint new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public Map<String,Object> setConstraint(String[] zimbraConstraint, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConstraint, zimbraConstraint);
        return attrs;
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @param zimbraConstraint new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public void addConstraint(String zimbraConstraint) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConstraint, zimbraConstraint);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @param zimbraConstraint new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public Map<String,Object> addConstraint(String zimbraConstraint, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConstraint, zimbraConstraint);
        return attrs;
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @param zimbraConstraint existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public void removeConstraint(String zimbraConstraint) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConstraint, zimbraConstraint);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @param zimbraConstraint existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public Map<String,Object> removeConstraint(String zimbraConstraint, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConstraint, zimbraConstraint);
        return attrs;
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public void unsetConstraint() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConstraint, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute constraints TODO: fill all the constraints
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=766)
    public Map<String,Object> unsetConstraint(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConstraint, "");
        return attrs;
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @return zimbraContactHiddenAttributes, or "dn,vcardUID,vcardURL,vcardXProps,member" if unset
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public String getContactHiddenAttributes() {
        return getAttr(Provisioning.A_zimbraContactHiddenAttributes, "dn,vcardUID,vcardURL,vcardXProps,member", true);
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @param zimbraContactHiddenAttributes new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public void setContactHiddenAttributes(String zimbraContactHiddenAttributes) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactHiddenAttributes, zimbraContactHiddenAttributes);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @param zimbraContactHiddenAttributes new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public Map<String,Object> setContactHiddenAttributes(String zimbraContactHiddenAttributes, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactHiddenAttributes, zimbraContactHiddenAttributes);
        return attrs;
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public void unsetContactHiddenAttributes() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactHiddenAttributes, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Comma separated list of Contact attributes that should be hidden from
     * clients and export of contacts.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.6
     */
    @ZAttr(id=1086)
    public Map<String,Object> unsetContactHiddenAttributes(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactHiddenAttributes, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getContactRankingTableRefreshIntervalAsString to access value as a string.
     *
     * @see #getContactRankingTableRefreshIntervalAsString()
     *
     * @return zimbraContactRankingTableRefreshInterval in millseconds, or 604800000 (7d)  if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public long getContactRankingTableRefreshInterval() {
        return getTimeInterval(Provisioning.A_zimbraContactRankingTableRefreshInterval, 604800000L, true);
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraContactRankingTableRefreshInterval, or "7d" if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public String getContactRankingTableRefreshIntervalAsString() {
        return getAttr(Provisioning.A_zimbraContactRankingTableRefreshInterval, "7d", true);
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraContactRankingTableRefreshInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public void setContactRankingTableRefreshInterval(String zimbraContactRankingTableRefreshInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableRefreshInterval, zimbraContactRankingTableRefreshInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraContactRankingTableRefreshInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public Map<String,Object> setContactRankingTableRefreshInterval(String zimbraContactRankingTableRefreshInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableRefreshInterval, zimbraContactRankingTableRefreshInterval);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public void unsetContactRankingTableRefreshInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableRefreshInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.6. Deprecated per bug 40081. Orig desc: How
     * often do we refresh contact ranking table from address book and GAL to
     * get friendly name for the email address. Use 0 to disable the
     * refresh.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1023)
    public Map<String,Object> unsetContactRankingTableRefreshInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactRankingTableRefreshInterval, "");
        return attrs;
    }

    /**
     * Specify the decomposition mode used for looking up the Contact items
     * by the phonetic last/first name or last/first name. The accepted value
     * is as follows: 0 = No decomposition. The accented characters will be
     * compared &#039;as is&#039; (not be decomposed)
     * (Collator.NO_DECOMPOSITION). 1 = Canonical decomposition mapping rules
     * found in the Unicode Standard is used
     * (Collator.CANONICAL_DECOMPOSITION). 2 = Unicode canonical and Unicode
     * compatibility decomposition mapping rules found in the Unicode
     * Standard is used. When this mode is selected, compatible characters,
     * such as half-width and full-width katakana characters, are considered
     * equivalent (Collator.FULL_DECOMPOSITION).
     *
     * @return zimbraContactSearchDecomposition, or 2 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1971)
    public int getContactSearchDecomposition() {
        return getIntAttr(Provisioning.A_zimbraContactSearchDecomposition, 2, true);
    }

    /**
     * Specify the decomposition mode used for looking up the Contact items
     * by the phonetic last/first name or last/first name. The accepted value
     * is as follows: 0 = No decomposition. The accented characters will be
     * compared &#039;as is&#039; (not be decomposed)
     * (Collator.NO_DECOMPOSITION). 1 = Canonical decomposition mapping rules
     * found in the Unicode Standard is used
     * (Collator.CANONICAL_DECOMPOSITION). 2 = Unicode canonical and Unicode
     * compatibility decomposition mapping rules found in the Unicode
     * Standard is used. When this mode is selected, compatible characters,
     * such as half-width and full-width katakana characters, are considered
     * equivalent (Collator.FULL_DECOMPOSITION).
     *
     * @param zimbraContactSearchDecomposition new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1971)
    public void setContactSearchDecomposition(int zimbraContactSearchDecomposition) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactSearchDecomposition, Integer.toString(zimbraContactSearchDecomposition));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specify the decomposition mode used for looking up the Contact items
     * by the phonetic last/first name or last/first name. The accepted value
     * is as follows: 0 = No decomposition. The accented characters will be
     * compared &#039;as is&#039; (not be decomposed)
     * (Collator.NO_DECOMPOSITION). 1 = Canonical decomposition mapping rules
     * found in the Unicode Standard is used
     * (Collator.CANONICAL_DECOMPOSITION). 2 = Unicode canonical and Unicode
     * compatibility decomposition mapping rules found in the Unicode
     * Standard is used. When this mode is selected, compatible characters,
     * such as half-width and full-width katakana characters, are considered
     * equivalent (Collator.FULL_DECOMPOSITION).
     *
     * @param zimbraContactSearchDecomposition new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1971)
    public Map<String,Object> setContactSearchDecomposition(int zimbraContactSearchDecomposition, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactSearchDecomposition, Integer.toString(zimbraContactSearchDecomposition));
        return attrs;
    }

    /**
     * Specify the decomposition mode used for looking up the Contact items
     * by the phonetic last/first name or last/first name. The accepted value
     * is as follows: 0 = No decomposition. The accented characters will be
     * compared &#039;as is&#039; (not be decomposed)
     * (Collator.NO_DECOMPOSITION). 1 = Canonical decomposition mapping rules
     * found in the Unicode Standard is used
     * (Collator.CANONICAL_DECOMPOSITION). 2 = Unicode canonical and Unicode
     * compatibility decomposition mapping rules found in the Unicode
     * Standard is used. When this mode is selected, compatible characters,
     * such as half-width and full-width katakana characters, are considered
     * equivalent (Collator.FULL_DECOMPOSITION).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1971)
    public void unsetContactSearchDecomposition() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactSearchDecomposition, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specify the decomposition mode used for looking up the Contact items
     * by the phonetic last/first name or last/first name. The accepted value
     * is as follows: 0 = No decomposition. The accented characters will be
     * compared &#039;as is&#039; (not be decomposed)
     * (Collator.NO_DECOMPOSITION). 1 = Canonical decomposition mapping rules
     * found in the Unicode Standard is used
     * (Collator.CANONICAL_DECOMPOSITION). 2 = Unicode canonical and Unicode
     * compatibility decomposition mapping rules found in the Unicode
     * Standard is used. When this mode is selected, compatible characters,
     * such as half-width and full-width katakana characters, are considered
     * equivalent (Collator.FULL_DECOMPOSITION).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1971)
    public Map<String,Object> unsetContactSearchDecomposition(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraContactSearchDecomposition, "");
        return attrs;
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @return zimbraConvertPoolTimeout, or 60000 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public int getConvertPoolTimeout() {
        return getIntAttr(Provisioning.A_zimbraConvertPoolTimeout, 60000, true);
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @param zimbraConvertPoolTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public void setConvertPoolTimeout(int zimbraConvertPoolTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertPoolTimeout, Integer.toString(zimbraConvertPoolTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @param zimbraConvertPoolTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public Map<String,Object> setConvertPoolTimeout(int zimbraConvertPoolTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertPoolTimeout, Integer.toString(zimbraConvertPoolTimeout));
        return attrs;
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public void unsetConvertPoolTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertPoolTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout in milliseconds before retrying failed convert URLs.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2059)
    public Map<String,Object> unsetConvertPoolTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertPoolTimeout, "");
        return attrs;
    }

    /**
     * convertd URL
     *
     * @return zimbraConvertdURL, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public String[] getConvertdURL() {
        return getMultiAttr(Provisioning.A_zimbraConvertdURL, true, true);
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public void setConvertdURL(String[] zimbraConvertdURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public Map<String,Object> setConvertdURL(String[] zimbraConvertdURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        return attrs;
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public void addConvertdURL(String zimbraConvertdURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public Map<String,Object> addConvertdURL(String zimbraConvertdURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        return attrs;
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public void removeConvertdURL(String zimbraConvertdURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * convertd URL
     *
     * @param zimbraConvertdURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public Map<String,Object> removeConvertdURL(String zimbraConvertdURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraConvertdURL, zimbraConvertdURL);
        return attrs;
    }

    /**
     * convertd URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public void unsetConvertdURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertdURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * convertd URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=776)
    public Map<String,Object> unsetConvertdURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraConvertdURL, "");
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @return zimbraCosExtraObjectClass, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public String[] getCosExtraObjectClass() {
        return getMultiAttr(Provisioning.A_zimbraCosExtraObjectClass, true, true);
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @param zimbraCosExtraObjectClass new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public void setCosExtraObjectClass(String[] zimbraCosExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCosExtraObjectClass, zimbraCosExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @param zimbraCosExtraObjectClass new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public Map<String,Object> setCosExtraObjectClass(String[] zimbraCosExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCosExtraObjectClass, zimbraCosExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @param zimbraCosExtraObjectClass new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public void addCosExtraObjectClass(String zimbraCosExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCosExtraObjectClass, zimbraCosExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @param zimbraCosExtraObjectClass new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public Map<String,Object> addCosExtraObjectClass(String zimbraCosExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCosExtraObjectClass, zimbraCosExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @param zimbraCosExtraObjectClass existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public void removeCosExtraObjectClass(String zimbraCosExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCosExtraObjectClass, zimbraCosExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @param zimbraCosExtraObjectClass existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public Map<String,Object> removeCosExtraObjectClass(String zimbraCosExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCosExtraObjectClass, zimbraCosExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public void unsetCosExtraObjectClass() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCosExtraObjectClass, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra cos object.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=754)
    public Map<String,Object> unsetCosExtraObjectClass(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCosExtraObjectClass, "");
        return attrs;
    }

    /**
     * time object was created
     *
     * <p>Use getCreateTimestampAsString to access value as a string.
     *
     * @see #getCreateTimestampAsString()
     *
     * @return zimbraCreateTimestamp as Date, null if unset or unable to parse
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Date getCreateTimestamp() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraCreateTimestamp, null, true);
    }

    /**
     * time object was created
     *
     * @return zimbraCreateTimestamp, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public String getCreateTimestampAsString() {
        return getAttr(Provisioning.A_zimbraCreateTimestamp, null, true);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void setCreateTimestamp(Date zimbraCreateTimestamp) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraCreateTimestamp));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> setCreateTimestamp(Date zimbraCreateTimestamp, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraCreateTimestamp));
        return attrs;
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void setCreateTimestampAsString(String zimbraCreateTimestamp) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param zimbraCreateTimestamp new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> setCreateTimestampAsString(String zimbraCreateTimestamp, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, zimbraCreateTimestamp);
        return attrs;
    }

    /**
     * time object was created
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public void unsetCreateTimestamp() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time object was created
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=790)
    public Map<String,Object> unsetCreateTimestamp(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCreateTimestamp, "");
        return attrs;
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @return zimbraCsrfAllowedRefererHosts, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public String[] getCsrfAllowedRefererHosts() {
        return getMultiAttr(Provisioning.A_zimbraCsrfAllowedRefererHosts, true, true);
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @param zimbraCsrfAllowedRefererHosts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public void setCsrfAllowedRefererHosts(String[] zimbraCsrfAllowedRefererHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfAllowedRefererHosts, zimbraCsrfAllowedRefererHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @param zimbraCsrfAllowedRefererHosts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public Map<String,Object> setCsrfAllowedRefererHosts(String[] zimbraCsrfAllowedRefererHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfAllowedRefererHosts, zimbraCsrfAllowedRefererHosts);
        return attrs;
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @param zimbraCsrfAllowedRefererHosts new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public void addCsrfAllowedRefererHosts(String zimbraCsrfAllowedRefererHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCsrfAllowedRefererHosts, zimbraCsrfAllowedRefererHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @param zimbraCsrfAllowedRefererHosts new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public Map<String,Object> addCsrfAllowedRefererHosts(String zimbraCsrfAllowedRefererHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCsrfAllowedRefererHosts, zimbraCsrfAllowedRefererHosts);
        return attrs;
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @param zimbraCsrfAllowedRefererHosts existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public void removeCsrfAllowedRefererHosts(String zimbraCsrfAllowedRefererHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCsrfAllowedRefererHosts, zimbraCsrfAllowedRefererHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @param zimbraCsrfAllowedRefererHosts existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public Map<String,Object> removeCsrfAllowedRefererHosts(String zimbraCsrfAllowedRefererHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCsrfAllowedRefererHosts, zimbraCsrfAllowedRefererHosts);
        return attrs;
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public void unsetCsrfAllowedRefererHosts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfAllowedRefererHosts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A list of hosts like www.abc.com, www.xyz.com. These are used while
     * doing CSRF referer check.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1630)
    public Map<String,Object> unsetCsrfAllowedRefererHosts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfAllowedRefererHosts, "");
        return attrs;
    }

    /**
     * A flag to turn on or off CSRF referer related check. When set to FALSE
     * no CSRF referer check happens. When set to true CSRF referer type
     * check happens.
     *
     * @return zimbraCsrfRefererCheckEnabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1631)
    public boolean isCsrfRefererCheckEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCsrfRefererCheckEnabled, true, true);
    }

    /**
     * A flag to turn on or off CSRF referer related check. When set to FALSE
     * no CSRF referer check happens. When set to true CSRF referer type
     * check happens.
     *
     * @param zimbraCsrfRefererCheckEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1631)
    public void setCsrfRefererCheckEnabled(boolean zimbraCsrfRefererCheckEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfRefererCheckEnabled, zimbraCsrfRefererCheckEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A flag to turn on or off CSRF referer related check. When set to FALSE
     * no CSRF referer check happens. When set to true CSRF referer type
     * check happens.
     *
     * @param zimbraCsrfRefererCheckEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1631)
    public Map<String,Object> setCsrfRefererCheckEnabled(boolean zimbraCsrfRefererCheckEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfRefererCheckEnabled, zimbraCsrfRefererCheckEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * A flag to turn on or off CSRF referer related check. When set to FALSE
     * no CSRF referer check happens. When set to true CSRF referer type
     * check happens.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1631)
    public void unsetCsrfRefererCheckEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfRefererCheckEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A flag to turn on or off CSRF referer related check. When set to FALSE
     * no CSRF referer check happens. When set to true CSRF referer type
     * check happens.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1631)
    public Map<String,Object> unsetCsrfRefererCheckEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfRefererCheckEnabled, "");
        return attrs;
    }

    /**
     * A flag to turn on or off CSRF token related check. When set to FALSE
     * no CSRF check happens. When set to true both CSRF referer and CSRF
     * token change is effective.
     *
     * @return zimbraCsrfTokenCheckEnabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1628)
    public boolean isCsrfTokenCheckEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraCsrfTokenCheckEnabled, true, true);
    }

    /**
     * A flag to turn on or off CSRF token related check. When set to FALSE
     * no CSRF check happens. When set to true both CSRF referer and CSRF
     * token change is effective.
     *
     * @param zimbraCsrfTokenCheckEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1628)
    public void setCsrfTokenCheckEnabled(boolean zimbraCsrfTokenCheckEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfTokenCheckEnabled, zimbraCsrfTokenCheckEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A flag to turn on or off CSRF token related check. When set to FALSE
     * no CSRF check happens. When set to true both CSRF referer and CSRF
     * token change is effective.
     *
     * @param zimbraCsrfTokenCheckEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1628)
    public Map<String,Object> setCsrfTokenCheckEnabled(boolean zimbraCsrfTokenCheckEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfTokenCheckEnabled, zimbraCsrfTokenCheckEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * A flag to turn on or off CSRF token related check. When set to FALSE
     * no CSRF check happens. When set to true both CSRF referer and CSRF
     * token change is effective.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1628)
    public void unsetCsrfTokenCheckEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfTokenCheckEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A flag to turn on or off CSRF token related check. When set to FALSE
     * no CSRF check happens. When set to true both CSRF referer and CSRF
     * token change is effective.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1628)
    public Map<String,Object> unsetCsrfTokenCheckEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfTokenCheckEnabled, "");
        return attrs;
    }

    /**
     * CSRF token secret key
     *
     * @return zimbraCsrfTokenKey, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public String[] getCsrfTokenKey() {
        return getMultiAttr(Provisioning.A_zimbraCsrfTokenKey, true, true);
    }

    /**
     * CSRF token secret key
     *
     * @param zimbraCsrfTokenKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public void setCsrfTokenKey(String[] zimbraCsrfTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfTokenKey, zimbraCsrfTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CSRF token secret key
     *
     * @param zimbraCsrfTokenKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public Map<String,Object> setCsrfTokenKey(String[] zimbraCsrfTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfTokenKey, zimbraCsrfTokenKey);
        return attrs;
    }

    /**
     * CSRF token secret key
     *
     * @param zimbraCsrfTokenKey new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public void addCsrfTokenKey(String zimbraCsrfTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCsrfTokenKey, zimbraCsrfTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CSRF token secret key
     *
     * @param zimbraCsrfTokenKey new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public Map<String,Object> addCsrfTokenKey(String zimbraCsrfTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCsrfTokenKey, zimbraCsrfTokenKey);
        return attrs;
    }

    /**
     * CSRF token secret key
     *
     * @param zimbraCsrfTokenKey existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public void removeCsrfTokenKey(String zimbraCsrfTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCsrfTokenKey, zimbraCsrfTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CSRF token secret key
     *
     * @param zimbraCsrfTokenKey existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public Map<String,Object> removeCsrfTokenKey(String zimbraCsrfTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCsrfTokenKey, zimbraCsrfTokenKey);
        return attrs;
    }

    /**
     * CSRF token secret key
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public void unsetCsrfTokenKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfTokenKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CSRF token secret key
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1627)
    public Map<String,Object> unsetCsrfTokenKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCsrfTokenKey, "");
        return attrs;
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @return zimbraCustomMimeHeaderNameAllowed, or empty array if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public String[] getCustomMimeHeaderNameAllowed() {
        return getMultiAttr(Provisioning.A_zimbraCustomMimeHeaderNameAllowed, true, true);
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @param zimbraCustomMimeHeaderNameAllowed new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public void setCustomMimeHeaderNameAllowed(String[] zimbraCustomMimeHeaderNameAllowed) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCustomMimeHeaderNameAllowed, zimbraCustomMimeHeaderNameAllowed);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @param zimbraCustomMimeHeaderNameAllowed new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public Map<String,Object> setCustomMimeHeaderNameAllowed(String[] zimbraCustomMimeHeaderNameAllowed, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCustomMimeHeaderNameAllowed, zimbraCustomMimeHeaderNameAllowed);
        return attrs;
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @param zimbraCustomMimeHeaderNameAllowed new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public void addCustomMimeHeaderNameAllowed(String zimbraCustomMimeHeaderNameAllowed) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCustomMimeHeaderNameAllowed, zimbraCustomMimeHeaderNameAllowed);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @param zimbraCustomMimeHeaderNameAllowed new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public Map<String,Object> addCustomMimeHeaderNameAllowed(String zimbraCustomMimeHeaderNameAllowed, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraCustomMimeHeaderNameAllowed, zimbraCustomMimeHeaderNameAllowed);
        return attrs;
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @param zimbraCustomMimeHeaderNameAllowed existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public void removeCustomMimeHeaderNameAllowed(String zimbraCustomMimeHeaderNameAllowed) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCustomMimeHeaderNameAllowed, zimbraCustomMimeHeaderNameAllowed);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @param zimbraCustomMimeHeaderNameAllowed existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public Map<String,Object> removeCustomMimeHeaderNameAllowed(String zimbraCustomMimeHeaderNameAllowed, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraCustomMimeHeaderNameAllowed, zimbraCustomMimeHeaderNameAllowed);
        return attrs;
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public void unsetCustomMimeHeaderNameAllowed() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCustomMimeHeaderNameAllowed, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom RFC822 header names (case-sensitive) allowed to specify in
     * SendMsgRequest
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1265)
    public Map<String,Object> unsetCustomMimeHeaderNameAllowed(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraCustomMimeHeaderNameAllowed, "");
        return attrs;
    }

    /**
     * This attribute is used for DNS check by customers that configure their
     * MX to point at spam relays or other non-zimbra inbox smtp servers
     *
     * @return zimbraDNSCheckHostname, or null if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=744)
    public String getDNSCheckHostname() {
        return getAttr(Provisioning.A_zimbraDNSCheckHostname, null, true);
    }

    /**
     * This attribute is used for DNS check by customers that configure their
     * MX to point at spam relays or other non-zimbra inbox smtp servers
     *
     * @param zimbraDNSCheckHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=744)
    public void setDNSCheckHostname(String zimbraDNSCheckHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSCheckHostname, zimbraDNSCheckHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for DNS check by customers that configure their
     * MX to point at spam relays or other non-zimbra inbox smtp servers
     *
     * @param zimbraDNSCheckHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=744)
    public Map<String,Object> setDNSCheckHostname(String zimbraDNSCheckHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSCheckHostname, zimbraDNSCheckHostname);
        return attrs;
    }

    /**
     * This attribute is used for DNS check by customers that configure their
     * MX to point at spam relays or other non-zimbra inbox smtp servers
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=744)
    public void unsetDNSCheckHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSCheckHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for DNS check by customers that configure their
     * MX to point at spam relays or other non-zimbra inbox smtp servers
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=744)
    public Map<String,Object> unsetDNSCheckHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSCheckHostname, "");
        return attrs;
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @return zimbraDNSMasterIP, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public String[] getDNSMasterIP() {
        return getMultiAttr(Provisioning.A_zimbraDNSMasterIP, true, true);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public void setDNSMasterIP(String[] zimbraDNSMasterIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public Map<String,Object> setDNSMasterIP(String[] zimbraDNSMasterIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        return attrs;
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public void addDNSMasterIP(String zimbraDNSMasterIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public Map<String,Object> addDNSMasterIP(String zimbraDNSMasterIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        return attrs;
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public void removeDNSMasterIP(String zimbraDNSMasterIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param zimbraDNSMasterIP existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public Map<String,Object> removeDNSMasterIP(String zimbraDNSMasterIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDNSMasterIP, zimbraDNSMasterIP);
        return attrs;
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public void unsetDNSMasterIP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSMasterIP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP Address(es) of the root DNS servers to be used by the DNS cache
     * service
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1569)
    public Map<String,Object> unsetDNSMasterIP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSMasterIP, "");
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraDNSTCPUpstream, or ZAttrProvisioning.DNSTCPUpstream.no if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public ZAttrProvisioning.DNSTCPUpstream getDNSTCPUpstream() {
        try { String v = getAttr(Provisioning.A_zimbraDNSTCPUpstream, true, true); return v == null ? ZAttrProvisioning.DNSTCPUpstream.no : ZAttrProvisioning.DNSTCPUpstream.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.DNSTCPUpstream.no; }
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraDNSTCPUpstream, or "no" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public String getDNSTCPUpstreamAsString() {
        return getAttr(Provisioning.A_zimbraDNSTCPUpstream, "no", true);
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSTCPUpstream new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public void setDNSTCPUpstream(ZAttrProvisioning.DNSTCPUpstream zimbraDNSTCPUpstream) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, zimbraDNSTCPUpstream.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSTCPUpstream new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public Map<String,Object> setDNSTCPUpstream(ZAttrProvisioning.DNSTCPUpstream zimbraDNSTCPUpstream, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, zimbraDNSTCPUpstream.toString());
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSTCPUpstream new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public void setDNSTCPUpstreamAsString(String zimbraDNSTCPUpstream) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, zimbraDNSTCPUpstream);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSTCPUpstream new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public Map<String,Object> setDNSTCPUpstreamAsString(String zimbraDNSTCPUpstream, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, zimbraDNSTCPUpstream);
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public void unsetDNSTCPUpstream() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to only use TCP when talking to
     * the upstream Master DNS servers. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1597)
    public Map<String,Object> unsetDNSTCPUpstream(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSTCPUpstream, "");
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraDNSUseTCP, or ZAttrProvisioning.DNSUseTCP.yes if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public ZAttrProvisioning.DNSUseTCP getDNSUseTCP() {
        try { String v = getAttr(Provisioning.A_zimbraDNSUseTCP, true, true); return v == null ? ZAttrProvisioning.DNSUseTCP.yes : ZAttrProvisioning.DNSUseTCP.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.DNSUseTCP.yes; }
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraDNSUseTCP, or "yes" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public String getDNSUseTCPAsString() {
        return getAttr(Provisioning.A_zimbraDNSUseTCP, "yes", true);
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSUseTCP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public void setDNSUseTCP(ZAttrProvisioning.DNSUseTCP zimbraDNSUseTCP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, zimbraDNSUseTCP.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSUseTCP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public Map<String,Object> setDNSUseTCP(ZAttrProvisioning.DNSUseTCP zimbraDNSUseTCP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, zimbraDNSUseTCP.toString());
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSUseTCP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public void setDNSUseTCPAsString(String zimbraDNSUseTCP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, zimbraDNSUseTCP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSUseTCP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public Map<String,Object> setDNSUseTCPAsString(String zimbraDNSUseTCP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, zimbraDNSUseTCP);
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public void unsetDNSUseTCP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use TCP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1584)
    public Map<String,Object> unsetDNSUseTCP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseTCP, "");
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraDNSUseUDP, or ZAttrProvisioning.DNSUseUDP.yes if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public ZAttrProvisioning.DNSUseUDP getDNSUseUDP() {
        try { String v = getAttr(Provisioning.A_zimbraDNSUseUDP, true, true); return v == null ? ZAttrProvisioning.DNSUseUDP.yes : ZAttrProvisioning.DNSUseUDP.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.DNSUseUDP.yes; }
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraDNSUseUDP, or "yes" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public String getDNSUseUDPAsString() {
        return getAttr(Provisioning.A_zimbraDNSUseUDP, "yes", true);
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSUseUDP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public void setDNSUseUDP(ZAttrProvisioning.DNSUseUDP zimbraDNSUseUDP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, zimbraDNSUseUDP.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSUseUDP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public Map<String,Object> setDNSUseUDP(ZAttrProvisioning.DNSUseUDP zimbraDNSUseUDP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, zimbraDNSUseUDP.toString());
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSUseUDP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public void setDNSUseUDPAsString(String zimbraDNSUseUDP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, zimbraDNSUseUDP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraDNSUseUDP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public Map<String,Object> setDNSUseUDPAsString(String zimbraDNSUseUDP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, zimbraDNSUseUDP);
        return attrs;
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public void unsetDNSUseUDP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * For zimbra dnscache, whether or not to use UDP. Defaults to yes
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1586)
    public Map<String,Object> unsetDNSUseUDP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDNSUseUDP, "");
        return attrs;
    }

    /**
     * Connect timeout in seconds for the data source
     *
     * @return zimbraDataSourceConnectTimeout, or 30 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1083)
    public int getDataSourceConnectTimeout() {
        return getIntAttr(Provisioning.A_zimbraDataSourceConnectTimeout, 30, true);
    }

    /**
     * Connect timeout in seconds for the data source
     *
     * @param zimbraDataSourceConnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1083)
    public void setDataSourceConnectTimeout(int zimbraDataSourceConnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectTimeout, Integer.toString(zimbraDataSourceConnectTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Connect timeout in seconds for the data source
     *
     * @param zimbraDataSourceConnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1083)
    public Map<String,Object> setDataSourceConnectTimeout(int zimbraDataSourceConnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectTimeout, Integer.toString(zimbraDataSourceConnectTimeout));
        return attrs;
    }

    /**
     * Connect timeout in seconds for the data source
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1083)
    public void unsetDataSourceConnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Connect timeout in seconds for the data source
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1083)
    public Map<String,Object> unsetDataSourceConnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectTimeout, "");
        return attrs;
    }

    /**
     * Which security layer to use for connection (cleartext, ssl, tls, or
     * tls if available). If not set on data source, fallback to the value on
     * global config.
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @return zimbraDataSourceConnectionType, or ZAttrProvisioning.DataSourceConnectionType.cleartext if unset and/or has invalid value
     */
    @ZAttr(id=425)
    public ZAttrProvisioning.DataSourceConnectionType getDataSourceConnectionType() {
        try { String v = getAttr(Provisioning.A_zimbraDataSourceConnectionType, true, true); return v == null ? ZAttrProvisioning.DataSourceConnectionType.cleartext : ZAttrProvisioning.DataSourceConnectionType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.DataSourceConnectionType.cleartext; }
    }

    /**
     * Which security layer to use for connection (cleartext, ssl, tls, or
     * tls if available). If not set on data source, fallback to the value on
     * global config.
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @return zimbraDataSourceConnectionType, or "cleartext" if unset
     */
    @ZAttr(id=425)
    public String getDataSourceConnectionTypeAsString() {
        return getAttr(Provisioning.A_zimbraDataSourceConnectionType, "cleartext", true);
    }

    /**
     * Which security layer to use for connection (cleartext, ssl, tls, or
     * tls if available). If not set on data source, fallback to the value on
     * global config.
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param zimbraDataSourceConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=425)
    public void setDataSourceConnectionType(ZAttrProvisioning.DataSourceConnectionType zimbraDataSourceConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectionType, zimbraDataSourceConnectionType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Which security layer to use for connection (cleartext, ssl, tls, or
     * tls if available). If not set on data source, fallback to the value on
     * global config.
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param zimbraDataSourceConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=425)
    public Map<String,Object> setDataSourceConnectionType(ZAttrProvisioning.DataSourceConnectionType zimbraDataSourceConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectionType, zimbraDataSourceConnectionType.toString());
        return attrs;
    }

    /**
     * Which security layer to use for connection (cleartext, ssl, tls, or
     * tls if available). If not set on data source, fallback to the value on
     * global config.
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param zimbraDataSourceConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=425)
    public void setDataSourceConnectionTypeAsString(String zimbraDataSourceConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectionType, zimbraDataSourceConnectionType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Which security layer to use for connection (cleartext, ssl, tls, or
     * tls if available). If not set on data source, fallback to the value on
     * global config.
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param zimbraDataSourceConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=425)
    public Map<String,Object> setDataSourceConnectionTypeAsString(String zimbraDataSourceConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectionType, zimbraDataSourceConnectionType);
        return attrs;
    }

    /**
     * Which security layer to use for connection (cleartext, ssl, tls, or
     * tls if available). If not set on data source, fallback to the value on
     * global config.
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=425)
    public void unsetDataSourceConnectionType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectionType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Which security layer to use for connection (cleartext, ssl, tls, or
     * tls if available). If not set on data source, fallback to the value on
     * global config.
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=425)
    public Map<String,Object> unsetDataSourceConnectionType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceConnectionType, "");
        return attrs;
    }

    /**
     * Read timeout in seconds
     *
     * @return zimbraDataSourceReadTimeout, or 60 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1084)
    public int getDataSourceReadTimeout() {
        return getIntAttr(Provisioning.A_zimbraDataSourceReadTimeout, 60, true);
    }

    /**
     * Read timeout in seconds
     *
     * @param zimbraDataSourceReadTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1084)
    public void setDataSourceReadTimeout(int zimbraDataSourceReadTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceReadTimeout, Integer.toString(zimbraDataSourceReadTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Read timeout in seconds
     *
     * @param zimbraDataSourceReadTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1084)
    public Map<String,Object> setDataSourceReadTimeout(int zimbraDataSourceReadTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceReadTimeout, Integer.toString(zimbraDataSourceReadTimeout));
        return attrs;
    }

    /**
     * Read timeout in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1084)
    public void unsetDataSourceReadTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceReadTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Read timeout in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1084)
    public Map<String,Object> unsetDataSourceReadTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDataSourceReadTimeout, "");
        return attrs;
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getDatabaseSlowSqlThresholdAsString to access value as a string.
     *
     * @see #getDatabaseSlowSqlThresholdAsString()
     *
     * @return zimbraDatabaseSlowSqlThreshold in millseconds, or 2000 (2s)  if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public long getDatabaseSlowSqlThreshold() {
        return getTimeInterval(Provisioning.A_zimbraDatabaseSlowSqlThreshold, 2000L, true);
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraDatabaseSlowSqlThreshold, or "2s" if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public String getDatabaseSlowSqlThresholdAsString() {
        return getAttr(Provisioning.A_zimbraDatabaseSlowSqlThreshold, "2s", true);
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraDatabaseSlowSqlThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public void setDatabaseSlowSqlThreshold(String zimbraDatabaseSlowSqlThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDatabaseSlowSqlThreshold, zimbraDatabaseSlowSqlThreshold);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraDatabaseSlowSqlThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public Map<String,Object> setDatabaseSlowSqlThreshold(String zimbraDatabaseSlowSqlThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDatabaseSlowSqlThreshold, zimbraDatabaseSlowSqlThreshold);
        return attrs;
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public void unsetDatabaseSlowSqlThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDatabaseSlowSqlThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SQL statements that take longer than this duration to execute will be
     * logged to the sqltrace category in mailbox.log.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1038)
    public Map<String,Object> unsetDatabaseSlowSqlThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDatabaseSlowSqlThreshold, "");
        return attrs;
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @return zimbraDefaultAnalyzerStopWords, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public String[] getDefaultAnalyzerStopWords() {
        String[] value = getMultiAttr(Provisioning.A_zimbraDefaultAnalyzerStopWords, true, true); return value.length > 0 ? value : new String[] {"a","an","and","are","as","at","be","but","by","for","if","in","into","is","it","no","not","of","on","or","such","that","the","their","then","there","these","they","this","to","was","will","with"};
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @param zimbraDefaultAnalyzerStopWords new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public void setDefaultAnalyzerStopWords(String[] zimbraDefaultAnalyzerStopWords) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultAnalyzerStopWords, zimbraDefaultAnalyzerStopWords);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @param zimbraDefaultAnalyzerStopWords new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public Map<String,Object> setDefaultAnalyzerStopWords(String[] zimbraDefaultAnalyzerStopWords, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultAnalyzerStopWords, zimbraDefaultAnalyzerStopWords);
        return attrs;
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @param zimbraDefaultAnalyzerStopWords new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public void addDefaultAnalyzerStopWords(String zimbraDefaultAnalyzerStopWords) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDefaultAnalyzerStopWords, zimbraDefaultAnalyzerStopWords);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @param zimbraDefaultAnalyzerStopWords new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public Map<String,Object> addDefaultAnalyzerStopWords(String zimbraDefaultAnalyzerStopWords, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDefaultAnalyzerStopWords, zimbraDefaultAnalyzerStopWords);
        return attrs;
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @param zimbraDefaultAnalyzerStopWords existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public void removeDefaultAnalyzerStopWords(String zimbraDefaultAnalyzerStopWords) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDefaultAnalyzerStopWords, zimbraDefaultAnalyzerStopWords);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @param zimbraDefaultAnalyzerStopWords existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public Map<String,Object> removeDefaultAnalyzerStopWords(String zimbraDefaultAnalyzerStopWords, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDefaultAnalyzerStopWords, zimbraDefaultAnalyzerStopWords);
        return attrs;
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public void unsetDefaultAnalyzerStopWords() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultAnalyzerStopWords, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * stop words for lucene text analyzer. This setting takes effect only
     * for default analyzer. This setting affects only accounts that do not
     * have custom text analyzers. See zimbraTextAnalyzer for information on
     * custom text analyzers.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1587)
    public Map<String,Object> unsetDefaultAnalyzerStopWords(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultAnalyzerStopWords, "");
        return attrs;
    }

    /**
     * name of the default domain for accounts when authenticating without a
     * domain
     *
     * @return zimbraDefaultDomainName, or null if unset
     */
    @ZAttr(id=172)
    public String getDefaultDomainName() {
        return getAttr(Provisioning.A_zimbraDefaultDomainName, null, true);
    }

    /**
     * name of the default domain for accounts when authenticating without a
     * domain
     *
     * @param zimbraDefaultDomainName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=172)
    public void setDefaultDomainName(String zimbraDefaultDomainName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultDomainName, zimbraDefaultDomainName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name of the default domain for accounts when authenticating without a
     * domain
     *
     * @param zimbraDefaultDomainName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=172)
    public Map<String,Object> setDefaultDomainName(String zimbraDefaultDomainName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultDomainName, zimbraDefaultDomainName);
        return attrs;
    }

    /**
     * name of the default domain for accounts when authenticating without a
     * domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=172)
    public void unsetDefaultDomainName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultDomainName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name of the default domain for accounts when authenticating without a
     * domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=172)
    public Map<String,Object> unsetDefaultDomainName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDefaultDomainName, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @return zimbraDomainAdminModifiableAttr, or empty array if unset
     */
    @ZAttr(id=300)
    public String[] getDomainAdminModifiableAttr() {
        return getMultiAttr(Provisioning.A_zimbraDomainAdminModifiableAttr, true, true);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @param zimbraDomainAdminModifiableAttr new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=300)
    public void setDomainAdminModifiableAttr(String[] zimbraDomainAdminModifiableAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAdminModifiableAttr, zimbraDomainAdminModifiableAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @param zimbraDomainAdminModifiableAttr new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=300)
    public Map<String,Object> setDomainAdminModifiableAttr(String[] zimbraDomainAdminModifiableAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAdminModifiableAttr, zimbraDomainAdminModifiableAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @param zimbraDomainAdminModifiableAttr new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=300)
    public void addDomainAdminModifiableAttr(String zimbraDomainAdminModifiableAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDomainAdminModifiableAttr, zimbraDomainAdminModifiableAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @param zimbraDomainAdminModifiableAttr new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=300)
    public Map<String,Object> addDomainAdminModifiableAttr(String zimbraDomainAdminModifiableAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDomainAdminModifiableAttr, zimbraDomainAdminModifiableAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @param zimbraDomainAdminModifiableAttr existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=300)
    public void removeDomainAdminModifiableAttr(String zimbraDomainAdminModifiableAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDomainAdminModifiableAttr, zimbraDomainAdminModifiableAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @param zimbraDomainAdminModifiableAttr existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=300)
    public Map<String,Object> removeDomainAdminModifiableAttr(String zimbraDomainAdminModifiableAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDomainAdminModifiableAttr, zimbraDomainAdminModifiableAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=300)
    public void unsetDomainAdminModifiableAttr() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAdminModifiableAttr, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the
     * domainAdminAdminModifiable flag. Orig desc: account attributes that a
     * domain administrator is allowed to modify
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=300)
    public Map<String,Object> unsetDomainAdminModifiableAttr(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAdminModifiableAttr, "");
        return attrs;
    }

    /**
     * maximum aggregate quota for the domain in bytes
     *
     * @return zimbraDomainAggregateQuota, or 0 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1327)
    public long getDomainAggregateQuota() {
        return getLongAttr(Provisioning.A_zimbraDomainAggregateQuota, 0L, true);
    }

    /**
     * maximum aggregate quota for the domain in bytes
     *
     * @param zimbraDomainAggregateQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1327)
    public void setDomainAggregateQuota(long zimbraDomainAggregateQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuota, Long.toString(zimbraDomainAggregateQuota));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum aggregate quota for the domain in bytes
     *
     * @param zimbraDomainAggregateQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1327)
    public Map<String,Object> setDomainAggregateQuota(long zimbraDomainAggregateQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuota, Long.toString(zimbraDomainAggregateQuota));
        return attrs;
    }

    /**
     * maximum aggregate quota for the domain in bytes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1327)
    public void unsetDomainAggregateQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum aggregate quota for the domain in bytes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1327)
    public Map<String,Object> unsetDomainAggregateQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuota, "");
        return attrs;
    }

    /**
     * policy for a domain whose quota usage is above
     * zimbraDomainAggregateQuota
     *
     * <p>Valid values: [ALLOWSENDRECEIVE, BLOCKSEND, BLOCKSENDRECEIVE]
     *
     * @return zimbraDomainAggregateQuotaPolicy, or ZAttrProvisioning.DomainAggregateQuotaPolicy.ALLOWSENDRECEIVE if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1329)
    public ZAttrProvisioning.DomainAggregateQuotaPolicy getDomainAggregateQuotaPolicy() {
        try { String v = getAttr(Provisioning.A_zimbraDomainAggregateQuotaPolicy, true, true); return v == null ? ZAttrProvisioning.DomainAggregateQuotaPolicy.ALLOWSENDRECEIVE : ZAttrProvisioning.DomainAggregateQuotaPolicy.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.DomainAggregateQuotaPolicy.ALLOWSENDRECEIVE; }
    }

    /**
     * policy for a domain whose quota usage is above
     * zimbraDomainAggregateQuota
     *
     * <p>Valid values: [ALLOWSENDRECEIVE, BLOCKSEND, BLOCKSENDRECEIVE]
     *
     * @return zimbraDomainAggregateQuotaPolicy, or "ALLOWSENDRECEIVE" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1329)
    public String getDomainAggregateQuotaPolicyAsString() {
        return getAttr(Provisioning.A_zimbraDomainAggregateQuotaPolicy, "ALLOWSENDRECEIVE", true);
    }

    /**
     * policy for a domain whose quota usage is above
     * zimbraDomainAggregateQuota
     *
     * <p>Valid values: [ALLOWSENDRECEIVE, BLOCKSEND, BLOCKSENDRECEIVE]
     *
     * @param zimbraDomainAggregateQuotaPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1329)
    public void setDomainAggregateQuotaPolicy(ZAttrProvisioning.DomainAggregateQuotaPolicy zimbraDomainAggregateQuotaPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaPolicy, zimbraDomainAggregateQuotaPolicy.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * policy for a domain whose quota usage is above
     * zimbraDomainAggregateQuota
     *
     * <p>Valid values: [ALLOWSENDRECEIVE, BLOCKSEND, BLOCKSENDRECEIVE]
     *
     * @param zimbraDomainAggregateQuotaPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1329)
    public Map<String,Object> setDomainAggregateQuotaPolicy(ZAttrProvisioning.DomainAggregateQuotaPolicy zimbraDomainAggregateQuotaPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaPolicy, zimbraDomainAggregateQuotaPolicy.toString());
        return attrs;
    }

    /**
     * policy for a domain whose quota usage is above
     * zimbraDomainAggregateQuota
     *
     * <p>Valid values: [ALLOWSENDRECEIVE, BLOCKSEND, BLOCKSENDRECEIVE]
     *
     * @param zimbraDomainAggregateQuotaPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1329)
    public void setDomainAggregateQuotaPolicyAsString(String zimbraDomainAggregateQuotaPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaPolicy, zimbraDomainAggregateQuotaPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * policy for a domain whose quota usage is above
     * zimbraDomainAggregateQuota
     *
     * <p>Valid values: [ALLOWSENDRECEIVE, BLOCKSEND, BLOCKSENDRECEIVE]
     *
     * @param zimbraDomainAggregateQuotaPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1329)
    public Map<String,Object> setDomainAggregateQuotaPolicyAsString(String zimbraDomainAggregateQuotaPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaPolicy, zimbraDomainAggregateQuotaPolicy);
        return attrs;
    }

    /**
     * policy for a domain whose quota usage is above
     * zimbraDomainAggregateQuota
     *
     * <p>Valid values: [ALLOWSENDRECEIVE, BLOCKSEND, BLOCKSENDRECEIVE]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1329)
    public void unsetDomainAggregateQuotaPolicy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaPolicy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * policy for a domain whose quota usage is above
     * zimbraDomainAggregateQuota
     *
     * <p>Valid values: [ALLOWSENDRECEIVE, BLOCKSEND, BLOCKSENDRECEIVE]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1329)
    public Map<String,Object> unsetDomainAggregateQuotaPolicy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaPolicy, "");
        return attrs;
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @return zimbraDomainAggregateQuotaWarnEmailRecipient, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public String[] getDomainAggregateQuotaWarnEmailRecipient() {
        return getMultiAttr(Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, true, true);
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @param zimbraDomainAggregateQuotaWarnEmailRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public void setDomainAggregateQuotaWarnEmailRecipient(String[] zimbraDomainAggregateQuotaWarnEmailRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, zimbraDomainAggregateQuotaWarnEmailRecipient);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @param zimbraDomainAggregateQuotaWarnEmailRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public Map<String,Object> setDomainAggregateQuotaWarnEmailRecipient(String[] zimbraDomainAggregateQuotaWarnEmailRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, zimbraDomainAggregateQuotaWarnEmailRecipient);
        return attrs;
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @param zimbraDomainAggregateQuotaWarnEmailRecipient new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public void addDomainAggregateQuotaWarnEmailRecipient(String zimbraDomainAggregateQuotaWarnEmailRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, zimbraDomainAggregateQuotaWarnEmailRecipient);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @param zimbraDomainAggregateQuotaWarnEmailRecipient new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public Map<String,Object> addDomainAggregateQuotaWarnEmailRecipient(String zimbraDomainAggregateQuotaWarnEmailRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, zimbraDomainAggregateQuotaWarnEmailRecipient);
        return attrs;
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @param zimbraDomainAggregateQuotaWarnEmailRecipient existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public void removeDomainAggregateQuotaWarnEmailRecipient(String zimbraDomainAggregateQuotaWarnEmailRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, zimbraDomainAggregateQuotaWarnEmailRecipient);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @param zimbraDomainAggregateQuotaWarnEmailRecipient existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public Map<String,Object> removeDomainAggregateQuotaWarnEmailRecipient(String zimbraDomainAggregateQuotaWarnEmailRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, zimbraDomainAggregateQuotaWarnEmailRecipient);
        return attrs;
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public void unsetDomainAggregateQuotaWarnEmailRecipient() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email recipients to be notified when zimbraAggregateQuotaLastUsage
     * reaches zimbraDomainAggregateQuotaWarnPercent of the
     * zimbraDomainAggregateQuota
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1331)
    public Map<String,Object> unsetDomainAggregateQuotaWarnEmailRecipient(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaWarnEmailRecipient, "");
        return attrs;
    }

    /**
     * percentage threshold for domain aggregate quota warnings
     *
     * @return zimbraDomainAggregateQuotaWarnPercent, or 80 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1330)
    public int getDomainAggregateQuotaWarnPercent() {
        return getIntAttr(Provisioning.A_zimbraDomainAggregateQuotaWarnPercent, 80, true);
    }

    /**
     * percentage threshold for domain aggregate quota warnings
     *
     * @param zimbraDomainAggregateQuotaWarnPercent new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1330)
    public void setDomainAggregateQuotaWarnPercent(int zimbraDomainAggregateQuotaWarnPercent) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaWarnPercent, Integer.toString(zimbraDomainAggregateQuotaWarnPercent));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * percentage threshold for domain aggregate quota warnings
     *
     * @param zimbraDomainAggregateQuotaWarnPercent new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1330)
    public Map<String,Object> setDomainAggregateQuotaWarnPercent(int zimbraDomainAggregateQuotaWarnPercent, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaWarnPercent, Integer.toString(zimbraDomainAggregateQuotaWarnPercent));
        return attrs;
    }

    /**
     * percentage threshold for domain aggregate quota warnings
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1330)
    public void unsetDomainAggregateQuotaWarnPercent() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaWarnPercent, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * percentage threshold for domain aggregate quota warnings
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1330)
    public Map<String,Object> unsetDomainAggregateQuotaWarnPercent(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainAggregateQuotaWarnPercent, "");
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @return zimbraDomainExtraObjectClass, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public String[] getDomainExtraObjectClass() {
        String[] value = getMultiAttr(Provisioning.A_zimbraDomainExtraObjectClass, true, true); return value.length > 0 ? value : new String[] {"amavisAccount"};
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @param zimbraDomainExtraObjectClass new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public void setDomainExtraObjectClass(String[] zimbraDomainExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainExtraObjectClass, zimbraDomainExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @param zimbraDomainExtraObjectClass new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public Map<String,Object> setDomainExtraObjectClass(String[] zimbraDomainExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainExtraObjectClass, zimbraDomainExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @param zimbraDomainExtraObjectClass new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public void addDomainExtraObjectClass(String zimbraDomainExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDomainExtraObjectClass, zimbraDomainExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @param zimbraDomainExtraObjectClass new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public Map<String,Object> addDomainExtraObjectClass(String zimbraDomainExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDomainExtraObjectClass, zimbraDomainExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @param zimbraDomainExtraObjectClass existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public void removeDomainExtraObjectClass(String zimbraDomainExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDomainExtraObjectClass, zimbraDomainExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @param zimbraDomainExtraObjectClass existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public Map<String,Object> removeDomainExtraObjectClass(String zimbraDomainExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDomainExtraObjectClass, zimbraDomainExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public void unsetDomainExtraObjectClass() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainExtraObjectClass, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra domain object.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=755)
    public Map<String,Object> unsetDomainExtraObjectClass(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainExtraObjectClass, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @return zimbraDomainInheritedAttr, or empty array if unset
     */
    @ZAttr(id=63)
    public String[] getDomainInheritedAttr() {
        return getMultiAttr(Provisioning.A_zimbraDomainInheritedAttr, true, true);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @param zimbraDomainInheritedAttr new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=63)
    public void setDomainInheritedAttr(String[] zimbraDomainInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainInheritedAttr, zimbraDomainInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @param zimbraDomainInheritedAttr new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=63)
    public Map<String,Object> setDomainInheritedAttr(String[] zimbraDomainInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainInheritedAttr, zimbraDomainInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @param zimbraDomainInheritedAttr new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=63)
    public void addDomainInheritedAttr(String zimbraDomainInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDomainInheritedAttr, zimbraDomainInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @param zimbraDomainInheritedAttr new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=63)
    public Map<String,Object> addDomainInheritedAttr(String zimbraDomainInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraDomainInheritedAttr, zimbraDomainInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @param zimbraDomainInheritedAttr existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=63)
    public void removeDomainInheritedAttr(String zimbraDomainInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDomainInheritedAttr, zimbraDomainInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @param zimbraDomainInheritedAttr existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=63)
    public Map<String,Object> removeDomainInheritedAttr(String zimbraDomainInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraDomainInheritedAttr, zimbraDomainInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=63)
    public void unsetDomainInheritedAttr() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainInheritedAttr, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the domainInherited
     * flag. Orig desc: zimbraDomain attrs that get inherited from global
     * config
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=63)
    public Map<String,Object> unsetDomainInheritedAttr(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainInheritedAttr, "");
        return attrs;
    }

    /**
     * enable domain mandatory mail signature
     *
     * @return zimbraDomainMandatoryMailSignatureEnabled, or false if unset
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1069)
    public boolean isDomainMandatoryMailSignatureEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraDomainMandatoryMailSignatureEnabled, false, true);
    }

    /**
     * enable domain mandatory mail signature
     *
     * @param zimbraDomainMandatoryMailSignatureEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1069)
    public void setDomainMandatoryMailSignatureEnabled(boolean zimbraDomainMandatoryMailSignatureEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureEnabled, zimbraDomainMandatoryMailSignatureEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable domain mandatory mail signature
     *
     * @param zimbraDomainMandatoryMailSignatureEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1069)
    public Map<String,Object> setDomainMandatoryMailSignatureEnabled(boolean zimbraDomainMandatoryMailSignatureEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureEnabled, zimbraDomainMandatoryMailSignatureEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable domain mandatory mail signature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1069)
    public void unsetDomainMandatoryMailSignatureEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable domain mandatory mail signature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1069)
    public Map<String,Object> unsetDomainMandatoryMailSignatureEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerHTML. Orig desc: domain mandatory mail
     * html signature
     *
     * @return zimbraDomainMandatoryMailSignatureHTML, or null if unset
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1071)
    public String getDomainMandatoryMailSignatureHTML() {
        return getAttr(Provisioning.A_zimbraDomainMandatoryMailSignatureHTML, null, true);
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerHTML. Orig desc: domain mandatory mail
     * html signature
     *
     * @param zimbraDomainMandatoryMailSignatureHTML new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1071)
    public void setDomainMandatoryMailSignatureHTML(String zimbraDomainMandatoryMailSignatureHTML) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureHTML, zimbraDomainMandatoryMailSignatureHTML);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerHTML. Orig desc: domain mandatory mail
     * html signature
     *
     * @param zimbraDomainMandatoryMailSignatureHTML new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1071)
    public Map<String,Object> setDomainMandatoryMailSignatureHTML(String zimbraDomainMandatoryMailSignatureHTML, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureHTML, zimbraDomainMandatoryMailSignatureHTML);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerHTML. Orig desc: domain mandatory mail
     * html signature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1071)
    public void unsetDomainMandatoryMailSignatureHTML() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureHTML, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerHTML. Orig desc: domain mandatory mail
     * html signature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1071)
    public Map<String,Object> unsetDomainMandatoryMailSignatureHTML(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureHTML, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerText. Orig desc: domain mandatory mail
     * plain text signature
     *
     * @return zimbraDomainMandatoryMailSignatureText, or null if unset
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1070)
    public String getDomainMandatoryMailSignatureText() {
        return getAttr(Provisioning.A_zimbraDomainMandatoryMailSignatureText, null, true);
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerText. Orig desc: domain mandatory mail
     * plain text signature
     *
     * @param zimbraDomainMandatoryMailSignatureText new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1070)
    public void setDomainMandatoryMailSignatureText(String zimbraDomainMandatoryMailSignatureText) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureText, zimbraDomainMandatoryMailSignatureText);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerText. Orig desc: domain mandatory mail
     * plain text signature
     *
     * @param zimbraDomainMandatoryMailSignatureText new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1070)
    public Map<String,Object> setDomainMandatoryMailSignatureText(String zimbraDomainMandatoryMailSignatureText, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureText, zimbraDomainMandatoryMailSignatureText);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerText. Orig desc: domain mandatory mail
     * plain text signature
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1070)
    public void unsetDomainMandatoryMailSignatureText() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureText, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. deprecated in favor of
     * zimbraAmavisDomainDisclaimerText. Orig desc: domain mandatory mail
     * plain text signature
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.4
     */
    @ZAttr(id=1070)
    public Map<String,Object> unsetDomainMandatoryMailSignatureText(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainMandatoryMailSignatureText, "");
        return attrs;
    }

    /**
     * domain status. enum values are akin to those of zimbraAccountStatus
     * but the status affects all accounts on the domain. See table below for
     * how zimbraDomainStatus affects account status. active - see
     * zimbraAccountStatus maintenance - see zimbraAccountStatus locked - see
     * zimbraAccountStatus closed - see zimbraAccountStatus suspended -
     * maintenance + no creating/deleting/modifying accounts/DLs under the
     * domain. shutdown - suspended + cannot modify domain attrs + cannot
     * delete the domain Indicating server is doing major and lengthy
     * maintenance work on the domain, e.g. renaming the domain and moving
     * LDAP entries. Modification and deletion of the domain can only be done
     * internally by the server when it is safe to release the domain, they
     * cannot be done in admin console or zmprov. How zimbraDomainStatus
     * affects account behavior : -------------------------------------
     * zimbraDomainStatus account behavior
     * ------------------------------------- active zimbraAccountStatus
     * locked zimbraAccountStatus if it is maintenance or pending or closed,
     * else locked maintenance zimbraAccountStatus if it is pending or
     * closed, else maintenance suspended zimbraAccountStatus if it is
     * pending or closed, else maintenance shutdown zimbraAccountStatus if it
     * is pending or closed, else maintenance closed closed
     *
     * <p>Valid values: [active, maintenance, locked, closed, suspended, shutdown]
     *
     * @return zimbraDomainStatus, or null if unset and/or has invalid value
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=535)
    public ZAttrProvisioning.DomainStatus getDomainStatus() {
        try { String v = getAttr(Provisioning.A_zimbraDomainStatus, true, true); return v == null ? null : ZAttrProvisioning.DomainStatus.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * domain status. enum values are akin to those of zimbraAccountStatus
     * but the status affects all accounts on the domain. See table below for
     * how zimbraDomainStatus affects account status. active - see
     * zimbraAccountStatus maintenance - see zimbraAccountStatus locked - see
     * zimbraAccountStatus closed - see zimbraAccountStatus suspended -
     * maintenance + no creating/deleting/modifying accounts/DLs under the
     * domain. shutdown - suspended + cannot modify domain attrs + cannot
     * delete the domain Indicating server is doing major and lengthy
     * maintenance work on the domain, e.g. renaming the domain and moving
     * LDAP entries. Modification and deletion of the domain can only be done
     * internally by the server when it is safe to release the domain, they
     * cannot be done in admin console or zmprov. How zimbraDomainStatus
     * affects account behavior : -------------------------------------
     * zimbraDomainStatus account behavior
     * ------------------------------------- active zimbraAccountStatus
     * locked zimbraAccountStatus if it is maintenance or pending or closed,
     * else locked maintenance zimbraAccountStatus if it is pending or
     * closed, else maintenance suspended zimbraAccountStatus if it is
     * pending or closed, else maintenance shutdown zimbraAccountStatus if it
     * is pending or closed, else maintenance closed closed
     *
     * <p>Valid values: [active, maintenance, locked, closed, suspended, shutdown]
     *
     * @return zimbraDomainStatus, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=535)
    public String getDomainStatusAsString() {
        return getAttr(Provisioning.A_zimbraDomainStatus, null, true);
    }

    /**
     * domain status. enum values are akin to those of zimbraAccountStatus
     * but the status affects all accounts on the domain. See table below for
     * how zimbraDomainStatus affects account status. active - see
     * zimbraAccountStatus maintenance - see zimbraAccountStatus locked - see
     * zimbraAccountStatus closed - see zimbraAccountStatus suspended -
     * maintenance + no creating/deleting/modifying accounts/DLs under the
     * domain. shutdown - suspended + cannot modify domain attrs + cannot
     * delete the domain Indicating server is doing major and lengthy
     * maintenance work on the domain, e.g. renaming the domain and moving
     * LDAP entries. Modification and deletion of the domain can only be done
     * internally by the server when it is safe to release the domain, they
     * cannot be done in admin console or zmprov. How zimbraDomainStatus
     * affects account behavior : -------------------------------------
     * zimbraDomainStatus account behavior
     * ------------------------------------- active zimbraAccountStatus
     * locked zimbraAccountStatus if it is maintenance or pending or closed,
     * else locked maintenance zimbraAccountStatus if it is pending or
     * closed, else maintenance suspended zimbraAccountStatus if it is
     * pending or closed, else maintenance shutdown zimbraAccountStatus if it
     * is pending or closed, else maintenance closed closed
     *
     * <p>Valid values: [active, maintenance, locked, closed, suspended, shutdown]
     *
     * @param zimbraDomainStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=535)
    public void setDomainStatus(ZAttrProvisioning.DomainStatus zimbraDomainStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainStatus, zimbraDomainStatus.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * domain status. enum values are akin to those of zimbraAccountStatus
     * but the status affects all accounts on the domain. See table below for
     * how zimbraDomainStatus affects account status. active - see
     * zimbraAccountStatus maintenance - see zimbraAccountStatus locked - see
     * zimbraAccountStatus closed - see zimbraAccountStatus suspended -
     * maintenance + no creating/deleting/modifying accounts/DLs under the
     * domain. shutdown - suspended + cannot modify domain attrs + cannot
     * delete the domain Indicating server is doing major and lengthy
     * maintenance work on the domain, e.g. renaming the domain and moving
     * LDAP entries. Modification and deletion of the domain can only be done
     * internally by the server when it is safe to release the domain, they
     * cannot be done in admin console or zmprov. How zimbraDomainStatus
     * affects account behavior : -------------------------------------
     * zimbraDomainStatus account behavior
     * ------------------------------------- active zimbraAccountStatus
     * locked zimbraAccountStatus if it is maintenance or pending or closed,
     * else locked maintenance zimbraAccountStatus if it is pending or
     * closed, else maintenance suspended zimbraAccountStatus if it is
     * pending or closed, else maintenance shutdown zimbraAccountStatus if it
     * is pending or closed, else maintenance closed closed
     *
     * <p>Valid values: [active, maintenance, locked, closed, suspended, shutdown]
     *
     * @param zimbraDomainStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=535)
    public Map<String,Object> setDomainStatus(ZAttrProvisioning.DomainStatus zimbraDomainStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainStatus, zimbraDomainStatus.toString());
        return attrs;
    }

    /**
     * domain status. enum values are akin to those of zimbraAccountStatus
     * but the status affects all accounts on the domain. See table below for
     * how zimbraDomainStatus affects account status. active - see
     * zimbraAccountStatus maintenance - see zimbraAccountStatus locked - see
     * zimbraAccountStatus closed - see zimbraAccountStatus suspended -
     * maintenance + no creating/deleting/modifying accounts/DLs under the
     * domain. shutdown - suspended + cannot modify domain attrs + cannot
     * delete the domain Indicating server is doing major and lengthy
     * maintenance work on the domain, e.g. renaming the domain and moving
     * LDAP entries. Modification and deletion of the domain can only be done
     * internally by the server when it is safe to release the domain, they
     * cannot be done in admin console or zmprov. How zimbraDomainStatus
     * affects account behavior : -------------------------------------
     * zimbraDomainStatus account behavior
     * ------------------------------------- active zimbraAccountStatus
     * locked zimbraAccountStatus if it is maintenance or pending or closed,
     * else locked maintenance zimbraAccountStatus if it is pending or
     * closed, else maintenance suspended zimbraAccountStatus if it is
     * pending or closed, else maintenance shutdown zimbraAccountStatus if it
     * is pending or closed, else maintenance closed closed
     *
     * <p>Valid values: [active, maintenance, locked, closed, suspended, shutdown]
     *
     * @param zimbraDomainStatus new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=535)
    public void setDomainStatusAsString(String zimbraDomainStatus) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainStatus, zimbraDomainStatus);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * domain status. enum values are akin to those of zimbraAccountStatus
     * but the status affects all accounts on the domain. See table below for
     * how zimbraDomainStatus affects account status. active - see
     * zimbraAccountStatus maintenance - see zimbraAccountStatus locked - see
     * zimbraAccountStatus closed - see zimbraAccountStatus suspended -
     * maintenance + no creating/deleting/modifying accounts/DLs under the
     * domain. shutdown - suspended + cannot modify domain attrs + cannot
     * delete the domain Indicating server is doing major and lengthy
     * maintenance work on the domain, e.g. renaming the domain and moving
     * LDAP entries. Modification and deletion of the domain can only be done
     * internally by the server when it is safe to release the domain, they
     * cannot be done in admin console or zmprov. How zimbraDomainStatus
     * affects account behavior : -------------------------------------
     * zimbraDomainStatus account behavior
     * ------------------------------------- active zimbraAccountStatus
     * locked zimbraAccountStatus if it is maintenance or pending or closed,
     * else locked maintenance zimbraAccountStatus if it is pending or
     * closed, else maintenance suspended zimbraAccountStatus if it is
     * pending or closed, else maintenance shutdown zimbraAccountStatus if it
     * is pending or closed, else maintenance closed closed
     *
     * <p>Valid values: [active, maintenance, locked, closed, suspended, shutdown]
     *
     * @param zimbraDomainStatus new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=535)
    public Map<String,Object> setDomainStatusAsString(String zimbraDomainStatus, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainStatus, zimbraDomainStatus);
        return attrs;
    }

    /**
     * domain status. enum values are akin to those of zimbraAccountStatus
     * but the status affects all accounts on the domain. See table below for
     * how zimbraDomainStatus affects account status. active - see
     * zimbraAccountStatus maintenance - see zimbraAccountStatus locked - see
     * zimbraAccountStatus closed - see zimbraAccountStatus suspended -
     * maintenance + no creating/deleting/modifying accounts/DLs under the
     * domain. shutdown - suspended + cannot modify domain attrs + cannot
     * delete the domain Indicating server is doing major and lengthy
     * maintenance work on the domain, e.g. renaming the domain and moving
     * LDAP entries. Modification and deletion of the domain can only be done
     * internally by the server when it is safe to release the domain, they
     * cannot be done in admin console or zmprov. How zimbraDomainStatus
     * affects account behavior : -------------------------------------
     * zimbraDomainStatus account behavior
     * ------------------------------------- active zimbraAccountStatus
     * locked zimbraAccountStatus if it is maintenance or pending or closed,
     * else locked maintenance zimbraAccountStatus if it is pending or
     * closed, else maintenance suspended zimbraAccountStatus if it is
     * pending or closed, else maintenance shutdown zimbraAccountStatus if it
     * is pending or closed, else maintenance closed closed
     *
     * <p>Valid values: [active, maintenance, locked, closed, suspended, shutdown]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=535)
    public void unsetDomainStatus() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainStatus, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * domain status. enum values are akin to those of zimbraAccountStatus
     * but the status affects all accounts on the domain. See table below for
     * how zimbraDomainStatus affects account status. active - see
     * zimbraAccountStatus maintenance - see zimbraAccountStatus locked - see
     * zimbraAccountStatus closed - see zimbraAccountStatus suspended -
     * maintenance + no creating/deleting/modifying accounts/DLs under the
     * domain. shutdown - suspended + cannot modify domain attrs + cannot
     * delete the domain Indicating server is doing major and lengthy
     * maintenance work on the domain, e.g. renaming the domain and moving
     * LDAP entries. Modification and deletion of the domain can only be done
     * internally by the server when it is safe to release the domain, they
     * cannot be done in admin console or zmprov. How zimbraDomainStatus
     * affects account behavior : -------------------------------------
     * zimbraDomainStatus account behavior
     * ------------------------------------- active zimbraAccountStatus
     * locked zimbraAccountStatus if it is maintenance or pending or closed,
     * else locked maintenance zimbraAccountStatus if it is pending or
     * closed, else maintenance suspended zimbraAccountStatus if it is
     * pending or closed, else maintenance shutdown zimbraAccountStatus if it
     * is pending or closed, else maintenance closed closed
     *
     * <p>Valid values: [active, maintenance, locked, closed, suspended, shutdown]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=535)
    public Map<String,Object> unsetDomainStatus(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraDomainStatus, "");
        return attrs;
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @return zimbraEmptyFolderOpTimeout, or 3 if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public int getEmptyFolderOpTimeout() {
        return getIntAttr(Provisioning.A_zimbraEmptyFolderOpTimeout, 3, true);
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @param zimbraEmptyFolderOpTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public void setEmptyFolderOpTimeout(int zimbraEmptyFolderOpTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEmptyFolderOpTimeout, Integer.toString(zimbraEmptyFolderOpTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @param zimbraEmptyFolderOpTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public Map<String,Object> setEmptyFolderOpTimeout(int zimbraEmptyFolderOpTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEmptyFolderOpTimeout, Integer.toString(zimbraEmptyFolderOpTimeout));
        return attrs;
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public void unsetEmptyFolderOpTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEmptyFolderOpTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * EmptyFolderOpTimeout is the time in seconds for which empty folder
     * operation will wait for the current empty folder operation to complete
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1652)
    public Map<String,Object> unsetEmptyFolderOpTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEmptyFolderOpTimeout, "");
        return attrs;
    }

    /**
     * URL of ephemeral storage backend
     *
     * @return zimbraEphemeralBackendURL, or "ldap://default" if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2995)
    public String getEphemeralBackendURL() {
        return getAttr(Provisioning.A_zimbraEphemeralBackendURL, "ldap://default", true);
    }

    /**
     * URL of ephemeral storage backend
     *
     * @param zimbraEphemeralBackendURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2995)
    public void setEphemeralBackendURL(String zimbraEphemeralBackendURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEphemeralBackendURL, zimbraEphemeralBackendURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of ephemeral storage backend
     *
     * @param zimbraEphemeralBackendURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2995)
    public Map<String,Object> setEphemeralBackendURL(String zimbraEphemeralBackendURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEphemeralBackendURL, zimbraEphemeralBackendURL);
        return attrs;
    }

    /**
     * URL of ephemeral storage backend
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2995)
    public void unsetEphemeralBackendURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEphemeralBackendURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of ephemeral storage backend
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2995)
    public Map<String,Object> unsetEphemeralBackendURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraEphemeralBackendURL, "");
        return attrs;
    }

    /**
     * URL for posting error report popped up in WEB client
     *
     * @return zimbraErrorReportUrl, or null if unset
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1075)
    public String getErrorReportUrl() {
        return getAttr(Provisioning.A_zimbraErrorReportUrl, null, true);
    }

    /**
     * URL for posting error report popped up in WEB client
     *
     * @param zimbraErrorReportUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1075)
    public void setErrorReportUrl(String zimbraErrorReportUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraErrorReportUrl, zimbraErrorReportUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL for posting error report popped up in WEB client
     *
     * @param zimbraErrorReportUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1075)
    public Map<String,Object> setErrorReportUrl(String zimbraErrorReportUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraErrorReportUrl, zimbraErrorReportUrl);
        return attrs;
    }

    /**
     * URL for posting error report popped up in WEB client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1075)
    public void unsetErrorReportUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraErrorReportUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL for posting error report popped up in WEB client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1075)
    public Map<String,Object> unsetErrorReportUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraErrorReportUrl, "");
        return attrs;
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @return zimbraExportMaxDays, or 0 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public int getExportMaxDays() {
        return getIntAttr(Provisioning.A_zimbraExportMaxDays, 0, true);
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @param zimbraExportMaxDays new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public void setExportMaxDays(int zimbraExportMaxDays) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExportMaxDays, Integer.toString(zimbraExportMaxDays));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @param zimbraExportMaxDays new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public Map<String,Object> setExportMaxDays(int zimbraExportMaxDays, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExportMaxDays, Integer.toString(zimbraExportMaxDays));
        return attrs;
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public void unsetExportMaxDays() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExportMaxDays, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum period in days for export, including start and end date. No
     * limit if set to non-positive integer or unset.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2056)
    public Map<String,Object> unsetExportMaxDays(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExportMaxDays, "");
        return attrs;
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * <p>Use getExtensionBindPortAsString to access value as a string.
     *
     * @see #getExtensionBindPortAsString()
     *
     * @return zimbraExtensionBindPort, or 7072 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public int getExtensionBindPort() {
        return getIntAttr(Provisioning.A_zimbraExtensionBindPort, 7072, true);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @return zimbraExtensionBindPort, or "7072" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public String getExtensionBindPortAsString() {
        return getAttr(Provisioning.A_zimbraExtensionBindPort, "7072", true);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param zimbraExtensionBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public void setExtensionBindPort(int zimbraExtensionBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, Integer.toString(zimbraExtensionBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param zimbraExtensionBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public Map<String,Object> setExtensionBindPort(int zimbraExtensionBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, Integer.toString(zimbraExtensionBindPort));
        return attrs;
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param zimbraExtensionBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public void setExtensionBindPortAsString(String zimbraExtensionBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, zimbraExtensionBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param zimbraExtensionBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public Map<String,Object> setExtensionBindPortAsString(String zimbraExtensionBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, zimbraExtensionBindPort);
        return attrs;
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public void unsetExtensionBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTPs port on which zimbra extension server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1980)
    public Map<String,Object> unsetExtensionBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExtensionBindPort, "");
        return attrs;
    }

    /**
     * Auth token secret key used for encrypting data/auth token in share URL
     * when created for external users.
     *
     * @return zimbraExternalAccountProvisioningKey, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1648)
    public String getExternalAccountProvisioningKey() {
        return getAttr(Provisioning.A_zimbraExternalAccountProvisioningKey, null, true);
    }

    /**
     * Auth token secret key used for encrypting data/auth token in share URL
     * when created for external users.
     *
     * @param zimbraExternalAccountProvisioningKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1648)
    public void setExternalAccountProvisioningKey(String zimbraExternalAccountProvisioningKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountProvisioningKey, zimbraExternalAccountProvisioningKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Auth token secret key used for encrypting data/auth token in share URL
     * when created for external users.
     *
     * @param zimbraExternalAccountProvisioningKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1648)
    public Map<String,Object> setExternalAccountProvisioningKey(String zimbraExternalAccountProvisioningKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountProvisioningKey, zimbraExternalAccountProvisioningKey);
        return attrs;
    }

    /**
     * Auth token secret key used for encrypting data/auth token in share URL
     * when created for external users.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1648)
    public void unsetExternalAccountProvisioningKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountProvisioningKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Auth token secret key used for encrypting data/auth token in share URL
     * when created for external users.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1648)
    public Map<String,Object> unsetExternalAccountProvisioningKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountProvisioningKey, "");
        return attrs;
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getExternalAccountStatusCheckIntervalAsString to access value as a string.
     *
     * @see #getExternalAccountStatusCheckIntervalAsString()
     *
     * @return zimbraExternalAccountStatusCheckInterval in millseconds, or 86400000 (1d)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public long getExternalAccountStatusCheckInterval() {
        return getTimeInterval(Provisioning.A_zimbraExternalAccountStatusCheckInterval, 86400000L, true);
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraExternalAccountStatusCheckInterval, or "1d" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public String getExternalAccountStatusCheckIntervalAsString() {
        return getAttr(Provisioning.A_zimbraExternalAccountStatusCheckInterval, "1d", true);
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraExternalAccountStatusCheckInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public void setExternalAccountStatusCheckInterval(String zimbraExternalAccountStatusCheckInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountStatusCheckInterval, zimbraExternalAccountStatusCheckInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraExternalAccountStatusCheckInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public Map<String,Object> setExternalAccountStatusCheckInterval(String zimbraExternalAccountStatusCheckInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountStatusCheckInterval, zimbraExternalAccountStatusCheckInterval);
        return attrs;
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public void unsetExternalAccountStatusCheckInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountStatusCheckInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interval between successive executions of the task that: - disables an
     * external virtual account when all its accessible shares have been
     * revoked or expired. - deletes an external virtual account after
     * zimbraExternalAccountLifetimeAfterDisabled of being disabled. . Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1370)
    public Map<String,Object> unsetExternalAccountStatusCheckInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalAccountStatusCheckInterval, "");
        return attrs;
    }

    /**
     * Duration for which the URL sent in the share invitation email to an
     * external user is valid. A value of 0 indicates that the URL never
     * expires. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getExternalShareInvitationUrlExpirationAsString to access value as a string.
     *
     * @see #getExternalShareInvitationUrlExpirationAsString()
     *
     * @return zimbraExternalShareInvitationUrlExpiration in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1349)
    public long getExternalShareInvitationUrlExpiration() {
        return getTimeInterval(Provisioning.A_zimbraExternalShareInvitationUrlExpiration, 0L, true);
    }

    /**
     * Duration for which the URL sent in the share invitation email to an
     * external user is valid. A value of 0 indicates that the URL never
     * expires. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraExternalShareInvitationUrlExpiration, or "0" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1349)
    public String getExternalShareInvitationUrlExpirationAsString() {
        return getAttr(Provisioning.A_zimbraExternalShareInvitationUrlExpiration, "0", true);
    }

    /**
     * Duration for which the URL sent in the share invitation email to an
     * external user is valid. A value of 0 indicates that the URL never
     * expires. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraExternalShareInvitationUrlExpiration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1349)
    public void setExternalShareInvitationUrlExpiration(String zimbraExternalShareInvitationUrlExpiration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareInvitationUrlExpiration, zimbraExternalShareInvitationUrlExpiration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Duration for which the URL sent in the share invitation email to an
     * external user is valid. A value of 0 indicates that the URL never
     * expires. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraExternalShareInvitationUrlExpiration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1349)
    public Map<String,Object> setExternalShareInvitationUrlExpiration(String zimbraExternalShareInvitationUrlExpiration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareInvitationUrlExpiration, zimbraExternalShareInvitationUrlExpiration);
        return attrs;
    }

    /**
     * Duration for which the URL sent in the share invitation email to an
     * external user is valid. A value of 0 indicates that the URL never
     * expires. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1349)
    public void unsetExternalShareInvitationUrlExpiration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareInvitationUrlExpiration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Duration for which the URL sent in the share invitation email to an
     * external user is valid. A value of 0 indicates that the URL never
     * expires. . Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1349)
    public Map<String,Object> unsetExternalShareInvitationUrlExpiration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraExternalShareInvitationUrlExpiration, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.8.6. No longer used by ContactBackupRequest SOAP
     * handler. Orig desc: Sleep time between subsequent contact backups. 0
     * means that contact backup is disabled. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getFeatureContactBackupFrequencyAsString to access value as a string.
     *
     * @see #getFeatureContactBackupFrequencyAsString()
     *
     * @return zimbraFeatureContactBackupFrequency in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2124)
    public long getFeatureContactBackupFrequency() {
        return getTimeInterval(Provisioning.A_zimbraFeatureContactBackupFrequency, 0L, true);
    }

    /**
     * Deprecated since: 8.8.6. No longer used by ContactBackupRequest SOAP
     * handler. Orig desc: Sleep time between subsequent contact backups. 0
     * means that contact backup is disabled. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraFeatureContactBackupFrequency, or "0" if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2124)
    public String getFeatureContactBackupFrequencyAsString() {
        return getAttr(Provisioning.A_zimbraFeatureContactBackupFrequency, "0", true);
    }

    /**
     * Deprecated since: 8.8.6. No longer used by ContactBackupRequest SOAP
     * handler. Orig desc: Sleep time between subsequent contact backups. 0
     * means that contact backup is disabled. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraFeatureContactBackupFrequency new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2124)
    public void setFeatureContactBackupFrequency(String zimbraFeatureContactBackupFrequency) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupFrequency, zimbraFeatureContactBackupFrequency);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.8.6. No longer used by ContactBackupRequest SOAP
     * handler. Orig desc: Sleep time between subsequent contact backups. 0
     * means that contact backup is disabled. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraFeatureContactBackupFrequency new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2124)
    public Map<String,Object> setFeatureContactBackupFrequency(String zimbraFeatureContactBackupFrequency, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupFrequency, zimbraFeatureContactBackupFrequency);
        return attrs;
    }

    /**
     * Deprecated since: 8.8.6. No longer used by ContactBackupRequest SOAP
     * handler. Orig desc: Sleep time between subsequent contact backups. 0
     * means that contact backup is disabled. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2124)
    public void unsetFeatureContactBackupFrequency() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupFrequency, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.8.6. No longer used by ContactBackupRequest SOAP
     * handler. Orig desc: Sleep time between subsequent contact backups. 0
     * means that contact backup is disabled. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2124)
    public Map<String,Object> unsetFeatureContactBackupFrequency(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupFrequency, "");
        return attrs;
    }

    /**
     * Duration for which the backups should be preserved. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFeatureContactBackupLifeTimeAsString to access value as a string.
     *
     * @see #getFeatureContactBackupLifeTimeAsString()
     *
     * @return zimbraFeatureContactBackupLifeTime in millseconds, or 1296000000 (15d)  if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2125)
    public long getFeatureContactBackupLifeTime() {
        return getTimeInterval(Provisioning.A_zimbraFeatureContactBackupLifeTime, 1296000000L, true);
    }

    /**
     * Duration for which the backups should be preserved. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFeatureContactBackupLifeTime, or "15d" if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2125)
    public String getFeatureContactBackupLifeTimeAsString() {
        return getAttr(Provisioning.A_zimbraFeatureContactBackupLifeTime, "15d", true);
    }

    /**
     * Duration for which the backups should be preserved. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFeatureContactBackupLifeTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2125)
    public void setFeatureContactBackupLifeTime(String zimbraFeatureContactBackupLifeTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupLifeTime, zimbraFeatureContactBackupLifeTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Duration for which the backups should be preserved. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFeatureContactBackupLifeTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2125)
    public Map<String,Object> setFeatureContactBackupLifeTime(String zimbraFeatureContactBackupLifeTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupLifeTime, zimbraFeatureContactBackupLifeTime);
        return attrs;
    }

    /**
     * Duration for which the backups should be preserved. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2125)
    public void unsetFeatureContactBackupLifeTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupLifeTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Duration for which the backups should be preserved. . Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2125)
    public Map<String,Object> unsetFeatureContactBackupLifeTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureContactBackupLifeTime, "");
        return attrs;
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @return zimbraFeatureDistributionListFolderEnabled, or false if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public boolean isFeatureDistributionListFolderEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, false, true);
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @param zimbraFeatureDistributionListFolderEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public void setFeatureDistributionListFolderEnabled(boolean zimbraFeatureDistributionListFolderEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, zimbraFeatureDistributionListFolderEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @param zimbraFeatureDistributionListFolderEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public Map<String,Object> setFeatureDistributionListFolderEnabled(boolean zimbraFeatureDistributionListFolderEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, zimbraFeatureDistributionListFolderEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public void unsetFeatureDistributionListFolderEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to display the distribution list folder in address book
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1438)
    public Map<String,Object> unsetFeatureDistributionListFolderEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFeatureDistributionListFolderEnabled, "");
        return attrs;
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @return zimbraFileUploadMaxSize, or 10485760 if unset
     */
    @ZAttr(id=227)
    public long getFileUploadMaxSize() {
        return getLongAttr(Provisioning.A_zimbraFileUploadMaxSize, 10485760L, true);
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @param zimbraFileUploadMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=227)
    public void setFileUploadMaxSize(long zimbraFileUploadMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSize, Long.toString(zimbraFileUploadMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @param zimbraFileUploadMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=227)
    public Map<String,Object> setFileUploadMaxSize(long zimbraFileUploadMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSize, Long.toString(zimbraFileUploadMaxSize));
        return attrs;
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=227)
    public void unsetFileUploadMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for file uploads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=227)
    public Map<String,Object> unsetFileUploadMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSize, "");
        return attrs;
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @return zimbraFileUploadMaxSizePerFile, or 2147483648 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public long getFileUploadMaxSizePerFile() {
        return getLongAttr(Provisioning.A_zimbraFileUploadMaxSizePerFile, 2147483648L, true);
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @param zimbraFileUploadMaxSizePerFile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public void setFileUploadMaxSizePerFile(long zimbraFileUploadMaxSizePerFile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSizePerFile, Long.toString(zimbraFileUploadMaxSizePerFile));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @param zimbraFileUploadMaxSizePerFile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public Map<String,Object> setFileUploadMaxSizePerFile(long zimbraFileUploadMaxSizePerFile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSizePerFile, Long.toString(zimbraFileUploadMaxSizePerFile));
        return attrs;
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public void unsetFileUploadMaxSizePerFile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSizePerFile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for each attachment.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1350)
    public Map<String,Object> unsetFileUploadMaxSizePerFile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFileUploadMaxSizePerFile, "");
        return attrs;
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @return zimbraForceClearCookies, or false if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public boolean isForceClearCookies() {
        return getBooleanAttr(Provisioning.A_zimbraForceClearCookies, false, true);
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @param zimbraForceClearCookies new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public void setForceClearCookies(boolean zimbraForceClearCookies) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForceClearCookies, zimbraForceClearCookies ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @param zimbraForceClearCookies new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public Map<String,Object> setForceClearCookies(boolean zimbraForceClearCookies, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForceClearCookies, zimbraForceClearCookies ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public void unsetForceClearCookies() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForceClearCookies, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to force clear zimbra auth cookies when SOAP session ends
     * (i.e. force logout on browser tab close)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1437)
    public Map<String,Object> unsetForceClearCookies(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraForceClearCookies, "");
        return attrs;
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @return zimbraFreebusyExchangeAuthPassword, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public String getFreebusyExchangeAuthPassword() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeAuthPassword, null, true);
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeAuthPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public void setFreebusyExchangeAuthPassword(String zimbraFreebusyExchangeAuthPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthPassword, zimbraFreebusyExchangeAuthPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeAuthPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public Map<String,Object> setFreebusyExchangeAuthPassword(String zimbraFreebusyExchangeAuthPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthPassword, zimbraFreebusyExchangeAuthPassword);
        return attrs;
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public void unsetFreebusyExchangeAuthPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Exchange user password for free/busy lookup and propagation
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=609)
    public Map<String,Object> unsetFreebusyExchangeAuthPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthPassword, "");
        return attrs;
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @return zimbraFreebusyExchangeAuthScheme, or null if unset and/or has invalid value
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public ZAttrProvisioning.FreebusyExchangeAuthScheme getFreebusyExchangeAuthScheme() {
        try { String v = getAttr(Provisioning.A_zimbraFreebusyExchangeAuthScheme, true, true); return v == null ? null : ZAttrProvisioning.FreebusyExchangeAuthScheme.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @return zimbraFreebusyExchangeAuthScheme, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public String getFreebusyExchangeAuthSchemeAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeAuthScheme, null, true);
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param zimbraFreebusyExchangeAuthScheme new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public void setFreebusyExchangeAuthScheme(ZAttrProvisioning.FreebusyExchangeAuthScheme zimbraFreebusyExchangeAuthScheme) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, zimbraFreebusyExchangeAuthScheme.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param zimbraFreebusyExchangeAuthScheme new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public Map<String,Object> setFreebusyExchangeAuthScheme(ZAttrProvisioning.FreebusyExchangeAuthScheme zimbraFreebusyExchangeAuthScheme, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, zimbraFreebusyExchangeAuthScheme.toString());
        return attrs;
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param zimbraFreebusyExchangeAuthScheme new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public void setFreebusyExchangeAuthSchemeAsString(String zimbraFreebusyExchangeAuthScheme) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, zimbraFreebusyExchangeAuthScheme);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param zimbraFreebusyExchangeAuthScheme new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public Map<String,Object> setFreebusyExchangeAuthSchemeAsString(String zimbraFreebusyExchangeAuthScheme, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, zimbraFreebusyExchangeAuthScheme);
        return attrs;
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public void unsetFreebusyExchangeAuthScheme() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * auth scheme to use
     *
     * <p>Valid values: [basic, form]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=611)
    public Map<String,Object> unsetFreebusyExchangeAuthScheme(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthScheme, "");
        return attrs;
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @return zimbraFreebusyExchangeAuthUsername, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public String getFreebusyExchangeAuthUsername() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeAuthUsername, null, true);
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeAuthUsername new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public void setFreebusyExchangeAuthUsername(String zimbraFreebusyExchangeAuthUsername) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthUsername, zimbraFreebusyExchangeAuthUsername);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeAuthUsername new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public Map<String,Object> setFreebusyExchangeAuthUsername(String zimbraFreebusyExchangeAuthUsername, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthUsername, zimbraFreebusyExchangeAuthUsername);
        return attrs;
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public void unsetFreebusyExchangeAuthUsername() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthUsername, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Exchange username for free/busy lookup and propagation
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=608)
    public Map<String,Object> unsetFreebusyExchangeAuthUsername(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeAuthUsername, "");
        return attrs;
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFreebusyExchangeCachedIntervalAsString to access value as a string.
     *
     * @see #getFreebusyExchangeCachedIntervalAsString()
     *
     * @return zimbraFreebusyExchangeCachedInterval in millseconds, or 5184000000 (60d)  if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public long getFreebusyExchangeCachedInterval() {
        return getTimeInterval(Provisioning.A_zimbraFreebusyExchangeCachedInterval, 5184000000L, true);
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFreebusyExchangeCachedInterval, or "60d" if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public String getFreebusyExchangeCachedIntervalAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeCachedInterval, "60d", true);
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFreebusyExchangeCachedInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public void setFreebusyExchangeCachedInterval(String zimbraFreebusyExchangeCachedInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedInterval, zimbraFreebusyExchangeCachedInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFreebusyExchangeCachedInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public Map<String,Object> setFreebusyExchangeCachedInterval(String zimbraFreebusyExchangeCachedInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedInterval, zimbraFreebusyExchangeCachedInterval);
        return attrs;
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public void unsetFreebusyExchangeCachedInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The duration of f/b block pushed to Exchange server.. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=621)
    public Map<String,Object> unsetFreebusyExchangeCachedInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedInterval, "");
        return attrs;
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getFreebusyExchangeCachedIntervalStartAsString to access value as a string.
     *
     * @see #getFreebusyExchangeCachedIntervalStartAsString()
     *
     * @return zimbraFreebusyExchangeCachedIntervalStart in millseconds, or 604800000 (7d)  if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public long getFreebusyExchangeCachedIntervalStart() {
        return getTimeInterval(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, 604800000L, true);
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraFreebusyExchangeCachedIntervalStart, or "7d" if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public String getFreebusyExchangeCachedIntervalStartAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, "7d", true);
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFreebusyExchangeCachedIntervalStart new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public void setFreebusyExchangeCachedIntervalStart(String zimbraFreebusyExchangeCachedIntervalStart) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, zimbraFreebusyExchangeCachedIntervalStart);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraFreebusyExchangeCachedIntervalStart new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public Map<String,Object> setFreebusyExchangeCachedIntervalStart(String zimbraFreebusyExchangeCachedIntervalStart, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, zimbraFreebusyExchangeCachedIntervalStart);
        return attrs;
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public void unsetFreebusyExchangeCachedIntervalStart() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The value of duration is used to indicate the start date (in the past
     * relative to today) of the f/b interval pushed to Exchange server..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=620)
    public Map<String,Object> unsetFreebusyExchangeCachedIntervalStart(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeCachedIntervalStart, "");
        return attrs;
    }

    /**
     * Can be set to either webdav for Exchange 2007 or older, or ews for
     * 2010 and newer
     *
     * <p>Valid values: [webdav, ews]
     *
     * @return zimbraFreebusyExchangeServerType, or ZAttrProvisioning.FreebusyExchangeServerType.webdav if unset and/or has invalid value
     *
     * @since ZCS 6.0.11
     */
    @ZAttr(id=1174)
    public ZAttrProvisioning.FreebusyExchangeServerType getFreebusyExchangeServerType() {
        try { String v = getAttr(Provisioning.A_zimbraFreebusyExchangeServerType, true, true); return v == null ? ZAttrProvisioning.FreebusyExchangeServerType.webdav : ZAttrProvisioning.FreebusyExchangeServerType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.FreebusyExchangeServerType.webdav; }
    }

    /**
     * Can be set to either webdav for Exchange 2007 or older, or ews for
     * 2010 and newer
     *
     * <p>Valid values: [webdav, ews]
     *
     * @return zimbraFreebusyExchangeServerType, or "webdav" if unset
     *
     * @since ZCS 6.0.11
     */
    @ZAttr(id=1174)
    public String getFreebusyExchangeServerTypeAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeServerType, "webdav", true);
    }

    /**
     * Can be set to either webdav for Exchange 2007 or older, or ews for
     * 2010 and newer
     *
     * <p>Valid values: [webdav, ews]
     *
     * @param zimbraFreebusyExchangeServerType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.11
     */
    @ZAttr(id=1174)
    public void setFreebusyExchangeServerType(ZAttrProvisioning.FreebusyExchangeServerType zimbraFreebusyExchangeServerType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeServerType, zimbraFreebusyExchangeServerType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Can be set to either webdav for Exchange 2007 or older, or ews for
     * 2010 and newer
     *
     * <p>Valid values: [webdav, ews]
     *
     * @param zimbraFreebusyExchangeServerType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.11
     */
    @ZAttr(id=1174)
    public Map<String,Object> setFreebusyExchangeServerType(ZAttrProvisioning.FreebusyExchangeServerType zimbraFreebusyExchangeServerType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeServerType, zimbraFreebusyExchangeServerType.toString());
        return attrs;
    }

    /**
     * Can be set to either webdav for Exchange 2007 or older, or ews for
     * 2010 and newer
     *
     * <p>Valid values: [webdav, ews]
     *
     * @param zimbraFreebusyExchangeServerType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.11
     */
    @ZAttr(id=1174)
    public void setFreebusyExchangeServerTypeAsString(String zimbraFreebusyExchangeServerType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeServerType, zimbraFreebusyExchangeServerType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Can be set to either webdav for Exchange 2007 or older, or ews for
     * 2010 and newer
     *
     * <p>Valid values: [webdav, ews]
     *
     * @param zimbraFreebusyExchangeServerType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.11
     */
    @ZAttr(id=1174)
    public Map<String,Object> setFreebusyExchangeServerTypeAsString(String zimbraFreebusyExchangeServerType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeServerType, zimbraFreebusyExchangeServerType);
        return attrs;
    }

    /**
     * Can be set to either webdav for Exchange 2007 or older, or ews for
     * 2010 and newer
     *
     * <p>Valid values: [webdav, ews]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.11
     */
    @ZAttr(id=1174)
    public void unsetFreebusyExchangeServerType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeServerType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Can be set to either webdav for Exchange 2007 or older, or ews for
     * 2010 and newer
     *
     * <p>Valid values: [webdav, ews]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.11
     */
    @ZAttr(id=1174)
    public Map<String,Object> unsetFreebusyExchangeServerType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeServerType, "");
        return attrs;
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @return zimbraFreebusyExchangeURL, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public String getFreebusyExchangeURL() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeURL, null, true);
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public void setFreebusyExchangeURL(String zimbraFreebusyExchangeURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeURL, zimbraFreebusyExchangeURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @param zimbraFreebusyExchangeURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public Map<String,Object> setFreebusyExchangeURL(String zimbraFreebusyExchangeURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeURL, zimbraFreebusyExchangeURL);
        return attrs;
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public void unsetFreebusyExchangeURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL to Exchange server for free/busy lookup and propagation
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=607)
    public Map<String,Object> unsetFreebusyExchangeURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeURL, "");
        return attrs;
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @return zimbraFreebusyExchangeUserOrg, or null if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public String getFreebusyExchangeUserOrg() {
        return getAttr(Provisioning.A_zimbraFreebusyExchangeUserOrg, null, true);
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @param zimbraFreebusyExchangeUserOrg new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public void setFreebusyExchangeUserOrg(String zimbraFreebusyExchangeUserOrg) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeUserOrg, zimbraFreebusyExchangeUserOrg);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @param zimbraFreebusyExchangeUserOrg new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public Map<String,Object> setFreebusyExchangeUserOrg(String zimbraFreebusyExchangeUserOrg, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeUserOrg, zimbraFreebusyExchangeUserOrg);
        return attrs;
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public void unsetFreebusyExchangeUserOrg() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeUserOrg, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * O and OU used in legacyExchangeDN attribute
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=610)
    public Map<String,Object> unsetFreebusyExchangeUserOrg(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExchangeUserOrg, "");
        return attrs;
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @return zimbraFreebusyExternalZimbraURL, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public String[] getFreebusyExternalZimbraURL() {
        return getMultiAttr(Provisioning.A_zimbraFreebusyExternalZimbraURL, true, true);
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @param zimbraFreebusyExternalZimbraURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public void setFreebusyExternalZimbraURL(String[] zimbraFreebusyExternalZimbraURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExternalZimbraURL, zimbraFreebusyExternalZimbraURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @param zimbraFreebusyExternalZimbraURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public Map<String,Object> setFreebusyExternalZimbraURL(String[] zimbraFreebusyExternalZimbraURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExternalZimbraURL, zimbraFreebusyExternalZimbraURL);
        return attrs;
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @param zimbraFreebusyExternalZimbraURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public void addFreebusyExternalZimbraURL(String zimbraFreebusyExternalZimbraURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraFreebusyExternalZimbraURL, zimbraFreebusyExternalZimbraURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @param zimbraFreebusyExternalZimbraURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public Map<String,Object> addFreebusyExternalZimbraURL(String zimbraFreebusyExternalZimbraURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraFreebusyExternalZimbraURL, zimbraFreebusyExternalZimbraURL);
        return attrs;
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @param zimbraFreebusyExternalZimbraURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public void removeFreebusyExternalZimbraURL(String zimbraFreebusyExternalZimbraURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraFreebusyExternalZimbraURL, zimbraFreebusyExternalZimbraURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @param zimbraFreebusyExternalZimbraURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public Map<String,Object> removeFreebusyExternalZimbraURL(String zimbraFreebusyExternalZimbraURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraFreebusyExternalZimbraURL, zimbraFreebusyExternalZimbraURL);
        return attrs;
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public void unsetFreebusyExternalZimbraURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExternalZimbraURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URLs of external Zimbra servers for free/busy lookup in the form of
     * http[s]://[user:pass@]host:port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1253)
    public Map<String,Object> unsetFreebusyExternalZimbraURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyExternalZimbraURL, "");
        return attrs;
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getFreebusyPropagationRetryIntervalAsString to access value as a string.
     *
     * @see #getFreebusyPropagationRetryIntervalAsString()
     *
     * @return zimbraFreebusyPropagationRetryInterval in millseconds, or 60000 (1m)  if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public long getFreebusyPropagationRetryInterval() {
        return getTimeInterval(Provisioning.A_zimbraFreebusyPropagationRetryInterval, 60000L, true);
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraFreebusyPropagationRetryInterval, or "1m" if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public String getFreebusyPropagationRetryIntervalAsString() {
        return getAttr(Provisioning.A_zimbraFreebusyPropagationRetryInterval, "1m", true);
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraFreebusyPropagationRetryInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public void setFreebusyPropagationRetryInterval(String zimbraFreebusyPropagationRetryInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyPropagationRetryInterval, zimbraFreebusyPropagationRetryInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraFreebusyPropagationRetryInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public Map<String,Object> setFreebusyPropagationRetryInterval(String zimbraFreebusyPropagationRetryInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyPropagationRetryInterval, zimbraFreebusyPropagationRetryInterval);
        return attrs;
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public void unsetFreebusyPropagationRetryInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyPropagationRetryInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The interval to wait when the server encounters problems while
     * propagating Zimbra users free/busy information to external provider
     * such as Exchange. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1026)
    public Map<String,Object> unsetFreebusyPropagationRetryInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraFreebusyPropagationRetryInterval, "");
        return attrs;
    }

    /**
     * Google Server API key used by sever to push notifications to GCM
     *
     * @return zimbraGCMAuthorizationKey, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1955)
    public String getGCMAuthorizationKey() {
        return getAttr(Provisioning.A_zimbraGCMAuthorizationKey, null, true);
    }

    /**
     * Google Server API key used by sever to push notifications to GCM
     *
     * @param zimbraGCMAuthorizationKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1955)
    public void setGCMAuthorizationKey(String zimbraGCMAuthorizationKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMAuthorizationKey, zimbraGCMAuthorizationKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Google Server API key used by sever to push notifications to GCM
     *
     * @param zimbraGCMAuthorizationKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1955)
    public Map<String,Object> setGCMAuthorizationKey(String zimbraGCMAuthorizationKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMAuthorizationKey, zimbraGCMAuthorizationKey);
        return attrs;
    }

    /**
     * Google Server API key used by sever to push notifications to GCM
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1955)
    public void unsetGCMAuthorizationKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMAuthorizationKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Google Server API key used by sever to push notifications to GCM
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1955)
    public Map<String,Object> unsetGCMAuthorizationKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMAuthorizationKey, "");
        return attrs;
    }

    /**
     * Sender Id used by android client to register for GCM
     *
     * @return zimbraGCMSenderId, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1954)
    public String getGCMSenderId() {
        return getAttr(Provisioning.A_zimbraGCMSenderId, null, true);
    }

    /**
     * Sender Id used by android client to register for GCM
     *
     * @param zimbraGCMSenderId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1954)
    public void setGCMSenderId(String zimbraGCMSenderId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMSenderId, zimbraGCMSenderId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sender Id used by android client to register for GCM
     *
     * @param zimbraGCMSenderId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1954)
    public Map<String,Object> setGCMSenderId(String zimbraGCMSenderId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMSenderId, zimbraGCMSenderId);
        return attrs;
    }

    /**
     * Sender Id used by android client to register for GCM
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1954)
    public void unsetGCMSenderId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMSenderId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sender Id used by android client to register for GCM
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1954)
    public Map<String,Object> unsetGCMSenderId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMSenderId, "");
        return attrs;
    }

    /**
     * Google Cloud Messaging URL
     *
     * @return zimbraGCMUrl, or "https://android.googleapis.com/gcm/send" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1953)
    public String getGCMUrl() {
        return getAttr(Provisioning.A_zimbraGCMUrl, "https://android.googleapis.com/gcm/send", true);
    }

    /**
     * Google Cloud Messaging URL
     *
     * @param zimbraGCMUrl new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1953)
    public void setGCMUrl(String zimbraGCMUrl) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMUrl, zimbraGCMUrl);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Google Cloud Messaging URL
     *
     * @param zimbraGCMUrl new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1953)
    public Map<String,Object> setGCMUrl(String zimbraGCMUrl, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMUrl, zimbraGCMUrl);
        return attrs;
    }

    /**
     * Google Cloud Messaging URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1953)
    public void unsetGCMUrl() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMUrl, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Google Cloud Messaging URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1953)
    public Map<String,Object> unsetGCMUrl(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGCMUrl, "");
        return attrs;
    }

    /**
     * When set to TRUE, GAL search will always include local calendar
     * resources regardless of zimbraGalMode.
     *
     * @return zimbraGalAlwaysIncludeLocalCalendarResources, or false if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1093)
    public boolean isGalAlwaysIncludeLocalCalendarResources() {
        return getBooleanAttr(Provisioning.A_zimbraGalAlwaysIncludeLocalCalendarResources, false, true);
    }

    /**
     * When set to TRUE, GAL search will always include local calendar
     * resources regardless of zimbraGalMode.
     *
     * @param zimbraGalAlwaysIncludeLocalCalendarResources new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1093)
    public void setGalAlwaysIncludeLocalCalendarResources(boolean zimbraGalAlwaysIncludeLocalCalendarResources) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalAlwaysIncludeLocalCalendarResources, zimbraGalAlwaysIncludeLocalCalendarResources ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When set to TRUE, GAL search will always include local calendar
     * resources regardless of zimbraGalMode.
     *
     * @param zimbraGalAlwaysIncludeLocalCalendarResources new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1093)
    public Map<String,Object> setGalAlwaysIncludeLocalCalendarResources(boolean zimbraGalAlwaysIncludeLocalCalendarResources, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalAlwaysIncludeLocalCalendarResources, zimbraGalAlwaysIncludeLocalCalendarResources ? TRUE : FALSE);
        return attrs;
    }

    /**
     * When set to TRUE, GAL search will always include local calendar
     * resources regardless of zimbraGalMode.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1093)
    public void unsetGalAlwaysIncludeLocalCalendarResources() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalAlwaysIncludeLocalCalendarResources, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When set to TRUE, GAL search will always include local calendar
     * resources regardless of zimbraGalMode.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1093)
    public Map<String,Object> unsetGalAlwaysIncludeLocalCalendarResources(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalAlwaysIncludeLocalCalendarResources, "");
        return attrs;
    }

    /**
     * LDAP search filter for external GAL auto-complete queries
     *
     * @return zimbraGalAutoCompleteLdapFilter, or "externalLdapAutoComplete" if unset
     */
    @ZAttr(id=360)
    public String getGalAutoCompleteLdapFilter() {
        return getAttr(Provisioning.A_zimbraGalAutoCompleteLdapFilter, "externalLdapAutoComplete", true);
    }

    /**
     * LDAP search filter for external GAL auto-complete queries
     *
     * @param zimbraGalAutoCompleteLdapFilter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=360)
    public void setGalAutoCompleteLdapFilter(String zimbraGalAutoCompleteLdapFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalAutoCompleteLdapFilter, zimbraGalAutoCompleteLdapFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter for external GAL auto-complete queries
     *
     * @param zimbraGalAutoCompleteLdapFilter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=360)
    public Map<String,Object> setGalAutoCompleteLdapFilter(String zimbraGalAutoCompleteLdapFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalAutoCompleteLdapFilter, zimbraGalAutoCompleteLdapFilter);
        return attrs;
    }

    /**
     * LDAP search filter for external GAL auto-complete queries
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=360)
    public void unsetGalAutoCompleteLdapFilter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalAutoCompleteLdapFilter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter for external GAL auto-complete queries
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=360)
    public Map<String,Object> unsetGalAutoCompleteLdapFilter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalAutoCompleteLdapFilter, "");
        return attrs;
    }

    /**
     * whether to indicate if an email address on a message is a GAL group
     *
     * @return zimbraGalGroupIndicatorEnabled, or true if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1153)
    public boolean isGalGroupIndicatorEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraGalGroupIndicatorEnabled, true, true);
    }

    /**
     * whether to indicate if an email address on a message is a GAL group
     *
     * @param zimbraGalGroupIndicatorEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1153)
    public void setGalGroupIndicatorEnabled(boolean zimbraGalGroupIndicatorEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupIndicatorEnabled, zimbraGalGroupIndicatorEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to indicate if an email address on a message is a GAL group
     *
     * @param zimbraGalGroupIndicatorEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1153)
    public Map<String,Object> setGalGroupIndicatorEnabled(boolean zimbraGalGroupIndicatorEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupIndicatorEnabled, zimbraGalGroupIndicatorEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to indicate if an email address on a message is a GAL group
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1153)
    public void unsetGalGroupIndicatorEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupIndicatorEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to indicate if an email address on a message is a GAL group
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1153)
    public Map<String,Object> unsetGalGroupIndicatorEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalGroupIndicatorEnabled, "");
        return attrs;
    }

    /**
     * LDAP search base for internal GAL queries (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains)
     *
     * @return zimbraGalInternalSearchBase, or "DOMAIN" if unset
     */
    @ZAttr(id=358)
    public String getGalInternalSearchBase() {
        return getAttr(Provisioning.A_zimbraGalInternalSearchBase, "DOMAIN", true);
    }

    /**
     * LDAP search base for internal GAL queries (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains)
     *
     * @param zimbraGalInternalSearchBase new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=358)
    public void setGalInternalSearchBase(String zimbraGalInternalSearchBase) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalInternalSearchBase, zimbraGalInternalSearchBase);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search base for internal GAL queries (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains)
     *
     * @param zimbraGalInternalSearchBase new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=358)
    public Map<String,Object> setGalInternalSearchBase(String zimbraGalInternalSearchBase, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalInternalSearchBase, zimbraGalInternalSearchBase);
        return attrs;
    }

    /**
     * LDAP search base for internal GAL queries (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=358)
    public void unsetGalInternalSearchBase() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalInternalSearchBase, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search base for internal GAL queries (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=358)
    public Map<String,Object> unsetGalInternalSearchBase(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalInternalSearchBase, "");
        return attrs;
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @return zimbraGalLdapAttrMap, or empty array if unset
     */
    @ZAttr(id=153)
    public String[] getGalLdapAttrMap() {
        String[] value = getMultiAttr(Provisioning.A_zimbraGalLdapAttrMap, true, true); return value.length > 0 ? value : new String[] {"co=workCountry","company=company","zimbraPhoneticCompany,ms-DS-Phonetic-Company-Name=phoneticCompany","givenName,gn=firstName","zimbraPhoneticFirstName,ms-DS-Phonetic-First-Name=phoneticFirstName","sn=lastName","zimbraPhoneticLastName,ms-DS-Phonetic-Last-Name=phoneticLastName","displayName,cn=fullName,fullName2,fullName3,fullName4,fullName5,fullName6,fullName7,fullName8,fullName9,fullName10","initials=initials","description=notes","l=workCity","physicalDeliveryOfficeName=office","ou=department","street,streetAddress=workStreet","postalCode=workPostalCode","facsimileTelephoneNumber,fax=workFax","homeTelephoneNumber,homePhone=homePhone","mobileTelephoneNumber,mobile=mobilePhone","pagerTelephoneNumber,pager=pager","telephoneNumber=workPhone","st=workState","zimbraMailDeliveryAddress,zimbraMailAlias,mail=email,email2,email3,email4,email5,email6,email7,email8,email9,email10,email11,email12,email13,email14,email15,email16","title=jobTitle","whenChanged,modifyTimeStamp=modifyTimeStamp","whenCreated,createTimeStamp=createTimeStamp","zimbraId=zimbraId","objectClass=objectClass","zimbraMailForwardingAddress=member","zimbraCalResType,msExchResourceSearchProperties=zimbraCalResType","zimbraCalResLocationDisplayName=zimbraCalResLocationDisplayName","zimbraCalResBuilding=zimbraCalResBuilding","zimbraCalResCapacity,msExchResourceCapacity=zimbraCalResCapacity","zimbraCalResFloor=zimbraCalResFloor","zimbraCalResSite=zimbraCalResSite","zimbraCalResContactEmail=zimbraCalResContactEmail","zimbraDistributionListSubscriptionPolicy=zimbraDistributionListSubscriptionPolicy","zimbraDistributionListUnsubscriptionPolicy=zimbraDistributionListUnsubscriptionPolicy","msExchResourceSearchProperties=zimbraAccountCalendarUserType","(certificate) userCertificate=userCertificate","(binary) userSMIMECertificate=userSMIMECertificate","(binary) thumbnailPhoto=thumbnailPhoto"};
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @param zimbraGalLdapAttrMap new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=153)
    public void setGalLdapAttrMap(String[] zimbraGalLdapAttrMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapAttrMap, zimbraGalLdapAttrMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @param zimbraGalLdapAttrMap new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=153)
    public Map<String,Object> setGalLdapAttrMap(String[] zimbraGalLdapAttrMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapAttrMap, zimbraGalLdapAttrMap);
        return attrs;
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @param zimbraGalLdapAttrMap new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=153)
    public void addGalLdapAttrMap(String zimbraGalLdapAttrMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraGalLdapAttrMap, zimbraGalLdapAttrMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @param zimbraGalLdapAttrMap new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=153)
    public Map<String,Object> addGalLdapAttrMap(String zimbraGalLdapAttrMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraGalLdapAttrMap, zimbraGalLdapAttrMap);
        return attrs;
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @param zimbraGalLdapAttrMap existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=153)
    public void removeGalLdapAttrMap(String zimbraGalLdapAttrMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraGalLdapAttrMap, zimbraGalLdapAttrMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @param zimbraGalLdapAttrMap existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=153)
    public Map<String,Object> removeGalLdapAttrMap(String zimbraGalLdapAttrMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraGalLdapAttrMap, zimbraGalLdapAttrMap);
        return attrs;
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=153)
    public void unsetGalLdapAttrMap() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapAttrMap, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP Gal attribute to contact attr mapping
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=153)
    public Map<String,Object> unsetGalLdapAttrMap(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapAttrMap, "");
        return attrs;
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @return zimbraGalLdapFilterDef, or empty array if unset
     */
    @ZAttr(id=52)
    public String[] getGalLdapFilterDef() {
        String[] value = getMultiAttr(Provisioning.A_zimbraGalLdapFilterDef, true, true); return value.length > 0 ? value : new String[] {"zimbraAccounts:(&(|(displayName=*%s*)(cn=*%s*)(sn=*%s*)(gn=*%s*)(zimbraPhoneticFirstName=*%s*)(zimbraPhoneticLastName=*%s*)(mail=*%s*)(zimbraMailDeliveryAddress=*%s*)(zimbraMailAlias=*%s*))(|(objectclass=zimbraAccount)(objectclass=zimbraDistributionList)(objectclass=zimbraGroup))(!(objectclass=zimbraCalendarResource)))","zimbraAccountAutoComplete:(&(|(displayName=*%s*)(cn=%s*)(sn=%s*)(gn=%s*)(zimbraPhoneticFirstName=%s*)(zimbraPhoneticLastName=%s*)(mail=%s*)(zimbraMailDeliveryAddress=%s*)(zimbraMailAlias=%s*))(|(objectclass=zimbraAccount)(objectclass=zimbraDistributionList)(objectclass=zimbraGroup))(!(objectclass=zimbraCalendarResource)))","zimbraAccountSync:(&(|(objectclass=zimbraAccount)(objectclass=zimbraDistributionList)(objectclass=zimbraGroup))(!(objectclass=zimbraCalendarResource)))","zimbraResources:(&(|(displayName=*%s*)(cn=*%s*)(sn=*%s*)(gn=*%s*)(mail=*%s*)(zimbraMailDeliveryAddress=*%s*)(zimbraMailAlias=*%s*))(objectclass=zimbraCalendarResource)(zimbraAccountStatus=active))","zimbraResourceAutoComplete:(&(|(displayName=%s*)(cn=%s*)(sn=%s*)(gn=%s*)(mail=%s*)(zimbraMailDeliveryAddress=%s*)(zimbraMailAlias=%s*))(objectclass=zimbraCalendarResource)(zimbraAccountStatus=active))","zimbraResourceSync:(&(objectclass=zimbraCalendarResource)(zimbraAccountStatus=active))","zimbraGroups:(&(|(displayName=*%s*)(cn=*%s*)(sn=*%s*)(gn=*%s*)(mail=*%s*)(zimbraMailDeliveryAddress=*%s*)(zimbraMailAlias=*%s*))(|(objectclass=zimbraDistributionList)(objectclass=zimbraGroup)))","zimbraGroupAutoComplete:(&(|(displayName=%s*)(cn=%s*)(sn=%s*)(gn=%s*)(mail=%s*)(zimbraMailDeliveryAddress=%s*)(zimbraMailAlias=%s*))(|(objectclass=zimbraDistributionList)(objectclass=zimbraGroup)))","zimbraGroupSync:(|(objectclass=zimbraDistributionList)(objectclass=zimbraGroup))","zimbraAutoComplete:(&(|(displayName=%s*)(cn=%s*)(sn=%s*)(gn=%s*)(zimbraPhoneticFirstName=%s*)(zimbraPhoneticLastName=%s*)(mail=%s*)(zimbraMailDeliveryAddress=%s*)(zimbraMailAlias=%s*))(|(objectclass=zimbraAccount)(objectclass=zimbraDistributionList)(objectclass=zimbraGroup)))","zimbraSearch:(&(|(displayName=*%s*)(cn=*%s*)(sn=*%s*)(gn=*%s*)(zimbraPhoneticFirstName=*%s*)(zimbraPhoneticLastName=*%s*)(mail=*%s*)(zimbraMailDeliveryAddress=*%s*)(zimbraMailAlias=*%s*))(|(objectclass=zimbraAccount)(objectclass=zimbraDistributionList)(objectclass=zimbraGroup)))","zimbraSync:(&(|(objectclass=zimbraAccount)(objectclass=zimbraDistributionList)(objectclass=zimbraGroup)(objectclass=zimbraAddressList)(objectclass=zimbraHabGroup))(!(&(objectclass=zimbraCalendarResource)(!(|(zimbraAccountStatus=active)(zimbraIsAddressListActive=TRUE)(zimbraMailStatus=enabled))))))","ad:(&(|(displayName=*%s*)(cn=*%s*)(sn=*%s*)(givenName=*%s*)(mail=*%s*))(!(msExchHideFromAddressLists=TRUE))(|(&(objectCategory=person)(objectClass=user)(!(homeMDB=*))(!(msExchHomeServerName=*)))(&(objectCategory=person)(objectClass=user)(|(homeMDB=*)(msExchHomeServerName=*)))(&(objectCategory=person)(objectClass=contact))(objectCategory=group)(objectCategory=publicFolder)(objectCategory=msExchDynamicDistributionList)))","adAutoComplete:(&(|(displayName=%s*)(cn=%s*)(sn=%s*)(givenName=%s*)(mail=%s*))(!(msExchHideFromAddressLists=TRUE))(|(&(objectCategory=person)(objectClass=user)(!(homeMDB=*))(!(msExchHomeServerName=*)))(&(objectCategory=person)(objectClass=user)(|(homeMDB=*)(msExchHomeServerName=*)))(&(objectCategory=person)(objectClass=contact))(objectCategory=group)(objectCategory=publicFolder)(objectCategory=msExchDynamicDistributionList)))","externalLdapAutoComplete:(|(cn=%s*)(sn=%s*)(gn=%s*)(mail=%s*))","email_has:(mail=*%s*)","email2_has:(mail=*%s*)","email3_has:(mail=*%s*)","email4_has:(mail=*%s*)","email5_has:(mail=*%s*)","email6_has:(mail=*%s*)","email7_has:(mail=*%s*)","email8_has:(mail=*%s*)","email9_has:(mail=*%s*)","email10_has:(mail=*%s*)","email11_has:(mail=*%s*)","email12_has:(mail=*%s*)","email13_has:(mail=*%s*)","email14_has:(mail=*%s*)","email15_has:(mail=*%s*)","email16_has:(mail=*%s*)","department_has:(ou=*%s*)","firstName_has:(gn=*%s*)","lastName_has:(sn=*%s*)","middleName_has:(initials=*%s*)","nickname_has:(|(displayName=*%s*)(cn=*%s*))","phoneticFirstName_has:(zimbraPhoneticFirstName=*%s*)","phoneticLastName_has:(zimbraPhoneticLastName=*%s*)","notes_has:(description=*%s*)"};
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @param zimbraGalLdapFilterDef new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=52)
    public void setGalLdapFilterDef(String[] zimbraGalLdapFilterDef) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapFilterDef, zimbraGalLdapFilterDef);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @param zimbraGalLdapFilterDef new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=52)
    public Map<String,Object> setGalLdapFilterDef(String[] zimbraGalLdapFilterDef, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapFilterDef, zimbraGalLdapFilterDef);
        return attrs;
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @param zimbraGalLdapFilterDef new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=52)
    public void addGalLdapFilterDef(String zimbraGalLdapFilterDef) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraGalLdapFilterDef, zimbraGalLdapFilterDef);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @param zimbraGalLdapFilterDef new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=52)
    public Map<String,Object> addGalLdapFilterDef(String zimbraGalLdapFilterDef, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraGalLdapFilterDef, zimbraGalLdapFilterDef);
        return attrs;
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @param zimbraGalLdapFilterDef existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=52)
    public void removeGalLdapFilterDef(String zimbraGalLdapFilterDef) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraGalLdapFilterDef, zimbraGalLdapFilterDef);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @param zimbraGalLdapFilterDef existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=52)
    public Map<String,Object> removeGalLdapFilterDef(String zimbraGalLdapFilterDef, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraGalLdapFilterDef, zimbraGalLdapFilterDef);
        return attrs;
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=52)
    public void unsetGalLdapFilterDef() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapFilterDef, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter definitions for GAL queries
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=52)
    public Map<String,Object> unsetGalLdapFilterDef(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapFilterDef, "");
        return attrs;
    }

    /**
     * the handler class for mapping groups from GAL source to zimbra GAL
     * contacts for external GAL
     *
     * @return zimbraGalLdapGroupHandlerClass, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1112)
    public String getGalLdapGroupHandlerClass() {
        return getAttr(Provisioning.A_zimbraGalLdapGroupHandlerClass, null, true);
    }

    /**
     * the handler class for mapping groups from GAL source to zimbra GAL
     * contacts for external GAL
     *
     * @param zimbraGalLdapGroupHandlerClass new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1112)
    public void setGalLdapGroupHandlerClass(String zimbraGalLdapGroupHandlerClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapGroupHandlerClass, zimbraGalLdapGroupHandlerClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the handler class for mapping groups from GAL source to zimbra GAL
     * contacts for external GAL
     *
     * @param zimbraGalLdapGroupHandlerClass new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1112)
    public Map<String,Object> setGalLdapGroupHandlerClass(String zimbraGalLdapGroupHandlerClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapGroupHandlerClass, zimbraGalLdapGroupHandlerClass);
        return attrs;
    }

    /**
     * the handler class for mapping groups from GAL source to zimbra GAL
     * contacts for external GAL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1112)
    public void unsetGalLdapGroupHandlerClass() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapGroupHandlerClass, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the handler class for mapping groups from GAL source to zimbra GAL
     * contacts for external GAL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1112)
    public Map<String,Object> unsetGalLdapGroupHandlerClass(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapGroupHandlerClass, "");
        return attrs;
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled.
     *
     * @return zimbraGalLdapPageSize, or 1000 if unset
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=583)
    public int getGalLdapPageSize() {
        return getIntAttr(Provisioning.A_zimbraGalLdapPageSize, 1000, true);
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled.
     *
     * @param zimbraGalLdapPageSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=583)
    public void setGalLdapPageSize(int zimbraGalLdapPageSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapPageSize, Integer.toString(zimbraGalLdapPageSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled.
     *
     * @param zimbraGalLdapPageSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=583)
    public Map<String,Object> setGalLdapPageSize(int zimbraGalLdapPageSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapPageSize, Integer.toString(zimbraGalLdapPageSize));
        return attrs;
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=583)
    public void unsetGalLdapPageSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapPageSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=583)
    public Map<String,Object> unsetGalLdapPageSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapPageSize, "");
        return attrs;
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @return zimbraGalLdapValueMap, or empty array if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public String[] getGalLdapValueMap() {
        String[] value = getMultiAttr(Provisioning.A_zimbraGalLdapValueMap, true, true); return value.length > 0 ? value : new String[] {"zimbraCalResType: Room Location","zimbraAccountCalendarUserType: Room|Equipment RESOURCE"};
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @param zimbraGalLdapValueMap new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public void setGalLdapValueMap(String[] zimbraGalLdapValueMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapValueMap, zimbraGalLdapValueMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @param zimbraGalLdapValueMap new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public Map<String,Object> setGalLdapValueMap(String[] zimbraGalLdapValueMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapValueMap, zimbraGalLdapValueMap);
        return attrs;
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @param zimbraGalLdapValueMap new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public void addGalLdapValueMap(String zimbraGalLdapValueMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraGalLdapValueMap, zimbraGalLdapValueMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @param zimbraGalLdapValueMap new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public Map<String,Object> addGalLdapValueMap(String zimbraGalLdapValueMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraGalLdapValueMap, zimbraGalLdapValueMap);
        return attrs;
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @param zimbraGalLdapValueMap existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public void removeGalLdapValueMap(String zimbraGalLdapValueMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraGalLdapValueMap, zimbraGalLdapValueMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @param zimbraGalLdapValueMap existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public Map<String,Object> removeGalLdapValueMap(String zimbraGalLdapValueMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraGalLdapValueMap, zimbraGalLdapValueMap);
        return attrs;
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public void unsetGalLdapValueMap() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapValueMap, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP Gal attribute to contact value mapping. Each value is in the
     * format of {gal contact filed}: {regex} {replacement}
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1110)
    public Map<String,Object> unsetGalLdapValueMap(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalLdapValueMap, "");
        return attrs;
    }

    /**
     * maximum number of gal entries to return from a search
     *
     * @return zimbraGalMaxResults, or 100 if unset
     */
    @ZAttr(id=53)
    public int getGalMaxResults() {
        return getIntAttr(Provisioning.A_zimbraGalMaxResults, 100, true);
    }

    /**
     * maximum number of gal entries to return from a search
     *
     * @param zimbraGalMaxResults new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=53)
    public void setGalMaxResults(int zimbraGalMaxResults) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalMaxResults, Integer.toString(zimbraGalMaxResults));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of gal entries to return from a search
     *
     * @param zimbraGalMaxResults new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=53)
    public Map<String,Object> setGalMaxResults(int zimbraGalMaxResults, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalMaxResults, Integer.toString(zimbraGalMaxResults));
        return attrs;
    }

    /**
     * maximum number of gal entries to return from a search
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=53)
    public void unsetGalMaxResults() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalMaxResults, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum number of gal entries to return from a search
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=53)
    public Map<String,Object> unsetGalMaxResults(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalMaxResults, "");
        return attrs;
    }

    /**
     * LDAP search base for internal GAL sync (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains) If not set fallback
     * to zimbraGalInternalSearchBase
     *
     * @return zimbraGalSyncInternalSearchBase, or null if unset
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=598)
    public String getGalSyncInternalSearchBase() {
        return getAttr(Provisioning.A_zimbraGalSyncInternalSearchBase, null, true);
    }

    /**
     * LDAP search base for internal GAL sync (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains) If not set fallback
     * to zimbraGalInternalSearchBase
     *
     * @param zimbraGalSyncInternalSearchBase new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=598)
    public void setGalSyncInternalSearchBase(String zimbraGalSyncInternalSearchBase) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncInternalSearchBase, zimbraGalSyncInternalSearchBase);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search base for internal GAL sync (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains) If not set fallback
     * to zimbraGalInternalSearchBase
     *
     * @param zimbraGalSyncInternalSearchBase new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=598)
    public Map<String,Object> setGalSyncInternalSearchBase(String zimbraGalSyncInternalSearchBase, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncInternalSearchBase, zimbraGalSyncInternalSearchBase);
        return attrs;
    }

    /**
     * LDAP search base for internal GAL sync (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains) If not set fallback
     * to zimbraGalInternalSearchBase
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=598)
    public void unsetGalSyncInternalSearchBase() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncInternalSearchBase, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search base for internal GAL sync (special values:
     * &quot;ROOT&quot; for top, &quot;DOMAIN&quot; for domain only,
     * &quot;SUBDOMAINS&quot; for domain and subdomains) If not set fallback
     * to zimbraGalInternalSearchBase
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=598)
    public Map<String,Object> unsetGalSyncInternalSearchBase(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncInternalSearchBase, "");
        return attrs;
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL sync. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled. If not set fallback to
     * zimbraGalLdapPageSize
     *
     * @return zimbraGalSyncLdapPageSize, or 1000 if unset
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=597)
    public int getGalSyncLdapPageSize() {
        return getIntAttr(Provisioning.A_zimbraGalSyncLdapPageSize, 1000, true);
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL sync. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled. If not set fallback to
     * zimbraGalLdapPageSize
     *
     * @param zimbraGalSyncLdapPageSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=597)
    public void setGalSyncLdapPageSize(int zimbraGalSyncLdapPageSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncLdapPageSize, Integer.toString(zimbraGalSyncLdapPageSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL sync. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled. If not set fallback to
     * zimbraGalLdapPageSize
     *
     * @param zimbraGalSyncLdapPageSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=597)
    public Map<String,Object> setGalSyncLdapPageSize(int zimbraGalSyncLdapPageSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncLdapPageSize, Integer.toString(zimbraGalSyncLdapPageSize));
        return attrs;
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL sync. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled. If not set fallback to
     * zimbraGalLdapPageSize
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=597)
    public void unsetGalSyncLdapPageSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncLdapPageSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP page size for paged search control while accessing LDAP server
     * for GAL sync. This applies to both Zimbra and external LDAP servers. A
     * value of 0 means paging is not enabled. If not set fallback to
     * zimbraGalLdapPageSize
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=597)
    public Map<String,Object> unsetGalSyncLdapPageSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncLdapPageSize, "");
        return attrs;
    }

    /**
     * Maximum number of concurrent GAL sync requests allowed on the system /
     * domain.
     *
     * @return zimbraGalSyncMaxConcurrentClients, or 2 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1154)
    public int getGalSyncMaxConcurrentClients() {
        return getIntAttr(Provisioning.A_zimbraGalSyncMaxConcurrentClients, 2, true);
    }

    /**
     * Maximum number of concurrent GAL sync requests allowed on the system /
     * domain.
     *
     * @param zimbraGalSyncMaxConcurrentClients new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1154)
    public void setGalSyncMaxConcurrentClients(int zimbraGalSyncMaxConcurrentClients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncMaxConcurrentClients, Integer.toString(zimbraGalSyncMaxConcurrentClients));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent GAL sync requests allowed on the system /
     * domain.
     *
     * @param zimbraGalSyncMaxConcurrentClients new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1154)
    public Map<String,Object> setGalSyncMaxConcurrentClients(int zimbraGalSyncMaxConcurrentClients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncMaxConcurrentClients, Integer.toString(zimbraGalSyncMaxConcurrentClients));
        return attrs;
    }

    /**
     * Maximum number of concurrent GAL sync requests allowed on the system /
     * domain.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1154)
    public void unsetGalSyncMaxConcurrentClients() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncMaxConcurrentClients, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent GAL sync requests allowed on the system /
     * domain.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1154)
    public Map<String,Object> unsetGalSyncMaxConcurrentClients(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncMaxConcurrentClients, "");
        return attrs;
    }

    /**
     * Page size control for SyncGalRequest. By default not more than 30000
     * entries will be returned for every SyncGalRequest
     *
     * @return zimbraGalSyncSizeLimit, or 30000 if unset
     *
     * @since ZCS 8.7.2
     */
    @ZAttr(id=2097)
    public int getGalSyncSizeLimit() {
        return getIntAttr(Provisioning.A_zimbraGalSyncSizeLimit, 30000, true);
    }

    /**
     * Page size control for SyncGalRequest. By default not more than 30000
     * entries will be returned for every SyncGalRequest
     *
     * @param zimbraGalSyncSizeLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.2
     */
    @ZAttr(id=2097)
    public void setGalSyncSizeLimit(int zimbraGalSyncSizeLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncSizeLimit, Integer.toString(zimbraGalSyncSizeLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Page size control for SyncGalRequest. By default not more than 30000
     * entries will be returned for every SyncGalRequest
     *
     * @param zimbraGalSyncSizeLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.2
     */
    @ZAttr(id=2097)
    public Map<String,Object> setGalSyncSizeLimit(int zimbraGalSyncSizeLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncSizeLimit, Integer.toString(zimbraGalSyncSizeLimit));
        return attrs;
    }

    /**
     * Page size control for SyncGalRequest. By default not more than 30000
     * entries will be returned for every SyncGalRequest
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.2
     */
    @ZAttr(id=2097)
    public void unsetGalSyncSizeLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncSizeLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Page size control for SyncGalRequest. By default not more than 30000
     * entries will be returned for every SyncGalRequest
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.2
     */
    @ZAttr(id=2097)
    public Map<String,Object> unsetGalSyncSizeLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncSizeLimit, "");
        return attrs;
    }

    /**
     * LDAP generalized time format for external GAL sync
     *
     * @return zimbraGalSyncTimestampFormat, or "yyyyMMddHHmmss'Z'" if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1019)
    public String getGalSyncTimestampFormat() {
        return getAttr(Provisioning.A_zimbraGalSyncTimestampFormat, "yyyyMMddHHmmss'Z'", true);
    }

    /**
     * LDAP generalized time format for external GAL sync
     *
     * @param zimbraGalSyncTimestampFormat new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1019)
    public void setGalSyncTimestampFormat(String zimbraGalSyncTimestampFormat) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncTimestampFormat, zimbraGalSyncTimestampFormat);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP generalized time format for external GAL sync
     *
     * @param zimbraGalSyncTimestampFormat new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1019)
    public Map<String,Object> setGalSyncTimestampFormat(String zimbraGalSyncTimestampFormat, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncTimestampFormat, zimbraGalSyncTimestampFormat);
        return attrs;
    }

    /**
     * LDAP generalized time format for external GAL sync
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1019)
    public void unsetGalSyncTimestampFormat() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncTimestampFormat, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP generalized time format for external GAL sync
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1019)
    public Map<String,Object> unsetGalSyncTimestampFormat(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalSyncTimestampFormat, "");
        return attrs;
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * auto complete, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @return zimbraGalTokenizeAutoCompleteKey, or ZAttrProvisioning.GalTokenizeAutoCompleteKey.and if unset and/or has invalid value
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=599)
    public ZAttrProvisioning.GalTokenizeAutoCompleteKey getGalTokenizeAutoCompleteKey() {
        try { String v = getAttr(Provisioning.A_zimbraGalTokenizeAutoCompleteKey, true, true); return v == null ? ZAttrProvisioning.GalTokenizeAutoCompleteKey.and : ZAttrProvisioning.GalTokenizeAutoCompleteKey.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.GalTokenizeAutoCompleteKey.and; }
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * auto complete, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @return zimbraGalTokenizeAutoCompleteKey, or "and" if unset
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=599)
    public String getGalTokenizeAutoCompleteKeyAsString() {
        return getAttr(Provisioning.A_zimbraGalTokenizeAutoCompleteKey, "and", true);
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * auto complete, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param zimbraGalTokenizeAutoCompleteKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=599)
    public void setGalTokenizeAutoCompleteKey(ZAttrProvisioning.GalTokenizeAutoCompleteKey zimbraGalTokenizeAutoCompleteKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeAutoCompleteKey, zimbraGalTokenizeAutoCompleteKey.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * auto complete, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param zimbraGalTokenizeAutoCompleteKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=599)
    public Map<String,Object> setGalTokenizeAutoCompleteKey(ZAttrProvisioning.GalTokenizeAutoCompleteKey zimbraGalTokenizeAutoCompleteKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeAutoCompleteKey, zimbraGalTokenizeAutoCompleteKey.toString());
        return attrs;
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * auto complete, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param zimbraGalTokenizeAutoCompleteKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=599)
    public void setGalTokenizeAutoCompleteKeyAsString(String zimbraGalTokenizeAutoCompleteKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeAutoCompleteKey, zimbraGalTokenizeAutoCompleteKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * auto complete, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param zimbraGalTokenizeAutoCompleteKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=599)
    public Map<String,Object> setGalTokenizeAutoCompleteKeyAsString(String zimbraGalTokenizeAutoCompleteKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeAutoCompleteKey, zimbraGalTokenizeAutoCompleteKey);
        return attrs;
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * auto complete, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=599)
    public void unsetGalTokenizeAutoCompleteKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeAutoCompleteKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * auto complete, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=599)
    public Map<String,Object> unsetGalTokenizeAutoCompleteKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeAutoCompleteKey, "");
        return attrs;
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * search, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @return zimbraGalTokenizeSearchKey, or ZAttrProvisioning.GalTokenizeSearchKey.and if unset and/or has invalid value
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=600)
    public ZAttrProvisioning.GalTokenizeSearchKey getGalTokenizeSearchKey() {
        try { String v = getAttr(Provisioning.A_zimbraGalTokenizeSearchKey, true, true); return v == null ? ZAttrProvisioning.GalTokenizeSearchKey.and : ZAttrProvisioning.GalTokenizeSearchKey.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.GalTokenizeSearchKey.and; }
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * search, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @return zimbraGalTokenizeSearchKey, or "and" if unset
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=600)
    public String getGalTokenizeSearchKeyAsString() {
        return getAttr(Provisioning.A_zimbraGalTokenizeSearchKey, "and", true);
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * search, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param zimbraGalTokenizeSearchKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=600)
    public void setGalTokenizeSearchKey(ZAttrProvisioning.GalTokenizeSearchKey zimbraGalTokenizeSearchKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeSearchKey, zimbraGalTokenizeSearchKey.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * search, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param zimbraGalTokenizeSearchKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=600)
    public Map<String,Object> setGalTokenizeSearchKey(ZAttrProvisioning.GalTokenizeSearchKey zimbraGalTokenizeSearchKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeSearchKey, zimbraGalTokenizeSearchKey.toString());
        return attrs;
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * search, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param zimbraGalTokenizeSearchKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=600)
    public void setGalTokenizeSearchKeyAsString(String zimbraGalTokenizeSearchKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeSearchKey, zimbraGalTokenizeSearchKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * search, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param zimbraGalTokenizeSearchKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=600)
    public Map<String,Object> setGalTokenizeSearchKeyAsString(String zimbraGalTokenizeSearchKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeSearchKey, zimbraGalTokenizeSearchKey);
        return attrs;
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * search, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=600)
    public void unsetGalTokenizeSearchKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeSearchKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to tokenize key and AND or OR the tokenized queries for GAL
     * search, if not set, key is not tokenized
     *
     * <p>Valid values: [and, or]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.2
     */
    @ZAttr(id=600)
    public Map<String,Object> unsetGalTokenizeSearchKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGalTokenizeSearchKey, "");
        return attrs;
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @return zimbraGlobalConfigExtraObjectClass, or empty array if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public String[] getGlobalConfigExtraObjectClass() {
        return getMultiAttr(Provisioning.A_zimbraGlobalConfigExtraObjectClass, true, true);
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @param zimbraGlobalConfigExtraObjectClass new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public void setGlobalConfigExtraObjectClass(String[] zimbraGlobalConfigExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGlobalConfigExtraObjectClass, zimbraGlobalConfigExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @param zimbraGlobalConfigExtraObjectClass new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public Map<String,Object> setGlobalConfigExtraObjectClass(String[] zimbraGlobalConfigExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGlobalConfigExtraObjectClass, zimbraGlobalConfigExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @param zimbraGlobalConfigExtraObjectClass new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public void addGlobalConfigExtraObjectClass(String zimbraGlobalConfigExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraGlobalConfigExtraObjectClass, zimbraGlobalConfigExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @param zimbraGlobalConfigExtraObjectClass new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public Map<String,Object> addGlobalConfigExtraObjectClass(String zimbraGlobalConfigExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraGlobalConfigExtraObjectClass, zimbraGlobalConfigExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @param zimbraGlobalConfigExtraObjectClass existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public void removeGlobalConfigExtraObjectClass(String zimbraGlobalConfigExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraGlobalConfigExtraObjectClass, zimbraGlobalConfigExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @param zimbraGlobalConfigExtraObjectClass existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public Map<String,Object> removeGlobalConfigExtraObjectClass(String zimbraGlobalConfigExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraGlobalConfigExtraObjectClass, zimbraGlobalConfigExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public void unsetGlobalConfigExtraObjectClass() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGlobalConfigExtraObjectClass, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes added on the global config entry. Unlike other
     * zimbra***ExtraObjectClass attributes, object classes specified in this
     * attributes will not be automatically added to the global config entry.
     * Extra object class on the global config entry must be added using
     * &quot;zmprov mcf +objectClass {object class}&quot;, then recorded in
     * this attributes.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1254)
    public Map<String,Object> unsetGlobalConfigExtraObjectClass(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraGlobalConfigExtraObjectClass, "");
        return attrs;
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @return zimbraHABMemberLdapAttrMap, or empty array if unset
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public String[] getHABMemberLdapAttrMap() {
        String[] value = getMultiAttr(Provisioning.A_zimbraHABMemberLdapAttrMap, true, true); return value.length > 0 ? value : new String[] {"firstName=givenName","lastName=sn","displayName=displayName","commonName=cn","initials=initials","company=company","department=ou","jobTitle=title","workStreet=streetAddress","workPhone=telephoneNumber","workState=st","workCity=l","country=co","office=physicalDeliveryOfficeName","alias=zimbraMailAlias"};
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @param zimbraHABMemberLdapAttrMap new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public void setHABMemberLdapAttrMap(String[] zimbraHABMemberLdapAttrMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHABMemberLdapAttrMap, zimbraHABMemberLdapAttrMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @param zimbraHABMemberLdapAttrMap new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public Map<String,Object> setHABMemberLdapAttrMap(String[] zimbraHABMemberLdapAttrMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHABMemberLdapAttrMap, zimbraHABMemberLdapAttrMap);
        return attrs;
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @param zimbraHABMemberLdapAttrMap new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public void addHABMemberLdapAttrMap(String zimbraHABMemberLdapAttrMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHABMemberLdapAttrMap, zimbraHABMemberLdapAttrMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @param zimbraHABMemberLdapAttrMap new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public Map<String,Object> addHABMemberLdapAttrMap(String zimbraHABMemberLdapAttrMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHABMemberLdapAttrMap, zimbraHABMemberLdapAttrMap);
        return attrs;
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @param zimbraHABMemberLdapAttrMap existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public void removeHABMemberLdapAttrMap(String zimbraHABMemberLdapAttrMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHABMemberLdapAttrMap, zimbraHABMemberLdapAttrMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @param zimbraHABMemberLdapAttrMap existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public Map<String,Object> removeHABMemberLdapAttrMap(String zimbraHABMemberLdapAttrMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHABMemberLdapAttrMap, zimbraHABMemberLdapAttrMap);
        return attrs;
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public void unsetHABMemberLdapAttrMap() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHABMemberLdapAttrMap, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute to HAB Group Member attribute mapping
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.10
     */
    @ZAttr(id=3073)
    public Map<String,Object> unsetHABMemberLdapAttrMap(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHABMemberLdapAttrMap, "");
        return attrs;
    }

    /**
     * help URL for admin
     *
     * @return zimbraHelpAdminURL, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=674)
    public String getHelpAdminURL() {
        return getAttr(Provisioning.A_zimbraHelpAdminURL, null, true);
    }

    /**
     * help URL for admin
     *
     * @param zimbraHelpAdminURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=674)
    public void setHelpAdminURL(String zimbraHelpAdminURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpAdminURL, zimbraHelpAdminURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * help URL for admin
     *
     * @param zimbraHelpAdminURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=674)
    public Map<String,Object> setHelpAdminURL(String zimbraHelpAdminURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpAdminURL, zimbraHelpAdminURL);
        return attrs;
    }

    /**
     * help URL for admin
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=674)
    public void unsetHelpAdminURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpAdminURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * help URL for admin
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=674)
    public Map<String,Object> unsetHelpAdminURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpAdminURL, "");
        return attrs;
    }

    /**
     * help URL for advanced client
     *
     * @return zimbraHelpAdvancedURL, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=676)
    public String getHelpAdvancedURL() {
        return getAttr(Provisioning.A_zimbraHelpAdvancedURL, null, true);
    }

    /**
     * help URL for advanced client
     *
     * @param zimbraHelpAdvancedURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=676)
    public void setHelpAdvancedURL(String zimbraHelpAdvancedURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpAdvancedURL, zimbraHelpAdvancedURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * help URL for advanced client
     *
     * @param zimbraHelpAdvancedURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=676)
    public Map<String,Object> setHelpAdvancedURL(String zimbraHelpAdvancedURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpAdvancedURL, zimbraHelpAdvancedURL);
        return attrs;
    }

    /**
     * help URL for advanced client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=676)
    public void unsetHelpAdvancedURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpAdvancedURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * help URL for advanced client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=676)
    public Map<String,Object> unsetHelpAdvancedURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpAdvancedURL, "");
        return attrs;
    }

    /**
     * help URL for delegated admin
     *
     * @return zimbraHelpDelegatedURL, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=675)
    public String getHelpDelegatedURL() {
        return getAttr(Provisioning.A_zimbraHelpDelegatedURL, null, true);
    }

    /**
     * help URL for delegated admin
     *
     * @param zimbraHelpDelegatedURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=675)
    public void setHelpDelegatedURL(String zimbraHelpDelegatedURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpDelegatedURL, zimbraHelpDelegatedURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * help URL for delegated admin
     *
     * @param zimbraHelpDelegatedURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=675)
    public Map<String,Object> setHelpDelegatedURL(String zimbraHelpDelegatedURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpDelegatedURL, zimbraHelpDelegatedURL);
        return attrs;
    }

    /**
     * help URL for delegated admin
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=675)
    public void unsetHelpDelegatedURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpDelegatedURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * help URL for delegated admin
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=675)
    public Map<String,Object> unsetHelpDelegatedURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpDelegatedURL, "");
        return attrs;
    }

    /**
     * help URL for standard client
     *
     * @return zimbraHelpStandardURL, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=677)
    public String getHelpStandardURL() {
        return getAttr(Provisioning.A_zimbraHelpStandardURL, null, true);
    }

    /**
     * help URL for standard client
     *
     * @param zimbraHelpStandardURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=677)
    public void setHelpStandardURL(String zimbraHelpStandardURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpStandardURL, zimbraHelpStandardURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * help URL for standard client
     *
     * @param zimbraHelpStandardURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=677)
    public Map<String,Object> setHelpStandardURL(String zimbraHelpStandardURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpStandardURL, zimbraHelpStandardURL);
        return attrs;
    }

    /**
     * help URL for standard client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=677)
    public void unsetHelpStandardURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpStandardURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * help URL for standard client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=677)
    public Map<String,Object> unsetHelpStandardURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHelpStandardURL, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor for
     * zimbraHsmPolicy. Orig desc: Minimum age of mail items whose filesystem
     * data will be moved to secondary storage.. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getHsmAgeAsString to access value as a string.
     *
     * @see #getHsmAgeAsString()
     *
     * @return zimbraHsmAge in millseconds, or 2592000000 (30d)  if unset
     */
    @ZAttr(id=8)
    public long getHsmAge() {
        return getTimeInterval(Provisioning.A_zimbraHsmAge, 2592000000L, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor for
     * zimbraHsmPolicy. Orig desc: Minimum age of mail items whose filesystem
     * data will be moved to secondary storage.. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraHsmAge, or "30d" if unset
     */
    @ZAttr(id=8)
    public String getHsmAgeAsString() {
        return getAttr(Provisioning.A_zimbraHsmAge, "30d", true);
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor for
     * zimbraHsmPolicy. Orig desc: Minimum age of mail items whose filesystem
     * data will be moved to secondary storage.. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraHsmAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=8)
    public void setHsmAge(String zimbraHsmAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmAge, zimbraHsmAge);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor for
     * zimbraHsmPolicy. Orig desc: Minimum age of mail items whose filesystem
     * data will be moved to secondary storage.. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraHsmAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=8)
    public Map<String,Object> setHsmAge(String zimbraHsmAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmAge, zimbraHsmAge);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor for
     * zimbraHsmPolicy. Orig desc: Minimum age of mail items whose filesystem
     * data will be moved to secondary storage.. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=8)
    public void unsetHsmAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA2. deprecated in favor for
     * zimbraHsmPolicy. Orig desc: Minimum age of mail items whose filesystem
     * data will be moved to secondary storage.. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=8)
    public Map<String,Object> unsetHsmAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmAge, "");
        return attrs;
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @return zimbraHsmBatchSize, or 10000 if unset
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public int getHsmBatchSize() {
        return getIntAttr(Provisioning.A_zimbraHsmBatchSize, 10000, true);
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @param zimbraHsmBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public void setHsmBatchSize(int zimbraHsmBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmBatchSize, Integer.toString(zimbraHsmBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @param zimbraHsmBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public Map<String,Object> setHsmBatchSize(int zimbraHsmBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmBatchSize, Integer.toString(zimbraHsmBatchSize));
        return attrs;
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public void unsetHsmBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of items to move during a single HSM operation. If the
     * limit is exceeded, the HSM operation is repeated until all qualifying
     * items are moved.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.1
     */
    @ZAttr(id=1316)
    public Map<String,Object> unsetHsmBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmBatchSize, "");
        return attrs;
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @return zimbraHsmMovePreviousRevisions, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public boolean isHsmMovePreviousRevisions() {
        return getBooleanAttr(Provisioning.A_zimbraHsmMovePreviousRevisions, false, true);
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @param zimbraHsmMovePreviousRevisions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public void setHsmMovePreviousRevisions(boolean zimbraHsmMovePreviousRevisions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmMovePreviousRevisions, zimbraHsmMovePreviousRevisions ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @param zimbraHsmMovePreviousRevisions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public Map<String,Object> setHsmMovePreviousRevisions(boolean zimbraHsmMovePreviousRevisions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmMovePreviousRevisions, zimbraHsmMovePreviousRevisions ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public void unsetHsmMovePreviousRevisions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmMovePreviousRevisions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Keep only the tip revision in the main volume, and move all the old
     * revisions to the secondary volume. For document type mail items only,
     * works independently of zimbraHsmPolicy.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1393)
    public Map<String,Object> unsetHsmMovePreviousRevisions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmMovePreviousRevisions, "");
        return attrs;
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @return zimbraHsmPolicy, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public String[] getHsmPolicy() {
        String[] value = getMultiAttr(Provisioning.A_zimbraHsmPolicy, true, true); return value.length > 0 ? value : new String[] {"message,document:before:-30days"};
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public void setHsmPolicy(String[] zimbraHsmPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public Map<String,Object> setHsmPolicy(String[] zimbraHsmPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        return attrs;
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public void addHsmPolicy(String zimbraHsmPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public Map<String,Object> addHsmPolicy(String zimbraHsmPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        return attrs;
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public void removeHsmPolicy(String zimbraHsmPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param zimbraHsmPolicy existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public Map<String,Object> removeHsmPolicy(String zimbraHsmPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHsmPolicy, zimbraHsmPolicy);
        return attrs;
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public void unsetHsmPolicy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmPolicy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The policy that determines which mail items get moved to secondary
     * storage during HSM. Each value specifies a comma-separated list of
     * item types and the search query used to select items to move. See the
     * spec for &lt;SearchRequest&gt; for the complete list of item types and
     * query.txt for the search query spec.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1024)
    public Map<String,Object> unsetHsmPolicy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHsmPolicy, "");
        return attrs;
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @return zimbraHttpCompressionEnabled, or true if unset
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public boolean isHttpCompressionEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraHttpCompressionEnabled, true, true);
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @param zimbraHttpCompressionEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public void setHttpCompressionEnabled(boolean zimbraHttpCompressionEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpCompressionEnabled, zimbraHttpCompressionEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @param zimbraHttpCompressionEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public Map<String,Object> setHttpCompressionEnabled(boolean zimbraHttpCompressionEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpCompressionEnabled, zimbraHttpCompressionEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public void unsetHttpCompressionEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpCompressionEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable HTTP compression. Defaults to true.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1467)
    public Map<String,Object> unsetHttpCompressionEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpCompressionEnabled, "");
        return attrs;
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @return zimbraHttpConnectorMaxIdleTimeMillis, or 60000 if unset
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public int getHttpConnectorMaxIdleTimeMillis() {
        return getIntAttr(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, 60000, true);
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @param zimbraHttpConnectorMaxIdleTimeMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public void setHttpConnectorMaxIdleTimeMillis(int zimbraHttpConnectorMaxIdleTimeMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, Integer.toString(zimbraHttpConnectorMaxIdleTimeMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @param zimbraHttpConnectorMaxIdleTimeMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public Map<String,Object> setHttpConnectorMaxIdleTimeMillis(int zimbraHttpConnectorMaxIdleTimeMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, Integer.toString(zimbraHttpConnectorMaxIdleTimeMillis));
        return attrs;
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public void unsetHttpConnectorMaxIdleTimeMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Idle time in milli seconds for a connection. This is applied
     * when waiting for a new request to be received on a connection; when
     * reading the headers and content of a request; when writing the headers
     * and content of a response.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1428)
    public Map<String,Object> unsetHttpConnectorMaxIdleTimeMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpConnectorMaxIdleTimeMillis, "");
        return attrs;
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @return zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public String[] getHttpContextPathBasedThreadPoolBalancingFilterRules() {
        String[] value = getMultiAttr(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, true, true); return value.length > 0 ? value : new String[] {"/service:max=80%","/zimbra:max=15%","/zimbraAdmin:max=5%"};
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public void setHttpContextPathBasedThreadPoolBalancingFilterRules(String[] zimbraHttpContextPathBasedThreadPoolBalancingFilterRules) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public Map<String,Object> setHttpContextPathBasedThreadPoolBalancingFilterRules(String[] zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        return attrs;
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public void addHttpContextPathBasedThreadPoolBalancingFilterRules(String zimbraHttpContextPathBasedThreadPoolBalancingFilterRules) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public Map<String,Object> addHttpContextPathBasedThreadPoolBalancingFilterRules(String zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        return attrs;
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public void removeHttpContextPathBasedThreadPoolBalancingFilterRules(String zimbraHttpContextPathBasedThreadPoolBalancingFilterRules) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param zimbraHttpContextPathBasedThreadPoolBalancingFilterRules existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public Map<String,Object> removeHttpContextPathBasedThreadPoolBalancingFilterRules(String zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, zimbraHttpContextPathBasedThreadPoolBalancingFilterRules);
        return attrs;
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public void unsetHttpContextPathBasedThreadPoolBalancingFilterRules() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Rules for governing the allocation of threads to various web contexts
     * for the current thread pool. Sample value: /zimbra:min=10;max=40% or
     * /zimbraAdmin:min=5
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1593)
    public Map<String,Object> unsetHttpContextPathBasedThreadPoolBalancingFilterRules(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpContextPathBasedThreadPoolBalancingFilterRules, "");
        return attrs;
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @return zimbraHttpDebugHandlerEnabled, or true if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public boolean isHttpDebugHandlerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraHttpDebugHandlerEnabled, true, true);
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @param zimbraHttpDebugHandlerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public void setHttpDebugHandlerEnabled(boolean zimbraHttpDebugHandlerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDebugHandlerEnabled, zimbraHttpDebugHandlerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @param zimbraHttpDebugHandlerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public Map<String,Object> setHttpDebugHandlerEnabled(boolean zimbraHttpDebugHandlerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDebugHandlerEnabled, zimbraHttpDebugHandlerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public void unsetHttpDebugHandlerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDebugHandlerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable http debug handler on a server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1043)
    public Map<String,Object> unsetHttpDebugHandlerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDebugHandlerEnabled, "");
        return attrs;
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @return zimbraHttpDosFilterDelayMillis, or -1 if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public int getHttpDosFilterDelayMillis() {
        return getIntAttr(Provisioning.A_zimbraHttpDosFilterDelayMillis, -1, true);
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @param zimbraHttpDosFilterDelayMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public void setHttpDosFilterDelayMillis(int zimbraHttpDosFilterDelayMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterDelayMillis, Integer.toString(zimbraHttpDosFilterDelayMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @param zimbraHttpDosFilterDelayMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public Map<String,Object> setHttpDosFilterDelayMillis(int zimbraHttpDosFilterDelayMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterDelayMillis, Integer.toString(zimbraHttpDosFilterDelayMillis));
        return attrs;
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public void unsetHttpDosFilterDelayMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterDelayMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Delay imposed on all requests over the rate limit, before they are
     * considered at all. -1 = Reject request, 0 = No delay, any other value
     * = Delay in ms
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1430)
    public Map<String,Object> unsetHttpDosFilterDelayMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterDelayMillis, "");
        return attrs;
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @return zimbraHttpDosFilterMaxRequestsPerSec, or 30 if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public int getHttpDosFilterMaxRequestsPerSec() {
        return getIntAttr(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, 30, true);
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @param zimbraHttpDosFilterMaxRequestsPerSec new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public void setHttpDosFilterMaxRequestsPerSec(int zimbraHttpDosFilterMaxRequestsPerSec) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, Integer.toString(zimbraHttpDosFilterMaxRequestsPerSec));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @param zimbraHttpDosFilterMaxRequestsPerSec new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public Map<String,Object> setHttpDosFilterMaxRequestsPerSec(int zimbraHttpDosFilterMaxRequestsPerSec, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, Integer.toString(zimbraHttpDosFilterMaxRequestsPerSec));
        return attrs;
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public void unsetHttpDosFilterMaxRequestsPerSec() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of requests from a connection per second. Requests in
     * excess of this are throttled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1431)
    public Map<String,Object> unsetHttpDosFilterMaxRequestsPerSec(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpDosFilterMaxRequestsPerSec, "");
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @return zimbraHttpHeaderCacheSize, or 512 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public int getHttpHeaderCacheSize() {
        return getIntAttr(Provisioning.A_zimbraHttpHeaderCacheSize, 512, true);
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @param zimbraHttpHeaderCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public void setHttpHeaderCacheSize(int zimbraHttpHeaderCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpHeaderCacheSize, Integer.toString(zimbraHttpHeaderCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @param zimbraHttpHeaderCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public Map<String,Object> setHttpHeaderCacheSize(int zimbraHttpHeaderCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpHeaderCacheSize, Integer.toString(zimbraHttpHeaderCacheSize));
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public void unsetHttpHeaderCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpHeaderCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP header field cache in
     * Jetty
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1582)
    public Map<String,Object> unsetHttpHeaderCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpHeaderCacheSize, "");
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @return zimbraHttpMaxFormContentSize, or 200000 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public int getHttpMaxFormContentSize() {
        return getIntAttr(Provisioning.A_zimbraHttpMaxFormContentSize, 200000, true);
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @param zimbraHttpMaxFormContentSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public void setHttpMaxFormContentSize(int zimbraHttpMaxFormContentSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpMaxFormContentSize, Integer.toString(zimbraHttpMaxFormContentSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @param zimbraHttpMaxFormContentSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public Map<String,Object> setHttpMaxFormContentSize(int zimbraHttpMaxFormContentSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpMaxFormContentSize, Integer.toString(zimbraHttpMaxFormContentSize));
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public void unsetHttpMaxFormContentSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpMaxFormContentSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP form content in Jetty.
     * Can be set to 0 to block all web form submission
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1612)
    public Map<String,Object> unsetHttpMaxFormContentSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpMaxFormContentSize, "");
        return attrs;
    }

    /**
     * number of http handler threads
     *
     * @return zimbraHttpNumThreads, or 250 if unset
     */
    @ZAttr(id=518)
    public int getHttpNumThreads() {
        return getIntAttr(Provisioning.A_zimbraHttpNumThreads, 250, true);
    }

    /**
     * number of http handler threads
     *
     * @param zimbraHttpNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=518)
    public void setHttpNumThreads(int zimbraHttpNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpNumThreads, Integer.toString(zimbraHttpNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of http handler threads
     *
     * @param zimbraHttpNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=518)
    public Map<String,Object> setHttpNumThreads(int zimbraHttpNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpNumThreads, Integer.toString(zimbraHttpNumThreads));
        return attrs;
    }

    /**
     * number of http handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=518)
    public void unsetHttpNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of http handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=518)
    public Map<String,Object> unsetHttpNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpNumThreads, "");
        return attrs;
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @return zimbraHttpOutputBufferSize, or 32768 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public int getHttpOutputBufferSize() {
        return getIntAttr(Provisioning.A_zimbraHttpOutputBufferSize, 32768, true);
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @param zimbraHttpOutputBufferSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public void setHttpOutputBufferSize(int zimbraHttpOutputBufferSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpOutputBufferSize, Integer.toString(zimbraHttpOutputBufferSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @param zimbraHttpOutputBufferSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public Map<String,Object> setHttpOutputBufferSize(int zimbraHttpOutputBufferSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpOutputBufferSize, Integer.toString(zimbraHttpOutputBufferSize));
        return attrs;
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public void unsetHttpOutputBufferSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpOutputBufferSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The size in bytes of the output buffer used to aggregate HTTP output
     * in Jetty
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1579)
    public Map<String,Object> unsetHttpOutputBufferSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpOutputBufferSize, "");
        return attrs;
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @return zimbraHttpProxyURL, or empty array if unset
     */
    @ZAttr(id=388)
    public String[] getHttpProxyURL() {
        return getMultiAttr(Provisioning.A_zimbraHttpProxyURL, true, true);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=388)
    public void setHttpProxyURL(String[] zimbraHttpProxyURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=388)
    public Map<String,Object> setHttpProxyURL(String[] zimbraHttpProxyURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        return attrs;
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=388)
    public void addHttpProxyURL(String zimbraHttpProxyURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=388)
    public Map<String,Object> addHttpProxyURL(String zimbraHttpProxyURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        return attrs;
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=388)
    public void removeHttpProxyURL(String zimbraHttpProxyURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param zimbraHttpProxyURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=388)
    public Map<String,Object> removeHttpProxyURL(String zimbraHttpProxyURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpProxyURL, zimbraHttpProxyURL);
        return attrs;
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=388)
    public void unsetHttpProxyURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpProxyURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * external socks proxy URL to connect to when making outgoing
     * connections (eg.Zimlet proxy, RSS/ATOM feeds, etc)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=388)
    public Map<String,Object> unsetHttpProxyURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpProxyURL, "");
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP request header in Jetty
     *
     * @return zimbraHttpRequestHeaderSize, or 8192 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1580)
    public int getHttpRequestHeaderSize() {
        return getIntAttr(Provisioning.A_zimbraHttpRequestHeaderSize, 8192, true);
    }

    /**
     * The maximum allowed size in bytes for a HTTP request header in Jetty
     *
     * @param zimbraHttpRequestHeaderSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1580)
    public void setHttpRequestHeaderSize(int zimbraHttpRequestHeaderSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpRequestHeaderSize, Integer.toString(zimbraHttpRequestHeaderSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP request header in Jetty
     *
     * @param zimbraHttpRequestHeaderSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1580)
    public Map<String,Object> setHttpRequestHeaderSize(int zimbraHttpRequestHeaderSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpRequestHeaderSize, Integer.toString(zimbraHttpRequestHeaderSize));
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP request header in Jetty
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1580)
    public void unsetHttpRequestHeaderSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpRequestHeaderSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP request header in Jetty
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1580)
    public Map<String,Object> unsetHttpRequestHeaderSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpRequestHeaderSize, "");
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @return zimbraHttpResponseHeaderSize, or 8192 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public int getHttpResponseHeaderSize() {
        return getIntAttr(Provisioning.A_zimbraHttpResponseHeaderSize, 8192, true);
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @param zimbraHttpResponseHeaderSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public void setHttpResponseHeaderSize(int zimbraHttpResponseHeaderSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpResponseHeaderSize, Integer.toString(zimbraHttpResponseHeaderSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @param zimbraHttpResponseHeaderSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public Map<String,Object> setHttpResponseHeaderSize(int zimbraHttpResponseHeaderSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpResponseHeaderSize, Integer.toString(zimbraHttpResponseHeaderSize));
        return attrs;
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public void unsetHttpResponseHeaderSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpResponseHeaderSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum allowed size in bytes for a HTTP response header in Jetty
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1581)
    public Map<String,Object> unsetHttpResponseHeaderSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpResponseHeaderSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @return zimbraHttpSSLNumThreads, or 50 if unset
     */
    @ZAttr(id=519)
    public int getHttpSSLNumThreads() {
        return getIntAttr(Provisioning.A_zimbraHttpSSLNumThreads, 50, true);
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @param zimbraHttpSSLNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=519)
    public void setHttpSSLNumThreads(int zimbraHttpSSLNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpSSLNumThreads, Integer.toString(zimbraHttpSSLNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @param zimbraHttpSSLNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=519)
    public Map<String,Object> setHttpSSLNumThreads(int zimbraHttpSSLNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpSSLNumThreads, Integer.toString(zimbraHttpSSLNumThreads));
        return attrs;
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=519)
    public void unsetHttpSSLNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpSSLNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. not applicable for jetty. Orig desc: number of
     * https handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=519)
    public Map<String,Object> unsetHttpSSLNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpSSLNumThreads, "");
        return attrs;
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @return zimbraHttpThreadPoolMaxIdleTimeMillis, or 10000 if unset
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public int getHttpThreadPoolMaxIdleTimeMillis() {
        return getIntAttr(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, 10000, true);
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @param zimbraHttpThreadPoolMaxIdleTimeMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public void setHttpThreadPoolMaxIdleTimeMillis(int zimbraHttpThreadPoolMaxIdleTimeMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, Integer.toString(zimbraHttpThreadPoolMaxIdleTimeMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @param zimbraHttpThreadPoolMaxIdleTimeMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public Map<String,Object> setHttpThreadPoolMaxIdleTimeMillis(int zimbraHttpThreadPoolMaxIdleTimeMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, Integer.toString(zimbraHttpThreadPoolMaxIdleTimeMillis));
        return attrs;
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public void unsetHttpThreadPoolMaxIdleTimeMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum thread idle time in milli seconds. Threads that are idle
     * for longer than this period may be stopped.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.3
     */
    @ZAttr(id=1429)
    public Map<String,Object> unsetHttpThreadPoolMaxIdleTimeMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThreadPoolMaxIdleTimeMillis, "");
        return attrs;
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @return zimbraHttpThrottleSafeIPs, or empty array if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public String[] getHttpThrottleSafeIPs() {
        return getMultiAttr(Provisioning.A_zimbraHttpThrottleSafeIPs, true, true);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public void setHttpThrottleSafeIPs(String[] zimbraHttpThrottleSafeIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public Map<String,Object> setHttpThrottleSafeIPs(String[] zimbraHttpThrottleSafeIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        return attrs;
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public void addHttpThrottleSafeIPs(String zimbraHttpThrottleSafeIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public Map<String,Object> addHttpThrottleSafeIPs(String zimbraHttpThrottleSafeIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        return attrs;
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public void removeHttpThrottleSafeIPs(String zimbraHttpThrottleSafeIPs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param zimbraHttpThrottleSafeIPs existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public Map<String,Object> removeHttpThrottleSafeIPs(String zimbraHttpThrottleSafeIPs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraHttpThrottleSafeIPs, zimbraHttpThrottleSafeIPs);
        return attrs;
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public void unsetHttpThrottleSafeIPs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThrottleSafeIPs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IP addresses to ignore when applying Jetty DosFilter.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1427)
    public Map<String,Object> unsetHttpThrottleSafeIPs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraHttpThrottleSafeIPs, "");
        return attrs;
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @return zimbraIPMode, or ZAttrProvisioning.IPMode.ipv4 if unset and/or has invalid value
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public ZAttrProvisioning.IPMode getIPMode() {
        try { String v = getAttr(Provisioning.A_zimbraIPMode, true, true); return v == null ? ZAttrProvisioning.IPMode.ipv4 : ZAttrProvisioning.IPMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.IPMode.ipv4; }
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @return zimbraIPMode, or "ipv4" if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public String getIPModeAsString() {
        return getAttr(Provisioning.A_zimbraIPMode, "ipv4", true);
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param zimbraIPMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public void setIPMode(ZAttrProvisioning.IPMode zimbraIPMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, zimbraIPMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param zimbraIPMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public Map<String,Object> setIPMode(ZAttrProvisioning.IPMode zimbraIPMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, zimbraIPMode.toString());
        return attrs;
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param zimbraIPMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public void setIPModeAsString(String zimbraIPMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, zimbraIPMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param zimbraIPMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public Map<String,Object> setIPModeAsString(String zimbraIPMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, zimbraIPMode);
        return attrs;
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public void unsetIPMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * supported IP mode
     *
     * <p>Valid values: [ipv4, ipv6, both]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1171)
    public Map<String,Object> unsetIPMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraIPMode, "");
        return attrs;
    }

    /**
     * Ehcache: the maximum amount of disk space the imap active session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @return zimbraImapActiveSessionEhcacheMaxDiskSize, or 107374182400 if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3005)
    public long getImapActiveSessionEhcacheMaxDiskSize() {
        return getLongAttr(Provisioning.A_zimbraImapActiveSessionEhcacheMaxDiskSize, 107374182400L, true);
    }

    /**
     * Ehcache: the maximum amount of disk space the imap active session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @param zimbraImapActiveSessionEhcacheMaxDiskSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3005)
    public void setImapActiveSessionEhcacheMaxDiskSize(long zimbraImapActiveSessionEhcacheMaxDiskSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapActiveSessionEhcacheMaxDiskSize, Long.toString(zimbraImapActiveSessionEhcacheMaxDiskSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum amount of disk space the imap active session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @param zimbraImapActiveSessionEhcacheMaxDiskSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3005)
    public Map<String,Object> setImapActiveSessionEhcacheMaxDiskSize(long zimbraImapActiveSessionEhcacheMaxDiskSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapActiveSessionEhcacheMaxDiskSize, Long.toString(zimbraImapActiveSessionEhcacheMaxDiskSize));
        return attrs;
    }

    /**
     * Ehcache: the maximum amount of disk space the imap active session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3005)
    public void unsetImapActiveSessionEhcacheMaxDiskSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapActiveSessionEhcacheMaxDiskSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum amount of disk space the imap active session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3005)
    public Map<String,Object> unsetImapActiveSessionEhcacheMaxDiskSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapActiveSessionEhcacheMaxDiskSize, "");
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @return zimbraImapBindOnStartup, or true if unset
     */
    @ZAttr(id=268)
    public boolean isImapBindOnStartup() {
        return getBooleanAttr(Provisioning.A_zimbraImapBindOnStartup, true, true);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraImapBindOnStartup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=268)
    public void setImapBindOnStartup(boolean zimbraImapBindOnStartup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindOnStartup, zimbraImapBindOnStartup ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraImapBindOnStartup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=268)
    public Map<String,Object> setImapBindOnStartup(boolean zimbraImapBindOnStartup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindOnStartup, zimbraImapBindOnStartup ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=268)
    public void unsetImapBindOnStartup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindOnStartup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=268)
    public Map<String,Object> unsetImapBindOnStartup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindOnStartup, "");
        return attrs;
    }

    /**
     * port number on which IMAP server should listen
     *
     * <p>Use getImapBindPortAsString to access value as a string.
     *
     * @see #getImapBindPortAsString()
     *
     * @return zimbraImapBindPort, or 7143 if unset
     */
    @ZAttr(id=180)
    public int getImapBindPort() {
        return getIntAttr(Provisioning.A_zimbraImapBindPort, 7143, true);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @return zimbraImapBindPort, or "7143" if unset
     */
    @ZAttr(id=180)
    public String getImapBindPortAsString() {
        return getAttr(Provisioning.A_zimbraImapBindPort, "7143", true);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param zimbraImapBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=180)
    public void setImapBindPort(int zimbraImapBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, Integer.toString(zimbraImapBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param zimbraImapBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=180)
    public Map<String,Object> setImapBindPort(int zimbraImapBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, Integer.toString(zimbraImapBindPort));
        return attrs;
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param zimbraImapBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=180)
    public void setImapBindPortAsString(String zimbraImapBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, zimbraImapBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param zimbraImapBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=180)
    public Map<String,Object> setImapBindPortAsString(String zimbraImapBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, zimbraImapBindPort);
        return attrs;
    }

    /**
     * port number on which IMAP server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=180)
    public void unsetImapBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=180)
    public Map<String,Object> unsetImapBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapBindPort, "");
        return attrs;
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @return zimbraImapCleartextLoginEnabled, or false if unset
     */
    @ZAttr(id=185)
    public boolean isImapCleartextLoginEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraImapCleartextLoginEnabled, false, true);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param zimbraImapCleartextLoginEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=185)
    public void setImapCleartextLoginEnabled(boolean zimbraImapCleartextLoginEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapCleartextLoginEnabled, zimbraImapCleartextLoginEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param zimbraImapCleartextLoginEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=185)
    public Map<String,Object> setImapCleartextLoginEnabled(boolean zimbraImapCleartextLoginEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapCleartextLoginEnabled, zimbraImapCleartextLoginEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=185)
    public void unsetImapCleartextLoginEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapCleartextLoginEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=185)
    public Map<String,Object> unsetImapCleartextLoginEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapCleartextLoginEnabled, "");
        return attrs;
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @return zimbraImapDisabledCapability, or empty array if unset
     */
    @ZAttr(id=443)
    public String[] getImapDisabledCapability() {
        return getMultiAttr(Provisioning.A_zimbraImapDisabledCapability, true, true);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=443)
    public void setImapDisabledCapability(String[] zimbraImapDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=443)
    public Map<String,Object> setImapDisabledCapability(String[] zimbraImapDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=443)
    public void addImapDisabledCapability(String zimbraImapDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=443)
    public Map<String,Object> addImapDisabledCapability(String zimbraImapDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=443)
    public void removeImapDisabledCapability(String zimbraImapDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param zimbraImapDisabledCapability existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=443)
    public Map<String,Object> removeImapDisabledCapability(String zimbraImapDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapDisabledCapability, zimbraImapDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=443)
    public void unsetImapDisabledCapability() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisabledCapability, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP capabilities. Capabilities are listed on the CAPABILITY
     * line, also known in RFCs as extensions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=443)
    public Map<String,Object> unsetImapDisabledCapability(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisabledCapability, "");
        return attrs;
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @return zimbraImapDisplayMailFoldersOnly, or true if unset
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public boolean isImapDisplayMailFoldersOnly() {
        return getBooleanAttr(Provisioning.A_zimbraImapDisplayMailFoldersOnly, true, true);
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @param zimbraImapDisplayMailFoldersOnly new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public void setImapDisplayMailFoldersOnly(boolean zimbraImapDisplayMailFoldersOnly) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisplayMailFoldersOnly, zimbraImapDisplayMailFoldersOnly ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @param zimbraImapDisplayMailFoldersOnly new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public Map<String,Object> setImapDisplayMailFoldersOnly(boolean zimbraImapDisplayMailFoldersOnly, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisplayMailFoldersOnly, zimbraImapDisplayMailFoldersOnly ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public void unsetImapDisplayMailFoldersOnly() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisplayMailFoldersOnly, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to display IMAP Mail folders only
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0
     */
    @ZAttr(id=1909)
    public Map<String,Object> unsetImapDisplayMailFoldersOnly(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapDisplayMailFoldersOnly, "");
        return attrs;
    }

    /**
     * Whether to expose version on IMAP banner
     *
     * @return zimbraImapExposeVersionOnBanner, or false if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=693)
    public boolean isImapExposeVersionOnBanner() {
        return getBooleanAttr(Provisioning.A_zimbraImapExposeVersionOnBanner, false, true);
    }

    /**
     * Whether to expose version on IMAP banner
     *
     * @param zimbraImapExposeVersionOnBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=693)
    public void setImapExposeVersionOnBanner(boolean zimbraImapExposeVersionOnBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapExposeVersionOnBanner, zimbraImapExposeVersionOnBanner ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on IMAP banner
     *
     * @param zimbraImapExposeVersionOnBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=693)
    public Map<String,Object> setImapExposeVersionOnBanner(boolean zimbraImapExposeVersionOnBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapExposeVersionOnBanner, zimbraImapExposeVersionOnBanner ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to expose version on IMAP banner
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=693)
    public void unsetImapExposeVersionOnBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapExposeVersionOnBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on IMAP banner
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=693)
    public Map<String,Object> unsetImapExposeVersionOnBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapExposeVersionOnBanner, "");
        return attrs;
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @return zimbraImapInactiveSessionCacheMaxDiskSize, or 10737418240 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public long getImapInactiveSessionCacheMaxDiskSize() {
        return getLongAttr(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, 10737418240L, true);
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param zimbraImapInactiveSessionCacheMaxDiskSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public void setImapInactiveSessionCacheMaxDiskSize(long zimbraImapInactiveSessionCacheMaxDiskSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, Long.toString(zimbraImapInactiveSessionCacheMaxDiskSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param zimbraImapInactiveSessionCacheMaxDiskSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public Map<String,Object> setImapInactiveSessionCacheMaxDiskSize(long zimbraImapInactiveSessionCacheMaxDiskSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, Long.toString(zimbraImapInactiveSessionCacheMaxDiskSize));
        return attrs;
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public void unsetImapInactiveSessionCacheMaxDiskSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum disk size of inactive IMAP cache in Bytes before
     * eviction.By default this value is 10GB.This is a rough limit,Due to
     * internals of ehcache actual size on disk will often exceed this limit
     * by a modest margin.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2013)
    public Map<String,Object> unsetImapInactiveSessionCacheMaxDiskSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionCacheMaxDiskSize, "");
        return attrs;
    }

    /**
     * Ehcache: the maximum amount of disk space the imap inactive session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @return zimbraImapInactiveSessionEhcacheMaxDiskSize, or 107374182400 if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3006)
    public long getImapInactiveSessionEhcacheMaxDiskSize() {
        return getLongAttr(Provisioning.A_zimbraImapInactiveSessionEhcacheMaxDiskSize, 107374182400L, true);
    }

    /**
     * Ehcache: the maximum amount of disk space the imap inactive session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @param zimbraImapInactiveSessionEhcacheMaxDiskSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3006)
    public void setImapInactiveSessionEhcacheMaxDiskSize(long zimbraImapInactiveSessionEhcacheMaxDiskSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionEhcacheMaxDiskSize, Long.toString(zimbraImapInactiveSessionEhcacheMaxDiskSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum amount of disk space the imap inactive session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @param zimbraImapInactiveSessionEhcacheMaxDiskSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3006)
    public Map<String,Object> setImapInactiveSessionEhcacheMaxDiskSize(long zimbraImapInactiveSessionEhcacheMaxDiskSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionEhcacheMaxDiskSize, Long.toString(zimbraImapInactiveSessionEhcacheMaxDiskSize));
        return attrs;
    }

    /**
     * Ehcache: the maximum amount of disk space the imap inactive session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3006)
    public void unsetImapInactiveSessionEhcacheMaxDiskSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionEhcacheMaxDiskSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum amount of disk space the imap inactive session
     * cache will consume in Bytes before eviction. By default this value is
     * 100 gigabytes. This is a rough limit,Due to internals of ehcache
     * actual size in memory will often exceed this limit by a modest margin.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3006)
    public Map<String,Object> unsetImapInactiveSessionEhcacheMaxDiskSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionEhcacheMaxDiskSize, "");
        return attrs;
    }

    /**
     * Ehcache: the maximum heap size of the inactive session cache in Bytes
     * before eviction. By default this value is 1 megabyte. This is a rough
     * limit,Due to internals of ehcache actual size in memory will often
     * exceed this limit by a modest margin.
     *
     * @return zimbraImapInactiveSessionEhcacheSize, or 1048576 if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3004)
    public long getImapInactiveSessionEhcacheSize() {
        return getLongAttr(Provisioning.A_zimbraImapInactiveSessionEhcacheSize, 1048576L, true);
    }

    /**
     * Ehcache: the maximum heap size of the inactive session cache in Bytes
     * before eviction. By default this value is 1 megabyte. This is a rough
     * limit,Due to internals of ehcache actual size in memory will often
     * exceed this limit by a modest margin.
     *
     * @param zimbraImapInactiveSessionEhcacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3004)
    public void setImapInactiveSessionEhcacheSize(long zimbraImapInactiveSessionEhcacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionEhcacheSize, Long.toString(zimbraImapInactiveSessionEhcacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum heap size of the inactive session cache in Bytes
     * before eviction. By default this value is 1 megabyte. This is a rough
     * limit,Due to internals of ehcache actual size in memory will often
     * exceed this limit by a modest margin.
     *
     * @param zimbraImapInactiveSessionEhcacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3004)
    public Map<String,Object> setImapInactiveSessionEhcacheSize(long zimbraImapInactiveSessionEhcacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionEhcacheSize, Long.toString(zimbraImapInactiveSessionEhcacheSize));
        return attrs;
    }

    /**
     * Ehcache: the maximum heap size of the inactive session cache in Bytes
     * before eviction. By default this value is 1 megabyte. This is a rough
     * limit,Due to internals of ehcache actual size in memory will often
     * exceed this limit by a modest margin.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3004)
    public void unsetImapInactiveSessionEhcacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionEhcacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Ehcache: the maximum heap size of the inactive session cache in Bytes
     * before eviction. By default this value is 1 megabyte. This is a rough
     * limit,Due to internals of ehcache actual size in memory will often
     * exceed this limit by a modest margin.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3004)
    public Map<String,Object> unsetImapInactiveSessionEhcacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapInactiveSessionEhcacheSize, "");
        return attrs;
    }

    /**
     * Determines the load-balancing algorithm used to select an IMAP server
     * from the pool of available zimbraReverseProxyUpstreamImapServers.
     * Valid values are AccountIdHash, custom:{handler-algorithm} [arg1 arg2
     * ...]
     *
     * @return zimbraImapLoadBalancingAlgorithm, or "AccountIdHash" if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3009)
    public String getImapLoadBalancingAlgorithm() {
        return getAttr(Provisioning.A_zimbraImapLoadBalancingAlgorithm, "AccountIdHash", true);
    }

    /**
     * Determines the load-balancing algorithm used to select an IMAP server
     * from the pool of available zimbraReverseProxyUpstreamImapServers.
     * Valid values are AccountIdHash, custom:{handler-algorithm} [arg1 arg2
     * ...]
     *
     * @param zimbraImapLoadBalancingAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3009)
    public void setImapLoadBalancingAlgorithm(String zimbraImapLoadBalancingAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapLoadBalancingAlgorithm, zimbraImapLoadBalancingAlgorithm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Determines the load-balancing algorithm used to select an IMAP server
     * from the pool of available zimbraReverseProxyUpstreamImapServers.
     * Valid values are AccountIdHash, custom:{handler-algorithm} [arg1 arg2
     * ...]
     *
     * @param zimbraImapLoadBalancingAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3009)
    public Map<String,Object> setImapLoadBalancingAlgorithm(String zimbraImapLoadBalancingAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapLoadBalancingAlgorithm, zimbraImapLoadBalancingAlgorithm);
        return attrs;
    }

    /**
     * Determines the load-balancing algorithm used to select an IMAP server
     * from the pool of available zimbraReverseProxyUpstreamImapServers.
     * Valid values are AccountIdHash, custom:{handler-algorithm} [arg1 arg2
     * ...]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3009)
    public void unsetImapLoadBalancingAlgorithm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapLoadBalancingAlgorithm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Determines the load-balancing algorithm used to select an IMAP server
     * from the pool of available zimbraReverseProxyUpstreamImapServers.
     * Valid values are AccountIdHash, custom:{handler-algorithm} [arg1 arg2
     * ...]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3009)
    public Map<String,Object> unsetImapLoadBalancingAlgorithm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapLoadBalancingAlgorithm, "");
        return attrs;
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @return zimbraImapMaxConnections, or 200 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public int getImapMaxConnections() {
        return getIntAttr(Provisioning.A_zimbraImapMaxConnections, 200, true);
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param zimbraImapMaxConnections new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public void setImapMaxConnections(int zimbraImapMaxConnections) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConnections, Integer.toString(zimbraImapMaxConnections));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param zimbraImapMaxConnections new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public Map<String,Object> setImapMaxConnections(int zimbraImapMaxConnections, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConnections, Integer.toString(zimbraImapMaxConnections));
        return attrs;
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public void unsetImapMaxConnections() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConnections, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent IMAP connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1156)
    public Map<String,Object> unsetImapMaxConnections(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxConnections, "");
        return attrs;
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @return zimbraImapMaxRequestSize, or 10240 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public int getImapMaxRequestSize() {
        return getIntAttr(Provisioning.A_zimbraImapMaxRequestSize, 10240, true);
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @param zimbraImapMaxRequestSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public void setImapMaxRequestSize(int zimbraImapMaxRequestSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxRequestSize, Integer.toString(zimbraImapMaxRequestSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @param zimbraImapMaxRequestSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public Map<String,Object> setImapMaxRequestSize(int zimbraImapMaxRequestSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxRequestSize, Integer.toString(zimbraImapMaxRequestSize));
        return attrs;
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public void unsetImapMaxRequestSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxRequestSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * maximum size of IMAP request in bytes excluding literal data
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1085)
    public Map<String,Object> unsetImapMaxRequestSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapMaxRequestSize, "");
        return attrs;
    }

    /**
     * number of handler threads
     *
     * @return zimbraImapNumThreads, or 200 if unset
     */
    @ZAttr(id=181)
    public int getImapNumThreads() {
        return getIntAttr(Provisioning.A_zimbraImapNumThreads, 200, true);
    }

    /**
     * number of handler threads
     *
     * @param zimbraImapNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=181)
    public void setImapNumThreads(int zimbraImapNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNumThreads, Integer.toString(zimbraImapNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads
     *
     * @param zimbraImapNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=181)
    public Map<String,Object> setImapNumThreads(int zimbraImapNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNumThreads, Integer.toString(zimbraImapNumThreads));
        return attrs;
    }

    /**
     * number of handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=181)
    public void unsetImapNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=181)
    public Map<String,Object> unsetImapNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapNumThreads, "");
        return attrs;
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * <p>Use getImapProxyBindPortAsString to access value as a string.
     *
     * @see #getImapProxyBindPortAsString()
     *
     * @return zimbraImapProxyBindPort, or 143 if unset
     */
    @ZAttr(id=348)
    public int getImapProxyBindPort() {
        return getIntAttr(Provisioning.A_zimbraImapProxyBindPort, 143, true);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @return zimbraImapProxyBindPort, or "143" if unset
     */
    @ZAttr(id=348)
    public String getImapProxyBindPortAsString() {
        return getAttr(Provisioning.A_zimbraImapProxyBindPort, "143", true);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param zimbraImapProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=348)
    public void setImapProxyBindPort(int zimbraImapProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, Integer.toString(zimbraImapProxyBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param zimbraImapProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=348)
    public Map<String,Object> setImapProxyBindPort(int zimbraImapProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, Integer.toString(zimbraImapProxyBindPort));
        return attrs;
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param zimbraImapProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=348)
    public void setImapProxyBindPortAsString(String zimbraImapProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, zimbraImapProxyBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param zimbraImapProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=348)
    public Map<String,Object> setImapProxyBindPortAsString(String zimbraImapProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, zimbraImapProxyBindPort);
        return attrs;
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=348)
    public void unsetImapProxyBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP proxy server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=348)
    public Map<String,Object> unsetImapProxyBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapProxyBindPort, "");
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @return zimbraImapSSLBindOnStartup, or true if unset
     */
    @ZAttr(id=269)
    public boolean isImapSSLBindOnStartup() {
        return getBooleanAttr(Provisioning.A_zimbraImapSSLBindOnStartup, true, true);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraImapSSLBindOnStartup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=269)
    public void setImapSSLBindOnStartup(boolean zimbraImapSSLBindOnStartup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindOnStartup, zimbraImapSSLBindOnStartup ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraImapSSLBindOnStartup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=269)
    public Map<String,Object> setImapSSLBindOnStartup(boolean zimbraImapSSLBindOnStartup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindOnStartup, zimbraImapSSLBindOnStartup ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=269)
    public void unsetImapSSLBindOnStartup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindOnStartup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=269)
    public Map<String,Object> unsetImapSSLBindOnStartup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindOnStartup, "");
        return attrs;
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * <p>Use getImapSSLBindPortAsString to access value as a string.
     *
     * @see #getImapSSLBindPortAsString()
     *
     * @return zimbraImapSSLBindPort, or 7993 if unset
     */
    @ZAttr(id=183)
    public int getImapSSLBindPort() {
        return getIntAttr(Provisioning.A_zimbraImapSSLBindPort, 7993, true);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @return zimbraImapSSLBindPort, or "7993" if unset
     */
    @ZAttr(id=183)
    public String getImapSSLBindPortAsString() {
        return getAttr(Provisioning.A_zimbraImapSSLBindPort, "7993", true);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param zimbraImapSSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=183)
    public void setImapSSLBindPort(int zimbraImapSSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, Integer.toString(zimbraImapSSLBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param zimbraImapSSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=183)
    public Map<String,Object> setImapSSLBindPort(int zimbraImapSSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, Integer.toString(zimbraImapSSLBindPort));
        return attrs;
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param zimbraImapSSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=183)
    public void setImapSSLBindPortAsString(String zimbraImapSSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, zimbraImapSSLBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param zimbraImapSSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=183)
    public Map<String,Object> setImapSSLBindPortAsString(String zimbraImapSSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, zimbraImapSSLBindPort);
        return attrs;
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=183)
    public void unsetImapSSLBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAP SSL server should listen on
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=183)
    public Map<String,Object> unsetImapSSLBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLBindPort, "");
        return attrs;
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @return zimbraImapSSLDisabledCapability, or empty array if unset
     */
    @ZAttr(id=444)
    public String[] getImapSSLDisabledCapability() {
        return getMultiAttr(Provisioning.A_zimbraImapSSLDisabledCapability, true, true);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=444)
    public void setImapSSLDisabledCapability(String[] zimbraImapSSLDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=444)
    public Map<String,Object> setImapSSLDisabledCapability(String[] zimbraImapSSLDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=444)
    public void addImapSSLDisabledCapability(String zimbraImapSSLDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=444)
    public Map<String,Object> addImapSSLDisabledCapability(String zimbraImapSSLDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=444)
    public void removeImapSSLDisabledCapability(String zimbraImapSSLDisabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param zimbraImapSSLDisabledCapability existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=444)
    public Map<String,Object> removeImapSSLDisabledCapability(String zimbraImapSSLDisabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraImapSSLDisabledCapability, zimbraImapSSLDisabledCapability);
        return attrs;
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=444)
    public void unsetImapSSLDisabledCapability() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLDisabledCapability, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * disabled IMAP SSL capabilities. Capabilities are listed on the
     * CAPABILITY line, also known in RFCs as extensions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=444)
    public Map<String,Object> unsetImapSSLDisabledCapability(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLDisabledCapability, "");
        return attrs;
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * <p>Use getImapSSLProxyBindPortAsString to access value as a string.
     *
     * @see #getImapSSLProxyBindPortAsString()
     *
     * @return zimbraImapSSLProxyBindPort, or 993 if unset
     */
    @ZAttr(id=349)
    public int getImapSSLProxyBindPort() {
        return getIntAttr(Provisioning.A_zimbraImapSSLProxyBindPort, 993, true);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @return zimbraImapSSLProxyBindPort, or "993" if unset
     */
    @ZAttr(id=349)
    public String getImapSSLProxyBindPortAsString() {
        return getAttr(Provisioning.A_zimbraImapSSLProxyBindPort, "993", true);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param zimbraImapSSLProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=349)
    public void setImapSSLProxyBindPort(int zimbraImapSSLProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, Integer.toString(zimbraImapSSLProxyBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param zimbraImapSSLProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=349)
    public Map<String,Object> setImapSSLProxyBindPort(int zimbraImapSSLProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, Integer.toString(zimbraImapSSLProxyBindPort));
        return attrs;
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param zimbraImapSSLProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=349)
    public void setImapSSLProxyBindPortAsString(String zimbraImapSSLProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, zimbraImapSSLProxyBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param zimbraImapSSLProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=349)
    public Map<String,Object> setImapSSLProxyBindPortAsString(String zimbraImapSSLProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, zimbraImapSSLProxyBindPort);
        return attrs;
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=349)
    public void unsetImapSSLProxyBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which IMAPS proxy server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=349)
    public Map<String,Object> unsetImapSSLProxyBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLProxyBindPort, "");
        return attrs;
    }

    /**
     * whether IMAP SSL server is enabled for a given server
     *
     * @return zimbraImapSSLServerEnabled, or true if unset
     */
    @ZAttr(id=184)
    public boolean isImapSSLServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraImapSSLServerEnabled, true, true);
    }

    /**
     * whether IMAP SSL server is enabled for a given server
     *
     * @param zimbraImapSSLServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=184)
    public void setImapSSLServerEnabled(boolean zimbraImapSSLServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLServerEnabled, zimbraImapSSLServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SSL server is enabled for a given server
     *
     * @param zimbraImapSSLServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=184)
    public Map<String,Object> setImapSSLServerEnabled(boolean zimbraImapSSLServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLServerEnabled, zimbraImapSSLServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether IMAP SSL server is enabled for a given server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=184)
    public void unsetImapSSLServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SSL server is enabled for a given server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=184)
    public Map<String,Object> unsetImapSSLServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSSLServerEnabled, "");
        return attrs;
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for a given server
     *
     * @return zimbraImapSaslGssapiEnabled, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=555)
    public boolean isImapSaslGssapiEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraImapSaslGssapiEnabled, false, true);
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for a given server
     *
     * @param zimbraImapSaslGssapiEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=555)
    public void setImapSaslGssapiEnabled(boolean zimbraImapSaslGssapiEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSaslGssapiEnabled, zimbraImapSaslGssapiEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for a given server
     *
     * @param zimbraImapSaslGssapiEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=555)
    public Map<String,Object> setImapSaslGssapiEnabled(boolean zimbraImapSaslGssapiEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSaslGssapiEnabled, zimbraImapSaslGssapiEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for a given server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=555)
    public void unsetImapSaslGssapiEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSaslGssapiEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for a given server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=555)
    public Map<String,Object> unsetImapSaslGssapiEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapSaslGssapiEnabled, "");
        return attrs;
    }

    /**
     * whether IMAP is enabled for a server
     *
     * @return zimbraImapServerEnabled, or true if unset
     */
    @ZAttr(id=176)
    public boolean isImapServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraImapServerEnabled, true, true);
    }

    /**
     * whether IMAP is enabled for a server
     *
     * @param zimbraImapServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=176)
    public void setImapServerEnabled(boolean zimbraImapServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapServerEnabled, zimbraImapServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP is enabled for a server
     *
     * @param zimbraImapServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=176)
    public Map<String,Object> setImapServerEnabled(boolean zimbraImapServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapServerEnabled, zimbraImapServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether IMAP is enabled for a server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=176)
    public void unsetImapServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP is enabled for a server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=176)
    public Map<String,Object> unsetImapServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapServerEnabled, "");
        return attrs;
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @return zimbraImapShutdownGraceSeconds, or 10 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public int getImapShutdownGraceSeconds() {
        return getIntAttr(Provisioning.A_zimbraImapShutdownGraceSeconds, 10, true);
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @param zimbraImapShutdownGraceSeconds new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public void setImapShutdownGraceSeconds(int zimbraImapShutdownGraceSeconds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapShutdownGraceSeconds, Integer.toString(zimbraImapShutdownGraceSeconds));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @param zimbraImapShutdownGraceSeconds new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public Map<String,Object> setImapShutdownGraceSeconds(int zimbraImapShutdownGraceSeconds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapShutdownGraceSeconds, Integer.toString(zimbraImapShutdownGraceSeconds));
        return attrs;
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public void unsetImapShutdownGraceSeconds() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapShutdownGraceSeconds, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing IMAP server shutdown
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1080)
    public Map<String,Object> unsetImapShutdownGraceSeconds(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraImapShutdownGraceSeconds, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @return zimbraInstalledSkin, or empty array if unset
     */
    @ZAttr(id=368)
    public String[] getInstalledSkin() {
        return getMultiAttr(Provisioning.A_zimbraInstalledSkin, true, true);
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @param zimbraInstalledSkin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=368)
    public void setInstalledSkin(String[] zimbraInstalledSkin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInstalledSkin, zimbraInstalledSkin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @param zimbraInstalledSkin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=368)
    public Map<String,Object> setInstalledSkin(String[] zimbraInstalledSkin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInstalledSkin, zimbraInstalledSkin);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @param zimbraInstalledSkin new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=368)
    public void addInstalledSkin(String zimbraInstalledSkin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraInstalledSkin, zimbraInstalledSkin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @param zimbraInstalledSkin new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=368)
    public Map<String,Object> addInstalledSkin(String zimbraInstalledSkin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraInstalledSkin, zimbraInstalledSkin);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @param zimbraInstalledSkin existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=368)
    public void removeInstalledSkin(String zimbraInstalledSkin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraInstalledSkin, zimbraInstalledSkin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @param zimbraInstalledSkin existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=368)
    public Map<String,Object> removeInstalledSkin(String zimbraInstalledSkin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraInstalledSkin, zimbraInstalledSkin);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=368)
    public void unsetInstalledSkin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInstalledSkin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. Installed skin list is a per server property,
     * the list is now generated by directory scan of skin files. Orig desc:
     * Skins installed and available on all servers (this is global config
     * only)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=368)
    public Map<String,Object> unsetInstalledSkin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInstalledSkin, "");
        return attrs;
    }

    /**
     * whether sharing with accounts and groups of all other domains hosted
     * on this deployment be considered internal sharing
     *
     * @return zimbraInternalSharingCrossDomainEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1386)
    public boolean isInternalSharingCrossDomainEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraInternalSharingCrossDomainEnabled, true, true);
    }

    /**
     * whether sharing with accounts and groups of all other domains hosted
     * on this deployment be considered internal sharing
     *
     * @param zimbraInternalSharingCrossDomainEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1386)
    public void setInternalSharingCrossDomainEnabled(boolean zimbraInternalSharingCrossDomainEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInternalSharingCrossDomainEnabled, zimbraInternalSharingCrossDomainEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether sharing with accounts and groups of all other domains hosted
     * on this deployment be considered internal sharing
     *
     * @param zimbraInternalSharingCrossDomainEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1386)
    public Map<String,Object> setInternalSharingCrossDomainEnabled(boolean zimbraInternalSharingCrossDomainEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInternalSharingCrossDomainEnabled, zimbraInternalSharingCrossDomainEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether sharing with accounts and groups of all other domains hosted
     * on this deployment be considered internal sharing
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1386)
    public void unsetInternalSharingCrossDomainEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInternalSharingCrossDomainEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether sharing with accounts and groups of all other domains hosted
     * on this deployment be considered internal sharing
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1386)
    public Map<String,Object> unsetInternalSharingCrossDomainEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInternalSharingCrossDomainEnabled, "");
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @return zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, or 15 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public int getInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating() {
        return getIntAttr(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, 15, true);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @param zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public void setInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating(int zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, Integer.toString(zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @param zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public Map<String,Object> setInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating(int zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, Integer.toString(zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating));
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public void unsetInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the minimum time between current req and last req from the
     * same IP before this suspended IP will be reinstated
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1614)
    public Map<String,Object> unsetInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterDelayInMinBetwnReqBeforeReinstating, "");
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @return zimbraInvalidLoginFilterMaxFailedLogin, or 10 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public int getInvalidLoginFilterMaxFailedLogin() {
        return getIntAttr(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, 10, true);
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @param zimbraInvalidLoginFilterMaxFailedLogin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public void setInvalidLoginFilterMaxFailedLogin(int zimbraInvalidLoginFilterMaxFailedLogin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, Integer.toString(zimbraInvalidLoginFilterMaxFailedLogin));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @param zimbraInvalidLoginFilterMaxFailedLogin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public Map<String,Object> setInvalidLoginFilterMaxFailedLogin(int zimbraInvalidLoginFilterMaxFailedLogin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, Integer.toString(zimbraInvalidLoginFilterMaxFailedLogin));
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public void unsetInvalidLoginFilterMaxFailedLogin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests.This is a
     * DOSFilter style check for repeated failed logins from IP, if set to 0
     * no check happens, else failed login is recorded.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1613)
    public Map<String,Object> unsetInvalidLoginFilterMaxFailedLogin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxFailedLogin, "");
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @return zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, or 7000 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public int getInvalidLoginFilterMaxSizeOfFailedIpDb() {
        return getIntAttr(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, 7000, true);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @param zimbraInvalidLoginFilterMaxSizeOfFailedIpDb new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public void setInvalidLoginFilterMaxSizeOfFailedIpDb(int zimbraInvalidLoginFilterMaxSizeOfFailedIpDb) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, Integer.toString(zimbraInvalidLoginFilterMaxSizeOfFailedIpDb));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @param zimbraInvalidLoginFilterMaxSizeOfFailedIpDb new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public Map<String,Object> setInvalidLoginFilterMaxSizeOfFailedIpDb(int zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, Integer.toString(zimbraInvalidLoginFilterMaxSizeOfFailedIpDb));
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public void unsetInvalidLoginFilterMaxSizeOfFailedIpDb() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. It
     * indicates the max size of data structures that holds the list of
     * failed logins
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1618)
    public Map<String,Object> unsetInvalidLoginFilterMaxSizeOfFailedIpDb(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterMaxSizeOfFailedIpDb, "");
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @return zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, or 5 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public int getInvalidLoginFilterReinstateIpTaskIntervalInMin() {
        return getIntAttr(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, 5, true);
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @param zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public void setInvalidLoginFilterReinstateIpTaskIntervalInMin(int zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, Integer.toString(zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @param zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public Map<String,Object> setInvalidLoginFilterReinstateIpTaskIntervalInMin(int zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, Integer.toString(zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin));
        return attrs;
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public void unsetInvalidLoginFilterReinstateIpTaskIntervalInMin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used for failed authentication requests. Interval at
     * which Task to reinstate IPs suspended as part of ZimbraInvalidLoging
     * filter are run.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1615)
    public Map<String,Object> unsetInvalidLoginFilterReinstateIpTaskIntervalInMin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraInvalidLoginFilterReinstateIpTaskIntervalInMin, "");
        return attrs;
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @return zimbraItemActionBatchSize, or 1000 if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public int getItemActionBatchSize() {
        return getIntAttr(Provisioning.A_zimbraItemActionBatchSize, 1000, true);
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @param zimbraItemActionBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public void setItemActionBatchSize(int zimbraItemActionBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraItemActionBatchSize, Integer.toString(zimbraItemActionBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @param zimbraItemActionBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public Map<String,Object> setItemActionBatchSize(int zimbraItemActionBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraItemActionBatchSize, Integer.toString(zimbraItemActionBatchSize));
        return attrs;
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public void unsetItemActionBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraItemActionBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of item to perform an ItemAction on at a time.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1451)
    public Map<String,Object> unsetItemActionBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraItemActionBatchSize, "");
        return attrs;
    }

    /**
     * LDAP schema version for the system.
     *
     * @return zimbraLDAPSchemaVersion, or "1518163473" if unset
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3023)
    public String getLDAPSchemaVersion() {
        return getAttr(Provisioning.A_zimbraLDAPSchemaVersion, "1518163473", true);
    }

    /**
     * LDAP schema version for the system.
     *
     * @param zimbraLDAPSchemaVersion new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3023)
    public void setLDAPSchemaVersion(String zimbraLDAPSchemaVersion) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLDAPSchemaVersion, zimbraLDAPSchemaVersion);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP schema version for the system.
     *
     * @param zimbraLDAPSchemaVersion new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3023)
    public Map<String,Object> setLDAPSchemaVersion(String zimbraLDAPSchemaVersion, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLDAPSchemaVersion, zimbraLDAPSchemaVersion);
        return attrs;
    }

    /**
     * LDAP schema version for the system.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3023)
    public void unsetLDAPSchemaVersion() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLDAPSchemaVersion, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP schema version for the system.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.8
     */
    @ZAttr(id=3023)
    public Map<String,Object> unsetLDAPSchemaVersion(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLDAPSchemaVersion, "");
        return attrs;
    }

    /**
     * how often the zimbraLastLogonTimestamp is updated. if set to 0,
     * updating zimbraLastLogonTimestamp is completely disabled . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getLastLogonTimestampFrequencyAsString to access value as a string.
     *
     * @see #getLastLogonTimestampFrequencyAsString()
     *
     * @return zimbraLastLogonTimestampFrequency in millseconds, or 604800000 (7d)  if unset
     */
    @ZAttr(id=114)
    public long getLastLogonTimestampFrequency() {
        return getTimeInterval(Provisioning.A_zimbraLastLogonTimestampFrequency, 604800000L, true);
    }

    /**
     * how often the zimbraLastLogonTimestamp is updated. if set to 0,
     * updating zimbraLastLogonTimestamp is completely disabled . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraLastLogonTimestampFrequency, or "7d" if unset
     */
    @ZAttr(id=114)
    public String getLastLogonTimestampFrequencyAsString() {
        return getAttr(Provisioning.A_zimbraLastLogonTimestampFrequency, "7d", true);
    }

    /**
     * how often the zimbraLastLogonTimestamp is updated. if set to 0,
     * updating zimbraLastLogonTimestamp is completely disabled . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLastLogonTimestampFrequency new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=114)
    public void setLastLogonTimestampFrequency(String zimbraLastLogonTimestampFrequency) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastLogonTimestampFrequency, zimbraLastLogonTimestampFrequency);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how often the zimbraLastLogonTimestamp is updated. if set to 0,
     * updating zimbraLastLogonTimestamp is completely disabled . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLastLogonTimestampFrequency new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=114)
    public Map<String,Object> setLastLogonTimestampFrequency(String zimbraLastLogonTimestampFrequency, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastLogonTimestampFrequency, zimbraLastLogonTimestampFrequency);
        return attrs;
    }

    /**
     * how often the zimbraLastLogonTimestamp is updated. if set to 0,
     * updating zimbraLastLogonTimestamp is completely disabled . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=114)
    public void unsetLastLogonTimestampFrequency() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastLogonTimestampFrequency, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how often the zimbraLastLogonTimestamp is updated. if set to 0,
     * updating zimbraLastLogonTimestamp is completely disabled . Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=114)
    public Map<String,Object> unsetLastLogonTimestampFrequency(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastLogonTimestampFrequency, "");
        return attrs;
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getLastPurgeMaxDurationAsString to access value as a string.
     *
     * @see #getLastPurgeMaxDurationAsString()
     *
     * @return zimbraLastPurgeMaxDuration in millseconds, or 2592000000 (30d)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public long getLastPurgeMaxDuration() {
        return getTimeInterval(Provisioning.A_zimbraLastPurgeMaxDuration, 2592000000L, true);
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraLastPurgeMaxDuration, or "30d" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public String getLastPurgeMaxDurationAsString() {
        return getAttr(Provisioning.A_zimbraLastPurgeMaxDuration, "30d", true);
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLastPurgeMaxDuration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public void setLastPurgeMaxDuration(String zimbraLastPurgeMaxDuration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastPurgeMaxDuration, zimbraLastPurgeMaxDuration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLastPurgeMaxDuration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public Map<String,Object> setLastPurgeMaxDuration(String zimbraLastPurgeMaxDuration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastPurgeMaxDuration, zimbraLastPurgeMaxDuration);
        return attrs;
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public void unsetLastPurgeMaxDuration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastPurgeMaxDuration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum duration beyond which the mailbox must be scheduled for purge
     * irrespective of whether it is loaded into memory or not.. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1382)
    public Map<String,Object> unsetLastPurgeMaxDuration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLastPurgeMaxDuration, "");
        return attrs;
    }

    /**
     * whether ldap based galsync disabled or not
     *
     * @return zimbraLdapGalSyncDisabled, or false if unset
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1420)
    public boolean isLdapGalSyncDisabled() {
        return getBooleanAttr(Provisioning.A_zimbraLdapGalSyncDisabled, false, true);
    }

    /**
     * whether ldap based galsync disabled or not
     *
     * @param zimbraLdapGalSyncDisabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1420)
    public void setLdapGalSyncDisabled(boolean zimbraLdapGalSyncDisabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGalSyncDisabled, zimbraLdapGalSyncDisabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether ldap based galsync disabled or not
     *
     * @param zimbraLdapGalSyncDisabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1420)
    public Map<String,Object> setLdapGalSyncDisabled(boolean zimbraLdapGalSyncDisabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGalSyncDisabled, zimbraLdapGalSyncDisabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether ldap based galsync disabled or not
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1420)
    public void unsetLdapGalSyncDisabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGalSyncDisabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether ldap based galsync disabled or not
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.2
     */
    @ZAttr(id=1420)
    public Map<String,Object> unsetLdapGalSyncDisabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGalSyncDisabled, "");
        return attrs;
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @return zimbraLdapGentimeFractionalSecondsEnabled, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public boolean isLdapGentimeFractionalSecondsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, true, true);
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @param zimbraLdapGentimeFractionalSecondsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public void setLdapGentimeFractionalSecondsEnabled(boolean zimbraLdapGentimeFractionalSecondsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, zimbraLdapGentimeFractionalSecondsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @param zimbraLdapGentimeFractionalSecondsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public Map<String,Object> setLdapGentimeFractionalSecondsEnabled(boolean zimbraLdapGentimeFractionalSecondsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, zimbraLdapGentimeFractionalSecondsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public void unsetLdapGentimeFractionalSecondsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to include fractional seconds in LDAP gentime values (e.g.
     * zimbraPasswordLockoutFailureTime or
     * zimbraGalLastSuccessfulSyncTimestamp). Releases prior to 8.7 are
     * unable to parse gentime values which include fractional seconds;
     * therefore this value must remain set to FALSE in environments where
     * any release 8.6 or lower is present. It should be changed to TRUE once
     * all systems are upgraded to 8.7 or higher.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2018)
    public Map<String,Object> unsetLdapGentimeFractionalSecondsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLdapGentimeFractionalSecondsEnabled, "");
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @return zimbraLmtpBindOnStartup, or false if unset
     */
    @ZAttr(id=270)
    public boolean isLmtpBindOnStartup() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpBindOnStartup, false, true);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraLmtpBindOnStartup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=270)
    public void setLmtpBindOnStartup(boolean zimbraLmtpBindOnStartup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindOnStartup, zimbraLmtpBindOnStartup ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraLmtpBindOnStartup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=270)
    public Map<String,Object> setLmtpBindOnStartup(boolean zimbraLmtpBindOnStartup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindOnStartup, zimbraLmtpBindOnStartup ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=270)
    public void unsetLmtpBindOnStartup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindOnStartup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=270)
    public Map<String,Object> unsetLmtpBindOnStartup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindOnStartup, "");
        return attrs;
    }

    /**
     * port number on which LMTP server should listen
     *
     * <p>Use getLmtpBindPortAsString to access value as a string.
     *
     * @see #getLmtpBindPortAsString()
     *
     * @return zimbraLmtpBindPort, or 7025 if unset
     */
    @ZAttr(id=24)
    public int getLmtpBindPort() {
        return getIntAttr(Provisioning.A_zimbraLmtpBindPort, 7025, true);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @return zimbraLmtpBindPort, or "7025" if unset
     */
    @ZAttr(id=24)
    public String getLmtpBindPortAsString() {
        return getAttr(Provisioning.A_zimbraLmtpBindPort, "7025", true);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param zimbraLmtpBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=24)
    public void setLmtpBindPort(int zimbraLmtpBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, Integer.toString(zimbraLmtpBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param zimbraLmtpBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=24)
    public Map<String,Object> setLmtpBindPort(int zimbraLmtpBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, Integer.toString(zimbraLmtpBindPort));
        return attrs;
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param zimbraLmtpBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=24)
    public void setLmtpBindPortAsString(String zimbraLmtpBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, zimbraLmtpBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param zimbraLmtpBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=24)
    public Map<String,Object> setLmtpBindPortAsString(String zimbraLmtpBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, zimbraLmtpBindPort);
        return attrs;
    }

    /**
     * port number on which LMTP server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=24)
    public void unsetLmtpBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which LMTP server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=24)
    public Map<String,Object> unsetLmtpBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpBindPort, "");
        return attrs;
    }

    /**
     * Whether to expose version on LMTP banner
     *
     * @return zimbraLmtpExposeVersionOnBanner, or false if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=691)
    public boolean isLmtpExposeVersionOnBanner() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpExposeVersionOnBanner, false, true);
    }

    /**
     * Whether to expose version on LMTP banner
     *
     * @param zimbraLmtpExposeVersionOnBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=691)
    public void setLmtpExposeVersionOnBanner(boolean zimbraLmtpExposeVersionOnBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpExposeVersionOnBanner, zimbraLmtpExposeVersionOnBanner ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on LMTP banner
     *
     * @param zimbraLmtpExposeVersionOnBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=691)
    public Map<String,Object> setLmtpExposeVersionOnBanner(boolean zimbraLmtpExposeVersionOnBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpExposeVersionOnBanner, zimbraLmtpExposeVersionOnBanner ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to expose version on LMTP banner
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=691)
    public void unsetLmtpExposeVersionOnBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpExposeVersionOnBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on LMTP banner
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=691)
    public Map<String,Object> unsetLmtpExposeVersionOnBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpExposeVersionOnBanner, "");
        return attrs;
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @return zimbraLmtpLHLORequired, or true if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public boolean isLmtpLHLORequired() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpLHLORequired, true, true);
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @param zimbraLmtpLHLORequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public void setLmtpLHLORequired(boolean zimbraLmtpLHLORequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpLHLORequired, zimbraLmtpLHLORequired ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @param zimbraLmtpLHLORequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public Map<String,Object> setLmtpLHLORequired(boolean zimbraLmtpLHLORequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpLHLORequired, zimbraLmtpLHLORequired ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public void unsetLmtpLHLORequired() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpLHLORequired, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Lmtp Server will reject the client transactions which do not issue
     * LHLO
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1675)
    public Map<String,Object> unsetLmtpLHLORequired(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpLHLORequired, "");
        return attrs;
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @return zimbraLmtpNumThreads, or 20 if unset
     */
    @ZAttr(id=26)
    public int getLmtpNumThreads() {
        return getIntAttr(Provisioning.A_zimbraLmtpNumThreads, 20, true);
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @param zimbraLmtpNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=26)
    public void setLmtpNumThreads(int zimbraLmtpNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpNumThreads, Integer.toString(zimbraLmtpNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @param zimbraLmtpNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=26)
    public Map<String,Object> setLmtpNumThreads(int zimbraLmtpNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpNumThreads, Integer.toString(zimbraLmtpNumThreads));
        return attrs;
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=26)
    public void unsetLmtpNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads, should match MTA concurrency setting for
     * this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=26)
    public Map<String,Object> unsetLmtpNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpNumThreads, "");
        return attrs;
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @return zimbraLmtpPermanentFailureWhenOverQuota, or false if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public boolean isLmtpPermanentFailureWhenOverQuota() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, false, true);
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @param zimbraLmtpPermanentFailureWhenOverQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public void setLmtpPermanentFailureWhenOverQuota(boolean zimbraLmtpPermanentFailureWhenOverQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, zimbraLmtpPermanentFailureWhenOverQuota ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @param zimbraLmtpPermanentFailureWhenOverQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public Map<String,Object> setLmtpPermanentFailureWhenOverQuota(boolean zimbraLmtpPermanentFailureWhenOverQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, zimbraLmtpPermanentFailureWhenOverQuota ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public void unsetLmtpPermanentFailureWhenOverQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, a permanent failure (552) is returned when the user is over
     * quota. If false, a temporary failure (452) is returned.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=657)
    public Map<String,Object> unsetLmtpPermanentFailureWhenOverQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpPermanentFailureWhenOverQuota, "");
        return attrs;
    }

    /**
     * whether LMTP server is enabled for a given server
     *
     * @return zimbraLmtpServerEnabled, or true if unset
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=630)
    public boolean isLmtpServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraLmtpServerEnabled, true, true);
    }

    /**
     * whether LMTP server is enabled for a given server
     *
     * @param zimbraLmtpServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=630)
    public void setLmtpServerEnabled(boolean zimbraLmtpServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpServerEnabled, zimbraLmtpServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether LMTP server is enabled for a given server
     *
     * @param zimbraLmtpServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=630)
    public Map<String,Object> setLmtpServerEnabled(boolean zimbraLmtpServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpServerEnabled, zimbraLmtpServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether LMTP server is enabled for a given server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=630)
    public void unsetLmtpServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether LMTP server is enabled for a given server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.4
     */
    @ZAttr(id=630)
    public Map<String,Object> unsetLmtpServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpServerEnabled, "");
        return attrs;
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @return zimbraLmtpShutdownGraceSeconds, or 10 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public int getLmtpShutdownGraceSeconds() {
        return getIntAttr(Provisioning.A_zimbraLmtpShutdownGraceSeconds, 10, true);
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @param zimbraLmtpShutdownGraceSeconds new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public void setLmtpShutdownGraceSeconds(int zimbraLmtpShutdownGraceSeconds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpShutdownGraceSeconds, Integer.toString(zimbraLmtpShutdownGraceSeconds));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @param zimbraLmtpShutdownGraceSeconds new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public Map<String,Object> setLmtpShutdownGraceSeconds(int zimbraLmtpShutdownGraceSeconds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpShutdownGraceSeconds, Integer.toString(zimbraLmtpShutdownGraceSeconds));
        return attrs;
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public void unsetLmtpShutdownGraceSeconds() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpShutdownGraceSeconds, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing LMTP server shutdown
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1082)
    public Map<String,Object> unsetLmtpShutdownGraceSeconds(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLmtpShutdownGraceSeconds, "");
        return attrs;
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @return zimbraLocale, or null if unset
     */
    @ZAttr(id=345)
    public String getLocaleAsString() {
        return getAttr(Provisioning.A_zimbraLocale, null, true);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param zimbraLocale new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=345)
    public void setLocale(String zimbraLocale) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, zimbraLocale);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param zimbraLocale new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=345)
    public Map<String,Object> setLocale(String zimbraLocale, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, zimbraLocale);
        return attrs;
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=345)
    public void unsetLocale() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * locale of entry, e.g. en_US
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=345)
    public Map<String,Object> unsetLocale(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLocale, "");
        return attrs;
    }

    /**
     * destination for syslog messages
     *
     * @return zimbraLogHostname, or empty array if unset
     */
    @ZAttr(id=250)
    public String[] getLogHostname() {
        return getMultiAttr(Provisioning.A_zimbraLogHostname, true, true);
    }

    /**
     * destination for syslog messages
     *
     * @param zimbraLogHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=250)
    public void setLogHostname(String[] zimbraLogHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogHostname, zimbraLogHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * destination for syslog messages
     *
     * @param zimbraLogHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=250)
    public Map<String,Object> setLogHostname(String[] zimbraLogHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogHostname, zimbraLogHostname);
        return attrs;
    }

    /**
     * destination for syslog messages
     *
     * @param zimbraLogHostname new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=250)
    public void addLogHostname(String zimbraLogHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraLogHostname, zimbraLogHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * destination for syslog messages
     *
     * @param zimbraLogHostname new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=250)
    public Map<String,Object> addLogHostname(String zimbraLogHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraLogHostname, zimbraLogHostname);
        return attrs;
    }

    /**
     * destination for syslog messages
     *
     * @param zimbraLogHostname existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=250)
    public void removeLogHostname(String zimbraLogHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraLogHostname, zimbraLogHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * destination for syslog messages
     *
     * @param zimbraLogHostname existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=250)
    public Map<String,Object> removeLogHostname(String zimbraLogHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraLogHostname, zimbraLogHostname);
        return attrs;
    }

    /**
     * destination for syslog messages
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=250)
    public void unsetLogHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * destination for syslog messages
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=250)
    public Map<String,Object> unsetLogHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogHostname, "");
        return attrs;
    }

    /**
     * lifetime of raw log rows in consolidated logger tables. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getLogRawLifetimeAsString to access value as a string.
     *
     * @see #getLogRawLifetimeAsString()
     *
     * @return zimbraLogRawLifetime in millseconds, or 2678400000 (31d)  if unset
     */
    @ZAttr(id=263)
    public long getLogRawLifetime() {
        return getTimeInterval(Provisioning.A_zimbraLogRawLifetime, 2678400000L, true);
    }

    /**
     * lifetime of raw log rows in consolidated logger tables. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraLogRawLifetime, or "31d" if unset
     */
    @ZAttr(id=263)
    public String getLogRawLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraLogRawLifetime, "31d", true);
    }

    /**
     * lifetime of raw log rows in consolidated logger tables. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLogRawLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=263)
    public void setLogRawLifetime(String zimbraLogRawLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogRawLifetime, zimbraLogRawLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of raw log rows in consolidated logger tables. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLogRawLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=263)
    public Map<String,Object> setLogRawLifetime(String zimbraLogRawLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogRawLifetime, zimbraLogRawLifetime);
        return attrs;
    }

    /**
     * lifetime of raw log rows in consolidated logger tables. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=263)
    public void unsetLogRawLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogRawLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of raw log rows in consolidated logger tables. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=263)
    public Map<String,Object> unsetLogRawLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogRawLifetime, "");
        return attrs;
    }

    /**
     * lifetime of summarized log rows in consolidated logger tables. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getLogSummaryLifetimeAsString to access value as a string.
     *
     * @see #getLogSummaryLifetimeAsString()
     *
     * @return zimbraLogSummaryLifetime in millseconds, or 63072000000 (730d)  if unset
     */
    @ZAttr(id=264)
    public long getLogSummaryLifetime() {
        return getTimeInterval(Provisioning.A_zimbraLogSummaryLifetime, 63072000000L, true);
    }

    /**
     * lifetime of summarized log rows in consolidated logger tables. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraLogSummaryLifetime, or "730d" if unset
     */
    @ZAttr(id=264)
    public String getLogSummaryLifetimeAsString() {
        return getAttr(Provisioning.A_zimbraLogSummaryLifetime, "730d", true);
    }

    /**
     * lifetime of summarized log rows in consolidated logger tables. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLogSummaryLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=264)
    public void setLogSummaryLifetime(String zimbraLogSummaryLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogSummaryLifetime, zimbraLogSummaryLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of summarized log rows in consolidated logger tables. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraLogSummaryLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=264)
    public Map<String,Object> setLogSummaryLifetime(String zimbraLogSummaryLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogSummaryLifetime, zimbraLogSummaryLifetime);
        return attrs;
    }

    /**
     * lifetime of summarized log rows in consolidated logger tables. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=264)
    public void unsetLogSummaryLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogSummaryLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * lifetime of summarized log rows in consolidated logger tables. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=264)
    public Map<String,Object> unsetLogSummaryLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogSummaryLifetime, "");
        return attrs;
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @return zimbraLogToSyslog, or false if unset
     */
    @ZAttr(id=520)
    public boolean isLogToSyslog() {
        return getBooleanAttr(Provisioning.A_zimbraLogToSyslog, false, true);
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @param zimbraLogToSyslog new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=520)
    public void setLogToSyslog(boolean zimbraLogToSyslog) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogToSyslog, zimbraLogToSyslog ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @param zimbraLogToSyslog new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=520)
    public Map<String,Object> setLogToSyslog(boolean zimbraLogToSyslog, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogToSyslog, zimbraLogToSyslog ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=520)
    public void unsetLogToSyslog() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogToSyslog, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether mailbox server should log to syslog
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=520)
    public Map<String,Object> unsetLogToSyslog(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLogToSyslog, "");
        return attrs;
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @return zimbraLowestSupportedAuthVersion, or 2 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public int getLowestSupportedAuthVersion() {
        return getIntAttr(Provisioning.A_zimbraLowestSupportedAuthVersion, 2, true);
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @param zimbraLowestSupportedAuthVersion new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public void setLowestSupportedAuthVersion(int zimbraLowestSupportedAuthVersion) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLowestSupportedAuthVersion, Integer.toString(zimbraLowestSupportedAuthVersion));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @param zimbraLowestSupportedAuthVersion new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public Map<String,Object> setLowestSupportedAuthVersion(int zimbraLowestSupportedAuthVersion, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLowestSupportedAuthVersion, Integer.toString(zimbraLowestSupportedAuthVersion));
        return attrs;
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public void unsetLowestSupportedAuthVersion() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLowestSupportedAuthVersion, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * version of lowest supported authentication protocol
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1589)
    public Map<String,Object> unsetLowestSupportedAuthVersion(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraLowestSupportedAuthVersion, "");
        return attrs;
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @return zimbraMailAddressValidationRegex, or empty array if unset
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public String[] getMailAddressValidationRegex() {
        return getMultiAttr(Provisioning.A_zimbraMailAddressValidationRegex, true, true);
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @param zimbraMailAddressValidationRegex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public void setMailAddressValidationRegex(String[] zimbraMailAddressValidationRegex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAddressValidationRegex, zimbraMailAddressValidationRegex);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @param zimbraMailAddressValidationRegex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public Map<String,Object> setMailAddressValidationRegex(String[] zimbraMailAddressValidationRegex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAddressValidationRegex, zimbraMailAddressValidationRegex);
        return attrs;
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @param zimbraMailAddressValidationRegex new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public void addMailAddressValidationRegex(String zimbraMailAddressValidationRegex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailAddressValidationRegex, zimbraMailAddressValidationRegex);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @param zimbraMailAddressValidationRegex new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public Map<String,Object> addMailAddressValidationRegex(String zimbraMailAddressValidationRegex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailAddressValidationRegex, zimbraMailAddressValidationRegex);
        return attrs;
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @param zimbraMailAddressValidationRegex existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public void removeMailAddressValidationRegex(String zimbraMailAddressValidationRegex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailAddressValidationRegex, zimbraMailAddressValidationRegex);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @param zimbraMailAddressValidationRegex existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public Map<String,Object> removeMailAddressValidationRegex(String zimbraMailAddressValidationRegex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailAddressValidationRegex, zimbraMailAddressValidationRegex);
        return attrs;
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public void unsetMailAddressValidationRegex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAddressValidationRegex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * optional regex used by web client to validate email address
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1241)
    public Map<String,Object> unsetMailAddressValidationRegex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailAddressValidationRegex, "");
        return attrs;
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @return zimbraMailClearTextPasswordEnabled, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public boolean isMailClearTextPasswordEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailClearTextPasswordEnabled, true, true);
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @param zimbraMailClearTextPasswordEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public void setMailClearTextPasswordEnabled(boolean zimbraMailClearTextPasswordEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailClearTextPasswordEnabled, zimbraMailClearTextPasswordEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @param zimbraMailClearTextPasswordEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public Map<String,Object> setMailClearTextPasswordEnabled(boolean zimbraMailClearTextPasswordEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailClearTextPasswordEnabled, zimbraMailClearTextPasswordEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public void unsetMailClearTextPasswordEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailClearTextPasswordEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to allow password sent to non-secured port when zimbraMailMode
     * is mixed. If it set to TRUE the server will allow login with clear
     * text AuthRequests and change password with clear text
     * ChangePasswordRequest. If it set to FALSE the server will return an
     * error if an attempt is made to ChangePasswordRequest or AuthRequest.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=791)
    public Map<String,Object> unsetMailClearTextPasswordEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailClearTextPasswordEnabled, "");
        return attrs;
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @return zimbraMailContentMaxSize, or 10240000 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public long getMailContentMaxSize() {
        return getLongAttr(Provisioning.A_zimbraMailContentMaxSize, 10240000L, true);
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @param zimbraMailContentMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public void setMailContentMaxSize(long zimbraMailContentMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailContentMaxSize, Long.toString(zimbraMailContentMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @param zimbraMailContentMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public Map<String,Object> setMailContentMaxSize(long zimbraMailContentMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailContentMaxSize, Long.toString(zimbraMailContentMaxSize));
        return attrs;
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public void unsetMailContentMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailContentMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for the &lt;content &gt; element in SOAP. Mail
     * content larger than this limit will be truncated.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=807)
    public Map<String,Object> unsetMailContentMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailContentMaxSize, "");
        return attrs;
    }

    /**
     * Incoming messages larger than this number of bytes are streamed to
     * disk during LMTP delivery, instead of being read into memory. This
     * limits memory consumption at the expense of higher disk utilization.
     *
     * @return zimbraMailDiskStreamingThreshold, or 1048576 if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=565)
    public int getMailDiskStreamingThreshold() {
        return getIntAttr(Provisioning.A_zimbraMailDiskStreamingThreshold, 1048576, true);
    }

    /**
     * Incoming messages larger than this number of bytes are streamed to
     * disk during LMTP delivery, instead of being read into memory. This
     * limits memory consumption at the expense of higher disk utilization.
     *
     * @param zimbraMailDiskStreamingThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=565)
    public void setMailDiskStreamingThreshold(int zimbraMailDiskStreamingThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDiskStreamingThreshold, Integer.toString(zimbraMailDiskStreamingThreshold));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Incoming messages larger than this number of bytes are streamed to
     * disk during LMTP delivery, instead of being read into memory. This
     * limits memory consumption at the expense of higher disk utilization.
     *
     * @param zimbraMailDiskStreamingThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=565)
    public Map<String,Object> setMailDiskStreamingThreshold(int zimbraMailDiskStreamingThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDiskStreamingThreshold, Integer.toString(zimbraMailDiskStreamingThreshold));
        return attrs;
    }

    /**
     * Incoming messages larger than this number of bytes are streamed to
     * disk during LMTP delivery, instead of being read into memory. This
     * limits memory consumption at the expense of higher disk utilization.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=565)
    public void unsetMailDiskStreamingThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDiskStreamingThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Incoming messages larger than this number of bytes are streamed to
     * disk during LMTP delivery, instead of being read into memory. This
     * limits memory consumption at the expense of higher disk utilization.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=565)
    public Map<String,Object> unsetMailDiskStreamingThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDiskStreamingThreshold, "");
        return attrs;
    }

    /**
     * Maximum mailbox quota for the domain in bytes. The effective quota for
     * a mailbox would be the minimum of this and zimbraMailQuota.
     *
     * @return zimbraMailDomainQuota, or 0 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1326)
    public long getMailDomainQuota() {
        return getLongAttr(Provisioning.A_zimbraMailDomainQuota, 0L, true);
    }

    /**
     * Maximum mailbox quota for the domain in bytes. The effective quota for
     * a mailbox would be the minimum of this and zimbraMailQuota.
     *
     * @param zimbraMailDomainQuota new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1326)
    public void setMailDomainQuota(long zimbraMailDomainQuota) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDomainQuota, Long.toString(zimbraMailDomainQuota));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum mailbox quota for the domain in bytes. The effective quota for
     * a mailbox would be the minimum of this and zimbraMailQuota.
     *
     * @param zimbraMailDomainQuota new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1326)
    public Map<String,Object> setMailDomainQuota(long zimbraMailDomainQuota, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDomainQuota, Long.toString(zimbraMailDomainQuota));
        return attrs;
    }

    /**
     * Maximum mailbox quota for the domain in bytes. The effective quota for
     * a mailbox would be the minimum of this and zimbraMailQuota.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1326)
    public void unsetMailDomainQuota() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDomainQuota, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum mailbox quota for the domain in bytes. The effective quota for
     * a mailbox would be the minimum of this and zimbraMailQuota.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1326)
    public Map<String,Object> unsetMailDomainQuota(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailDomainQuota, "");
        return attrs;
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @return zimbraMailEmptyFolderBatchSize, or 1000 if unset
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public int getMailEmptyFolderBatchSize() {
        return getIntAttr(Provisioning.A_zimbraMailEmptyFolderBatchSize, 1000, true);
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @param zimbraMailEmptyFolderBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public void setMailEmptyFolderBatchSize(int zimbraMailEmptyFolderBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchSize, Integer.toString(zimbraMailEmptyFolderBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @param zimbraMailEmptyFolderBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public Map<String,Object> setMailEmptyFolderBatchSize(int zimbraMailEmptyFolderBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchSize, Integer.toString(zimbraMailEmptyFolderBatchSize));
        return attrs;
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public void unsetMailEmptyFolderBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages to delete during a single transaction when
     * emptying a large folder.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1097)
    public Map<String,Object> unsetMailEmptyFolderBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Empty folder operation now always deletes
     * items in batches, hence a threshold is no longer applicable.. Orig
     * desc: Folders that contain more than this many messages will be
     * emptied in batches of size zimbraMailEmptyFolderBatchSize.
     *
     * @return zimbraMailEmptyFolderBatchThreshold, or 100000 if unset
     *
     * @since ZCS 6.0.13
     */
    @ZAttr(id=1208)
    public int getMailEmptyFolderBatchThreshold() {
        return getIntAttr(Provisioning.A_zimbraMailEmptyFolderBatchThreshold, 100000, true);
    }

    /**
     * Deprecated since: 8.0.0. Empty folder operation now always deletes
     * items in batches, hence a threshold is no longer applicable.. Orig
     * desc: Folders that contain more than this many messages will be
     * emptied in batches of size zimbraMailEmptyFolderBatchSize.
     *
     * @param zimbraMailEmptyFolderBatchThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.13
     */
    @ZAttr(id=1208)
    public void setMailEmptyFolderBatchThreshold(int zimbraMailEmptyFolderBatchThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchThreshold, Integer.toString(zimbraMailEmptyFolderBatchThreshold));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Empty folder operation now always deletes
     * items in batches, hence a threshold is no longer applicable.. Orig
     * desc: Folders that contain more than this many messages will be
     * emptied in batches of size zimbraMailEmptyFolderBatchSize.
     *
     * @param zimbraMailEmptyFolderBatchThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.13
     */
    @ZAttr(id=1208)
    public Map<String,Object> setMailEmptyFolderBatchThreshold(int zimbraMailEmptyFolderBatchThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchThreshold, Integer.toString(zimbraMailEmptyFolderBatchThreshold));
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. Empty folder operation now always deletes
     * items in batches, hence a threshold is no longer applicable.. Orig
     * desc: Folders that contain more than this many messages will be
     * emptied in batches of size zimbraMailEmptyFolderBatchSize.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.13
     */
    @ZAttr(id=1208)
    public void unsetMailEmptyFolderBatchThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. Empty folder operation now always deletes
     * items in batches, hence a threshold is no longer applicable.. Orig
     * desc: Folders that contain more than this many messages will be
     * emptied in batches of size zimbraMailEmptyFolderBatchSize.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.13
     */
    @ZAttr(id=1208)
    public Map<String,Object> unsetMailEmptyFolderBatchThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailEmptyFolderBatchThreshold, "");
        return attrs;
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @return zimbraMailFileDescriptorBufferSize, or 4096 if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public int getMailFileDescriptorBufferSize() {
        return getIntAttr(Provisioning.A_zimbraMailFileDescriptorBufferSize, 4096, true);
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @param zimbraMailFileDescriptorBufferSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public void setMailFileDescriptorBufferSize(int zimbraMailFileDescriptorBufferSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorBufferSize, Integer.toString(zimbraMailFileDescriptorBufferSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @param zimbraMailFileDescriptorBufferSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public Map<String,Object> setMailFileDescriptorBufferSize(int zimbraMailFileDescriptorBufferSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorBufferSize, Integer.toString(zimbraMailFileDescriptorBufferSize));
        return attrs;
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public void unsetMailFileDescriptorBufferSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorBufferSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of bytes to buffer in memory per file descriptor in the cache.
     * Larger values result in fewer disk reads, but increase memory
     * consumption.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1035)
    public Map<String,Object> unsetMailFileDescriptorBufferSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorBufferSize, "");
        return attrs;
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @return zimbraMailFileDescriptorCacheSize, or 1000 if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public int getMailFileDescriptorCacheSize() {
        return getIntAttr(Provisioning.A_zimbraMailFileDescriptorCacheSize, 1000, true);
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @param zimbraMailFileDescriptorCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public void setMailFileDescriptorCacheSize(int zimbraMailFileDescriptorCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorCacheSize, Integer.toString(zimbraMailFileDescriptorCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @param zimbraMailFileDescriptorCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public Map<String,Object> setMailFileDescriptorCacheSize(int zimbraMailFileDescriptorCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorCacheSize, Integer.toString(zimbraMailFileDescriptorCacheSize));
        return attrs;
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public void unsetMailFileDescriptorCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of file descriptors that are opened for accessing
     * message content.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1034)
    public Map<String,Object> unsetMailFileDescriptorCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailFileDescriptorCacheSize, "");
        return attrs;
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @return zimbraMailKeepOutWebCrawlers, or false if unset
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public boolean isMailKeepOutWebCrawlers() {
        return getBooleanAttr(Provisioning.A_zimbraMailKeepOutWebCrawlers, false, true);
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @param zimbraMailKeepOutWebCrawlers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public void setMailKeepOutWebCrawlers(boolean zimbraMailKeepOutWebCrawlers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailKeepOutWebCrawlers, zimbraMailKeepOutWebCrawlers ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @param zimbraMailKeepOutWebCrawlers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public Map<String,Object> setMailKeepOutWebCrawlers(boolean zimbraMailKeepOutWebCrawlers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailKeepOutWebCrawlers, zimbraMailKeepOutWebCrawlers ? TRUE : FALSE);
        return attrs;
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public void unsetMailKeepOutWebCrawlers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailKeepOutWebCrawlers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When set to true, robots.txt on mailboxd will be set up to keep web
     * crawlers out
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1161)
    public Map<String,Object> unsetMailKeepOutWebCrawlers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailKeepOutWebCrawlers, "");
        return attrs;
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @return zimbraMailMode, or null if unset and/or has invalid value
     */
    @ZAttr(id=308)
    public ZAttrProvisioning.MailMode getMailMode() {
        try { String v = getAttr(Provisioning.A_zimbraMailMode, true, true); return v == null ? null : ZAttrProvisioning.MailMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @return zimbraMailMode, or null if unset
     */
    @ZAttr(id=308)
    public String getMailModeAsString() {
        return getAttr(Provisioning.A_zimbraMailMode, null, true);
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param zimbraMailMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=308)
    public void setMailMode(ZAttrProvisioning.MailMode zimbraMailMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, zimbraMailMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param zimbraMailMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=308)
    public Map<String,Object> setMailMode(ZAttrProvisioning.MailMode zimbraMailMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, zimbraMailMode.toString());
        return attrs;
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param zimbraMailMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=308)
    public void setMailModeAsString(String zimbraMailMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, zimbraMailMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param zimbraMailMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=308)
    public Map<String,Object> setMailModeAsString(String zimbraMailMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, zimbraMailMode);
        return attrs;
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=308)
    public void unsetMailMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run HTTP or HTTPS or both/mixed mode or redirect mode. See
     * also related attributes zimbraMailPort and zimbraMailSSLPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=308)
    public Map<String,Object> unsetMailMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailMode, "");
        return attrs;
    }

    /**
     * HTTP port for end-user UI
     *
     * <p>Use getMailPortAsString to access value as a string.
     *
     * @see #getMailPortAsString()
     *
     * @return zimbraMailPort, or 80 if unset
     */
    @ZAttr(id=154)
    public int getMailPort() {
        return getIntAttr(Provisioning.A_zimbraMailPort, 80, true);
    }

    /**
     * HTTP port for end-user UI
     *
     * @return zimbraMailPort, or "80" if unset
     */
    @ZAttr(id=154)
    public String getMailPortAsString() {
        return getAttr(Provisioning.A_zimbraMailPort, "80", true);
    }

    /**
     * HTTP port for end-user UI
     *
     * @param zimbraMailPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=154)
    public void setMailPort(int zimbraMailPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, Integer.toString(zimbraMailPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for end-user UI
     *
     * @param zimbraMailPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=154)
    public Map<String,Object> setMailPort(int zimbraMailPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, Integer.toString(zimbraMailPort));
        return attrs;
    }

    /**
     * HTTP port for end-user UI
     *
     * @param zimbraMailPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=154)
    public void setMailPortAsString(String zimbraMailPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, zimbraMailPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for end-user UI
     *
     * @param zimbraMailPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=154)
    public Map<String,Object> setMailPortAsString(String zimbraMailPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, zimbraMailPort);
        return attrs;
    }

    /**
     * HTTP port for end-user UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=154)
    public void unsetMailPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP port for end-user UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=154)
    public Map<String,Object> unsetMailPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPort, "");
        return attrs;
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @return zimbraMailProxyMaxFails, or 1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public int getMailProxyMaxFails() {
        return getIntAttr(Provisioning.A_zimbraMailProxyMaxFails, 1, true);
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @param zimbraMailProxyMaxFails new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public void setMailProxyMaxFails(int zimbraMailProxyMaxFails) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyMaxFails, Integer.toString(zimbraMailProxyMaxFails));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @param zimbraMailProxyMaxFails new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public Map<String,Object> setMailProxyMaxFails(int zimbraMailProxyMaxFails, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyMaxFails, Integer.toString(zimbraMailProxyMaxFails));
        return attrs;
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public void unsetMailProxyMaxFails() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyMaxFails, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The max number of unsuccessful attempts to connect to the current
     * server (as an upstream). If this number is reached, proxy will refuse
     * to connect to the current server, wait for
     * zimbraMailProxyReconnectTimeout and then try to reconnect. Default
     * value is 1. Setting this to 0 means turning this check off.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1358)
    public Map<String,Object> unsetMailProxyMaxFails(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyMaxFails, "");
        return attrs;
    }

    /**
     * HTTP proxy port
     *
     * <p>Use getMailProxyPortAsString to access value as a string.
     *
     * @see #getMailProxyPortAsString()
     *
     * @return zimbraMailProxyPort, or 0 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=626)
    public int getMailProxyPort() {
        return getIntAttr(Provisioning.A_zimbraMailProxyPort, 0, true);
    }

    /**
     * HTTP proxy port
     *
     * @return zimbraMailProxyPort, or "0" if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=626)
    public String getMailProxyPortAsString() {
        return getAttr(Provisioning.A_zimbraMailProxyPort, "0", true);
    }

    /**
     * HTTP proxy port
     *
     * @param zimbraMailProxyPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=626)
    public void setMailProxyPort(int zimbraMailProxyPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyPort, Integer.toString(zimbraMailProxyPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP proxy port
     *
     * @param zimbraMailProxyPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=626)
    public Map<String,Object> setMailProxyPort(int zimbraMailProxyPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyPort, Integer.toString(zimbraMailProxyPort));
        return attrs;
    }

    /**
     * HTTP proxy port
     *
     * @param zimbraMailProxyPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=626)
    public void setMailProxyPortAsString(String zimbraMailProxyPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyPort, zimbraMailProxyPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP proxy port
     *
     * @param zimbraMailProxyPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=626)
    public Map<String,Object> setMailProxyPortAsString(String zimbraMailProxyPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyPort, zimbraMailProxyPort);
        return attrs;
    }

    /**
     * HTTP proxy port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=626)
    public void unsetMailProxyPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * HTTP proxy port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=626)
    public Map<String,Object> unsetMailProxyPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyPort, "");
        return attrs;
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @return zimbraMailProxyReconnectTimeout, or "10" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public String getMailProxyReconnectTimeout() {
        return getAttr(Provisioning.A_zimbraMailProxyReconnectTimeout, "10", true);
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @param zimbraMailProxyReconnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public void setMailProxyReconnectTimeout(String zimbraMailProxyReconnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyReconnectTimeout, zimbraMailProxyReconnectTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @param zimbraMailProxyReconnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public Map<String,Object> setMailProxyReconnectTimeout(String zimbraMailProxyReconnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyReconnectTimeout, zimbraMailProxyReconnectTimeout);
        return attrs;
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public void unsetMailProxyReconnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyReconnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the time in sec that proxy will reconnect the current server (as an
     * upstream) after connection errors happened before
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1268)
    public Map<String,Object> unsetMailProxyReconnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailProxyReconnectTimeout, "");
        return attrs;
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @return zimbraMailPurgeBatchSize, or 1000 if unset
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public int getMailPurgeBatchSize() {
        return getIntAttr(Provisioning.A_zimbraMailPurgeBatchSize, 1000, true);
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @param zimbraMailPurgeBatchSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public void setMailPurgeBatchSize(int zimbraMailPurgeBatchSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeBatchSize, Integer.toString(zimbraMailPurgeBatchSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @param zimbraMailPurgeBatchSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public Map<String,Object> setMailPurgeBatchSize(int zimbraMailPurgeBatchSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeBatchSize, Integer.toString(zimbraMailPurgeBatchSize));
        return attrs;
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public void unsetMailPurgeBatchSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeBatchSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of messages to delete from a folder during a single
     * purge operation. If the limit is exceeded, the mailbox is purged again
     * at the end of the purge cycle until all qualifying messages are
     * purged.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.8
     */
    @ZAttr(id=1096)
    public Map<String,Object> unsetMailPurgeBatchSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeBatchSize, "");
        return attrs;
    }

    /**
     * Sleep time between subsequent mailbox purges. 0 means that mailbox
     * purging is disabled. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getMailPurgeSleepIntervalAsString to access value as a string.
     *
     * @see #getMailPurgeSleepIntervalAsString()
     *
     * @return zimbraMailPurgeSleepInterval in millseconds, or 60000 (1m)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=542)
    public long getMailPurgeSleepInterval() {
        return getTimeInterval(Provisioning.A_zimbraMailPurgeSleepInterval, 60000L, true);
    }

    /**
     * Sleep time between subsequent mailbox purges. 0 means that mailbox
     * purging is disabled. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraMailPurgeSleepInterval, or "1m" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=542)
    public String getMailPurgeSleepIntervalAsString() {
        return getAttr(Provisioning.A_zimbraMailPurgeSleepInterval, "1m", true);
    }

    /**
     * Sleep time between subsequent mailbox purges. 0 means that mailbox
     * purging is disabled. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailPurgeSleepInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=542)
    public void setMailPurgeSleepInterval(String zimbraMailPurgeSleepInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeSleepInterval, zimbraMailPurgeSleepInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sleep time between subsequent mailbox purges. 0 means that mailbox
     * purging is disabled. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraMailPurgeSleepInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=542)
    public Map<String,Object> setMailPurgeSleepInterval(String zimbraMailPurgeSleepInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeSleepInterval, zimbraMailPurgeSleepInterval);
        return attrs;
    }

    /**
     * Sleep time between subsequent mailbox purges. 0 means that mailbox
     * purging is disabled. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=542)
    public void unsetMailPurgeSleepInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeSleepInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sleep time between subsequent mailbox purges. 0 means that mailbox
     * purging is disabled. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=542)
    public Map<String,Object> unsetMailPurgeSleepInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeSleepInterval, "");
        return attrs;
    }

    /**
     * System purge policy, encoded as metadata. Users can apply these policy
     * elements to their folders and tags. If the system policy changes, user
     * settings are automatically updated with the change.
     *
     * @return zimbraMailPurgeSystemPolicy, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1239)
    public String getMailPurgeSystemPolicy() {
        return getAttr(Provisioning.A_zimbraMailPurgeSystemPolicy, null, true);
    }

    /**
     * System purge policy, encoded as metadata. Users can apply these policy
     * elements to their folders and tags. If the system policy changes, user
     * settings are automatically updated with the change.
     *
     * @param zimbraMailPurgeSystemPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1239)
    public void setMailPurgeSystemPolicy(String zimbraMailPurgeSystemPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeSystemPolicy, zimbraMailPurgeSystemPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * System purge policy, encoded as metadata. Users can apply these policy
     * elements to their folders and tags. If the system policy changes, user
     * settings are automatically updated with the change.
     *
     * @param zimbraMailPurgeSystemPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1239)
    public Map<String,Object> setMailPurgeSystemPolicy(String zimbraMailPurgeSystemPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeSystemPolicy, zimbraMailPurgeSystemPolicy);
        return attrs;
    }

    /**
     * System purge policy, encoded as metadata. Users can apply these policy
     * elements to their folders and tags. If the system policy changes, user
     * settings are automatically updated with the change.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1239)
    public void unsetMailPurgeSystemPolicy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeSystemPolicy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * System purge policy, encoded as metadata. Users can apply these policy
     * elements to their folders and tags. If the system policy changes, user
     * settings are automatically updated with the change.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1239)
    public Map<String,Object> unsetMailPurgeSystemPolicy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailPurgeSystemPolicy, "");
        return attrs;
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @return zimbraMailRedirectSetEnvelopeSender, or true if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public boolean isMailRedirectSetEnvelopeSender() {
        return getBooleanAttr(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, true, true);
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @param zimbraMailRedirectSetEnvelopeSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public void setMailRedirectSetEnvelopeSender(boolean zimbraMailRedirectSetEnvelopeSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, zimbraMailRedirectSetEnvelopeSender ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @param zimbraMailRedirectSetEnvelopeSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public Map<String,Object> setMailRedirectSetEnvelopeSender(boolean zimbraMailRedirectSetEnvelopeSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, zimbraMailRedirectSetEnvelopeSender ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public void unsetMailRedirectSetEnvelopeSender() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, the envelope sender of a message redirected by mail filters
     * will be set to the users address. If FALSE, the envelope sender will
     * be set to the From address of the redirected message.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=764)
    public Map<String,Object> unsetMailRedirectSetEnvelopeSender(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailRedirectSetEnvelopeSender, "");
        return attrs;
    }

    /**
     * whether to send back a refer tag in an auth response to force a client
     * redirect. always - always send refer wronghost - send refer if only if
     * the account being authenticated does not live on this mail host
     * reverse-proxied - reverse proxy is in place and should never send
     * refer
     *
     * <p>Valid values: [always, wronghost, reverse-proxied]
     *
     * @return zimbraMailReferMode, or ZAttrProvisioning.MailReferMode.reverse_proxied if unset and/or has invalid value
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=613)
    public ZAttrProvisioning.MailReferMode getMailReferMode() {
        try { String v = getAttr(Provisioning.A_zimbraMailReferMode, true, true); return v == null ? ZAttrProvisioning.MailReferMode.reverse_proxied : ZAttrProvisioning.MailReferMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MailReferMode.reverse_proxied; }
    }

    /**
     * whether to send back a refer tag in an auth response to force a client
     * redirect. always - always send refer wronghost - send refer if only if
     * the account being authenticated does not live on this mail host
     * reverse-proxied - reverse proxy is in place and should never send
     * refer
     *
     * <p>Valid values: [always, wronghost, reverse-proxied]
     *
     * @return zimbraMailReferMode, or "reverse-proxied" if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=613)
    public String getMailReferModeAsString() {
        return getAttr(Provisioning.A_zimbraMailReferMode, "reverse-proxied", true);
    }

    /**
     * whether to send back a refer tag in an auth response to force a client
     * redirect. always - always send refer wronghost - send refer if only if
     * the account being authenticated does not live on this mail host
     * reverse-proxied - reverse proxy is in place and should never send
     * refer
     *
     * <p>Valid values: [always, wronghost, reverse-proxied]
     *
     * @param zimbraMailReferMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=613)
    public void setMailReferMode(ZAttrProvisioning.MailReferMode zimbraMailReferMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailReferMode, zimbraMailReferMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to send back a refer tag in an auth response to force a client
     * redirect. always - always send refer wronghost - send refer if only if
     * the account being authenticated does not live on this mail host
     * reverse-proxied - reverse proxy is in place and should never send
     * refer
     *
     * <p>Valid values: [always, wronghost, reverse-proxied]
     *
     * @param zimbraMailReferMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=613)
    public Map<String,Object> setMailReferMode(ZAttrProvisioning.MailReferMode zimbraMailReferMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailReferMode, zimbraMailReferMode.toString());
        return attrs;
    }

    /**
     * whether to send back a refer tag in an auth response to force a client
     * redirect. always - always send refer wronghost - send refer if only if
     * the account being authenticated does not live on this mail host
     * reverse-proxied - reverse proxy is in place and should never send
     * refer
     *
     * <p>Valid values: [always, wronghost, reverse-proxied]
     *
     * @param zimbraMailReferMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=613)
    public void setMailReferModeAsString(String zimbraMailReferMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailReferMode, zimbraMailReferMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to send back a refer tag in an auth response to force a client
     * redirect. always - always send refer wronghost - send refer if only if
     * the account being authenticated does not live on this mail host
     * reverse-proxied - reverse proxy is in place and should never send
     * refer
     *
     * <p>Valid values: [always, wronghost, reverse-proxied]
     *
     * @param zimbraMailReferMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=613)
    public Map<String,Object> setMailReferModeAsString(String zimbraMailReferMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailReferMode, zimbraMailReferMode);
        return attrs;
    }

    /**
     * whether to send back a refer tag in an auth response to force a client
     * redirect. always - always send refer wronghost - send refer if only if
     * the account being authenticated does not live on this mail host
     * reverse-proxied - reverse proxy is in place and should never send
     * refer
     *
     * <p>Valid values: [always, wronghost, reverse-proxied]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=613)
    public void unsetMailReferMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailReferMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to send back a refer tag in an auth response to force a client
     * redirect. always - always send refer wronghost - send refer if only if
     * the account being authenticated does not live on this mail host
     * reverse-proxied - reverse proxy is in place and should never send
     * refer
     *
     * <p>Valid values: [always, wronghost, reverse-proxied]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=613)
    public Map<String,Object> unsetMailReferMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailReferMode, "");
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @return zimbraMailSSLClientCertMode, or ZAttrProvisioning.MailSSLClientCertMode.Disabled if unset and/or has invalid value
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public ZAttrProvisioning.MailSSLClientCertMode getMailSSLClientCertMode() {
        try { String v = getAttr(Provisioning.A_zimbraMailSSLClientCertMode, true, true); return v == null ? ZAttrProvisioning.MailSSLClientCertMode.Disabled : ZAttrProvisioning.MailSSLClientCertMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MailSSLClientCertMode.Disabled; }
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @return zimbraMailSSLClientCertMode, or "Disabled" if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public String getMailSSLClientCertModeAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLClientCertMode, "Disabled", true);
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param zimbraMailSSLClientCertMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public void setMailSSLClientCertMode(ZAttrProvisioning.MailSSLClientCertMode zimbraMailSSLClientCertMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, zimbraMailSSLClientCertMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param zimbraMailSSLClientCertMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public Map<String,Object> setMailSSLClientCertMode(ZAttrProvisioning.MailSSLClientCertMode zimbraMailSSLClientCertMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, zimbraMailSSLClientCertMode.toString());
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param zimbraMailSSLClientCertMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public void setMailSSLClientCertModeAsString(String zimbraMailSSLClientCertMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, zimbraMailSSLClientCertMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param zimbraMailSSLClientCertMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public Map<String,Object> setMailSSLClientCertModeAsString(String zimbraMailSSLClientCertMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, zimbraMailSSLClientCertMode);
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public void unsetMailSSLClientCertMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate. Disabled: client
     * authentication is disabled. NeedClientAuth: client authentication is
     * required during SSL handshake on the SSL mutual authentication
     * port(see zimbraMailSSLClientCertPort). The SSL handshake will fail if
     * the client does not present a certificate to authenticate.
     * WantClientAuth: client authentication is requested during SSL
     * handshake on the SSL mutual authentication port(see
     * zimbraMailSSLClientCertPort). The SSL handshake will still proceed if
     * the client does not present a certificate to authenticate. In the case
     * when client does not send a certificate, user will be redirected to
     * the usual entry page of the requested webapp, where username/password
     * is prompted.
     *
     * <p>Valid values: [Disabled, NeedClientAuth, WantClientAuth]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1190)
    public Map<String,Object> unsetMailSSLClientCertMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertMode, "");
        return attrs;
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @return zimbraMailSSLClientCertOCSPEnabled, or true if unset
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public boolean isMailSSLClientCertOCSPEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, true, true);
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @param zimbraMailSSLClientCertOCSPEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public void setMailSSLClientCertOCSPEnabled(boolean zimbraMailSSLClientCertOCSPEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, zimbraMailSSLClientCertOCSPEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @param zimbraMailSSLClientCertOCSPEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public Map<String,Object> setMailSSLClientCertOCSPEnabled(boolean zimbraMailSSLClientCertOCSPEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, zimbraMailSSLClientCertOCSPEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public void unsetMailSSLClientCertOCSPEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable OCSP support for two way authentication.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1395)
    public Map<String,Object> unsetMailSSLClientCertOCSPEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertOCSPEnabled, "");
        return attrs;
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * <p>Use getMailSSLClientCertPortAsString to access value as a string.
     *
     * @see #getMailSSLClientCertPortAsString()
     *
     * @return zimbraMailSSLClientCertPort, or 9443 if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public int getMailSSLClientCertPort() {
        return getIntAttr(Provisioning.A_zimbraMailSSLClientCertPort, 9443, true);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @return zimbraMailSSLClientCertPort, or "9443" if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public String getMailSSLClientCertPortAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLClientCertPort, "9443", true);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param zimbraMailSSLClientCertPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public void setMailSSLClientCertPort(int zimbraMailSSLClientCertPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, Integer.toString(zimbraMailSSLClientCertPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param zimbraMailSSLClientCertPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public Map<String,Object> setMailSSLClientCertPort(int zimbraMailSSLClientCertPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, Integer.toString(zimbraMailSSLClientCertPort));
        return attrs;
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param zimbraMailSSLClientCertPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public void setMailSSLClientCertPortAsString(String zimbraMailSSLClientCertPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, zimbraMailSSLClientCertPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param zimbraMailSSLClientCertPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public Map<String,Object> setMailSSLClientCertPortAsString(String zimbraMailSSLClientCertPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, zimbraMailSSLClientCertPort);
        return attrs;
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public void unsetMailSSLClientCertPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port requesting client certificate for end-user UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1199)
    public Map<String,Object> unsetMailSSLClientCertPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPort, "");
        return attrs;
    }

    /**
     * Map from a certificate field to a Zimbra account key that can uniquely
     * identify a Zimbra account for client certificate authentication. Value
     * is a comma-separated list of mapping rules, each mapping maps a
     * certificate field to a Zimbra account key. Each is attempted in
     * sequence until a unique account can be resolved. e.g. a value can be:
     * SUBJECTALTNAME_OTHERNAME_UPN=zimbraForeignPrincipal,(uid=%{SUBJECT_CN})
     * value: comma-separated mapping-rule mapping-rule:
     * {cert-field-to-zimbra-key-map} | {LDAP-filter}
     * cert-field-to-zimbra-key-map: {certificate-field}={Zimbra-account-key}
     * certificate-field: SUBJECT_{an RDN attr, e.g. CN}: a RND in DN of
     * Subject SUBJECT_DN: entire DN of Subject SUBJECTALTNAME_OTHERNAME_UPN:
     * UPN(aka Principal Name) in otherName in subjectAltName extension
     * SUBJECTALTNAME_RFC822NAME: rfc822Name in subjectAltName extension
     * Zimbra-account-key: name: primary name or any of the aliases of an
     * account zimbraId: zimbraId of an account zimbraForeignPrincipal:
     * zimbraForeignPrincipal of an account. The matching value on the
     * zimbraForeignPrincipal must be prefixed with &quot;cert
     * {supported-certificate-filed}:&quot; e.g. cert
     * SUBJECTALTNAME_OTHERNAME_UPN:123456@mydomain LDAP-filter: An LDAP
     * filter template with placeholders to be substituted by certificate
     * field values. (objectClass=zimbraAccount) is internally ANDed with the
     * supplied filter. e.g.
     * (|(uid=%{SUBJECT_CN})(mail=%{SUBJECTALTNAME_RFC822NAME})) Note: it is
     * recommended not to use LDAP-filter rule, as it will trigger an LDAP
     * search for each cert auth request. LDAP-filter is disabled by default.
     * To enable it globally, set
     * zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled on global config
     * to TRUE. If LDAP-filter is not enabled, all client certificate
     * authentication will fail on domains configured with LDAP-filter.
     *
     * @return zimbraMailSSLClientCertPrincipalMap, or "SUBJECT_EMAILADDRESS=name" if unset
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1215)
    public String getMailSSLClientCertPrincipalMap() {
        return getAttr(Provisioning.A_zimbraMailSSLClientCertPrincipalMap, "SUBJECT_EMAILADDRESS=name", true);
    }

    /**
     * Map from a certificate field to a Zimbra account key that can uniquely
     * identify a Zimbra account for client certificate authentication. Value
     * is a comma-separated list of mapping rules, each mapping maps a
     * certificate field to a Zimbra account key. Each is attempted in
     * sequence until a unique account can be resolved. e.g. a value can be:
     * SUBJECTALTNAME_OTHERNAME_UPN=zimbraForeignPrincipal,(uid=%{SUBJECT_CN})
     * value: comma-separated mapping-rule mapping-rule:
     * {cert-field-to-zimbra-key-map} | {LDAP-filter}
     * cert-field-to-zimbra-key-map: {certificate-field}={Zimbra-account-key}
     * certificate-field: SUBJECT_{an RDN attr, e.g. CN}: a RND in DN of
     * Subject SUBJECT_DN: entire DN of Subject SUBJECTALTNAME_OTHERNAME_UPN:
     * UPN(aka Principal Name) in otherName in subjectAltName extension
     * SUBJECTALTNAME_RFC822NAME: rfc822Name in subjectAltName extension
     * Zimbra-account-key: name: primary name or any of the aliases of an
     * account zimbraId: zimbraId of an account zimbraForeignPrincipal:
     * zimbraForeignPrincipal of an account. The matching value on the
     * zimbraForeignPrincipal must be prefixed with &quot;cert
     * {supported-certificate-filed}:&quot; e.g. cert
     * SUBJECTALTNAME_OTHERNAME_UPN:123456@mydomain LDAP-filter: An LDAP
     * filter template with placeholders to be substituted by certificate
     * field values. (objectClass=zimbraAccount) is internally ANDed with the
     * supplied filter. e.g.
     * (|(uid=%{SUBJECT_CN})(mail=%{SUBJECTALTNAME_RFC822NAME})) Note: it is
     * recommended not to use LDAP-filter rule, as it will trigger an LDAP
     * search for each cert auth request. LDAP-filter is disabled by default.
     * To enable it globally, set
     * zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled on global config
     * to TRUE. If LDAP-filter is not enabled, all client certificate
     * authentication will fail on domains configured with LDAP-filter.
     *
     * @param zimbraMailSSLClientCertPrincipalMap new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1215)
    public void setMailSSLClientCertPrincipalMap(String zimbraMailSSLClientCertPrincipalMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPrincipalMap, zimbraMailSSLClientCertPrincipalMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Map from a certificate field to a Zimbra account key that can uniquely
     * identify a Zimbra account for client certificate authentication. Value
     * is a comma-separated list of mapping rules, each mapping maps a
     * certificate field to a Zimbra account key. Each is attempted in
     * sequence until a unique account can be resolved. e.g. a value can be:
     * SUBJECTALTNAME_OTHERNAME_UPN=zimbraForeignPrincipal,(uid=%{SUBJECT_CN})
     * value: comma-separated mapping-rule mapping-rule:
     * {cert-field-to-zimbra-key-map} | {LDAP-filter}
     * cert-field-to-zimbra-key-map: {certificate-field}={Zimbra-account-key}
     * certificate-field: SUBJECT_{an RDN attr, e.g. CN}: a RND in DN of
     * Subject SUBJECT_DN: entire DN of Subject SUBJECTALTNAME_OTHERNAME_UPN:
     * UPN(aka Principal Name) in otherName in subjectAltName extension
     * SUBJECTALTNAME_RFC822NAME: rfc822Name in subjectAltName extension
     * Zimbra-account-key: name: primary name or any of the aliases of an
     * account zimbraId: zimbraId of an account zimbraForeignPrincipal:
     * zimbraForeignPrincipal of an account. The matching value on the
     * zimbraForeignPrincipal must be prefixed with &quot;cert
     * {supported-certificate-filed}:&quot; e.g. cert
     * SUBJECTALTNAME_OTHERNAME_UPN:123456@mydomain LDAP-filter: An LDAP
     * filter template with placeholders to be substituted by certificate
     * field values. (objectClass=zimbraAccount) is internally ANDed with the
     * supplied filter. e.g.
     * (|(uid=%{SUBJECT_CN})(mail=%{SUBJECTALTNAME_RFC822NAME})) Note: it is
     * recommended not to use LDAP-filter rule, as it will trigger an LDAP
     * search for each cert auth request. LDAP-filter is disabled by default.
     * To enable it globally, set
     * zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled on global config
     * to TRUE. If LDAP-filter is not enabled, all client certificate
     * authentication will fail on domains configured with LDAP-filter.
     *
     * @param zimbraMailSSLClientCertPrincipalMap new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1215)
    public Map<String,Object> setMailSSLClientCertPrincipalMap(String zimbraMailSSLClientCertPrincipalMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPrincipalMap, zimbraMailSSLClientCertPrincipalMap);
        return attrs;
    }

    /**
     * Map from a certificate field to a Zimbra account key that can uniquely
     * identify a Zimbra account for client certificate authentication. Value
     * is a comma-separated list of mapping rules, each mapping maps a
     * certificate field to a Zimbra account key. Each is attempted in
     * sequence until a unique account can be resolved. e.g. a value can be:
     * SUBJECTALTNAME_OTHERNAME_UPN=zimbraForeignPrincipal,(uid=%{SUBJECT_CN})
     * value: comma-separated mapping-rule mapping-rule:
     * {cert-field-to-zimbra-key-map} | {LDAP-filter}
     * cert-field-to-zimbra-key-map: {certificate-field}={Zimbra-account-key}
     * certificate-field: SUBJECT_{an RDN attr, e.g. CN}: a RND in DN of
     * Subject SUBJECT_DN: entire DN of Subject SUBJECTALTNAME_OTHERNAME_UPN:
     * UPN(aka Principal Name) in otherName in subjectAltName extension
     * SUBJECTALTNAME_RFC822NAME: rfc822Name in subjectAltName extension
     * Zimbra-account-key: name: primary name or any of the aliases of an
     * account zimbraId: zimbraId of an account zimbraForeignPrincipal:
     * zimbraForeignPrincipal of an account. The matching value on the
     * zimbraForeignPrincipal must be prefixed with &quot;cert
     * {supported-certificate-filed}:&quot; e.g. cert
     * SUBJECTALTNAME_OTHERNAME_UPN:123456@mydomain LDAP-filter: An LDAP
     * filter template with placeholders to be substituted by certificate
     * field values. (objectClass=zimbraAccount) is internally ANDed with the
     * supplied filter. e.g.
     * (|(uid=%{SUBJECT_CN})(mail=%{SUBJECTALTNAME_RFC822NAME})) Note: it is
     * recommended not to use LDAP-filter rule, as it will trigger an LDAP
     * search for each cert auth request. LDAP-filter is disabled by default.
     * To enable it globally, set
     * zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled on global config
     * to TRUE. If LDAP-filter is not enabled, all client certificate
     * authentication will fail on domains configured with LDAP-filter.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1215)
    public void unsetMailSSLClientCertPrincipalMap() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPrincipalMap, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Map from a certificate field to a Zimbra account key that can uniquely
     * identify a Zimbra account for client certificate authentication. Value
     * is a comma-separated list of mapping rules, each mapping maps a
     * certificate field to a Zimbra account key. Each is attempted in
     * sequence until a unique account can be resolved. e.g. a value can be:
     * SUBJECTALTNAME_OTHERNAME_UPN=zimbraForeignPrincipal,(uid=%{SUBJECT_CN})
     * value: comma-separated mapping-rule mapping-rule:
     * {cert-field-to-zimbra-key-map} | {LDAP-filter}
     * cert-field-to-zimbra-key-map: {certificate-field}={Zimbra-account-key}
     * certificate-field: SUBJECT_{an RDN attr, e.g. CN}: a RND in DN of
     * Subject SUBJECT_DN: entire DN of Subject SUBJECTALTNAME_OTHERNAME_UPN:
     * UPN(aka Principal Name) in otherName in subjectAltName extension
     * SUBJECTALTNAME_RFC822NAME: rfc822Name in subjectAltName extension
     * Zimbra-account-key: name: primary name or any of the aliases of an
     * account zimbraId: zimbraId of an account zimbraForeignPrincipal:
     * zimbraForeignPrincipal of an account. The matching value on the
     * zimbraForeignPrincipal must be prefixed with &quot;cert
     * {supported-certificate-filed}:&quot; e.g. cert
     * SUBJECTALTNAME_OTHERNAME_UPN:123456@mydomain LDAP-filter: An LDAP
     * filter template with placeholders to be substituted by certificate
     * field values. (objectClass=zimbraAccount) is internally ANDed with the
     * supplied filter. e.g.
     * (|(uid=%{SUBJECT_CN})(mail=%{SUBJECTALTNAME_RFC822NAME})) Note: it is
     * recommended not to use LDAP-filter rule, as it will trigger an LDAP
     * search for each cert auth request. LDAP-filter is disabled by default.
     * To enable it globally, set
     * zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled on global config
     * to TRUE. If LDAP-filter is not enabled, all client certificate
     * authentication will fail on domains configured with LDAP-filter.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1215)
    public Map<String,Object> unsetMailSSLClientCertPrincipalMap(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPrincipalMap, "");
        return attrs;
    }

    /**
     * whether to enable LDAP-filter in zimbraMailSSLClientCertPrincipalMap
     *
     * @return zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled, or false if unset
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1216)
    public boolean isMailSSLClientCertPrincipalMapLdapFilterEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled, false, true);
    }

    /**
     * whether to enable LDAP-filter in zimbraMailSSLClientCertPrincipalMap
     *
     * @param zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1216)
    public void setMailSSLClientCertPrincipalMapLdapFilterEnabled(boolean zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled, zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable LDAP-filter in zimbraMailSSLClientCertPrincipalMap
     *
     * @param zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1216)
    public Map<String,Object> setMailSSLClientCertPrincipalMapLdapFilterEnabled(boolean zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled, zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to enable LDAP-filter in zimbraMailSSLClientCertPrincipalMap
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1216)
    public void unsetMailSSLClientCertPrincipalMapLdapFilterEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to enable LDAP-filter in zimbraMailSSLClientCertPrincipalMap
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.2
     */
    @ZAttr(id=1216)
    public Map<String,Object> unsetMailSSLClientCertPrincipalMapLdapFilterEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLClientCertPrincipalMapLdapFilterEnabled, "");
        return attrs;
    }

    /**
     * SSL port for end-user UI
     *
     * <p>Use getMailSSLPortAsString to access value as a string.
     *
     * @see #getMailSSLPortAsString()
     *
     * @return zimbraMailSSLPort, or 0 if unset
     */
    @ZAttr(id=166)
    public int getMailSSLPort() {
        return getIntAttr(Provisioning.A_zimbraMailSSLPort, 0, true);
    }

    /**
     * SSL port for end-user UI
     *
     * @return zimbraMailSSLPort, or "0" if unset
     */
    @ZAttr(id=166)
    public String getMailSSLPortAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLPort, "0", true);
    }

    /**
     * SSL port for end-user UI
     *
     * @param zimbraMailSSLPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=166)
    public void setMailSSLPort(int zimbraMailSSLPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, Integer.toString(zimbraMailSSLPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for end-user UI
     *
     * @param zimbraMailSSLPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=166)
    public Map<String,Object> setMailSSLPort(int zimbraMailSSLPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, Integer.toString(zimbraMailSSLPort));
        return attrs;
    }

    /**
     * SSL port for end-user UI
     *
     * @param zimbraMailSSLPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=166)
    public void setMailSSLPortAsString(String zimbraMailSSLPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, zimbraMailSSLPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for end-user UI
     *
     * @param zimbraMailSSLPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=166)
    public Map<String,Object> setMailSSLPortAsString(String zimbraMailSSLPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, zimbraMailSSLPort);
        return attrs;
    }

    /**
     * SSL port for end-user UI
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=166)
    public void unsetMailSSLPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port for end-user UI
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=166)
    public Map<String,Object> unsetMailSSLPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLPort, "");
        return attrs;
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * <p>Use getMailSSLProxyClientCertPortAsString to access value as a string.
     *
     * @see #getMailSSLProxyClientCertPortAsString()
     *
     * @return zimbraMailSSLProxyClientCertPort, or 3443 if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public int getMailSSLProxyClientCertPort() {
        return getIntAttr(Provisioning.A_zimbraMailSSLProxyClientCertPort, 3443, true);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @return zimbraMailSSLProxyClientCertPort, or "3443" if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public String getMailSSLProxyClientCertPortAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLProxyClientCertPort, "3443", true);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param zimbraMailSSLProxyClientCertPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public void setMailSSLProxyClientCertPort(int zimbraMailSSLProxyClientCertPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, Integer.toString(zimbraMailSSLProxyClientCertPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param zimbraMailSSLProxyClientCertPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public Map<String,Object> setMailSSLProxyClientCertPort(int zimbraMailSSLProxyClientCertPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, Integer.toString(zimbraMailSSLProxyClientCertPort));
        return attrs;
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param zimbraMailSSLProxyClientCertPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public void setMailSSLProxyClientCertPortAsString(String zimbraMailSSLProxyClientCertPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, zimbraMailSSLProxyClientCertPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param zimbraMailSSLProxyClientCertPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public Map<String,Object> setMailSSLProxyClientCertPortAsString(String zimbraMailSSLProxyClientCertPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, zimbraMailSSLProxyClientCertPort);
        return attrs;
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public void unsetMailSSLProxyClientCertPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL client certificate port for HTTP proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1212)
    public Map<String,Object> unsetMailSSLProxyClientCertPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyClientCertPort, "");
        return attrs;
    }

    /**
     * SSL port HTTP proxy
     *
     * <p>Use getMailSSLProxyPortAsString to access value as a string.
     *
     * @see #getMailSSLProxyPortAsString()
     *
     * @return zimbraMailSSLProxyPort, or 0 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=627)
    public int getMailSSLProxyPort() {
        return getIntAttr(Provisioning.A_zimbraMailSSLProxyPort, 0, true);
    }

    /**
     * SSL port HTTP proxy
     *
     * @return zimbraMailSSLProxyPort, or "0" if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=627)
    public String getMailSSLProxyPortAsString() {
        return getAttr(Provisioning.A_zimbraMailSSLProxyPort, "0", true);
    }

    /**
     * SSL port HTTP proxy
     *
     * @param zimbraMailSSLProxyPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=627)
    public void setMailSSLProxyPort(int zimbraMailSSLProxyPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyPort, Integer.toString(zimbraMailSSLProxyPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port HTTP proxy
     *
     * @param zimbraMailSSLProxyPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=627)
    public Map<String,Object> setMailSSLProxyPort(int zimbraMailSSLProxyPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyPort, Integer.toString(zimbraMailSSLProxyPort));
        return attrs;
    }

    /**
     * SSL port HTTP proxy
     *
     * @param zimbraMailSSLProxyPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=627)
    public void setMailSSLProxyPortAsString(String zimbraMailSSLProxyPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyPort, zimbraMailSSLProxyPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port HTTP proxy
     *
     * @param zimbraMailSSLProxyPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=627)
    public Map<String,Object> setMailSSLProxyPortAsString(String zimbraMailSSLProxyPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyPort, zimbraMailSSLProxyPort);
        return attrs;
    }

    /**
     * SSL port HTTP proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=627)
    public void unsetMailSSLProxyPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL port HTTP proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=627)
    public Map<String,Object> unsetMailSSLProxyPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSSLProxyPort, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveNotifyActionRFCCompliant, which can be used at account
     * level. Orig desc: Whether the RFC compliant &#039;notify&#039; is
     * used. If TRUE, ZCS parses the &#039;notify&#039; action parameters
     * based on the syntax defined by the RFC 5435 and 5436. If FALSE, ZCS
     * treats the &#039;notify&#039; action parameters with Zimbra specific
     * format
     *
     * @return zimbraMailSieveNotifyActionRFCCompliant, or false if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2095)
    public boolean isMailSieveNotifyActionRFCCompliant() {
        return getBooleanAttr(Provisioning.A_zimbraMailSieveNotifyActionRFCCompliant, false, true);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveNotifyActionRFCCompliant, which can be used at account
     * level. Orig desc: Whether the RFC compliant &#039;notify&#039; is
     * used. If TRUE, ZCS parses the &#039;notify&#039; action parameters
     * based on the syntax defined by the RFC 5435 and 5436. If FALSE, ZCS
     * treats the &#039;notify&#039; action parameters with Zimbra specific
     * format
     *
     * @param zimbraMailSieveNotifyActionRFCCompliant new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2095)
    public void setMailSieveNotifyActionRFCCompliant(boolean zimbraMailSieveNotifyActionRFCCompliant) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSieveNotifyActionRFCCompliant, zimbraMailSieveNotifyActionRFCCompliant ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveNotifyActionRFCCompliant, which can be used at account
     * level. Orig desc: Whether the RFC compliant &#039;notify&#039; is
     * used. If TRUE, ZCS parses the &#039;notify&#039; action parameters
     * based on the syntax defined by the RFC 5435 and 5436. If FALSE, ZCS
     * treats the &#039;notify&#039; action parameters with Zimbra specific
     * format
     *
     * @param zimbraMailSieveNotifyActionRFCCompliant new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2095)
    public Map<String,Object> setMailSieveNotifyActionRFCCompliant(boolean zimbraMailSieveNotifyActionRFCCompliant, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSieveNotifyActionRFCCompliant, zimbraMailSieveNotifyActionRFCCompliant ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveNotifyActionRFCCompliant, which can be used at account
     * level. Orig desc: Whether the RFC compliant &#039;notify&#039; is
     * used. If TRUE, ZCS parses the &#039;notify&#039; action parameters
     * based on the syntax defined by the RFC 5435 and 5436. If FALSE, ZCS
     * treats the &#039;notify&#039; action parameters with Zimbra specific
     * format
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2095)
    public void unsetMailSieveNotifyActionRFCCompliant() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSieveNotifyActionRFCCompliant, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveNotifyActionRFCCompliant, which can be used at account
     * level. Orig desc: Whether the RFC compliant &#039;notify&#039; is
     * used. If TRUE, ZCS parses the &#039;notify&#039; action parameters
     * based on the syntax defined by the RFC 5435 and 5436. If FALSE, ZCS
     * treats the &#039;notify&#039; action parameters with Zimbra specific
     * format
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2095)
    public Map<String,Object> unsetMailSieveNotifyActionRFCCompliant(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailSieveNotifyActionRFCCompliant, "");
        return attrs;
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @return zimbraMailTrustedIP, or empty array if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public String[] getMailTrustedIP() {
        return getMultiAttr(Provisioning.A_zimbraMailTrustedIP, true, true);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public void setMailTrustedIP(String[] zimbraMailTrustedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public Map<String,Object> setMailTrustedIP(String[] zimbraMailTrustedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        return attrs;
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public void addMailTrustedIP(String zimbraMailTrustedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public Map<String,Object> addMailTrustedIP(String zimbraMailTrustedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        return attrs;
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public void removeMailTrustedIP(String zimbraMailTrustedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param zimbraMailTrustedIP existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public Map<String,Object> removeMailTrustedIP(String zimbraMailTrustedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailTrustedIP, zimbraMailTrustedIP);
        return attrs;
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public void unsetMailTrustedIP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedIP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * In our web app, AJAX and standard html client, we have support for
     * adding the HTTP client IP address as X-Originating-IP in an outbound
     * message. We also use the HTTP client IP address in our logging. In the
     * case of standard client making connections to the SOAP layer, the JSP
     * layer tells the SOAP layer in a http header what the remote HTTP
     * client address is. In the case where nginx or some other proxy layer
     * is fronting our webapps, the proxy tells the SOAP/JSP layers in a http
     * header what the real HTTP client s address is. Our SOAP/JSP layers
     * will trust the client/proxy only if the IP address of the client/proxy
     * is one of the IPs listed in this attribute.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1025)
    public Map<String,Object> unsetMailTrustedIP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailTrustedIP, "");
        return attrs;
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @return zimbraMailURL, or "/" if unset
     */
    @ZAttr(id=340)
    public String getMailURL() {
        return getAttr(Provisioning.A_zimbraMailURL, "/", true);
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @param zimbraMailURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=340)
    public void setMailURL(String zimbraMailURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailURL, zimbraMailURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @param zimbraMailURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=340)
    public Map<String,Object> setMailURL(String zimbraMailURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailURL, zimbraMailURL);
        return attrs;
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=340)
    public void unsetMailURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL prefix for where the zimbra app resides on this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=340)
    public Map<String,Object> unsetMailURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailURL, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of bytes
     * stored in the uncompressed blob cache on disk
     *
     * @return zimbraMailUncompressedCacheMaxBytes, or 1073741824 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=825)
    public long getMailUncompressedCacheMaxBytes() {
        return getLongAttr(Provisioning.A_zimbraMailUncompressedCacheMaxBytes, 1073741824L, true);
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of bytes
     * stored in the uncompressed blob cache on disk
     *
     * @param zimbraMailUncompressedCacheMaxBytes new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=825)
    public void setMailUncompressedCacheMaxBytes(long zimbraMailUncompressedCacheMaxBytes) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUncompressedCacheMaxBytes, Long.toString(zimbraMailUncompressedCacheMaxBytes));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of bytes
     * stored in the uncompressed blob cache on disk
     *
     * @param zimbraMailUncompressedCacheMaxBytes new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=825)
    public Map<String,Object> setMailUncompressedCacheMaxBytes(long zimbraMailUncompressedCacheMaxBytes, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUncompressedCacheMaxBytes, Long.toString(zimbraMailUncompressedCacheMaxBytes));
        return attrs;
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of bytes
     * stored in the uncompressed blob cache on disk
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=825)
    public void unsetMailUncompressedCacheMaxBytes() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUncompressedCacheMaxBytes, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of bytes
     * stored in the uncompressed blob cache on disk
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=825)
    public Map<String,Object> unsetMailUncompressedCacheMaxBytes(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUncompressedCacheMaxBytes, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of files in
     * the uncompressed blob cache on disk
     *
     * @return zimbraMailUncompressedCacheMaxFiles, or 5000 if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=824)
    public int getMailUncompressedCacheMaxFiles() {
        return getIntAttr(Provisioning.A_zimbraMailUncompressedCacheMaxFiles, 5000, true);
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of files in
     * the uncompressed blob cache on disk
     *
     * @param zimbraMailUncompressedCacheMaxFiles new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=824)
    public void setMailUncompressedCacheMaxFiles(int zimbraMailUncompressedCacheMaxFiles) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUncompressedCacheMaxFiles, Integer.toString(zimbraMailUncompressedCacheMaxFiles));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of files in
     * the uncompressed blob cache on disk
     *
     * @param zimbraMailUncompressedCacheMaxFiles new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=824)
    public Map<String,Object> setMailUncompressedCacheMaxFiles(int zimbraMailUncompressedCacheMaxFiles, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUncompressedCacheMaxFiles, Integer.toString(zimbraMailUncompressedCacheMaxFiles));
        return attrs;
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of files in
     * the uncompressed blob cache on disk
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=824)
    public void unsetMailUncompressedCacheMaxFiles() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUncompressedCacheMaxFiles, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.7. Deprecated per bug 43497. The number of
     * uncompressed files on disk will never exceed
     * zimbraMailFileDescriptorCacheSize.. Orig desc: max number of files in
     * the uncompressed blob cache on disk
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=824)
    public Map<String,Object> unsetMailUncompressedCacheMaxFiles(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUncompressedCacheMaxFiles, "");
        return attrs;
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @return zimbraMailUseDirectBuffers, or false if unset
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public boolean isMailUseDirectBuffers() {
        return getBooleanAttr(Provisioning.A_zimbraMailUseDirectBuffers, false, true);
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @param zimbraMailUseDirectBuffers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public void setMailUseDirectBuffers(boolean zimbraMailUseDirectBuffers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUseDirectBuffers, zimbraMailUseDirectBuffers ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @param zimbraMailUseDirectBuffers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public Map<String,Object> setMailUseDirectBuffers(boolean zimbraMailUseDirectBuffers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUseDirectBuffers, zimbraMailUseDirectBuffers ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public void unsetMailUseDirectBuffers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUseDirectBuffers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Used to control whether Java NIO direct buffers are used. Value is
     * propagated to Jetty configuration. In the future, other NIO pieces
     * (IMAP/POP/LMTP) will also honor this.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.22
     */
    @ZAttr(id=1002)
    public Map<String,Object> unsetMailUseDirectBuffers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailUseDirectBuffers, "");
        return attrs;
    }

    /**
     * This attribute is used in the case of a failed mailbox move. It
     * indicates the delay before the cleanup task is executed for the first
     * time. It also indicates the time interval at which the cleanup task
     * will be re-run in case cleanup does not take place in first attempt.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getMailboxMoveFailedCleanupTaskIntervalAsString to access value as a string.
     *
     * @see #getMailboxMoveFailedCleanupTaskIntervalAsString()
     *
     * @return zimbraMailboxMoveFailedCleanupTaskInterval in millseconds, or 1200000 (20m)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2079)
    public long getMailboxMoveFailedCleanupTaskInterval() {
        return getTimeInterval(Provisioning.A_zimbraMailboxMoveFailedCleanupTaskInterval, 1200000L, true);
    }

    /**
     * This attribute is used in the case of a failed mailbox move. It
     * indicates the delay before the cleanup task is executed for the first
     * time. It also indicates the time interval at which the cleanup task
     * will be re-run in case cleanup does not take place in first attempt.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraMailboxMoveFailedCleanupTaskInterval, or "20m" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2079)
    public String getMailboxMoveFailedCleanupTaskIntervalAsString() {
        return getAttr(Provisioning.A_zimbraMailboxMoveFailedCleanupTaskInterval, "20m", true);
    }

    /**
     * This attribute is used in the case of a failed mailbox move. It
     * indicates the delay before the cleanup task is executed for the first
     * time. It also indicates the time interval at which the cleanup task
     * will be re-run in case cleanup does not take place in first attempt.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxMoveFailedCleanupTaskInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2079)
    public void setMailboxMoveFailedCleanupTaskInterval(String zimbraMailboxMoveFailedCleanupTaskInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveFailedCleanupTaskInterval, zimbraMailboxMoveFailedCleanupTaskInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used in the case of a failed mailbox move. It
     * indicates the delay before the cleanup task is executed for the first
     * time. It also indicates the time interval at which the cleanup task
     * will be re-run in case cleanup does not take place in first attempt.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraMailboxMoveFailedCleanupTaskInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2079)
    public Map<String,Object> setMailboxMoveFailedCleanupTaskInterval(String zimbraMailboxMoveFailedCleanupTaskInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveFailedCleanupTaskInterval, zimbraMailboxMoveFailedCleanupTaskInterval);
        return attrs;
    }

    /**
     * This attribute is used in the case of a failed mailbox move. It
     * indicates the delay before the cleanup task is executed for the first
     * time. It also indicates the time interval at which the cleanup task
     * will be re-run in case cleanup does not take place in first attempt.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2079)
    public void unsetMailboxMoveFailedCleanupTaskInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveFailedCleanupTaskInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used in the case of a failed mailbox move. It
     * indicates the delay before the cleanup task is executed for the first
     * time. It also indicates the time interval at which the cleanup task
     * will be re-run in case cleanup does not take place in first attempt.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2079)
    public Map<String,Object> unsetMailboxMoveFailedCleanupTaskInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveFailedCleanupTaskInterval, "");
        return attrs;
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @return zimbraMailboxMoveSkipBlobs, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public boolean isMailboxMoveSkipBlobs() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxMoveSkipBlobs, false, true);
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @param zimbraMailboxMoveSkipBlobs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public void setMailboxMoveSkipBlobs(boolean zimbraMailboxMoveSkipBlobs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipBlobs, zimbraMailboxMoveSkipBlobs ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @param zimbraMailboxMoveSkipBlobs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public Map<String,Object> setMailboxMoveSkipBlobs(boolean zimbraMailboxMoveSkipBlobs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipBlobs, zimbraMailboxMoveSkipBlobs ? TRUE : FALSE);
        return attrs;
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public void unsetMailboxMoveSkipBlobs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipBlobs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude blobs (HSM or not) from mailbox move
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1007)
    public Map<String,Object> unsetMailboxMoveSkipBlobs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipBlobs, "");
        return attrs;
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @return zimbraMailboxMoveSkipHsmBlobs, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public boolean isMailboxMoveSkipHsmBlobs() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, false, true);
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @param zimbraMailboxMoveSkipHsmBlobs new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public void setMailboxMoveSkipHsmBlobs(boolean zimbraMailboxMoveSkipHsmBlobs) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, zimbraMailboxMoveSkipHsmBlobs ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @param zimbraMailboxMoveSkipHsmBlobs new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public Map<String,Object> setMailboxMoveSkipHsmBlobs(boolean zimbraMailboxMoveSkipHsmBlobs, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, zimbraMailboxMoveSkipHsmBlobs ? TRUE : FALSE);
        return attrs;
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public void unsetMailboxMoveSkipHsmBlobs() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude blobs on secondary (HSM) volumes from mailbox move
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1008)
    public Map<String,Object> unsetMailboxMoveSkipHsmBlobs(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipHsmBlobs, "");
        return attrs;
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @return zimbraMailboxMoveSkipSearchIndex, or false if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public boolean isMailboxMoveSkipSearchIndex() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, false, true);
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @param zimbraMailboxMoveSkipSearchIndex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public void setMailboxMoveSkipSearchIndex(boolean zimbraMailboxMoveSkipSearchIndex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, zimbraMailboxMoveSkipSearchIndex ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @param zimbraMailboxMoveSkipSearchIndex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public Map<String,Object> setMailboxMoveSkipSearchIndex(boolean zimbraMailboxMoveSkipSearchIndex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, zimbraMailboxMoveSkipSearchIndex ? TRUE : FALSE);
        return attrs;
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public void unsetMailboxMoveSkipSearchIndex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, exclude search index from mailbox move
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1006)
    public Map<String,Object> unsetMailboxMoveSkipSearchIndex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveSkipSearchIndex, "");
        return attrs;
    }

    /**
     * temp directory for mailbox move
     *
     * @return zimbraMailboxMoveTempDir, or "/opt/zimbra/backup/tmp/mboxmove" if unset
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public String getMailboxMoveTempDir() {
        return getAttr(Provisioning.A_zimbraMailboxMoveTempDir, "/opt/zimbra/backup/tmp/mboxmove", true);
    }

    /**
     * temp directory for mailbox move
     *
     * @param zimbraMailboxMoveTempDir new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public void setMailboxMoveTempDir(String zimbraMailboxMoveTempDir) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveTempDir, zimbraMailboxMoveTempDir);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * temp directory for mailbox move
     *
     * @param zimbraMailboxMoveTempDir new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public Map<String,Object> setMailboxMoveTempDir(String zimbraMailboxMoveTempDir, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveTempDir, zimbraMailboxMoveTempDir);
        return attrs;
    }

    /**
     * temp directory for mailbox move
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public void unsetMailboxMoveTempDir() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveTempDir, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * temp directory for mailbox move
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1175)
    public Map<String,Object> unsetMailboxMoveTempDir(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxMoveTempDir, "");
        return attrs;
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getMailboxThrottleReapIntervalAsString to access value as a string.
     *
     * @see #getMailboxThrottleReapIntervalAsString()
     *
     * @return zimbraMailboxThrottleReapInterval in millseconds, or 60000 (60s)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public long getMailboxThrottleReapInterval() {
        return getTimeInterval(Provisioning.A_zimbraMailboxThrottleReapInterval, 60000L, true);
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraMailboxThrottleReapInterval, or "60s" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public String getMailboxThrottleReapIntervalAsString() {
        return getAttr(Provisioning.A_zimbraMailboxThrottleReapInterval, "60s", true);
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraMailboxThrottleReapInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public void setMailboxThrottleReapInterval(String zimbraMailboxThrottleReapInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThrottleReapInterval, zimbraMailboxThrottleReapInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraMailboxThrottleReapInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public Map<String,Object> setMailboxThrottleReapInterval(String zimbraMailboxThrottleReapInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThrottleReapInterval, zimbraMailboxThrottleReapInterval);
        return attrs;
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public void unsetMailboxThrottleReapInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThrottleReapInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time in milliseconds between IMAP/POP/LMTP rate limiter stale entry
     * cleanup cycle.. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2053)
    public Map<String,Object> unsetMailboxThrottleReapInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxThrottleReapInterval, "");
        return attrs;
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @return zimbraMailboxdSSLProtocols, or empty array if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public String[] getMailboxdSSLProtocols() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMailboxdSSLProtocols, true, true); return value.length > 0 ? value : new String[] {"TLSv1","TLSv1.1","TLSv1.2","SSLv2Hello"};
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public void setMailboxdSSLProtocols(String[] zimbraMailboxdSSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public Map<String,Object> setMailboxdSSLProtocols(String[] zimbraMailboxdSSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        return attrs;
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public void addMailboxdSSLProtocols(String zimbraMailboxdSSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public Map<String,Object> addMailboxdSSLProtocols(String zimbraMailboxdSSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        return attrs;
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public void removeMailboxdSSLProtocols(String zimbraMailboxdSSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param zimbraMailboxdSSLProtocols existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public Map<String,Object> removeMailboxdSSLProtocols(String zimbraMailboxdSSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMailboxdSSLProtocols, zimbraMailboxdSSLProtocols);
        return attrs;
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public void unsetMailboxdSSLProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of SSL/TLS protocols (as documented by SunJSSE Provider Protocols
     * and used in setEnabledProtocols) to be enabled in Jetty for HTTPS,
     * IMAPS, POP3S, and STARTTLS (including LMTP)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1657)
    public Map<String,Object> unsetMailboxdSSLProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLProtocols, "");
        return attrs;
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @return zimbraMailboxdSSLRenegotiationAllowed, or true if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1832)
    public boolean isMailboxdSSLRenegotiationAllowed() {
        return getBooleanAttr(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, true, true);
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @param zimbraMailboxdSSLRenegotiationAllowed new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1832)
    public void setMailboxdSSLRenegotiationAllowed(boolean zimbraMailboxdSSLRenegotiationAllowed) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, zimbraMailboxdSSLRenegotiationAllowed ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @param zimbraMailboxdSSLRenegotiationAllowed new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1832)
    public Map<String,Object> setMailboxdSSLRenegotiationAllowed(boolean zimbraMailboxdSSLRenegotiationAllowed, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, zimbraMailboxdSSLRenegotiationAllowed ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1832)
    public void unsetMailboxdSSLRenegotiationAllowed() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether TLS renegotiation is allowed. See also RFC 5746 and
     * CVE-2011-1473 for concerns about possible SSL renegotiation DoS
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1832)
    public Map<String,Object> unsetMailboxdSSLRenegotiationAllowed(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMailboxdSSLRenegotiationAllowed, "");
        return attrs;
    }

    /**
     * port number on which memcached server should listen
     *
     * <p>Use getMemcachedBindPortAsString to access value as a string.
     *
     * @see #getMemcachedBindPortAsString()
     *
     * @return zimbraMemcachedBindPort, or 11211 if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=580)
    public int getMemcachedBindPort() {
        return getIntAttr(Provisioning.A_zimbraMemcachedBindPort, 11211, true);
    }

    /**
     * port number on which memcached server should listen
     *
     * @return zimbraMemcachedBindPort, or "11211" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=580)
    public String getMemcachedBindPortAsString() {
        return getAttr(Provisioning.A_zimbraMemcachedBindPort, "11211", true);
    }

    /**
     * port number on which memcached server should listen
     *
     * @param zimbraMemcachedBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=580)
    public void setMemcachedBindPort(int zimbraMemcachedBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindPort, Integer.toString(zimbraMemcachedBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which memcached server should listen
     *
     * @param zimbraMemcachedBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=580)
    public Map<String,Object> setMemcachedBindPort(int zimbraMemcachedBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindPort, Integer.toString(zimbraMemcachedBindPort));
        return attrs;
    }

    /**
     * port number on which memcached server should listen
     *
     * @param zimbraMemcachedBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=580)
    public void setMemcachedBindPortAsString(String zimbraMemcachedBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindPort, zimbraMemcachedBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which memcached server should listen
     *
     * @param zimbraMemcachedBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=580)
    public Map<String,Object> setMemcachedBindPortAsString(String zimbraMemcachedBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindPort, zimbraMemcachedBindPort);
        return attrs;
    }

    /**
     * port number on which memcached server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=580)
    public void unsetMemcachedBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which memcached server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=580)
    public Map<String,Object> unsetMemcachedBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedBindPort, "");
        return attrs;
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @return zimbraMemcachedClientBinaryProtocolEnabled, or false if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public boolean isMemcachedClientBinaryProtocolEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, false, true);
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @param zimbraMemcachedClientBinaryProtocolEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public void setMemcachedClientBinaryProtocolEnabled(boolean zimbraMemcachedClientBinaryProtocolEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, zimbraMemcachedClientBinaryProtocolEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @param zimbraMemcachedClientBinaryProtocolEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public Map<String,Object> setMemcachedClientBinaryProtocolEnabled(boolean zimbraMemcachedClientBinaryProtocolEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, zimbraMemcachedClientBinaryProtocolEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public void unsetMemcachedClientBinaryProtocolEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * if true, use binary protocol of memcached; if false, use ascii
     * protocol
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1015)
    public Map<String,Object> unsetMemcachedClientBinaryProtocolEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientBinaryProtocolEnabled, "");
        return attrs;
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @return zimbraMemcachedClientExpirySeconds, or 86400 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public int getMemcachedClientExpirySeconds() {
        return getIntAttr(Provisioning.A_zimbraMemcachedClientExpirySeconds, 86400, true);
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @param zimbraMemcachedClientExpirySeconds new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public void setMemcachedClientExpirySeconds(int zimbraMemcachedClientExpirySeconds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientExpirySeconds, Integer.toString(zimbraMemcachedClientExpirySeconds));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @param zimbraMemcachedClientExpirySeconds new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public Map<String,Object> setMemcachedClientExpirySeconds(int zimbraMemcachedClientExpirySeconds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientExpirySeconds, Integer.toString(zimbraMemcachedClientExpirySeconds));
        return attrs;
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public void unsetMemcachedClientExpirySeconds() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientExpirySeconds, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default expiration time in seconds for memcached values; default is 1
     * day
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1017)
    public Map<String,Object> unsetMemcachedClientExpirySeconds(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientExpirySeconds, "");
        return attrs;
    }

    /**
     * memcached hash algorithm
     *
     * @return zimbraMemcachedClientHashAlgorithm, or "KETAMA_HASH" if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public String getMemcachedClientHashAlgorithm() {
        return getAttr(Provisioning.A_zimbraMemcachedClientHashAlgorithm, "KETAMA_HASH", true);
    }

    /**
     * memcached hash algorithm
     *
     * @param zimbraMemcachedClientHashAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public void setMemcachedClientHashAlgorithm(String zimbraMemcachedClientHashAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientHashAlgorithm, zimbraMemcachedClientHashAlgorithm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * memcached hash algorithm
     *
     * @param zimbraMemcachedClientHashAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public Map<String,Object> setMemcachedClientHashAlgorithm(String zimbraMemcachedClientHashAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientHashAlgorithm, zimbraMemcachedClientHashAlgorithm);
        return attrs;
    }

    /**
     * memcached hash algorithm
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public void unsetMemcachedClientHashAlgorithm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientHashAlgorithm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * memcached hash algorithm
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1016)
    public Map<String,Object> unsetMemcachedClientHashAlgorithm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientHashAlgorithm, "");
        return attrs;
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @return zimbraMemcachedClientServerList, or empty array if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public String[] getMemcachedClientServerList() {
        return getMultiAttr(Provisioning.A_zimbraMemcachedClientServerList, true, true);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public void setMemcachedClientServerList(String[] zimbraMemcachedClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public Map<String,Object> setMemcachedClientServerList(String[] zimbraMemcachedClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        return attrs;
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public void addMemcachedClientServerList(String zimbraMemcachedClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public Map<String,Object> addMemcachedClientServerList(String zimbraMemcachedClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        return attrs;
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public void removeMemcachedClientServerList(String zimbraMemcachedClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param zimbraMemcachedClientServerList existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public Map<String,Object> removeMemcachedClientServerList(String zimbraMemcachedClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMemcachedClientServerList, zimbraMemcachedClientServerList);
        return attrs;
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public void unsetMemcachedClientServerList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientServerList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for memcached servers; set to empty value to disable
     * the use of memcached
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1014)
    public Map<String,Object> unsetMemcachedClientServerList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientServerList, "");
        return attrs;
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @return zimbraMemcachedClientTimeoutMillis, or 10000 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public int getMemcachedClientTimeoutMillis() {
        return getIntAttr(Provisioning.A_zimbraMemcachedClientTimeoutMillis, 10000, true);
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @param zimbraMemcachedClientTimeoutMillis new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public void setMemcachedClientTimeoutMillis(int zimbraMemcachedClientTimeoutMillis) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientTimeoutMillis, Integer.toString(zimbraMemcachedClientTimeoutMillis));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @param zimbraMemcachedClientTimeoutMillis new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public Map<String,Object> setMemcachedClientTimeoutMillis(int zimbraMemcachedClientTimeoutMillis, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientTimeoutMillis, Integer.toString(zimbraMemcachedClientTimeoutMillis));
        return attrs;
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public void unsetMemcachedClientTimeoutMillis() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientTimeoutMillis, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * default timeout in milliseconds for async memcached operations
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1018)
    public Map<String,Object> unsetMemcachedClientTimeoutMillis(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMemcachedClientTimeoutMillis, "");
        return attrs;
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @return zimbraMessageCacheSize, or 2000 if unset
     */
    @ZAttr(id=297)
    public int getMessageCacheSize() {
        return getIntAttr(Provisioning.A_zimbraMessageCacheSize, 2000, true);
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @param zimbraMessageCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=297)
    public void setMessageCacheSize(int zimbraMessageCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageCacheSize, Integer.toString(zimbraMessageCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @param zimbraMessageCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=297)
    public Map<String,Object> setMessageCacheSize(int zimbraMessageCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageCacheSize, Integer.toString(zimbraMessageCacheSize));
        return attrs;
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=297)
    public void unsetMessageCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of JavaMail MimeMessage objects in the message cache.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=297)
    public Map<String,Object> unsetMessageCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageCacheSize, "");
        return attrs;
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @return zimbraMessageChannelEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public boolean isMessageChannelEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMessageChannelEnabled, false, true);
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @param zimbraMessageChannelEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public void setMessageChannelEnabled(boolean zimbraMessageChannelEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelEnabled, zimbraMessageChannelEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @param zimbraMessageChannelEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public Map<String,Object> setMessageChannelEnabled(boolean zimbraMessageChannelEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelEnabled, zimbraMessageChannelEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public void unsetMessageChannelEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether message channel service is enabled on this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1417)
    public Map<String,Object> unsetMessageChannelEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelEnabled, "");
        return attrs;
    }

    /**
     * port number on which message channel should listen
     *
     * @return zimbraMessageChannelPort, or 7285 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public int getMessageChannelPort() {
        return getIntAttr(Provisioning.A_zimbraMessageChannelPort, 7285, true);
    }

    /**
     * port number on which message channel should listen
     *
     * @param zimbraMessageChannelPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public void setMessageChannelPort(int zimbraMessageChannelPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelPort, Integer.toString(zimbraMessageChannelPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which message channel should listen
     *
     * @param zimbraMessageChannelPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public Map<String,Object> setMessageChannelPort(int zimbraMessageChannelPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelPort, Integer.toString(zimbraMessageChannelPort));
        return attrs;
    }

    /**
     * port number on which message channel should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public void unsetMessageChannelPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which message channel should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1415)
    public Map<String,Object> unsetMessageChannelPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageChannelPort, "");
        return attrs;
    }

    /**
     * Number of Message-Id header values to keep in the LMTP dedupe cache.
     * Subsequent attempts to deliver a message with a matching Message-Id to
     * the same mailbox will be ignored. A value of 0 disables deduping.
     *
     * @return zimbraMessageIdDedupeCacheSize, or 3000 if unset
     */
    @ZAttr(id=334)
    public int getMessageIdDedupeCacheSize() {
        return getIntAttr(Provisioning.A_zimbraMessageIdDedupeCacheSize, 3000, true);
    }

    /**
     * Number of Message-Id header values to keep in the LMTP dedupe cache.
     * Subsequent attempts to deliver a message with a matching Message-Id to
     * the same mailbox will be ignored. A value of 0 disables deduping.
     *
     * @param zimbraMessageIdDedupeCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=334)
    public void setMessageIdDedupeCacheSize(int zimbraMessageIdDedupeCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageIdDedupeCacheSize, Integer.toString(zimbraMessageIdDedupeCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of Message-Id header values to keep in the LMTP dedupe cache.
     * Subsequent attempts to deliver a message with a matching Message-Id to
     * the same mailbox will be ignored. A value of 0 disables deduping.
     *
     * @param zimbraMessageIdDedupeCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=334)
    public Map<String,Object> setMessageIdDedupeCacheSize(int zimbraMessageIdDedupeCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageIdDedupeCacheSize, Integer.toString(zimbraMessageIdDedupeCacheSize));
        return attrs;
    }

    /**
     * Number of Message-Id header values to keep in the LMTP dedupe cache.
     * Subsequent attempts to deliver a message with a matching Message-Id to
     * the same mailbox will be ignored. A value of 0 disables deduping.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=334)
    public void unsetMessageIdDedupeCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageIdDedupeCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of Message-Id header values to keep in the LMTP dedupe cache.
     * Subsequent attempts to deliver a message with a matching Message-Id to
     * the same mailbox will be ignored. A value of 0 disables deduping.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=334)
    public Map<String,Object> unsetMessageIdDedupeCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageIdDedupeCacheSize, "");
        return attrs;
    }

    /**
     * Timeout for a Message-Id entry in the LMTP dedupe cache. A value of 0
     * indicates no timeout. zimbraMessageIdDedupeCacheSize limit is ignored
     * when this is set to a non-zero value. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getMessageIdDedupeCacheTimeoutAsString to access value as a string.
     *
     * @see #getMessageIdDedupeCacheTimeoutAsString()
     *
     * @return zimbraMessageIdDedupeCacheTimeout in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1340)
    public long getMessageIdDedupeCacheTimeout() {
        return getTimeInterval(Provisioning.A_zimbraMessageIdDedupeCacheTimeout, 0L, true);
    }

    /**
     * Timeout for a Message-Id entry in the LMTP dedupe cache. A value of 0
     * indicates no timeout. zimbraMessageIdDedupeCacheSize limit is ignored
     * when this is set to a non-zero value. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraMessageIdDedupeCacheTimeout, or "0" if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1340)
    public String getMessageIdDedupeCacheTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraMessageIdDedupeCacheTimeout, "0", true);
    }

    /**
     * Timeout for a Message-Id entry in the LMTP dedupe cache. A value of 0
     * indicates no timeout. zimbraMessageIdDedupeCacheSize limit is ignored
     * when this is set to a non-zero value. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraMessageIdDedupeCacheTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1340)
    public void setMessageIdDedupeCacheTimeout(String zimbraMessageIdDedupeCacheTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageIdDedupeCacheTimeout, zimbraMessageIdDedupeCacheTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for a Message-Id entry in the LMTP dedupe cache. A value of 0
     * indicates no timeout. zimbraMessageIdDedupeCacheSize limit is ignored
     * when this is set to a non-zero value. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraMessageIdDedupeCacheTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1340)
    public Map<String,Object> setMessageIdDedupeCacheTimeout(String zimbraMessageIdDedupeCacheTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageIdDedupeCacheTimeout, zimbraMessageIdDedupeCacheTimeout);
        return attrs;
    }

    /**
     * Timeout for a Message-Id entry in the LMTP dedupe cache. A value of 0
     * indicates no timeout. zimbraMessageIdDedupeCacheSize limit is ignored
     * when this is set to a non-zero value. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1340)
    public void unsetMessageIdDedupeCacheTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageIdDedupeCacheTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Timeout for a Message-Id entry in the LMTP dedupe cache. A value of 0
     * indicates no timeout. zimbraMessageIdDedupeCacheSize limit is ignored
     * when this is set to a non-zero value. . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1340)
    public Map<String,Object> unsetMessageIdDedupeCacheTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMessageIdDedupeCacheTimeout, "");
        return attrs;
    }

    /**
     * port number on which milter server should listen
     *
     * <p>Use getMilterBindPortAsString to access value as a string.
     *
     * @see #getMilterBindPortAsString()
     *
     * @return zimbraMilterBindPort, or 7026 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public int getMilterBindPort() {
        return getIntAttr(Provisioning.A_zimbraMilterBindPort, 7026, true);
    }

    /**
     * port number on which milter server should listen
     *
     * @return zimbraMilterBindPort, or "7026" if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public String getMilterBindPortAsString() {
        return getAttr(Provisioning.A_zimbraMilterBindPort, "7026", true);
    }

    /**
     * port number on which milter server should listen
     *
     * @param zimbraMilterBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public void setMilterBindPort(int zimbraMilterBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, Integer.toString(zimbraMilterBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which milter server should listen
     *
     * @param zimbraMilterBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public Map<String,Object> setMilterBindPort(int zimbraMilterBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, Integer.toString(zimbraMilterBindPort));
        return attrs;
    }

    /**
     * port number on which milter server should listen
     *
     * @param zimbraMilterBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public void setMilterBindPortAsString(String zimbraMilterBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, zimbraMilterBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which milter server should listen
     *
     * @param zimbraMilterBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public Map<String,Object> setMilterBindPortAsString(String zimbraMilterBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, zimbraMilterBindPort);
        return attrs;
    }

    /**
     * port number on which milter server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public void unsetMilterBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which milter server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1114)
    public Map<String,Object> unsetMilterBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterBindPort, "");
        return attrs;
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @return zimbraMilterMaxConnections, or 20000 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public int getMilterMaxConnections() {
        return getIntAttr(Provisioning.A_zimbraMilterMaxConnections, 20000, true);
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @param zimbraMilterMaxConnections new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public void setMilterMaxConnections(int zimbraMilterMaxConnections) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxConnections, Integer.toString(zimbraMilterMaxConnections));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @param zimbraMilterMaxConnections new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public Map<String,Object> setMilterMaxConnections(int zimbraMilterMaxConnections, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxConnections, Integer.toString(zimbraMilterMaxConnections));
        return attrs;
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public void unsetMilterMaxConnections() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxConnections, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent MILTER connections allowed. New
     * connections exceeding this limit are rejected.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1157)
    public Map<String,Object> unsetMilterMaxConnections(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterMaxConnections, "");
        return attrs;
    }

    /**
     * number of milter handler threads
     *
     * @return zimbraMilterNumThreads, or 100 if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public int getMilterNumThreads() {
        return getIntAttr(Provisioning.A_zimbraMilterNumThreads, 100, true);
    }

    /**
     * number of milter handler threads
     *
     * @param zimbraMilterNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public void setMilterNumThreads(int zimbraMilterNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterNumThreads, Integer.toString(zimbraMilterNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of milter handler threads
     *
     * @param zimbraMilterNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public Map<String,Object> setMilterNumThreads(int zimbraMilterNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterNumThreads, Integer.toString(zimbraMilterNumThreads));
        return attrs;
    }

    /**
     * number of milter handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public void unsetMilterNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of milter handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1144)
    public Map<String,Object> unsetMilterNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterNumThreads, "");
        return attrs;
    }

    /**
     * whether milter server is enabled for a given server
     *
     * @return zimbraMilterServerEnabled, or false if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1116)
    public boolean isMilterServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMilterServerEnabled, false, true);
    }

    /**
     * whether milter server is enabled for a given server
     *
     * @param zimbraMilterServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1116)
    public void setMilterServerEnabled(boolean zimbraMilterServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterServerEnabled, zimbraMilterServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether milter server is enabled for a given server
     *
     * @param zimbraMilterServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1116)
    public Map<String,Object> setMilterServerEnabled(boolean zimbraMilterServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterServerEnabled, zimbraMilterServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether milter server is enabled for a given server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1116)
    public void unsetMilterServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether milter server is enabled for a given server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1116)
    public Map<String,Object> unsetMilterServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMilterServerEnabled, "");
        return attrs;
    }

    /**
     * id of the doamin under which (hidden) accounts for apps would be
     * created
     *
     * @return zimbraMobileGatewayDefaultAppAccountDomainId, or null if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1759)
    public String getMobileGatewayDefaultAppAccountDomainId() {
        return getAttr(Provisioning.A_zimbraMobileGatewayDefaultAppAccountDomainId, null, true);
    }

    /**
     * id of the doamin under which (hidden) accounts for apps would be
     * created
     *
     * @param zimbraMobileGatewayDefaultAppAccountDomainId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1759)
    public void setMobileGatewayDefaultAppAccountDomainId(String zimbraMobileGatewayDefaultAppAccountDomainId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayDefaultAppAccountDomainId, zimbraMobileGatewayDefaultAppAccountDomainId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * id of the doamin under which (hidden) accounts for apps would be
     * created
     *
     * @param zimbraMobileGatewayDefaultAppAccountDomainId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1759)
    public Map<String,Object> setMobileGatewayDefaultAppAccountDomainId(String zimbraMobileGatewayDefaultAppAccountDomainId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayDefaultAppAccountDomainId, zimbraMobileGatewayDefaultAppAccountDomainId);
        return attrs;
    }

    /**
     * id of the doamin under which (hidden) accounts for apps would be
     * created
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1759)
    public void unsetMobileGatewayDefaultAppAccountDomainId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayDefaultAppAccountDomainId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * id of the doamin under which (hidden) accounts for apps would be
     * created
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1759)
    public Map<String,Object> unsetMobileGatewayDefaultAppAccountDomainId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayDefaultAppAccountDomainId, "");
        return attrs;
    }

    /**
     * Id of the domain under which &quot;Proxy&quot; accounts would be
     * created. One can configure the system to act as a &quot;Proxy&quot; to
     * another Zimbra system. When the Proxy mode is enabled, some accounts
     * in the system would be syncing mailbox data from a Zimbra account
     * hosted on a different Zimbra system into a data source.
     *
     * @return zimbraMobileGatewayDefaultProxyAccountDomainId, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2029)
    public String getMobileGatewayDefaultProxyAccountDomainId() {
        return getAttr(Provisioning.A_zimbraMobileGatewayDefaultProxyAccountDomainId, null, true);
    }

    /**
     * Id of the domain under which &quot;Proxy&quot; accounts would be
     * created. One can configure the system to act as a &quot;Proxy&quot; to
     * another Zimbra system. When the Proxy mode is enabled, some accounts
     * in the system would be syncing mailbox data from a Zimbra account
     * hosted on a different Zimbra system into a data source.
     *
     * @param zimbraMobileGatewayDefaultProxyAccountDomainId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2029)
    public void setMobileGatewayDefaultProxyAccountDomainId(String zimbraMobileGatewayDefaultProxyAccountDomainId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayDefaultProxyAccountDomainId, zimbraMobileGatewayDefaultProxyAccountDomainId);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Id of the domain under which &quot;Proxy&quot; accounts would be
     * created. One can configure the system to act as a &quot;Proxy&quot; to
     * another Zimbra system. When the Proxy mode is enabled, some accounts
     * in the system would be syncing mailbox data from a Zimbra account
     * hosted on a different Zimbra system into a data source.
     *
     * @param zimbraMobileGatewayDefaultProxyAccountDomainId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2029)
    public Map<String,Object> setMobileGatewayDefaultProxyAccountDomainId(String zimbraMobileGatewayDefaultProxyAccountDomainId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayDefaultProxyAccountDomainId, zimbraMobileGatewayDefaultProxyAccountDomainId);
        return attrs;
    }

    /**
     * Id of the domain under which &quot;Proxy&quot; accounts would be
     * created. One can configure the system to act as a &quot;Proxy&quot; to
     * another Zimbra system. When the Proxy mode is enabled, some accounts
     * in the system would be syncing mailbox data from a Zimbra account
     * hosted on a different Zimbra system into a data source.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2029)
    public void unsetMobileGatewayDefaultProxyAccountDomainId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayDefaultProxyAccountDomainId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Id of the domain under which &quot;Proxy&quot; accounts would be
     * created. One can configure the system to act as a &quot;Proxy&quot; to
     * another Zimbra system. When the Proxy mode is enabled, some accounts
     * in the system would be syncing mailbox data from a Zimbra account
     * hosted on a different Zimbra system into a data source.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2029)
    public Map<String,Object> unsetMobileGatewayDefaultProxyAccountDomainId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayDefaultProxyAccountDomainId, "");
        return attrs;
    }

    /**
     * IMAP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @return zimbraMobileGatewayProxyImapConnectionType, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2032)
    public ZAttrProvisioning.MobileGatewayProxyImapConnectionType getMobileGatewayProxyImapConnectionType() {
        try { String v = getAttr(Provisioning.A_zimbraMobileGatewayProxyImapConnectionType, true, true); return v == null ? null : ZAttrProvisioning.MobileGatewayProxyImapConnectionType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * IMAP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @return zimbraMobileGatewayProxyImapConnectionType, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2032)
    public String getMobileGatewayProxyImapConnectionTypeAsString() {
        return getAttr(Provisioning.A_zimbraMobileGatewayProxyImapConnectionType, null, true);
    }

    /**
     * IMAP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param zimbraMobileGatewayProxyImapConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2032)
    public void setMobileGatewayProxyImapConnectionType(ZAttrProvisioning.MobileGatewayProxyImapConnectionType zimbraMobileGatewayProxyImapConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapConnectionType, zimbraMobileGatewayProxyImapConnectionType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IMAP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param zimbraMobileGatewayProxyImapConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2032)
    public Map<String,Object> setMobileGatewayProxyImapConnectionType(ZAttrProvisioning.MobileGatewayProxyImapConnectionType zimbraMobileGatewayProxyImapConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapConnectionType, zimbraMobileGatewayProxyImapConnectionType.toString());
        return attrs;
    }

    /**
     * IMAP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param zimbraMobileGatewayProxyImapConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2032)
    public void setMobileGatewayProxyImapConnectionTypeAsString(String zimbraMobileGatewayProxyImapConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapConnectionType, zimbraMobileGatewayProxyImapConnectionType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IMAP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param zimbraMobileGatewayProxyImapConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2032)
    public Map<String,Object> setMobileGatewayProxyImapConnectionTypeAsString(String zimbraMobileGatewayProxyImapConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapConnectionType, zimbraMobileGatewayProxyImapConnectionType);
        return attrs;
    }

    /**
     * IMAP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2032)
    public void unsetMobileGatewayProxyImapConnectionType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapConnectionType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IMAP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl, tls, tls_if_available]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2032)
    public Map<String,Object> unsetMobileGatewayProxyImapConnectionType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapConnectionType, "");
        return attrs;
    }

    /**
     * IMAP host name of the Zimbra system being proxied
     *
     * @return zimbraMobileGatewayProxyImapHost, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2030)
    public String getMobileGatewayProxyImapHost() {
        return getAttr(Provisioning.A_zimbraMobileGatewayProxyImapHost, null, true);
    }

    /**
     * IMAP host name of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxyImapHost new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2030)
    public void setMobileGatewayProxyImapHost(String zimbraMobileGatewayProxyImapHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapHost, zimbraMobileGatewayProxyImapHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IMAP host name of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxyImapHost new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2030)
    public Map<String,Object> setMobileGatewayProxyImapHost(String zimbraMobileGatewayProxyImapHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapHost, zimbraMobileGatewayProxyImapHost);
        return attrs;
    }

    /**
     * IMAP host name of the Zimbra system being proxied
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2030)
    public void unsetMobileGatewayProxyImapHost() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapHost, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IMAP host name of the Zimbra system being proxied
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2030)
    public Map<String,Object> unsetMobileGatewayProxyImapHost(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapHost, "");
        return attrs;
    }

    /**
     * IMAP port of the Zimbra system being proxied
     *
     * <p>Use getMobileGatewayProxyImapPortAsString to access value as a string.
     *
     * @see #getMobileGatewayProxyImapPortAsString()
     *
     * @return zimbraMobileGatewayProxyImapPort, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2031)
    public int getMobileGatewayProxyImapPort() {
        return getIntAttr(Provisioning.A_zimbraMobileGatewayProxyImapPort, -1, true);
    }

    /**
     * IMAP port of the Zimbra system being proxied
     *
     * @return zimbraMobileGatewayProxyImapPort, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2031)
    public String getMobileGatewayProxyImapPortAsString() {
        return getAttr(Provisioning.A_zimbraMobileGatewayProxyImapPort, null, true);
    }

    /**
     * IMAP port of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxyImapPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2031)
    public void setMobileGatewayProxyImapPort(int zimbraMobileGatewayProxyImapPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapPort, Integer.toString(zimbraMobileGatewayProxyImapPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IMAP port of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxyImapPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2031)
    public Map<String,Object> setMobileGatewayProxyImapPort(int zimbraMobileGatewayProxyImapPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapPort, Integer.toString(zimbraMobileGatewayProxyImapPort));
        return attrs;
    }

    /**
     * IMAP port of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxyImapPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2031)
    public void setMobileGatewayProxyImapPortAsString(String zimbraMobileGatewayProxyImapPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapPort, zimbraMobileGatewayProxyImapPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IMAP port of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxyImapPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2031)
    public Map<String,Object> setMobileGatewayProxyImapPortAsString(String zimbraMobileGatewayProxyImapPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapPort, zimbraMobileGatewayProxyImapPort);
        return attrs;
    }

    /**
     * IMAP port of the Zimbra system being proxied
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2031)
    public void unsetMobileGatewayProxyImapPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * IMAP port of the Zimbra system being proxied
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2031)
    public Map<String,Object> unsetMobileGatewayProxyImapPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxyImapPort, "");
        return attrs;
    }

    /**
     * SMTP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl]
     *
     * @return zimbraMobileGatewayProxySmtpConnectionType, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2035)
    public ZAttrProvisioning.MobileGatewayProxySmtpConnectionType getMobileGatewayProxySmtpConnectionType() {
        try { String v = getAttr(Provisioning.A_zimbraMobileGatewayProxySmtpConnectionType, true, true); return v == null ? null : ZAttrProvisioning.MobileGatewayProxySmtpConnectionType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * SMTP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl]
     *
     * @return zimbraMobileGatewayProxySmtpConnectionType, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2035)
    public String getMobileGatewayProxySmtpConnectionTypeAsString() {
        return getAttr(Provisioning.A_zimbraMobileGatewayProxySmtpConnectionType, null, true);
    }

    /**
     * SMTP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl]
     *
     * @param zimbraMobileGatewayProxySmtpConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2035)
    public void setMobileGatewayProxySmtpConnectionType(ZAttrProvisioning.MobileGatewayProxySmtpConnectionType zimbraMobileGatewayProxySmtpConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpConnectionType, zimbraMobileGatewayProxySmtpConnectionType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl]
     *
     * @param zimbraMobileGatewayProxySmtpConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2035)
    public Map<String,Object> setMobileGatewayProxySmtpConnectionType(ZAttrProvisioning.MobileGatewayProxySmtpConnectionType zimbraMobileGatewayProxySmtpConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpConnectionType, zimbraMobileGatewayProxySmtpConnectionType.toString());
        return attrs;
    }

    /**
     * SMTP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl]
     *
     * @param zimbraMobileGatewayProxySmtpConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2035)
    public void setMobileGatewayProxySmtpConnectionTypeAsString(String zimbraMobileGatewayProxySmtpConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpConnectionType, zimbraMobileGatewayProxySmtpConnectionType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl]
     *
     * @param zimbraMobileGatewayProxySmtpConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2035)
    public Map<String,Object> setMobileGatewayProxySmtpConnectionTypeAsString(String zimbraMobileGatewayProxySmtpConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpConnectionType, zimbraMobileGatewayProxySmtpConnectionType);
        return attrs;
    }

    /**
     * SMTP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2035)
    public void unsetMobileGatewayProxySmtpConnectionType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpConnectionType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP connection type of the Zimbra system being proxied
     *
     * <p>Valid values: [cleartext, ssl]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2035)
    public Map<String,Object> unsetMobileGatewayProxySmtpConnectionType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpConnectionType, "");
        return attrs;
    }

    /**
     * SMTP host name of the Zimbra system being proxied
     *
     * @return zimbraMobileGatewayProxySmtpHost, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2033)
    public String getMobileGatewayProxySmtpHost() {
        return getAttr(Provisioning.A_zimbraMobileGatewayProxySmtpHost, null, true);
    }

    /**
     * SMTP host name of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxySmtpHost new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2033)
    public void setMobileGatewayProxySmtpHost(String zimbraMobileGatewayProxySmtpHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpHost, zimbraMobileGatewayProxySmtpHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP host name of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxySmtpHost new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2033)
    public Map<String,Object> setMobileGatewayProxySmtpHost(String zimbraMobileGatewayProxySmtpHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpHost, zimbraMobileGatewayProxySmtpHost);
        return attrs;
    }

    /**
     * SMTP host name of the Zimbra system being proxied
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2033)
    public void unsetMobileGatewayProxySmtpHost() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpHost, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP host name of the Zimbra system being proxied
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2033)
    public Map<String,Object> unsetMobileGatewayProxySmtpHost(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpHost, "");
        return attrs;
    }

    /**
     * SMTP port of the Zimbra system being proxied
     *
     * <p>Use getMobileGatewayProxySmtpPortAsString to access value as a string.
     *
     * @see #getMobileGatewayProxySmtpPortAsString()
     *
     * @return zimbraMobileGatewayProxySmtpPort, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2034)
    public int getMobileGatewayProxySmtpPort() {
        return getIntAttr(Provisioning.A_zimbraMobileGatewayProxySmtpPort, -1, true);
    }

    /**
     * SMTP port of the Zimbra system being proxied
     *
     * @return zimbraMobileGatewayProxySmtpPort, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2034)
    public String getMobileGatewayProxySmtpPortAsString() {
        return getAttr(Provisioning.A_zimbraMobileGatewayProxySmtpPort, null, true);
    }

    /**
     * SMTP port of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxySmtpPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2034)
    public void setMobileGatewayProxySmtpPort(int zimbraMobileGatewayProxySmtpPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpPort, Integer.toString(zimbraMobileGatewayProxySmtpPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP port of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxySmtpPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2034)
    public Map<String,Object> setMobileGatewayProxySmtpPort(int zimbraMobileGatewayProxySmtpPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpPort, Integer.toString(zimbraMobileGatewayProxySmtpPort));
        return attrs;
    }

    /**
     * SMTP port of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxySmtpPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2034)
    public void setMobileGatewayProxySmtpPortAsString(String zimbraMobileGatewayProxySmtpPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpPort, zimbraMobileGatewayProxySmtpPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP port of the Zimbra system being proxied
     *
     * @param zimbraMobileGatewayProxySmtpPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2034)
    public Map<String,Object> setMobileGatewayProxySmtpPortAsString(String zimbraMobileGatewayProxySmtpPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpPort, zimbraMobileGatewayProxySmtpPort);
        return attrs;
    }

    /**
     * SMTP port of the Zimbra system being proxied
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2034)
    public void unsetMobileGatewayProxySmtpPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP port of the Zimbra system being proxied
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2034)
    public Map<String,Object> unsetMobileGatewayProxySmtpPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileGatewayProxySmtpPort, "");
        return attrs;
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @return zimbraMobileItemsToTrackPerFolderMaxSize, or empty array if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public String[] getMobileItemsToTrackPerFolderMaxSize() {
        return getMultiAttr(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, true, true);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public void setMobileItemsToTrackPerFolderMaxSize(String[] zimbraMobileItemsToTrackPerFolderMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public Map<String,Object> setMobileItemsToTrackPerFolderMaxSize(String[] zimbraMobileItemsToTrackPerFolderMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        return attrs;
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public void addMobileItemsToTrackPerFolderMaxSize(String zimbraMobileItemsToTrackPerFolderMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public Map<String,Object> addMobileItemsToTrackPerFolderMaxSize(String zimbraMobileItemsToTrackPerFolderMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        return attrs;
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public void removeMobileItemsToTrackPerFolderMaxSize(String zimbraMobileItemsToTrackPerFolderMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param zimbraMobileItemsToTrackPerFolderMaxSize existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public Map<String,Object> removeMobileItemsToTrackPerFolderMaxSize(String zimbraMobileItemsToTrackPerFolderMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, zimbraMobileItemsToTrackPerFolderMaxSize);
        return attrs;
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public void unsetMobileItemsToTrackPerFolderMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max size of items in a folder that server tracks, categorized by
     * collection type (Email,Calendar,Contacts,Tasks). e.g. Email:3000 makes
     * the max size of items to track for an Email folder to be 3000. If not
     * specify, default value is Integer.MAX_VALUE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1426)
    public Map<String,Object> unsetMobileItemsToTrackPerFolderMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileItemsToTrackPerFolderMaxSize, "");
        return attrs;
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. 0 means no limit
     *
     * @return zimbraMobileMaxMessageSize, or 10240000 if unset
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public int getMobileMaxMessageSize() {
        return getIntAttr(Provisioning.A_zimbraMobileMaxMessageSize, 10240000, true);
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. 0 means no limit
     *
     * @param zimbraMobileMaxMessageSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public void setMobileMaxMessageSize(int zimbraMobileMaxMessageSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMaxMessageSize, Integer.toString(zimbraMobileMaxMessageSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. 0 means no limit
     *
     * @param zimbraMobileMaxMessageSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public Map<String,Object> setMobileMaxMessageSize(int zimbraMobileMaxMessageSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMaxMessageSize, Integer.toString(zimbraMobileMaxMessageSize));
        return attrs;
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. 0 means no limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public void unsetMobileMaxMessageSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMaxMessageSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum total size of a mail message that can be synced to device
     * without truncation. 0 means no limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1596)
    public Map<String,Object> unsetMobileMaxMessageSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMaxMessageSize, "");
        return attrs;
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @return zimbraMobileMetadataMaxSizeEnabled, or false if unset
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public boolean isMobileMetadataMaxSizeEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, false, true);
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @param zimbraMobileMetadataMaxSizeEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public void setMobileMetadataMaxSizeEnabled(boolean zimbraMobileMetadataMaxSizeEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, zimbraMobileMetadataMaxSizeEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @param zimbraMobileMetadataMaxSizeEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public Map<String,Object> setMobileMetadataMaxSizeEnabled(boolean zimbraMobileMetadataMaxSizeEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, zimbraMobileMetadataMaxSizeEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public void unsetMobileMetadataMaxSizeEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to enable truncating on client metadata size, if
     * enabled server will only track recent items on client device instead
     * of all
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.3
     */
    @ZAttr(id=1425)
    public Map<String,Object> unsetMobileMetadataMaxSizeEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataMaxSizeEnabled, "");
        return attrs;
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @return zimbraMobileMetadataRetentionPolicy, or "180:30:1" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public String getMobileMetadataRetentionPolicy() {
        return getAttr(Provisioning.A_zimbraMobileMetadataRetentionPolicy, "180:30:1", true);
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @param zimbraMobileMetadataRetentionPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public void setMobileMetadataRetentionPolicy(String zimbraMobileMetadataRetentionPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataRetentionPolicy, zimbraMobileMetadataRetentionPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @param zimbraMobileMetadataRetentionPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public Map<String,Object> setMobileMetadataRetentionPolicy(String zimbraMobileMetadataRetentionPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataRetentionPolicy, zimbraMobileMetadataRetentionPolicy);
        return attrs;
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public void unsetMobileMetadataRetentionPolicy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataRetentionPolicy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Retention policy for stale mobile metadata. Format is
     * &quot;aa:bb:c&quot;, &quot;aa&quot; being the number of days to define
     * stale data. e.g. 180 means if device&#039;s last_used_date is 180 days
     * ago, its metadata need to be removed. &quot;bb&quot; being the days
     * between two retentions are run, e.g. 30 means to run retention every
     * 30 days. &quot;hh&quot; being the hour of day to run retention, from 0
     * to 23. e.g. 1 means to run retention at some time between 1am and 2am.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1617)
    public Map<String,Object> unsetMobileMetadataRetentionPolicy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMobileMetadataRetentionPolicy, "");
        return attrs;
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @return zimbraMtaAddressVerifyNegativeRefreshTime, or "10m" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public String getMtaAddressVerifyNegativeRefreshTime() {
        return getAttr(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, "10m", true);
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @param zimbraMtaAddressVerifyNegativeRefreshTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public void setMtaAddressVerifyNegativeRefreshTime(String zimbraMtaAddressVerifyNegativeRefreshTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, zimbraMtaAddressVerifyNegativeRefreshTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @param zimbraMtaAddressVerifyNegativeRefreshTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public Map<String,Object> setMtaAddressVerifyNegativeRefreshTime(String zimbraMtaAddressVerifyNegativeRefreshTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, zimbraMtaAddressVerifyNegativeRefreshTime);
        return attrs;
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public void unsetMtaAddressVerifyNegativeRefreshTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_negative_refresh_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1609)
    public Map<String,Object> unsetMtaAddressVerifyNegativeRefreshTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyNegativeRefreshTime, "");
        return attrs;
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @return zimbraMtaAddressVerifyPollCount, or "${stress?3}${stress:5}" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public String getMtaAddressVerifyPollCount() {
        return getAttr(Provisioning.A_zimbraMtaAddressVerifyPollCount, "${stress?3}${stress:5}", true);
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @param zimbraMtaAddressVerifyPollCount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public void setMtaAddressVerifyPollCount(String zimbraMtaAddressVerifyPollCount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollCount, zimbraMtaAddressVerifyPollCount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @param zimbraMtaAddressVerifyPollCount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public Map<String,Object> setMtaAddressVerifyPollCount(String zimbraMtaAddressVerifyPollCount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollCount, zimbraMtaAddressVerifyPollCount);
        return attrs;
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public void unsetMtaAddressVerifyPollCount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollCount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_poll_count
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1607)
    public Map<String,Object> unsetMtaAddressVerifyPollCount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollCount, "");
        return attrs;
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @return zimbraMtaAddressVerifyPollDelay, or "3s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public String getMtaAddressVerifyPollDelay() {
        return getAttr(Provisioning.A_zimbraMtaAddressVerifyPollDelay, "3s", true);
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @param zimbraMtaAddressVerifyPollDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public void setMtaAddressVerifyPollDelay(String zimbraMtaAddressVerifyPollDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollDelay, zimbraMtaAddressVerifyPollDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @param zimbraMtaAddressVerifyPollDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public Map<String,Object> setMtaAddressVerifyPollDelay(String zimbraMtaAddressVerifyPollDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollDelay, zimbraMtaAddressVerifyPollDelay);
        return attrs;
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public void unsetMtaAddressVerifyPollDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_poll_delay
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1608)
    public Map<String,Object> unsetMtaAddressVerifyPollDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPollDelay, "");
        return attrs;
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @return zimbraMtaAddressVerifyPositiveRefreshTime, or "12h" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public String getMtaAddressVerifyPositiveRefreshTime() {
        return getAttr(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, "12h", true);
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @param zimbraMtaAddressVerifyPositiveRefreshTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public void setMtaAddressVerifyPositiveRefreshTime(String zimbraMtaAddressVerifyPositiveRefreshTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, zimbraMtaAddressVerifyPositiveRefreshTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @param zimbraMtaAddressVerifyPositiveRefreshTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public Map<String,Object> setMtaAddressVerifyPositiveRefreshTime(String zimbraMtaAddressVerifyPositiveRefreshTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, zimbraMtaAddressVerifyPositiveRefreshTime);
        return attrs;
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public void unsetMtaAddressVerifyPositiveRefreshTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf address_verify_positive_refresh_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1610)
    public Map<String,Object> unsetMtaAddressVerifyPositiveRefreshTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAddressVerifyPositiveRefreshTime, "");
        return attrs;
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @return zimbraMtaAliasMaps, or "lmdb:/etc/aliases" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public String getMtaAliasMaps() {
        return getAttr(Provisioning.A_zimbraMtaAliasMaps, "lmdb:/etc/aliases", true);
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @param zimbraMtaAliasMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public void setMtaAliasMaps(String zimbraMtaAliasMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAliasMaps, zimbraMtaAliasMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @param zimbraMtaAliasMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public Map<String,Object> setMtaAliasMaps(String zimbraMtaAliasMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAliasMaps, zimbraMtaAliasMaps);
        return attrs;
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public void unsetMtaAliasMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAliasMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf alias_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1493)
    public Map<String,Object> unsetMtaAliasMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAliasMaps, "");
        return attrs;
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaAlwaysAddMissingHeaders, or ZAttrProvisioning.MtaAlwaysAddMissingHeaders.yes if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public ZAttrProvisioning.MtaAlwaysAddMissingHeaders getMtaAlwaysAddMissingHeaders() {
        try { String v = getAttr(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, true, true); return v == null ? ZAttrProvisioning.MtaAlwaysAddMissingHeaders.yes : ZAttrProvisioning.MtaAlwaysAddMissingHeaders.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaAlwaysAddMissingHeaders.yes; }
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaAlwaysAddMissingHeaders, or "yes" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public String getMtaAlwaysAddMissingHeadersAsString() {
        return getAttr(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, "yes", true);
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaAlwaysAddMissingHeaders new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public void setMtaAlwaysAddMissingHeaders(ZAttrProvisioning.MtaAlwaysAddMissingHeaders zimbraMtaAlwaysAddMissingHeaders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, zimbraMtaAlwaysAddMissingHeaders.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaAlwaysAddMissingHeaders new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public Map<String,Object> setMtaAlwaysAddMissingHeaders(ZAttrProvisioning.MtaAlwaysAddMissingHeaders zimbraMtaAlwaysAddMissingHeaders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, zimbraMtaAlwaysAddMissingHeaders.toString());
        return attrs;
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaAlwaysAddMissingHeaders new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public void setMtaAlwaysAddMissingHeadersAsString(String zimbraMtaAlwaysAddMissingHeaders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, zimbraMtaAlwaysAddMissingHeaders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaAlwaysAddMissingHeaders new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public Map<String,Object> setMtaAlwaysAddMissingHeadersAsString(String zimbraMtaAlwaysAddMissingHeaders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, zimbraMtaAlwaysAddMissingHeaders);
        return attrs;
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public void unsetMtaAlwaysAddMissingHeaders() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf always_add_missing_headers
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1494)
    public Map<String,Object> unsetMtaAlwaysAddMissingHeaders(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAlwaysAddMissingHeaders, "");
        return attrs;
    }

    /**
     * mta anti spam lock method.
     *
     * @return zimbraMtaAntiSpamLockMethod, or "flock" if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=612)
    public String getMtaAntiSpamLockMethod() {
        return getAttr(Provisioning.A_zimbraMtaAntiSpamLockMethod, "flock", true);
    }

    /**
     * mta anti spam lock method.
     *
     * @param zimbraMtaAntiSpamLockMethod new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=612)
    public void setMtaAntiSpamLockMethod(String zimbraMtaAntiSpamLockMethod) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAntiSpamLockMethod, zimbraMtaAntiSpamLockMethod);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mta anti spam lock method.
     *
     * @param zimbraMtaAntiSpamLockMethod new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=612)
    public Map<String,Object> setMtaAntiSpamLockMethod(String zimbraMtaAntiSpamLockMethod, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAntiSpamLockMethod, zimbraMtaAntiSpamLockMethod);
        return attrs;
    }

    /**
     * mta anti spam lock method.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=612)
    public void unsetMtaAntiSpamLockMethod() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAntiSpamLockMethod, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mta anti spam lock method.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=612)
    public Map<String,Object> unsetMtaAntiSpamLockMethod(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAntiSpamLockMethod, "");
        return attrs;
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; if empty, binds to all interfaces
     *
     * @return zimbraMtaAuthBindAddress, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public String getMtaAuthBindAddress() {
        return getAttr(Provisioning.A_zimbraMtaAuthBindAddress, null, true);
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; if empty, binds to all interfaces
     *
     * @param zimbraMtaAuthBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public void setMtaAuthBindAddress(String zimbraMtaAuthBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthBindAddress, zimbraMtaAuthBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; if empty, binds to all interfaces
     *
     * @param zimbraMtaAuthBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public Map<String,Object> setMtaAuthBindAddress(String zimbraMtaAuthBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthBindAddress, zimbraMtaAuthBindAddress);
        return attrs;
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; if empty, binds to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public void unsetMtaAuthBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * interface address on which Admin HTTPS connector for MTA Auth should
     * listen; if empty, binds to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1908)
    public Map<String,Object> unsetMtaAuthBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthBindAddress, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated in favor of
     * zimbraMtaTlsSecurityLevel and zimbraMtaSaslAuthEnable. Orig desc:
     * Value for postconf smtpd_tls_security_level
     *
     * @return zimbraMtaAuthEnabled, or true if unset
     */
    @ZAttr(id=194)
    public boolean isMtaAuthEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMtaAuthEnabled, true, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated in favor of
     * zimbraMtaTlsSecurityLevel and zimbraMtaSaslAuthEnable. Orig desc:
     * Value for postconf smtpd_tls_security_level
     *
     * @param zimbraMtaAuthEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=194)
    public void setMtaAuthEnabled(boolean zimbraMtaAuthEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthEnabled, zimbraMtaAuthEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated in favor of
     * zimbraMtaTlsSecurityLevel and zimbraMtaSaslAuthEnable. Orig desc:
     * Value for postconf smtpd_tls_security_level
     *
     * @param zimbraMtaAuthEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=194)
    public Map<String,Object> setMtaAuthEnabled(boolean zimbraMtaAuthEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthEnabled, zimbraMtaAuthEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated in favor of
     * zimbraMtaTlsSecurityLevel and zimbraMtaSaslAuthEnable. Orig desc:
     * Value for postconf smtpd_tls_security_level
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=194)
    public void unsetMtaAuthEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated in favor of
     * zimbraMtaTlsSecurityLevel and zimbraMtaSaslAuthEnable. Orig desc:
     * Value for postconf smtpd_tls_security_level
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=194)
    public Map<String,Object> unsetMtaAuthEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @return zimbraMtaAuthHost, or empty array if unset
     */
    @ZAttr(id=309)
    public String[] getMtaAuthHost() {
        return getMultiAttr(Provisioning.A_zimbraMtaAuthHost, true, true);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @param zimbraMtaAuthHost new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=309)
    public void setMtaAuthHost(String[] zimbraMtaAuthHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthHost, zimbraMtaAuthHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @param zimbraMtaAuthHost new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=309)
    public Map<String,Object> setMtaAuthHost(String[] zimbraMtaAuthHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthHost, zimbraMtaAuthHost);
        return attrs;
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @param zimbraMtaAuthHost new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=309)
    public void addMtaAuthHost(String zimbraMtaAuthHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaAuthHost, zimbraMtaAuthHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @param zimbraMtaAuthHost new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=309)
    public Map<String,Object> addMtaAuthHost(String zimbraMtaAuthHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaAuthHost, zimbraMtaAuthHost);
        return attrs;
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @param zimbraMtaAuthHost existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=309)
    public void removeMtaAuthHost(String zimbraMtaAuthHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaAuthHost, zimbraMtaAuthHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @param zimbraMtaAuthHost existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=309)
    public Map<String,Object> removeMtaAuthHost(String zimbraMtaAuthHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaAuthHost, zimbraMtaAuthHost);
        return attrs;
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=309)
    public void unsetMtaAuthHost() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthHost, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: Host running SOAP service
     * for use by MTA auth. Setting this sets zimbraMtaAuthURL via attr
     * callback mechanism.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=309)
    public Map<String,Object> unsetMtaAuthHost(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthHost, "");
        return attrs;
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * <p>Use getMtaAuthPortAsString to access value as a string.
     *
     * @see #getMtaAuthPortAsString()
     *
     * @return zimbraMtaAuthPort, or 7073 if unset
     *
     * @since ZCS 8.7,9.0.0
     */
    @ZAttr(id=1906)
    public int getMtaAuthPort() {
        return getIntAttr(Provisioning.A_zimbraMtaAuthPort, 7073, true);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @return zimbraMtaAuthPort, or "7073" if unset
     *
     * @since ZCS 8.7,9.0.0
     */
    @ZAttr(id=1906)
    public String getMtaAuthPortAsString() {
        return getAttr(Provisioning.A_zimbraMtaAuthPort, "7073", true);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param zimbraMtaAuthPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7,9.0.0
     */
    @ZAttr(id=1906)
    public void setMtaAuthPort(int zimbraMtaAuthPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, Integer.toString(zimbraMtaAuthPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param zimbraMtaAuthPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7,9.0.0
     */
    @ZAttr(id=1906)
    public Map<String,Object> setMtaAuthPort(int zimbraMtaAuthPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, Integer.toString(zimbraMtaAuthPort));
        return attrs;
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param zimbraMtaAuthPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7,9.0.0
     */
    @ZAttr(id=1906)
    public void setMtaAuthPortAsString(String zimbraMtaAuthPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, zimbraMtaAuthPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param zimbraMtaAuthPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7,9.0.0
     */
    @ZAttr(id=1906)
    public Map<String,Object> setMtaAuthPortAsString(String zimbraMtaAuthPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, zimbraMtaAuthPort);
        return attrs;
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7,9.0.0
     */
    @ZAttr(id=1906)
    public void unsetMtaAuthPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Internal port used by saslauthd to authenticate over SOAP
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7,9.0.0
     */
    @ZAttr(id=1906)
    public Map<String,Object> unsetMtaAuthPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthPort, "");
        return attrs;
    }

    /**
     * whether this server is a mta auth target
     *
     * @return zimbraMtaAuthTarget, or false if unset
     */
    @ZAttr(id=505)
    public boolean isMtaAuthTarget() {
        return getBooleanAttr(Provisioning.A_zimbraMtaAuthTarget, false, true);
    }

    /**
     * whether this server is a mta auth target
     *
     * @param zimbraMtaAuthTarget new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=505)
    public void setMtaAuthTarget(boolean zimbraMtaAuthTarget) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthTarget, zimbraMtaAuthTarget ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this server is a mta auth target
     *
     * @param zimbraMtaAuthTarget new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=505)
    public Map<String,Object> setMtaAuthTarget(boolean zimbraMtaAuthTarget, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthTarget, zimbraMtaAuthTarget ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether this server is a mta auth target
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=505)
    public void unsetMtaAuthTarget() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthTarget, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this server is a mta auth target
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=505)
    public Map<String,Object> unsetMtaAuthTarget(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthTarget, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @return zimbraMtaAuthURL, or empty array if unset
     */
    @ZAttr(id=310)
    public String[] getMtaAuthURL() {
        return getMultiAttr(Provisioning.A_zimbraMtaAuthURL, true, true);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @param zimbraMtaAuthURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=310)
    public void setMtaAuthURL(String[] zimbraMtaAuthURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthURL, zimbraMtaAuthURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @param zimbraMtaAuthURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=310)
    public Map<String,Object> setMtaAuthURL(String[] zimbraMtaAuthURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthURL, zimbraMtaAuthURL);
        return attrs;
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @param zimbraMtaAuthURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=310)
    public void addMtaAuthURL(String zimbraMtaAuthURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaAuthURL, zimbraMtaAuthURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @param zimbraMtaAuthURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=310)
    public Map<String,Object> addMtaAuthURL(String zimbraMtaAuthURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaAuthURL, zimbraMtaAuthURL);
        return attrs;
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @param zimbraMtaAuthURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=310)
    public void removeMtaAuthURL(String zimbraMtaAuthURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaAuthURL, zimbraMtaAuthURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @param zimbraMtaAuthURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=310)
    public Map<String,Object> removeMtaAuthURL(String zimbraMtaAuthURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaAuthURL, zimbraMtaAuthURL);
        return attrs;
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=310)
    public void unsetMtaAuthURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.6. Formally deprecated in 8.6 but has been unused
     * since at least 7.0. MTA now uses all servers which have
     * zimbraMtaAuthTarget set to TRUE. Orig desc: URL at which this MTA (via
     * zimbra saslauthd) should authenticate. Set by setting
     * zimbraMtaAuthHost.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=310)
    public Map<String,Object> unsetMtaAuthURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaAuthURL, "");
        return attrs;
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @return zimbraMtaBlockedExtension, or empty array if unset
     */
    @ZAttr(id=195)
    public String[] getMtaBlockedExtension() {
        return getMultiAttr(Provisioning.A_zimbraMtaBlockedExtension, true, true);
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @param zimbraMtaBlockedExtension new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=195)
    public void setMtaBlockedExtension(String[] zimbraMtaBlockedExtension) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtension, zimbraMtaBlockedExtension);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @param zimbraMtaBlockedExtension new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=195)
    public Map<String,Object> setMtaBlockedExtension(String[] zimbraMtaBlockedExtension, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtension, zimbraMtaBlockedExtension);
        return attrs;
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @param zimbraMtaBlockedExtension new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=195)
    public void addMtaBlockedExtension(String zimbraMtaBlockedExtension) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaBlockedExtension, zimbraMtaBlockedExtension);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @param zimbraMtaBlockedExtension new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=195)
    public Map<String,Object> addMtaBlockedExtension(String zimbraMtaBlockedExtension, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaBlockedExtension, zimbraMtaBlockedExtension);
        return attrs;
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @param zimbraMtaBlockedExtension existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=195)
    public void removeMtaBlockedExtension(String zimbraMtaBlockedExtension) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaBlockedExtension, zimbraMtaBlockedExtension);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @param zimbraMtaBlockedExtension existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=195)
    public Map<String,Object> removeMtaBlockedExtension(String zimbraMtaBlockedExtension, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaBlockedExtension, zimbraMtaBlockedExtension);
        return attrs;
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=195)
    public void unsetMtaBlockedExtension() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtension, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Attachment file extensions that are blocked
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=195)
    public Map<String,Object> unsetMtaBlockedExtension(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtension, "");
        return attrs;
    }

    /**
     * Whether to email admin on detection of attachment with blocked
     * extension
     *
     * @return zimbraMtaBlockedExtensionWarnAdmin, or true if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1031)
    public boolean isMtaBlockedExtensionWarnAdmin() {
        return getBooleanAttr(Provisioning.A_zimbraMtaBlockedExtensionWarnAdmin, true, true);
    }

    /**
     * Whether to email admin on detection of attachment with blocked
     * extension
     *
     * @param zimbraMtaBlockedExtensionWarnAdmin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1031)
    public void setMtaBlockedExtensionWarnAdmin(boolean zimbraMtaBlockedExtensionWarnAdmin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtensionWarnAdmin, zimbraMtaBlockedExtensionWarnAdmin ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to email admin on detection of attachment with blocked
     * extension
     *
     * @param zimbraMtaBlockedExtensionWarnAdmin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1031)
    public Map<String,Object> setMtaBlockedExtensionWarnAdmin(boolean zimbraMtaBlockedExtensionWarnAdmin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtensionWarnAdmin, zimbraMtaBlockedExtensionWarnAdmin ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to email admin on detection of attachment with blocked
     * extension
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1031)
    public void unsetMtaBlockedExtensionWarnAdmin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtensionWarnAdmin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to email admin on detection of attachment with blocked
     * extension
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1031)
    public Map<String,Object> unsetMtaBlockedExtensionWarnAdmin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtensionWarnAdmin, "");
        return attrs;
    }

    /**
     * Whether to email recipient on detection of attachment with blocked
     * extension
     *
     * @return zimbraMtaBlockedExtensionWarnRecipient, or true if unset
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1032)
    public boolean isMtaBlockedExtensionWarnRecipient() {
        return getBooleanAttr(Provisioning.A_zimbraMtaBlockedExtensionWarnRecipient, true, true);
    }

    /**
     * Whether to email recipient on detection of attachment with blocked
     * extension
     *
     * @param zimbraMtaBlockedExtensionWarnRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1032)
    public void setMtaBlockedExtensionWarnRecipient(boolean zimbraMtaBlockedExtensionWarnRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtensionWarnRecipient, zimbraMtaBlockedExtensionWarnRecipient ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to email recipient on detection of attachment with blocked
     * extension
     *
     * @param zimbraMtaBlockedExtensionWarnRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1032)
    public Map<String,Object> setMtaBlockedExtensionWarnRecipient(boolean zimbraMtaBlockedExtensionWarnRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtensionWarnRecipient, zimbraMtaBlockedExtensionWarnRecipient ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to email recipient on detection of attachment with blocked
     * extension
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1032)
    public void unsetMtaBlockedExtensionWarnRecipient() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtensionWarnRecipient, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to email recipient on detection of attachment with blocked
     * extension
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_RC1
     */
    @ZAttr(id=1032)
    public Map<String,Object> unsetMtaBlockedExtensionWarnRecipient(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBlockedExtensionWarnRecipient, "");
        return attrs;
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @return zimbraMtaBounceNoticeRecipient, or "postmaster" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public String getMtaBounceNoticeRecipient() {
        return getAttr(Provisioning.A_zimbraMtaBounceNoticeRecipient, "postmaster", true);
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @param zimbraMtaBounceNoticeRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public void setMtaBounceNoticeRecipient(String zimbraMtaBounceNoticeRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceNoticeRecipient, zimbraMtaBounceNoticeRecipient);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @param zimbraMtaBounceNoticeRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public Map<String,Object> setMtaBounceNoticeRecipient(String zimbraMtaBounceNoticeRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceNoticeRecipient, zimbraMtaBounceNoticeRecipient);
        return attrs;
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public void unsetMtaBounceNoticeRecipient() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceNoticeRecipient, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf bounce_notice_recipient
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1496)
    public Map<String,Object> unsetMtaBounceNoticeRecipient(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceNoticeRecipient, "");
        return attrs;
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @return zimbraMtaBounceQueueLifetime, or "5d" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public String getMtaBounceQueueLifetime() {
        return getAttr(Provisioning.A_zimbraMtaBounceQueueLifetime, "5d", true);
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @param zimbraMtaBounceQueueLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public void setMtaBounceQueueLifetime(String zimbraMtaBounceQueueLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceQueueLifetime, zimbraMtaBounceQueueLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @param zimbraMtaBounceQueueLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public Map<String,Object> setMtaBounceQueueLifetime(String zimbraMtaBounceQueueLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceQueueLifetime, zimbraMtaBounceQueueLifetime);
        return attrs;
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public void unsetMtaBounceQueueLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceQueueLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf bounce_queue_lifetime
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1497)
    public Map<String,Object> unsetMtaBounceQueueLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBounceQueueLifetime, "");
        return attrs;
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaBrokenSaslAuthClients, or ZAttrProvisioning.MtaBrokenSaslAuthClients.yes if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public ZAttrProvisioning.MtaBrokenSaslAuthClients getMtaBrokenSaslAuthClients() {
        try { String v = getAttr(Provisioning.A_zimbraMtaBrokenSaslAuthClients, true, true); return v == null ? ZAttrProvisioning.MtaBrokenSaslAuthClients.yes : ZAttrProvisioning.MtaBrokenSaslAuthClients.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaBrokenSaslAuthClients.yes; }
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaBrokenSaslAuthClients, or "yes" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public String getMtaBrokenSaslAuthClientsAsString() {
        return getAttr(Provisioning.A_zimbraMtaBrokenSaslAuthClients, "yes", true);
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaBrokenSaslAuthClients new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public void setMtaBrokenSaslAuthClients(ZAttrProvisioning.MtaBrokenSaslAuthClients zimbraMtaBrokenSaslAuthClients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, zimbraMtaBrokenSaslAuthClients.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaBrokenSaslAuthClients new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public Map<String,Object> setMtaBrokenSaslAuthClients(ZAttrProvisioning.MtaBrokenSaslAuthClients zimbraMtaBrokenSaslAuthClients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, zimbraMtaBrokenSaslAuthClients.toString());
        return attrs;
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaBrokenSaslAuthClients new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public void setMtaBrokenSaslAuthClientsAsString(String zimbraMtaBrokenSaslAuthClients) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, zimbraMtaBrokenSaslAuthClients);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaBrokenSaslAuthClients new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public Map<String,Object> setMtaBrokenSaslAuthClientsAsString(String zimbraMtaBrokenSaslAuthClients, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, zimbraMtaBrokenSaslAuthClients);
        return attrs;
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public void unsetMtaBrokenSaslAuthClients() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf broken_sasl_auth_clients
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1495)
    public Map<String,Object> unsetMtaBrokenSaslAuthClients(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaBrokenSaslAuthClients, "");
        return attrs;
    }

    /**
     * Value for postconf canonical_maps. Comma separated list.
     *
     * @return zimbraMtaCanonicalMaps, or "proxy:ldap:/opt/zimbra/conf/ldap-canonical.cf" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2080)
    public String getMtaCanonicalMaps() {
        return getAttr(Provisioning.A_zimbraMtaCanonicalMaps, "proxy:ldap:/opt/zimbra/conf/ldap-canonical.cf", true);
    }

    /**
     * Value for postconf canonical_maps. Comma separated list.
     *
     * @param zimbraMtaCanonicalMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2080)
    public void setMtaCanonicalMaps(String zimbraMtaCanonicalMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCanonicalMaps, zimbraMtaCanonicalMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf canonical_maps. Comma separated list.
     *
     * @param zimbraMtaCanonicalMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2080)
    public Map<String,Object> setMtaCanonicalMaps(String zimbraMtaCanonicalMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCanonicalMaps, zimbraMtaCanonicalMaps);
        return attrs;
    }

    /**
     * Value for postconf canonical_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2080)
    public void unsetMtaCanonicalMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCanonicalMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf canonical_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2080)
    public Map<String,Object> unsetMtaCanonicalMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCanonicalMaps, "");
        return attrs;
    }

    /**
     * Value for postconf command_directory
     *
     * @return zimbraMtaCommandDirectory, or "/opt/zimbra/common/sbin" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public String getMtaCommandDirectory() {
        return getAttr(Provisioning.A_zimbraMtaCommandDirectory, "/opt/zimbra/common/sbin", true);
    }

    /**
     * Value for postconf command_directory
     *
     * @param zimbraMtaCommandDirectory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public void setMtaCommandDirectory(String zimbraMtaCommandDirectory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommandDirectory, zimbraMtaCommandDirectory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf command_directory
     *
     * @param zimbraMtaCommandDirectory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public Map<String,Object> setMtaCommandDirectory(String zimbraMtaCommandDirectory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommandDirectory, zimbraMtaCommandDirectory);
        return attrs;
    }

    /**
     * Value for postconf command_directory
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public void unsetMtaCommandDirectory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommandDirectory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf command_directory
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1498)
    public Map<String,Object> unsetMtaCommandDirectory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommandDirectory, "");
        return attrs;
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @return zimbraMtaCommonBlockedExtension, or empty array if unset
     */
    @ZAttr(id=196)
    public String[] getMtaCommonBlockedExtension() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaCommonBlockedExtension, true, true); return value.length > 0 ? value : new String[] {"asd","bat","chm","cmd","com","dll","do","exe","hlp","hta","js","jse","lnk","ocx","pif","reg","scr","shb","shm","shs","vbe","vbs","vbx","vxd","wsf","wsh","xl"};
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @param zimbraMtaCommonBlockedExtension new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=196)
    public void setMtaCommonBlockedExtension(String[] zimbraMtaCommonBlockedExtension) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommonBlockedExtension, zimbraMtaCommonBlockedExtension);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @param zimbraMtaCommonBlockedExtension new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=196)
    public Map<String,Object> setMtaCommonBlockedExtension(String[] zimbraMtaCommonBlockedExtension, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommonBlockedExtension, zimbraMtaCommonBlockedExtension);
        return attrs;
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @param zimbraMtaCommonBlockedExtension new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=196)
    public void addMtaCommonBlockedExtension(String zimbraMtaCommonBlockedExtension) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaCommonBlockedExtension, zimbraMtaCommonBlockedExtension);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @param zimbraMtaCommonBlockedExtension new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=196)
    public Map<String,Object> addMtaCommonBlockedExtension(String zimbraMtaCommonBlockedExtension, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaCommonBlockedExtension, zimbraMtaCommonBlockedExtension);
        return attrs;
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @param zimbraMtaCommonBlockedExtension existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=196)
    public void removeMtaCommonBlockedExtension(String zimbraMtaCommonBlockedExtension) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaCommonBlockedExtension, zimbraMtaCommonBlockedExtension);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @param zimbraMtaCommonBlockedExtension existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=196)
    public Map<String,Object> removeMtaCommonBlockedExtension(String zimbraMtaCommonBlockedExtension, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaCommonBlockedExtension, zimbraMtaCommonBlockedExtension);
        return attrs;
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=196)
    public void unsetMtaCommonBlockedExtension() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommonBlockedExtension, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Commonly blocked attachment file extensions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=196)
    public Map<String,Object> unsetMtaCommonBlockedExtension(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaCommonBlockedExtension, "");
        return attrs;
    }

    /**
     * Value for postconf daemon_directory
     *
     * @return zimbraMtaDaemonDirectory, or "/opt/zimbra/common/libexec" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public String getMtaDaemonDirectory() {
        return getAttr(Provisioning.A_zimbraMtaDaemonDirectory, "/opt/zimbra/common/libexec", true);
    }

    /**
     * Value for postconf daemon_directory
     *
     * @param zimbraMtaDaemonDirectory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public void setMtaDaemonDirectory(String zimbraMtaDaemonDirectory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDaemonDirectory, zimbraMtaDaemonDirectory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf daemon_directory
     *
     * @param zimbraMtaDaemonDirectory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public Map<String,Object> setMtaDaemonDirectory(String zimbraMtaDaemonDirectory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDaemonDirectory, zimbraMtaDaemonDirectory);
        return attrs;
    }

    /**
     * Value for postconf daemon_directory
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public void unsetMtaDaemonDirectory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDaemonDirectory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf daemon_directory
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1499)
    public Map<String,Object> unsetMtaDaemonDirectory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDaemonDirectory, "");
        return attrs;
    }

    /**
     * Value for postconf default_process_limit
     *
     * @return zimbraMtaDefaultProcessLimit, or "100" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public String getMtaDefaultProcessLimit() {
        return getAttr(Provisioning.A_zimbraMtaDefaultProcessLimit, "100", true);
    }

    /**
     * Value for postconf default_process_limit
     *
     * @param zimbraMtaDefaultProcessLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public void setMtaDefaultProcessLimit(String zimbraMtaDefaultProcessLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDefaultProcessLimit, zimbraMtaDefaultProcessLimit);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf default_process_limit
     *
     * @param zimbraMtaDefaultProcessLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public Map<String,Object> setMtaDefaultProcessLimit(String zimbraMtaDefaultProcessLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDefaultProcessLimit, zimbraMtaDefaultProcessLimit);
        return attrs;
    }

    /**
     * Value for postconf default_process_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public void unsetMtaDefaultProcessLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDefaultProcessLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf default_process_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1501)
    public Map<String,Object> unsetMtaDefaultProcessLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDefaultProcessLimit, "");
        return attrs;
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @return zimbraMtaDelayWarningTime, or "0h" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public String getMtaDelayWarningTime() {
        return getAttr(Provisioning.A_zimbraMtaDelayWarningTime, "0h", true);
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @param zimbraMtaDelayWarningTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public void setMtaDelayWarningTime(String zimbraMtaDelayWarningTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDelayWarningTime, zimbraMtaDelayWarningTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @param zimbraMtaDelayWarningTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public Map<String,Object> setMtaDelayWarningTime(String zimbraMtaDelayWarningTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDelayWarningTime, zimbraMtaDelayWarningTime);
        return attrs;
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public void unsetMtaDelayWarningTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDelayWarningTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf delay_warning_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1500)
    public Map<String,Object> unsetMtaDelayWarningTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDelayWarningTime, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0_BETA2. deprecated in favor
     * zimbraMtaSmtpDnsSupportLevel. Orig desc: Value for postconf
     * disable_dns_lookups (note enable v. disable)
     *
     * @return zimbraMtaDnsLookupsEnabled, or true if unset
     */
    @ZAttr(id=197)
    public boolean isMtaDnsLookupsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraMtaDnsLookupsEnabled, true, true);
    }

    /**
     * Deprecated since: 8.7.0_BETA2. deprecated in favor
     * zimbraMtaSmtpDnsSupportLevel. Orig desc: Value for postconf
     * disable_dns_lookups (note enable v. disable)
     *
     * @param zimbraMtaDnsLookupsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=197)
    public void setMtaDnsLookupsEnabled(boolean zimbraMtaDnsLookupsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDnsLookupsEnabled, zimbraMtaDnsLookupsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0_BETA2. deprecated in favor
     * zimbraMtaSmtpDnsSupportLevel. Orig desc: Value for postconf
     * disable_dns_lookups (note enable v. disable)
     *
     * @param zimbraMtaDnsLookupsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=197)
    public Map<String,Object> setMtaDnsLookupsEnabled(boolean zimbraMtaDnsLookupsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDnsLookupsEnabled, zimbraMtaDnsLookupsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0_BETA2. deprecated in favor
     * zimbraMtaSmtpDnsSupportLevel. Orig desc: Value for postconf
     * disable_dns_lookups (note enable v. disable)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=197)
    public void unsetMtaDnsLookupsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDnsLookupsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0_BETA2. deprecated in favor
     * zimbraMtaSmtpDnsSupportLevel. Orig desc: Value for postconf
     * disable_dns_lookups (note enable v. disable)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=197)
    public Map<String,Object> unsetMtaDnsLookupsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaDnsLookupsEnabled, "");
        return attrs;
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @return zimbraMtaEnableSmtpdPolicyd, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public boolean isMtaEnableSmtpdPolicyd() {
        return getBooleanAttr(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, false, true);
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @param zimbraMtaEnableSmtpdPolicyd new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public void setMtaEnableSmtpdPolicyd(boolean zimbraMtaEnableSmtpdPolicyd) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, zimbraMtaEnableSmtpdPolicyd ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @param zimbraMtaEnableSmtpdPolicyd new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public Map<String,Object> setMtaEnableSmtpdPolicyd(boolean zimbraMtaEnableSmtpdPolicyd, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, zimbraMtaEnableSmtpdPolicyd ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public void unsetMtaEnableSmtpdPolicyd() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to enable zmpostfixpolicyd with MTA. Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1466)
    public Map<String,Object> unsetMtaEnableSmtpdPolicyd(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaEnableSmtpdPolicyd, "");
        return attrs;
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @return zimbraMtaFallbackRelayHost, or null if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public String getMtaFallbackRelayHost() {
        return getAttr(Provisioning.A_zimbraMtaFallbackRelayHost, null, true);
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @param zimbraMtaFallbackRelayHost new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public void setMtaFallbackRelayHost(String zimbraMtaFallbackRelayHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaFallbackRelayHost, zimbraMtaFallbackRelayHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @param zimbraMtaFallbackRelayHost new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public Map<String,Object> setMtaFallbackRelayHost(String zimbraMtaFallbackRelayHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaFallbackRelayHost, zimbraMtaFallbackRelayHost);
        return attrs;
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public void unsetMtaFallbackRelayHost() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaFallbackRelayHost, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Fallback value for postconf relayhost.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1435)
    public Map<String,Object> unsetMtaFallbackRelayHost(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaFallbackRelayHost, "");
        return attrs;
    }

    /**
     * Value for postconf header_checks
     *
     * @return zimbraMtaHeaderChecks, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public String[] getMtaHeaderChecks() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaHeaderChecks, true, true); return value.length > 0 ? value : new String[] {"pcre:/opt/zimbra/conf/postfix_header_checks"};
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public void setMtaHeaderChecks(String[] zimbraMtaHeaderChecks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public Map<String,Object> setMtaHeaderChecks(String[] zimbraMtaHeaderChecks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        return attrs;
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public void addMtaHeaderChecks(String zimbraMtaHeaderChecks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public Map<String,Object> addMtaHeaderChecks(String zimbraMtaHeaderChecks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        return attrs;
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public void removeMtaHeaderChecks(String zimbraMtaHeaderChecks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf header_checks
     *
     * @param zimbraMtaHeaderChecks existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public Map<String,Object> removeMtaHeaderChecks(String zimbraMtaHeaderChecks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaHeaderChecks, zimbraMtaHeaderChecks);
        return attrs;
    }

    /**
     * Value for postconf header_checks
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public void unsetMtaHeaderChecks() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHeaderChecks, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf header_checks
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1502)
    public Map<String,Object> unsetMtaHeaderChecks(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHeaderChecks, "");
        return attrs;
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @return zimbraMtaHopcountLimit, or 50 if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1835)
    public int getMtaHopcountLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaHopcountLimit, 50, true);
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @param zimbraMtaHopcountLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1835)
    public void setMtaHopcountLimit(int zimbraMtaHopcountLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHopcountLimit, Integer.toString(zimbraMtaHopcountLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @param zimbraMtaHopcountLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1835)
    public Map<String,Object> setMtaHopcountLimit(int zimbraMtaHopcountLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHopcountLimit, Integer.toString(zimbraMtaHopcountLimit));
        return attrs;
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1835)
    public void unsetMtaHopcountLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHopcountLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf hopcount_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1835)
    public Map<String,Object> unsetMtaHopcountLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaHopcountLimit, "");
        return attrs;
    }

    /**
     * Value for postconf import_environment
     *
     * @return zimbraMtaImportEnvironment, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public String[] getMtaImportEnvironment() {
        return getMultiAttr(Provisioning.A_zimbraMtaImportEnvironment, true, true);
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public void setMtaImportEnvironment(String[] zimbraMtaImportEnvironment) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public Map<String,Object> setMtaImportEnvironment(String[] zimbraMtaImportEnvironment, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        return attrs;
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public void addMtaImportEnvironment(String zimbraMtaImportEnvironment) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public Map<String,Object> addMtaImportEnvironment(String zimbraMtaImportEnvironment, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        return attrs;
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public void removeMtaImportEnvironment(String zimbraMtaImportEnvironment) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf import_environment
     *
     * @param zimbraMtaImportEnvironment existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public Map<String,Object> removeMtaImportEnvironment(String zimbraMtaImportEnvironment, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaImportEnvironment, zimbraMtaImportEnvironment);
        return attrs;
    }

    /**
     * Value for postconf import_environment
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public void unsetMtaImportEnvironment() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaImportEnvironment, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf import_environment
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1503)
    public Map<String,Object> unsetMtaImportEnvironment(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaImportEnvironment, "");
        return attrs;
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @return zimbraMtaInFlowDelay, or "1s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public String getMtaInFlowDelay() {
        return getAttr(Provisioning.A_zimbraMtaInFlowDelay, "1s", true);
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @param zimbraMtaInFlowDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public void setMtaInFlowDelay(String zimbraMtaInFlowDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaInFlowDelay, zimbraMtaInFlowDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @param zimbraMtaInFlowDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public Map<String,Object> setMtaInFlowDelay(String zimbraMtaInFlowDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaInFlowDelay, zimbraMtaInFlowDelay);
        return attrs;
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public void unsetMtaInFlowDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaInFlowDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf in_flow_delay
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1504)
    public Map<String,Object> unsetMtaInFlowDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaInFlowDelay, "");
        return attrs;
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @return zimbraMtaLmdbMapSize, or 16777216 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public int getMtaLmdbMapSize() {
        return getIntAttr(Provisioning.A_zimbraMtaLmdbMapSize, 16777216, true);
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @param zimbraMtaLmdbMapSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public void setMtaLmdbMapSize(int zimbraMtaLmdbMapSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmdbMapSize, Integer.toString(zimbraMtaLmdbMapSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @param zimbraMtaLmdbMapSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public Map<String,Object> setMtaLmdbMapSize(int zimbraMtaLmdbMapSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmdbMapSize, Integer.toString(zimbraMtaLmdbMapSize));
        return attrs;
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public void unsetMtaLmdbMapSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmdbMapSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum Map size for MTA LMDB dbs. Defaults to 16777216 (16MB).
     * Databases will not grow beyond this point.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1489)
    public Map<String,Object> unsetMtaLmdbMapSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmdbMapSize, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @return zimbraMtaLmtpConnectionCacheDestinations, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public String[] getMtaLmtpConnectionCacheDestinations() {
        return getMultiAttr(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, true, true);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public void setMtaLmtpConnectionCacheDestinations(String[] zimbraMtaLmtpConnectionCacheDestinations) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public Map<String,Object> setMtaLmtpConnectionCacheDestinations(String[] zimbraMtaLmtpConnectionCacheDestinations, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public void addMtaLmtpConnectionCacheDestinations(String zimbraMtaLmtpConnectionCacheDestinations) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public Map<String,Object> addMtaLmtpConnectionCacheDestinations(String zimbraMtaLmtpConnectionCacheDestinations, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public void removeMtaLmtpConnectionCacheDestinations(String zimbraMtaLmtpConnectionCacheDestinations) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param zimbraMtaLmtpConnectionCacheDestinations existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public Map<String,Object> removeMtaLmtpConnectionCacheDestinations(String zimbraMtaLmtpConnectionCacheDestinations, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, zimbraMtaLmtpConnectionCacheDestinations);
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public void unsetMtaLmtpConnectionCacheDestinations() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_destinations
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1505)
    public Map<String,Object> unsetMtaLmtpConnectionCacheDestinations(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheDestinations, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @return zimbraMtaLmtpConnectionCacheTimeLimit, or "4s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public String getMtaLmtpConnectionCacheTimeLimit() {
        return getAttr(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, "4s", true);
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @param zimbraMtaLmtpConnectionCacheTimeLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public void setMtaLmtpConnectionCacheTimeLimit(String zimbraMtaLmtpConnectionCacheTimeLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, zimbraMtaLmtpConnectionCacheTimeLimit);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @param zimbraMtaLmtpConnectionCacheTimeLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public Map<String,Object> setMtaLmtpConnectionCacheTimeLimit(String zimbraMtaLmtpConnectionCacheTimeLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, zimbraMtaLmtpConnectionCacheTimeLimit);
        return attrs;
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public void unsetMtaLmtpConnectionCacheTimeLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_connection_cache_time_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1506)
    public Map<String,Object> unsetMtaLmtpConnectionCacheTimeLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpConnectionCacheTimeLimit, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @return zimbraMtaLmtpHostLookup, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public String[] getMtaLmtpHostLookupAsString() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaLmtpHostLookup, true, true); return value.length > 0 ? value : new String[] {"dns"};
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param zimbraMtaLmtpHostLookup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public void setMtaLmtpHostLookup(ZAttrProvisioning.MtaLmtpHostLookup zimbraMtaLmtpHostLookup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, zimbraMtaLmtpHostLookup.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param zimbraMtaLmtpHostLookup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public Map<String,Object> setMtaLmtpHostLookup(ZAttrProvisioning.MtaLmtpHostLookup zimbraMtaLmtpHostLookup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, zimbraMtaLmtpHostLookup.toString());
        return attrs;
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param zimbraMtaLmtpHostLookup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public void setMtaLmtpHostLookupAsString(String[] zimbraMtaLmtpHostLookup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, zimbraMtaLmtpHostLookup);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param zimbraMtaLmtpHostLookup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public Map<String,Object> setMtaLmtpHostLookupAsString(String[] zimbraMtaLmtpHostLookup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, zimbraMtaLmtpHostLookup);
        return attrs;
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public void unsetMtaLmtpHostLookup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_host_lookup
     *
     * <p>Valid values: [dns, native]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1507)
    public Map<String,Object> unsetMtaLmtpHostLookup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpHostLookup, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @return zimbraMtaLmtpTlsCAfile, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public String getMtaLmtpTlsCAfile() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsCAfile, null, true);
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @param zimbraMtaLmtpTlsCAfile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public void setMtaLmtpTlsCAfile(String zimbraMtaLmtpTlsCAfile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCAfile, zimbraMtaLmtpTlsCAfile);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @param zimbraMtaLmtpTlsCAfile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public Map<String,Object> setMtaLmtpTlsCAfile(String zimbraMtaLmtpTlsCAfile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCAfile, zimbraMtaLmtpTlsCAfile);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public void unsetMtaLmtpTlsCAfile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCAfile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_CAfile
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1663)
    public Map<String,Object> unsetMtaLmtpTlsCAfile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCAfile, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @return zimbraMtaLmtpTlsCApath, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public String getMtaLmtpTlsCApath() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsCApath, null, true);
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @param zimbraMtaLmtpTlsCApath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public void setMtaLmtpTlsCApath(String zimbraMtaLmtpTlsCApath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCApath, zimbraMtaLmtpTlsCApath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @param zimbraMtaLmtpTlsCApath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public Map<String,Object> setMtaLmtpTlsCApath(String zimbraMtaLmtpTlsCApath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCApath, zimbraMtaLmtpTlsCApath);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public void unsetMtaLmtpTlsCApath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCApath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_CApath
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1664)
    public Map<String,Object> unsetMtaLmtpTlsCApath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCApath, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaLmtpTlsCiphers, or ZAttrProvisioning.MtaLmtpTlsCiphers.export if unset and/or has invalid value
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public ZAttrProvisioning.MtaLmtpTlsCiphers getMtaLmtpTlsCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaLmtpTlsCiphers, true, true); return v == null ? ZAttrProvisioning.MtaLmtpTlsCiphers.export : ZAttrProvisioning.MtaLmtpTlsCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaLmtpTlsCiphers.export; }
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaLmtpTlsCiphers, or "export" if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public String getMtaLmtpTlsCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsCiphers, "export", true);
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaLmtpTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public void setMtaLmtpTlsCiphers(ZAttrProvisioning.MtaLmtpTlsCiphers zimbraMtaLmtpTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, zimbraMtaLmtpTlsCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaLmtpTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public Map<String,Object> setMtaLmtpTlsCiphers(ZAttrProvisioning.MtaLmtpTlsCiphers zimbraMtaLmtpTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, zimbraMtaLmtpTlsCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaLmtpTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public void setMtaLmtpTlsCiphersAsString(String zimbraMtaLmtpTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, zimbraMtaLmtpTlsCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaLmtpTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public Map<String,Object> setMtaLmtpTlsCiphersAsString(String zimbraMtaLmtpTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, zimbraMtaLmtpTlsCiphers);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public void unsetMtaLmtpTlsCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1661)
    public Map<String,Object> unsetMtaLmtpTlsCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @return zimbraMtaLmtpTlsExcludeCiphers, or null if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public String getMtaLmtpTlsExcludeCiphers() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, null, true);
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @param zimbraMtaLmtpTlsExcludeCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public void setMtaLmtpTlsExcludeCiphers(String zimbraMtaLmtpTlsExcludeCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, zimbraMtaLmtpTlsExcludeCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @param zimbraMtaLmtpTlsExcludeCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public Map<String,Object> setMtaLmtpTlsExcludeCiphers(String zimbraMtaLmtpTlsExcludeCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, zimbraMtaLmtpTlsExcludeCiphers);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public void unsetMtaLmtpTlsExcludeCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_exclude_ciphers
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1659)
    public Map<String,Object> unsetMtaLmtpTlsExcludeCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsExcludeCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @return zimbraMtaLmtpTlsLoglevel, or 0 if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public int getMtaLmtpTlsLoglevel() {
        return getIntAttr(Provisioning.A_zimbraMtaLmtpTlsLoglevel, 0, true);
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param zimbraMtaLmtpTlsLoglevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public void setMtaLmtpTlsLoglevel(int zimbraMtaLmtpTlsLoglevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsLoglevel, Integer.toString(zimbraMtaLmtpTlsLoglevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param zimbraMtaLmtpTlsLoglevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public Map<String,Object> setMtaLmtpTlsLoglevel(int zimbraMtaLmtpTlsLoglevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsLoglevel, Integer.toString(zimbraMtaLmtpTlsLoglevel));
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public void unsetMtaLmtpTlsLoglevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsLoglevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1665)
    public Map<String,Object> unsetMtaLmtpTlsLoglevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsLoglevel, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaLmtpTlsMandatoryCiphers, or ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers.medium if unset and/or has invalid value
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers getMtaLmtpTlsMandatoryCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, true, true); return v == null ? ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers.medium : ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers.medium; }
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaLmtpTlsMandatoryCiphers, or "medium" if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public String getMtaLmtpTlsMandatoryCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, "medium", true);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaLmtpTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public void setMtaLmtpTlsMandatoryCiphers(ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers zimbraMtaLmtpTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, zimbraMtaLmtpTlsMandatoryCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaLmtpTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public Map<String,Object> setMtaLmtpTlsMandatoryCiphers(ZAttrProvisioning.MtaLmtpTlsMandatoryCiphers zimbraMtaLmtpTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, zimbraMtaLmtpTlsMandatoryCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaLmtpTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public void setMtaLmtpTlsMandatoryCiphersAsString(String zimbraMtaLmtpTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, zimbraMtaLmtpTlsMandatoryCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaLmtpTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public Map<String,Object> setMtaLmtpTlsMandatoryCiphersAsString(String zimbraMtaLmtpTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, zimbraMtaLmtpTlsMandatoryCiphers);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public void unsetMtaLmtpTlsMandatoryCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1662)
    public Map<String,Object> unsetMtaLmtpTlsMandatoryCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @return zimbraMtaLmtpTlsMandatoryProtocols, or "!SSLv2, !SSLv3" if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1784)
    public String getMtaLmtpTlsMandatoryProtocols() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, "!SSLv2, !SSLv3", true);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @param zimbraMtaLmtpTlsMandatoryProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1784)
    public void setMtaLmtpTlsMandatoryProtocols(String zimbraMtaLmtpTlsMandatoryProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, zimbraMtaLmtpTlsMandatoryProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @param zimbraMtaLmtpTlsMandatoryProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1784)
    public Map<String,Object> setMtaLmtpTlsMandatoryProtocols(String zimbraMtaLmtpTlsMandatoryProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, zimbraMtaLmtpTlsMandatoryProtocols);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1784)
    public void unsetMtaLmtpTlsMandatoryProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_mandatory_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1784)
    public Map<String,Object> unsetMtaLmtpTlsMandatoryProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsMandatoryProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @return zimbraMtaLmtpTlsProtocols, or "!SSLv2, !SSLv3" if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public String getMtaLmtpTlsProtocols() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsProtocols, "!SSLv2, !SSLv3", true);
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @param zimbraMtaLmtpTlsProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public void setMtaLmtpTlsProtocols(String zimbraMtaLmtpTlsProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsProtocols, zimbraMtaLmtpTlsProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @param zimbraMtaLmtpTlsProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public Map<String,Object> setMtaLmtpTlsProtocols(String zimbraMtaLmtpTlsProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsProtocols, zimbraMtaLmtpTlsProtocols);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public void unsetMtaLmtpTlsProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1658)
    public Map<String,Object> unsetMtaLmtpTlsProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @return zimbraMtaLmtpTlsSecurityLevel, or ZAttrProvisioning.MtaLmtpTlsSecurityLevel.may if unset and/or has invalid value
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public ZAttrProvisioning.MtaLmtpTlsSecurityLevel getMtaLmtpTlsSecurityLevel() {
        try { String v = getAttr(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, true, true); return v == null ? ZAttrProvisioning.MtaLmtpTlsSecurityLevel.may : ZAttrProvisioning.MtaLmtpTlsSecurityLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaLmtpTlsSecurityLevel.may; }
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @return zimbraMtaLmtpTlsSecurityLevel, or "may" if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public String getMtaLmtpTlsSecurityLevelAsString() {
        return getAttr(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, "may", true);
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param zimbraMtaLmtpTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public void setMtaLmtpTlsSecurityLevel(ZAttrProvisioning.MtaLmtpTlsSecurityLevel zimbraMtaLmtpTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, zimbraMtaLmtpTlsSecurityLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param zimbraMtaLmtpTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public Map<String,Object> setMtaLmtpTlsSecurityLevel(ZAttrProvisioning.MtaLmtpTlsSecurityLevel zimbraMtaLmtpTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, zimbraMtaLmtpTlsSecurityLevel.toString());
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param zimbraMtaLmtpTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public void setMtaLmtpTlsSecurityLevelAsString(String zimbraMtaLmtpTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, zimbraMtaLmtpTlsSecurityLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param zimbraMtaLmtpTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public Map<String,Object> setMtaLmtpTlsSecurityLevelAsString(String zimbraMtaLmtpTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, zimbraMtaLmtpTlsSecurityLevel);
        return attrs;
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public void unsetMtaLmtpTlsSecurityLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf lmtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1660)
    public Map<String,Object> unsetMtaLmtpTlsSecurityLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaLmtpTlsSecurityLevel, "");
        return attrs;
    }

    /**
     * Value for postconf mailq_path
     *
     * @return zimbraMtaMailqPath, or "/opt/zimbra/common/sbin/mailq" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public String getMtaMailqPath() {
        return getAttr(Provisioning.A_zimbraMtaMailqPath, "/opt/zimbra/common/sbin/mailq", true);
    }

    /**
     * Value for postconf mailq_path
     *
     * @param zimbraMtaMailqPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public void setMtaMailqPath(String zimbraMtaMailqPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMailqPath, zimbraMtaMailqPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf mailq_path
     *
     * @param zimbraMtaMailqPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public Map<String,Object> setMtaMailqPath(String zimbraMtaMailqPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMailqPath, zimbraMtaMailqPath);
        return attrs;
    }

    /**
     * Value for postconf mailq_path
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public void unsetMtaMailqPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMailqPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf mailq_path
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1508)
    public Map<String,Object> unsetMtaMailqPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMailqPath, "");
        return attrs;
    }

    /**
     * Value for postconf manpage_directory
     *
     * @return zimbraMtaManpageDirectory, or "/opt/zimbra/common/share/man" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public String getMtaManpageDirectory() {
        return getAttr(Provisioning.A_zimbraMtaManpageDirectory, "/opt/zimbra/common/share/man", true);
    }

    /**
     * Value for postconf manpage_directory
     *
     * @param zimbraMtaManpageDirectory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public void setMtaManpageDirectory(String zimbraMtaManpageDirectory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaManpageDirectory, zimbraMtaManpageDirectory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf manpage_directory
     *
     * @param zimbraMtaManpageDirectory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public Map<String,Object> setMtaManpageDirectory(String zimbraMtaManpageDirectory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaManpageDirectory, zimbraMtaManpageDirectory);
        return attrs;
    }

    /**
     * Value for postconf manpage_directory
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public void unsetMtaManpageDirectory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaManpageDirectory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf manpage_directory
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1509)
    public Map<String,Object> unsetMtaManpageDirectory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaManpageDirectory, "");
        return attrs;
    }

    /**
     * Maximum total size of a mail message. Enforced in mailbox server and
     * also used as value for postconf message_size_limit. 0 means &quot;no
     * limit&quot;
     *
     * @return zimbraMtaMaxMessageSize, or 10240000 if unset
     */
    @ZAttr(id=198)
    public long getMtaMaxMessageSize() {
        return getLongAttr(Provisioning.A_zimbraMtaMaxMessageSize, 10240000L, true);
    }

    /**
     * Maximum total size of a mail message. Enforced in mailbox server and
     * also used as value for postconf message_size_limit. 0 means &quot;no
     * limit&quot;
     *
     * @param zimbraMtaMaxMessageSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=198)
    public void setMtaMaxMessageSize(long zimbraMtaMaxMessageSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxMessageSize, Long.toString(zimbraMtaMaxMessageSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum total size of a mail message. Enforced in mailbox server and
     * also used as value for postconf message_size_limit. 0 means &quot;no
     * limit&quot;
     *
     * @param zimbraMtaMaxMessageSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=198)
    public Map<String,Object> setMtaMaxMessageSize(long zimbraMtaMaxMessageSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxMessageSize, Long.toString(zimbraMtaMaxMessageSize));
        return attrs;
    }

    /**
     * Maximum total size of a mail message. Enforced in mailbox server and
     * also used as value for postconf message_size_limit. 0 means &quot;no
     * limit&quot;
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=198)
    public void unsetMtaMaxMessageSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxMessageSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum total size of a mail message. Enforced in mailbox server and
     * also used as value for postconf message_size_limit. 0 means &quot;no
     * limit&quot;
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=198)
    public Map<String,Object> unsetMtaMaxMessageSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxMessageSize, "");
        return attrs;
    }

    /**
     * Value for postconf max_use
     *
     * @return zimbraMtaMaxUse, or 100 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public int getMtaMaxUse() {
        return getIntAttr(Provisioning.A_zimbraMtaMaxUse, 100, true);
    }

    /**
     * Value for postconf max_use
     *
     * @param zimbraMtaMaxUse new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public void setMtaMaxUse(int zimbraMtaMaxUse) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxUse, Integer.toString(zimbraMtaMaxUse));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf max_use
     *
     * @param zimbraMtaMaxUse new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public Map<String,Object> setMtaMaxUse(int zimbraMtaMaxUse, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxUse, Integer.toString(zimbraMtaMaxUse));
        return attrs;
    }

    /**
     * Value for postconf max_use
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public void unsetMtaMaxUse() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxUse, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf max_use
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1531)
    public Map<String,Object> unsetMtaMaxUse(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaxUse, "");
        return attrs;
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @return zimbraMtaMaximalBackoffTime, or "4000s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public String getMtaMaximalBackoffTime() {
        return getAttr(Provisioning.A_zimbraMtaMaximalBackoffTime, "4000s", true);
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @param zimbraMtaMaximalBackoffTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public void setMtaMaximalBackoffTime(String zimbraMtaMaximalBackoffTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalBackoffTime, zimbraMtaMaximalBackoffTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @param zimbraMtaMaximalBackoffTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public Map<String,Object> setMtaMaximalBackoffTime(String zimbraMtaMaximalBackoffTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalBackoffTime, zimbraMtaMaximalBackoffTime);
        return attrs;
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public void unsetMtaMaximalBackoffTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalBackoffTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf maximal_backoff_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1517)
    public Map<String,Object> unsetMtaMaximalBackoffTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalBackoffTime, "");
        return attrs;
    }

    /**
     * Value for postconf maximal_queue_lifetime
     *
     * @return zimbraMtaMaximalQueueLifetime, or "5d" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2078)
    public String getMtaMaximalQueueLifetime() {
        return getAttr(Provisioning.A_zimbraMtaMaximalQueueLifetime, "5d", true);
    }

    /**
     * Value for postconf maximal_queue_lifetime
     *
     * @param zimbraMtaMaximalQueueLifetime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2078)
    public void setMtaMaximalQueueLifetime(String zimbraMtaMaximalQueueLifetime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalQueueLifetime, zimbraMtaMaximalQueueLifetime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf maximal_queue_lifetime
     *
     * @param zimbraMtaMaximalQueueLifetime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2078)
    public Map<String,Object> setMtaMaximalQueueLifetime(String zimbraMtaMaximalQueueLifetime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalQueueLifetime, zimbraMtaMaximalQueueLifetime);
        return attrs;
    }

    /**
     * Value for postconf maximal_queue_lifetime
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2078)
    public void unsetMtaMaximalQueueLifetime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalQueueLifetime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf maximal_queue_lifetime
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2078)
    public Map<String,Object> unsetMtaMaximalQueueLifetime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMaximalQueueLifetime, "");
        return attrs;
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @return zimbraMtaMilterCommandTimeout, or "30s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public String getMtaMilterCommandTimeout() {
        return getAttr(Provisioning.A_zimbraMtaMilterCommandTimeout, "30s", true);
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @param zimbraMtaMilterCommandTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public void setMtaMilterCommandTimeout(String zimbraMtaMilterCommandTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterCommandTimeout, zimbraMtaMilterCommandTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @param zimbraMtaMilterCommandTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public Map<String,Object> setMtaMilterCommandTimeout(String zimbraMtaMilterCommandTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterCommandTimeout, zimbraMtaMilterCommandTimeout);
        return attrs;
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public void unsetMtaMilterCommandTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterCommandTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_command_timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1521)
    public Map<String,Object> unsetMtaMilterCommandTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterCommandTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @return zimbraMtaMilterConnectTimeout, or "30s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public String getMtaMilterConnectTimeout() {
        return getAttr(Provisioning.A_zimbraMtaMilterConnectTimeout, "30s", true);
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @param zimbraMtaMilterConnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public void setMtaMilterConnectTimeout(String zimbraMtaMilterConnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterConnectTimeout, zimbraMtaMilterConnectTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @param zimbraMtaMilterConnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public Map<String,Object> setMtaMilterConnectTimeout(String zimbraMtaMilterConnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterConnectTimeout, zimbraMtaMilterConnectTimeout);
        return attrs;
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public void unsetMtaMilterConnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterConnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_connect_timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1520)
    public Map<String,Object> unsetMtaMilterConnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterConnectTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @return zimbraMtaMilterContentTimeout, or "300s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public String getMtaMilterContentTimeout() {
        return getAttr(Provisioning.A_zimbraMtaMilterContentTimeout, "300s", true);
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @param zimbraMtaMilterContentTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public void setMtaMilterContentTimeout(String zimbraMtaMilterContentTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterContentTimeout, zimbraMtaMilterContentTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @param zimbraMtaMilterContentTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public Map<String,Object> setMtaMilterContentTimeout(String zimbraMtaMilterContentTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterContentTimeout, zimbraMtaMilterContentTimeout);
        return attrs;
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public void unsetMtaMilterContentTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterContentTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_content_timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1522)
    public Map<String,Object> unsetMtaMilterContentTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterContentTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [accept, reject, tempfail, quarantine]
     *
     * @return zimbraMtaMilterDefaultAction, or ZAttrProvisioning.MtaMilterDefaultAction.tempfail if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public ZAttrProvisioning.MtaMilterDefaultAction getMtaMilterDefaultAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaMilterDefaultAction, true, true); return v == null ? ZAttrProvisioning.MtaMilterDefaultAction.tempfail : ZAttrProvisioning.MtaMilterDefaultAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaMilterDefaultAction.tempfail; }
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [accept, reject, tempfail, quarantine]
     *
     * @return zimbraMtaMilterDefaultAction, or "tempfail" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public String getMtaMilterDefaultActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaMilterDefaultAction, "tempfail", true);
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [accept, reject, tempfail, quarantine]
     *
     * @param zimbraMtaMilterDefaultAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public void setMtaMilterDefaultAction(ZAttrProvisioning.MtaMilterDefaultAction zimbraMtaMilterDefaultAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, zimbraMtaMilterDefaultAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [accept, reject, tempfail, quarantine]
     *
     * @param zimbraMtaMilterDefaultAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public Map<String,Object> setMtaMilterDefaultAction(ZAttrProvisioning.MtaMilterDefaultAction zimbraMtaMilterDefaultAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, zimbraMtaMilterDefaultAction.toString());
        return attrs;
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [accept, reject, tempfail, quarantine]
     *
     * @param zimbraMtaMilterDefaultAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public void setMtaMilterDefaultActionAsString(String zimbraMtaMilterDefaultAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, zimbraMtaMilterDefaultAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [accept, reject, tempfail, quarantine]
     *
     * @param zimbraMtaMilterDefaultAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public Map<String,Object> setMtaMilterDefaultActionAsString(String zimbraMtaMilterDefaultAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, zimbraMtaMilterDefaultAction);
        return attrs;
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [accept, reject, tempfail, quarantine]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public void unsetMtaMilterDefaultAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf milter_default_action
     *
     * <p>Valid values: [accept, reject, tempfail, quarantine]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1523)
    public Map<String,Object> unsetMtaMilterDefaultAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMilterDefaultAction, "");
        return attrs;
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @return zimbraMtaMinimalBackoffTime, or "300s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public String getMtaMinimalBackoffTime() {
        return getAttr(Provisioning.A_zimbraMtaMinimalBackoffTime, "300s", true);
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @param zimbraMtaMinimalBackoffTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public void setMtaMinimalBackoffTime(String zimbraMtaMinimalBackoffTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMinimalBackoffTime, zimbraMtaMinimalBackoffTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @param zimbraMtaMinimalBackoffTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public Map<String,Object> setMtaMinimalBackoffTime(String zimbraMtaMinimalBackoffTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMinimalBackoffTime, zimbraMtaMinimalBackoffTime);
        return attrs;
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public void unsetMtaMinimalBackoffTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMinimalBackoffTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf minimal_backoff_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1518)
    public Map<String,Object> unsetMtaMinimalBackoffTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMinimalBackoffTime, "");
        return attrs;
    }

    /**
     * value of postfix mydestination
     *
     * @return zimbraMtaMyDestination, or "localhost" if unset
     */
    @ZAttr(id=524)
    public String getMtaMyDestination() {
        return getAttr(Provisioning.A_zimbraMtaMyDestination, "localhost", true);
    }

    /**
     * value of postfix mydestination
     *
     * @param zimbraMtaMyDestination new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=524)
    public void setMtaMyDestination(String zimbraMtaMyDestination) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyDestination, zimbraMtaMyDestination);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mydestination
     *
     * @param zimbraMtaMyDestination new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=524)
    public Map<String,Object> setMtaMyDestination(String zimbraMtaMyDestination, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyDestination, zimbraMtaMyDestination);
        return attrs;
    }

    /**
     * value of postfix mydestination
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=524)
    public void unsetMtaMyDestination() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyDestination, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mydestination
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=524)
    public Map<String,Object> unsetMtaMyDestination(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyDestination, "");
        return attrs;
    }

    /**
     * value of postfix myhostname
     *
     * @return zimbraMtaMyHostname, or null if unset
     */
    @ZAttr(id=509)
    public String getMtaMyHostname() {
        return getAttr(Provisioning.A_zimbraMtaMyHostname, null, true);
    }

    /**
     * value of postfix myhostname
     *
     * @param zimbraMtaMyHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=509)
    public void setMtaMyHostname(String zimbraMtaMyHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyHostname, zimbraMtaMyHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix myhostname
     *
     * @param zimbraMtaMyHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=509)
    public Map<String,Object> setMtaMyHostname(String zimbraMtaMyHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyHostname, zimbraMtaMyHostname);
        return attrs;
    }

    /**
     * value of postfix myhostname
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=509)
    public void unsetMtaMyHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix myhostname
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=509)
    public Map<String,Object> unsetMtaMyHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyHostname, "");
        return attrs;
    }

    /**
     * value of postfix mynetworks
     *
     * @return zimbraMtaMyNetworks, or empty array if unset
     */
    @ZAttr(id=311)
    public String[] getMtaMyNetworks() {
        return getMultiAttr(Provisioning.A_zimbraMtaMyNetworks, true, true);
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=311)
    public void setMtaMyNetworks(String[] zimbraMtaMyNetworks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=311)
    public Map<String,Object> setMtaMyNetworks(String[] zimbraMtaMyNetworks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        return attrs;
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=311)
    public void addMtaMyNetworks(String zimbraMtaMyNetworks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=311)
    public Map<String,Object> addMtaMyNetworks(String zimbraMtaMyNetworks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        return attrs;
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=311)
    public void removeMtaMyNetworks(String zimbraMtaMyNetworks) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mynetworks
     *
     * @param zimbraMtaMyNetworks existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=311)
    public Map<String,Object> removeMtaMyNetworks(String zimbraMtaMyNetworks, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaMyNetworks, zimbraMtaMyNetworks);
        return attrs;
    }

    /**
     * value of postfix mynetworks
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=311)
    public void unsetMtaMyNetworks() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyNetworks, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix mynetworks
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=311)
    public Map<String,Object> unsetMtaMyNetworks(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyNetworks, "");
        return attrs;
    }

    /**
     * value of postfix myorigin
     *
     * @return zimbraMtaMyOrigin, or null if unset
     */
    @ZAttr(id=510)
    public String getMtaMyOrigin() {
        return getAttr(Provisioning.A_zimbraMtaMyOrigin, null, true);
    }

    /**
     * value of postfix myorigin
     *
     * @param zimbraMtaMyOrigin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=510)
    public void setMtaMyOrigin(String zimbraMtaMyOrigin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyOrigin, zimbraMtaMyOrigin);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix myorigin
     *
     * @param zimbraMtaMyOrigin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=510)
    public Map<String,Object> setMtaMyOrigin(String zimbraMtaMyOrigin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyOrigin, zimbraMtaMyOrigin);
        return attrs;
    }

    /**
     * value of postfix myorigin
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=510)
    public void unsetMtaMyOrigin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyOrigin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value of postfix myorigin
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=510)
    public Map<String,Object> unsetMtaMyOrigin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaMyOrigin, "");
        return attrs;
    }

    /**
     * Value for postconf newaliases_path
     *
     * @return zimbraMtaNewaliasesPath, or "/opt/zimbra/common/sbin/newaliases" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public String getMtaNewaliasesPath() {
        return getAttr(Provisioning.A_zimbraMtaNewaliasesPath, "/opt/zimbra/common/sbin/newaliases", true);
    }

    /**
     * Value for postconf newaliases_path
     *
     * @param zimbraMtaNewaliasesPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public void setMtaNewaliasesPath(String zimbraMtaNewaliasesPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNewaliasesPath, zimbraMtaNewaliasesPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf newaliases_path
     *
     * @param zimbraMtaNewaliasesPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public Map<String,Object> setMtaNewaliasesPath(String zimbraMtaNewaliasesPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNewaliasesPath, zimbraMtaNewaliasesPath);
        return attrs;
    }

    /**
     * Value for postconf newaliases_path
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public void unsetMtaNewaliasesPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNewaliasesPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf newaliases_path
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1510)
    public Map<String,Object> unsetMtaNewaliasesPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNewaliasesPath, "");
        return attrs;
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @return zimbraMtaNonSmtpdMilters, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public String getMtaNonSmtpdMilters() {
        return getAttr(Provisioning.A_zimbraMtaNonSmtpdMilters, null, true);
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @param zimbraMtaNonSmtpdMilters new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public void setMtaNonSmtpdMilters(String zimbraMtaNonSmtpdMilters) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNonSmtpdMilters, zimbraMtaNonSmtpdMilters);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @param zimbraMtaNonSmtpdMilters new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public Map<String,Object> setMtaNonSmtpdMilters(String zimbraMtaNonSmtpdMilters, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNonSmtpdMilters, zimbraMtaNonSmtpdMilters);
        return attrs;
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public void unsetMtaNonSmtpdMilters() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNonSmtpdMilters, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for postfix non_smtpd_milters
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=673)
    public Map<String,Object> unsetMtaNonSmtpdMilters(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNonSmtpdMilters, "");
        return attrs;
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [bounce, 2bounce, data, delay, policy, protocol, resource, software]
     *
     * @return zimbraMtaNotifyClasses, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public String[] getMtaNotifyClassesAsString() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaNotifyClasses, true, true); return value.length > 0 ? value : new String[] {"resource","software"};
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [bounce, 2bounce, data, delay, policy, protocol, resource, software]
     *
     * @param zimbraMtaNotifyClasses new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public void setMtaNotifyClasses(ZAttrProvisioning.MtaNotifyClasses zimbraMtaNotifyClasses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, zimbraMtaNotifyClasses.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [bounce, 2bounce, data, delay, policy, protocol, resource, software]
     *
     * @param zimbraMtaNotifyClasses new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public Map<String,Object> setMtaNotifyClasses(ZAttrProvisioning.MtaNotifyClasses zimbraMtaNotifyClasses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, zimbraMtaNotifyClasses.toString());
        return attrs;
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [bounce, 2bounce, data, delay, policy, protocol, resource, software]
     *
     * @param zimbraMtaNotifyClasses new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public void setMtaNotifyClassesAsString(String[] zimbraMtaNotifyClasses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, zimbraMtaNotifyClasses);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [bounce, 2bounce, data, delay, policy, protocol, resource, software]
     *
     * @param zimbraMtaNotifyClasses new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public Map<String,Object> setMtaNotifyClassesAsString(String[] zimbraMtaNotifyClasses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, zimbraMtaNotifyClasses);
        return attrs;
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [bounce, 2bounce, data, delay, policy, protocol, resource, software]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public void unsetMtaNotifyClasses() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf notify_classes
     *
     * <p>Valid values: [bounce, 2bounce, data, delay, policy, protocol, resource, software]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1546)
    public Map<String,Object> unsetMtaNotifyClasses(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaNotifyClasses, "");
        return attrs;
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @return zimbraMtaPolicyTimeLimit, or 3600 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public int getMtaPolicyTimeLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaPolicyTimeLimit, 3600, true);
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @param zimbraMtaPolicyTimeLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public void setMtaPolicyTimeLimit(int zimbraMtaPolicyTimeLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPolicyTimeLimit, Integer.toString(zimbraMtaPolicyTimeLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @param zimbraMtaPolicyTimeLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public Map<String,Object> setMtaPolicyTimeLimit(int zimbraMtaPolicyTimeLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPolicyTimeLimit, Integer.toString(zimbraMtaPolicyTimeLimit));
        return attrs;
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public void unsetMtaPolicyTimeLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPolicyTimeLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf policy_time_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1530)
    public Map<String,Object> unsetMtaPolicyTimeLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPolicyTimeLimit, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @return zimbraMtaPostscreenAccessList, or "permit_mynetworks" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public String getMtaPostscreenAccessList() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenAccessList, "permit_mynetworks", true);
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @param zimbraMtaPostscreenAccessList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public void setMtaPostscreenAccessList(String zimbraMtaPostscreenAccessList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenAccessList, zimbraMtaPostscreenAccessList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @param zimbraMtaPostscreenAccessList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public Map<String,Object> setMtaPostscreenAccessList(String zimbraMtaPostscreenAccessList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenAccessList, zimbraMtaPostscreenAccessList);
        return attrs;
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public void unsetMtaPostscreenAccessList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenAccessList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_access_list. Single valued, commas
     * separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1917)
    public Map<String,Object> unsetMtaPostscreenAccessList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenAccessList, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenBareNewlineAction, or ZAttrProvisioning.MtaPostscreenBareNewlineAction.ignore if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public ZAttrProvisioning.MtaPostscreenBareNewlineAction getMtaPostscreenBareNewlineAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenBareNewlineAction.ignore : ZAttrProvisioning.MtaPostscreenBareNewlineAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenBareNewlineAction.ignore; }
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenBareNewlineAction, or "ignore" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public String getMtaPostscreenBareNewlineActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, "ignore", true);
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenBareNewlineAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public void setMtaPostscreenBareNewlineAction(ZAttrProvisioning.MtaPostscreenBareNewlineAction zimbraMtaPostscreenBareNewlineAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, zimbraMtaPostscreenBareNewlineAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenBareNewlineAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public Map<String,Object> setMtaPostscreenBareNewlineAction(ZAttrProvisioning.MtaPostscreenBareNewlineAction zimbraMtaPostscreenBareNewlineAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, zimbraMtaPostscreenBareNewlineAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenBareNewlineAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public void setMtaPostscreenBareNewlineActionAsString(String zimbraMtaPostscreenBareNewlineAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, zimbraMtaPostscreenBareNewlineAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenBareNewlineAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public Map<String,Object> setMtaPostscreenBareNewlineActionAsString(String zimbraMtaPostscreenBareNewlineAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, zimbraMtaPostscreenBareNewlineAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public void unsetMtaPostscreenBareNewlineAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1918)
    public Map<String,Object> unsetMtaPostscreenBareNewlineAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaPostscreenBareNewlineEnable, or ZAttrProvisioning.MtaPostscreenBareNewlineEnable.no if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public ZAttrProvisioning.MtaPostscreenBareNewlineEnable getMtaPostscreenBareNewlineEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenBareNewlineEnable.no : ZAttrProvisioning.MtaPostscreenBareNewlineEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenBareNewlineEnable.no; }
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaPostscreenBareNewlineEnable, or "no" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public String getMtaPostscreenBareNewlineEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, "no", true);
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenBareNewlineEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public void setMtaPostscreenBareNewlineEnable(ZAttrProvisioning.MtaPostscreenBareNewlineEnable zimbraMtaPostscreenBareNewlineEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, zimbraMtaPostscreenBareNewlineEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenBareNewlineEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public Map<String,Object> setMtaPostscreenBareNewlineEnable(ZAttrProvisioning.MtaPostscreenBareNewlineEnable zimbraMtaPostscreenBareNewlineEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, zimbraMtaPostscreenBareNewlineEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenBareNewlineEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public void setMtaPostscreenBareNewlineEnableAsString(String zimbraMtaPostscreenBareNewlineEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, zimbraMtaPostscreenBareNewlineEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenBareNewlineEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public Map<String,Object> setMtaPostscreenBareNewlineEnableAsString(String zimbraMtaPostscreenBareNewlineEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, zimbraMtaPostscreenBareNewlineEnable);
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public void unsetMtaPostscreenBareNewlineEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1919)
    public Map<String,Object> unsetMtaPostscreenBareNewlineEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineEnable, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @return zimbraMtaPostscreenBareNewlineTTL, or "30d" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public String getMtaPostscreenBareNewlineTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, "30d", true);
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @param zimbraMtaPostscreenBareNewlineTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public void setMtaPostscreenBareNewlineTTL(String zimbraMtaPostscreenBareNewlineTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, zimbraMtaPostscreenBareNewlineTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @param zimbraMtaPostscreenBareNewlineTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public Map<String,Object> setMtaPostscreenBareNewlineTTL(String zimbraMtaPostscreenBareNewlineTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, zimbraMtaPostscreenBareNewlineTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public void unsetMtaPostscreenBareNewlineTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_bare_newline_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1920)
    public Map<String,Object> unsetMtaPostscreenBareNewlineTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBareNewlineTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_blacklist_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenBlacklistAction, or ZAttrProvisioning.MtaPostscreenBlacklistAction.ignore if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1921)
    public ZAttrProvisioning.MtaPostscreenBlacklistAction getMtaPostscreenBlacklistAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenBlacklistAction, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenBlacklistAction.ignore : ZAttrProvisioning.MtaPostscreenBlacklistAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenBlacklistAction.ignore; }
    }

    /**
     * Value for postconf postscreen_blacklist_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenBlacklistAction, or "ignore" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1921)
    public String getMtaPostscreenBlacklistActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenBlacklistAction, "ignore", true);
    }

    /**
     * Value for postconf postscreen_blacklist_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenBlacklistAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1921)
    public void setMtaPostscreenBlacklistAction(ZAttrProvisioning.MtaPostscreenBlacklistAction zimbraMtaPostscreenBlacklistAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBlacklistAction, zimbraMtaPostscreenBlacklistAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_blacklist_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenBlacklistAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1921)
    public Map<String,Object> setMtaPostscreenBlacklistAction(ZAttrProvisioning.MtaPostscreenBlacklistAction zimbraMtaPostscreenBlacklistAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBlacklistAction, zimbraMtaPostscreenBlacklistAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_blacklist_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenBlacklistAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1921)
    public void setMtaPostscreenBlacklistActionAsString(String zimbraMtaPostscreenBlacklistAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBlacklistAction, zimbraMtaPostscreenBlacklistAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_blacklist_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenBlacklistAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1921)
    public Map<String,Object> setMtaPostscreenBlacklistActionAsString(String zimbraMtaPostscreenBlacklistAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBlacklistAction, zimbraMtaPostscreenBlacklistAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_blacklist_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1921)
    public void unsetMtaPostscreenBlacklistAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBlacklistAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_blacklist_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1921)
    public Map<String,Object> unsetMtaPostscreenBlacklistAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenBlacklistAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @return zimbraMtaPostscreenCacheCleanupInterval, or "12h" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public String getMtaPostscreenCacheCleanupInterval() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, "12h", true);
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @param zimbraMtaPostscreenCacheCleanupInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public void setMtaPostscreenCacheCleanupInterval(String zimbraMtaPostscreenCacheCleanupInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, zimbraMtaPostscreenCacheCleanupInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @param zimbraMtaPostscreenCacheCleanupInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public Map<String,Object> setMtaPostscreenCacheCleanupInterval(String zimbraMtaPostscreenCacheCleanupInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, zimbraMtaPostscreenCacheCleanupInterval);
        return attrs;
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public void unsetMtaPostscreenCacheCleanupInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_cache_cleanup_interval.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1922)
    public Map<String,Object> unsetMtaPostscreenCacheCleanupInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheCleanupInterval, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @return zimbraMtaPostscreenCacheRetentionTime, or "7d" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public String getMtaPostscreenCacheRetentionTime() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, "7d", true);
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @param zimbraMtaPostscreenCacheRetentionTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public void setMtaPostscreenCacheRetentionTime(String zimbraMtaPostscreenCacheRetentionTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, zimbraMtaPostscreenCacheRetentionTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @param zimbraMtaPostscreenCacheRetentionTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public Map<String,Object> setMtaPostscreenCacheRetentionTime(String zimbraMtaPostscreenCacheRetentionTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, zimbraMtaPostscreenCacheRetentionTime);
        return attrs;
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public void unsetMtaPostscreenCacheRetentionTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_cache_retention_time.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1923)
    public Map<String,Object> unsetMtaPostscreenCacheRetentionTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCacheRetentionTime, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @return zimbraMtaPostscreenCommandCountLimit, or 20 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public int getMtaPostscreenCommandCountLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, 20, true);
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @param zimbraMtaPostscreenCommandCountLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public void setMtaPostscreenCommandCountLimit(int zimbraMtaPostscreenCommandCountLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, Integer.toString(zimbraMtaPostscreenCommandCountLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @param zimbraMtaPostscreenCommandCountLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public Map<String,Object> setMtaPostscreenCommandCountLimit(int zimbraMtaPostscreenCommandCountLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, Integer.toString(zimbraMtaPostscreenCommandCountLimit));
        return attrs;
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public void unsetMtaPostscreenCommandCountLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_command_count_limit.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1924)
    public Map<String,Object> unsetMtaPostscreenCommandCountLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenCommandCountLimit, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenDnsblAction, or ZAttrProvisioning.MtaPostscreenDnsblAction.ignore if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public ZAttrProvisioning.MtaPostscreenDnsblAction getMtaPostscreenDnsblAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenDnsblAction, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenDnsblAction.ignore : ZAttrProvisioning.MtaPostscreenDnsblAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenDnsblAction.ignore; }
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenDnsblAction, or "ignore" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public String getMtaPostscreenDnsblActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblAction, "ignore", true);
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenDnsblAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public void setMtaPostscreenDnsblAction(ZAttrProvisioning.MtaPostscreenDnsblAction zimbraMtaPostscreenDnsblAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, zimbraMtaPostscreenDnsblAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenDnsblAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public Map<String,Object> setMtaPostscreenDnsblAction(ZAttrProvisioning.MtaPostscreenDnsblAction zimbraMtaPostscreenDnsblAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, zimbraMtaPostscreenDnsblAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenDnsblAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public void setMtaPostscreenDnsblActionAsString(String zimbraMtaPostscreenDnsblAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, zimbraMtaPostscreenDnsblAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenDnsblAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public Map<String,Object> setMtaPostscreenDnsblActionAsString(String zimbraMtaPostscreenDnsblAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, zimbraMtaPostscreenDnsblAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public void unsetMtaPostscreenDnsblAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1925)
    public Map<String,Object> unsetMtaPostscreenDnsblAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_max_ttl.
     *
     * @return zimbraMtaPostscreenDnsblMaxTTL, or "${postscreen_dnsbl_ttl?{$postscreen_dnsbl_ttl}:{1}}h" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2083)
    public String getMtaPostscreenDnsblMaxTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblMaxTTL, "${postscreen_dnsbl_ttl?{$postscreen_dnsbl_ttl}:{1}}h", true);
    }

    /**
     * Value for postconf postscreen_dnsbl_max_ttl.
     *
     * @param zimbraMtaPostscreenDnsblMaxTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2083)
    public void setMtaPostscreenDnsblMaxTTL(String zimbraMtaPostscreenDnsblMaxTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblMaxTTL, zimbraMtaPostscreenDnsblMaxTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_max_ttl.
     *
     * @param zimbraMtaPostscreenDnsblMaxTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2083)
    public Map<String,Object> setMtaPostscreenDnsblMaxTTL(String zimbraMtaPostscreenDnsblMaxTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblMaxTTL, zimbraMtaPostscreenDnsblMaxTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_max_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2083)
    public void unsetMtaPostscreenDnsblMaxTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblMaxTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_max_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2083)
    public Map<String,Object> unsetMtaPostscreenDnsblMaxTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblMaxTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_min_ttl.
     *
     * @return zimbraMtaPostscreenDnsblMinTTL, or "60s" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2082)
    public String getMtaPostscreenDnsblMinTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblMinTTL, "60s", true);
    }

    /**
     * Value for postconf postscreen_dnsbl_min_ttl.
     *
     * @param zimbraMtaPostscreenDnsblMinTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2082)
    public void setMtaPostscreenDnsblMinTTL(String zimbraMtaPostscreenDnsblMinTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblMinTTL, zimbraMtaPostscreenDnsblMinTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_min_ttl.
     *
     * @param zimbraMtaPostscreenDnsblMinTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2082)
    public Map<String,Object> setMtaPostscreenDnsblMinTTL(String zimbraMtaPostscreenDnsblMinTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblMinTTL, zimbraMtaPostscreenDnsblMinTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_min_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2082)
    public void unsetMtaPostscreenDnsblMinTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblMinTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_min_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2082)
    public Map<String,Object> unsetMtaPostscreenDnsblMinTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblMinTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @return zimbraMtaPostscreenDnsblReplyMap, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public String getMtaPostscreenDnsblReplyMap() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, null, true);
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @param zimbraMtaPostscreenDnsblReplyMap new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public void setMtaPostscreenDnsblReplyMap(String zimbraMtaPostscreenDnsblReplyMap) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, zimbraMtaPostscreenDnsblReplyMap);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @param zimbraMtaPostscreenDnsblReplyMap new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public Map<String,Object> setMtaPostscreenDnsblReplyMap(String zimbraMtaPostscreenDnsblReplyMap, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, zimbraMtaPostscreenDnsblReplyMap);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public void unsetMtaPostscreenDnsblReplyMap() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_reply_map. Single valued, comma
     * separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1941)
    public Map<String,Object> unsetMtaPostscreenDnsblReplyMap(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblReplyMap, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @return zimbraMtaPostscreenDnsblSites, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public String[] getMtaPostscreenDnsblSites() {
        return getMultiAttr(Provisioning.A_zimbraMtaPostscreenDnsblSites, true, true);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public void setMtaPostscreenDnsblSites(String[] zimbraMtaPostscreenDnsblSites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public Map<String,Object> setMtaPostscreenDnsblSites(String[] zimbraMtaPostscreenDnsblSites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public void addMtaPostscreenDnsblSites(String zimbraMtaPostscreenDnsblSites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public Map<String,Object> addMtaPostscreenDnsblSites(String zimbraMtaPostscreenDnsblSites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public void removeMtaPostscreenDnsblSites(String zimbraMtaPostscreenDnsblSites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param zimbraMtaPostscreenDnsblSites existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public Map<String,Object> removeMtaPostscreenDnsblSites(String zimbraMtaPostscreenDnsblSites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaPostscreenDnsblSites, zimbraMtaPostscreenDnsblSites);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public void unsetMtaPostscreenDnsblSites() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblSites, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_sites. Multi valued, one DNSBL
     * value pair per attribute value.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1926)
    public Map<String,Object> unsetMtaPostscreenDnsblSites(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblSites, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @return zimbraMtaPostscreenDnsblTTL, or "1h" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public String getMtaPostscreenDnsblTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblTTL, "1h", true);
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @param zimbraMtaPostscreenDnsblTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public void setMtaPostscreenDnsblTTL(String zimbraMtaPostscreenDnsblTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTTL, zimbraMtaPostscreenDnsblTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @param zimbraMtaPostscreenDnsblTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public Map<String,Object> setMtaPostscreenDnsblTTL(String zimbraMtaPostscreenDnsblTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTTL, zimbraMtaPostscreenDnsblTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public void unsetMtaPostscreenDnsblTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1929)
    public Map<String,Object> unsetMtaPostscreenDnsblTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @return zimbraMtaPostscreenDnsblThreshold, or 1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public int getMtaPostscreenDnsblThreshold() {
        return getIntAttr(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, 1, true);
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @param zimbraMtaPostscreenDnsblThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public void setMtaPostscreenDnsblThreshold(int zimbraMtaPostscreenDnsblThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, Integer.toString(zimbraMtaPostscreenDnsblThreshold));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @param zimbraMtaPostscreenDnsblThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public Map<String,Object> setMtaPostscreenDnsblThreshold(int zimbraMtaPostscreenDnsblThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, Integer.toString(zimbraMtaPostscreenDnsblThreshold));
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public void unsetMtaPostscreenDnsblThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_threshold.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1927)
    public Map<String,Object> unsetMtaPostscreenDnsblThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblThreshold, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @return zimbraMtaPostscreenDnsblTimeout, or "10s" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public String getMtaPostscreenDnsblTimeout() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, "10s", true);
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @param zimbraMtaPostscreenDnsblTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public void setMtaPostscreenDnsblTimeout(String zimbraMtaPostscreenDnsblTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, zimbraMtaPostscreenDnsblTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @param zimbraMtaPostscreenDnsblTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public Map<String,Object> setMtaPostscreenDnsblTimeout(String zimbraMtaPostscreenDnsblTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, zimbraMtaPostscreenDnsblTimeout);
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public void unsetMtaPostscreenDnsblTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_timeout.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1928)
    public Map<String,Object> unsetMtaPostscreenDnsblTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @return zimbraMtaPostscreenDnsblWhitelistThreshold, or 0 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public int getMtaPostscreenDnsblWhitelistThreshold() {
        return getIntAttr(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, 0, true);
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @param zimbraMtaPostscreenDnsblWhitelistThreshold new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public void setMtaPostscreenDnsblWhitelistThreshold(int zimbraMtaPostscreenDnsblWhitelistThreshold) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, Integer.toString(zimbraMtaPostscreenDnsblWhitelistThreshold));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @param zimbraMtaPostscreenDnsblWhitelistThreshold new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public Map<String,Object> setMtaPostscreenDnsblWhitelistThreshold(int zimbraMtaPostscreenDnsblWhitelistThreshold, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, Integer.toString(zimbraMtaPostscreenDnsblWhitelistThreshold));
        return attrs;
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public void unsetMtaPostscreenDnsblWhitelistThreshold() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_dnsbl_whitelist_threshold.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1930)
    public Map<String,Object> unsetMtaPostscreenDnsblWhitelistThreshold(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenDnsblWhitelistThreshold, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenGreetAction, or ZAttrProvisioning.MtaPostscreenGreetAction.ignore if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public ZAttrProvisioning.MtaPostscreenGreetAction getMtaPostscreenGreetAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenGreetAction, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenGreetAction.ignore : ZAttrProvisioning.MtaPostscreenGreetAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenGreetAction.ignore; }
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenGreetAction, or "ignore" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public String getMtaPostscreenGreetActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenGreetAction, "ignore", true);
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenGreetAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public void setMtaPostscreenGreetAction(ZAttrProvisioning.MtaPostscreenGreetAction zimbraMtaPostscreenGreetAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, zimbraMtaPostscreenGreetAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenGreetAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public Map<String,Object> setMtaPostscreenGreetAction(ZAttrProvisioning.MtaPostscreenGreetAction zimbraMtaPostscreenGreetAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, zimbraMtaPostscreenGreetAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenGreetAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public void setMtaPostscreenGreetActionAsString(String zimbraMtaPostscreenGreetAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, zimbraMtaPostscreenGreetAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenGreetAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public Map<String,Object> setMtaPostscreenGreetActionAsString(String zimbraMtaPostscreenGreetAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, zimbraMtaPostscreenGreetAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public void unsetMtaPostscreenGreetAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1931)
    public Map<String,Object> unsetMtaPostscreenGreetAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @return zimbraMtaPostscreenGreetTTL, or "1d" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public String getMtaPostscreenGreetTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenGreetTTL, "1d", true);
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @param zimbraMtaPostscreenGreetTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public void setMtaPostscreenGreetTTL(String zimbraMtaPostscreenGreetTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetTTL, zimbraMtaPostscreenGreetTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @param zimbraMtaPostscreenGreetTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public Map<String,Object> setMtaPostscreenGreetTTL(String zimbraMtaPostscreenGreetTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetTTL, zimbraMtaPostscreenGreetTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public void unsetMtaPostscreenGreetTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_greet_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1932)
    public Map<String,Object> unsetMtaPostscreenGreetTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenGreetTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenNonSmtpCommandAction, or ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction.drop if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction getMtaPostscreenNonSmtpCommandAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction.drop : ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction.drop; }
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenNonSmtpCommandAction, or "drop" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public String getMtaPostscreenNonSmtpCommandActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, "drop", true);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public void setMtaPostscreenNonSmtpCommandAction(ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction zimbraMtaPostscreenNonSmtpCommandAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, zimbraMtaPostscreenNonSmtpCommandAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandAction(ZAttrProvisioning.MtaPostscreenNonSmtpCommandAction zimbraMtaPostscreenNonSmtpCommandAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, zimbraMtaPostscreenNonSmtpCommandAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public void setMtaPostscreenNonSmtpCommandActionAsString(String zimbraMtaPostscreenNonSmtpCommandAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, zimbraMtaPostscreenNonSmtpCommandAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandActionAsString(String zimbraMtaPostscreenNonSmtpCommandAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, zimbraMtaPostscreenNonSmtpCommandAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public void unsetMtaPostscreenNonSmtpCommandAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1933)
    public Map<String,Object> unsetMtaPostscreenNonSmtpCommandAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaPostscreenNonSmtpCommandEnable, or ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable.no if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable getMtaPostscreenNonSmtpCommandEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable.no : ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable.no; }
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaPostscreenNonSmtpCommandEnable, or "no" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public String getMtaPostscreenNonSmtpCommandEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, "no", true);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public void setMtaPostscreenNonSmtpCommandEnable(ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable zimbraMtaPostscreenNonSmtpCommandEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, zimbraMtaPostscreenNonSmtpCommandEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandEnable(ZAttrProvisioning.MtaPostscreenNonSmtpCommandEnable zimbraMtaPostscreenNonSmtpCommandEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, zimbraMtaPostscreenNonSmtpCommandEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public void setMtaPostscreenNonSmtpCommandEnableAsString(String zimbraMtaPostscreenNonSmtpCommandEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, zimbraMtaPostscreenNonSmtpCommandEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenNonSmtpCommandEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandEnableAsString(String zimbraMtaPostscreenNonSmtpCommandEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, zimbraMtaPostscreenNonSmtpCommandEnable);
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public void unsetMtaPostscreenNonSmtpCommandEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1934)
    public Map<String,Object> unsetMtaPostscreenNonSmtpCommandEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandEnable, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @return zimbraMtaPostscreenNonSmtpCommandTTL, or "30d" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public String getMtaPostscreenNonSmtpCommandTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, "30d", true);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @param zimbraMtaPostscreenNonSmtpCommandTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public void setMtaPostscreenNonSmtpCommandTTL(String zimbraMtaPostscreenNonSmtpCommandTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, zimbraMtaPostscreenNonSmtpCommandTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @param zimbraMtaPostscreenNonSmtpCommandTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public Map<String,Object> setMtaPostscreenNonSmtpCommandTTL(String zimbraMtaPostscreenNonSmtpCommandTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, zimbraMtaPostscreenNonSmtpCommandTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public void unsetMtaPostscreenNonSmtpCommandTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_non_smtp_command_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1935)
    public Map<String,Object> unsetMtaPostscreenNonSmtpCommandTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenNonSmtpCommandTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenPipeliningAction, or ZAttrProvisioning.MtaPostscreenPipeliningAction.enforce if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public ZAttrProvisioning.MtaPostscreenPipeliningAction getMtaPostscreenPipeliningAction() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningAction, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenPipeliningAction.enforce : ZAttrProvisioning.MtaPostscreenPipeliningAction.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenPipeliningAction.enforce; }
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @return zimbraMtaPostscreenPipeliningAction, or "enforce" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public String getMtaPostscreenPipeliningActionAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningAction, "enforce", true);
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenPipeliningAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public void setMtaPostscreenPipeliningAction(ZAttrProvisioning.MtaPostscreenPipeliningAction zimbraMtaPostscreenPipeliningAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, zimbraMtaPostscreenPipeliningAction.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenPipeliningAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public Map<String,Object> setMtaPostscreenPipeliningAction(ZAttrProvisioning.MtaPostscreenPipeliningAction zimbraMtaPostscreenPipeliningAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, zimbraMtaPostscreenPipeliningAction.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenPipeliningAction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public void setMtaPostscreenPipeliningActionAsString(String zimbraMtaPostscreenPipeliningAction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, zimbraMtaPostscreenPipeliningAction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param zimbraMtaPostscreenPipeliningAction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public Map<String,Object> setMtaPostscreenPipeliningActionAsString(String zimbraMtaPostscreenPipeliningAction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, zimbraMtaPostscreenPipeliningAction);
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public void unsetMtaPostscreenPipeliningAction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_action.
     *
     * <p>Valid values: [ignore, enforce, drop]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1936)
    public Map<String,Object> unsetMtaPostscreenPipeliningAction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningAction, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaPostscreenPipeliningEnable, or ZAttrProvisioning.MtaPostscreenPipeliningEnable.no if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public ZAttrProvisioning.MtaPostscreenPipeliningEnable getMtaPostscreenPipeliningEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, true, true); return v == null ? ZAttrProvisioning.MtaPostscreenPipeliningEnable.no : ZAttrProvisioning.MtaPostscreenPipeliningEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaPostscreenPipeliningEnable.no; }
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaPostscreenPipeliningEnable, or "no" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public String getMtaPostscreenPipeliningEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, "no", true);
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenPipeliningEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public void setMtaPostscreenPipeliningEnable(ZAttrProvisioning.MtaPostscreenPipeliningEnable zimbraMtaPostscreenPipeliningEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, zimbraMtaPostscreenPipeliningEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenPipeliningEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public Map<String,Object> setMtaPostscreenPipeliningEnable(ZAttrProvisioning.MtaPostscreenPipeliningEnable zimbraMtaPostscreenPipeliningEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, zimbraMtaPostscreenPipeliningEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenPipeliningEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public void setMtaPostscreenPipeliningEnableAsString(String zimbraMtaPostscreenPipeliningEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, zimbraMtaPostscreenPipeliningEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaPostscreenPipeliningEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public Map<String,Object> setMtaPostscreenPipeliningEnableAsString(String zimbraMtaPostscreenPipeliningEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, zimbraMtaPostscreenPipeliningEnable);
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public void unsetMtaPostscreenPipeliningEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_enable.
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1937)
    public Map<String,Object> unsetMtaPostscreenPipeliningEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningEnable, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @return zimbraMtaPostscreenPipeliningTTL, or "30d" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public String getMtaPostscreenPipeliningTTL() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, "30d", true);
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @param zimbraMtaPostscreenPipeliningTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public void setMtaPostscreenPipeliningTTL(String zimbraMtaPostscreenPipeliningTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, zimbraMtaPostscreenPipeliningTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @param zimbraMtaPostscreenPipeliningTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public Map<String,Object> setMtaPostscreenPipeliningTTL(String zimbraMtaPostscreenPipeliningTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, zimbraMtaPostscreenPipeliningTTL);
        return attrs;
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public void unsetMtaPostscreenPipeliningTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_pipelining_ttl.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1938)
    public Map<String,Object> unsetMtaPostscreenPipeliningTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenPipeliningTTL, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_upstream_proxy_protocol.
     *
     * <p>Valid values: [haproxy]
     *
     * @return zimbraMtaPostscreenUpstreamProxyProtocol, or null if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2089)
    public ZAttrProvisioning.MtaPostscreenUpstreamProxyProtocol getMtaPostscreenUpstreamProxyProtocol() {
        try { String v = getAttr(Provisioning.A_zimbraMtaPostscreenUpstreamProxyProtocol, true, true); return v == null ? null : ZAttrProvisioning.MtaPostscreenUpstreamProxyProtocol.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * Value for postconf postscreen_upstream_proxy_protocol.
     *
     * <p>Valid values: [haproxy]
     *
     * @return zimbraMtaPostscreenUpstreamProxyProtocol, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2089)
    public String getMtaPostscreenUpstreamProxyProtocolAsString() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenUpstreamProxyProtocol, null, true);
    }

    /**
     * Value for postconf postscreen_upstream_proxy_protocol.
     *
     * <p>Valid values: [haproxy]
     *
     * @param zimbraMtaPostscreenUpstreamProxyProtocol new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2089)
    public void setMtaPostscreenUpstreamProxyProtocol(ZAttrProvisioning.MtaPostscreenUpstreamProxyProtocol zimbraMtaPostscreenUpstreamProxyProtocol) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenUpstreamProxyProtocol, zimbraMtaPostscreenUpstreamProxyProtocol.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_upstream_proxy_protocol.
     *
     * <p>Valid values: [haproxy]
     *
     * @param zimbraMtaPostscreenUpstreamProxyProtocol new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2089)
    public Map<String,Object> setMtaPostscreenUpstreamProxyProtocol(ZAttrProvisioning.MtaPostscreenUpstreamProxyProtocol zimbraMtaPostscreenUpstreamProxyProtocol, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenUpstreamProxyProtocol, zimbraMtaPostscreenUpstreamProxyProtocol.toString());
        return attrs;
    }

    /**
     * Value for postconf postscreen_upstream_proxy_protocol.
     *
     * <p>Valid values: [haproxy]
     *
     * @param zimbraMtaPostscreenUpstreamProxyProtocol new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2089)
    public void setMtaPostscreenUpstreamProxyProtocolAsString(String zimbraMtaPostscreenUpstreamProxyProtocol) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenUpstreamProxyProtocol, zimbraMtaPostscreenUpstreamProxyProtocol);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_upstream_proxy_protocol.
     *
     * <p>Valid values: [haproxy]
     *
     * @param zimbraMtaPostscreenUpstreamProxyProtocol new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2089)
    public Map<String,Object> setMtaPostscreenUpstreamProxyProtocolAsString(String zimbraMtaPostscreenUpstreamProxyProtocol, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenUpstreamProxyProtocol, zimbraMtaPostscreenUpstreamProxyProtocol);
        return attrs;
    }

    /**
     * Value for postconf postscreen_upstream_proxy_protocol.
     *
     * <p>Valid values: [haproxy]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2089)
    public void unsetMtaPostscreenUpstreamProxyProtocol() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenUpstreamProxyProtocol, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_upstream_proxy_protocol.
     *
     * <p>Valid values: [haproxy]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2089)
    public Map<String,Object> unsetMtaPostscreenUpstreamProxyProtocol(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenUpstreamProxyProtocol, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @return zimbraMtaPostscreenWatchdogTimeout, or "10s" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public String getMtaPostscreenWatchdogTimeout() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, "10s", true);
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @param zimbraMtaPostscreenWatchdogTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public void setMtaPostscreenWatchdogTimeout(String zimbraMtaPostscreenWatchdogTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, zimbraMtaPostscreenWatchdogTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @param zimbraMtaPostscreenWatchdogTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public Map<String,Object> setMtaPostscreenWatchdogTimeout(String zimbraMtaPostscreenWatchdogTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, zimbraMtaPostscreenWatchdogTimeout);
        return attrs;
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public void unsetMtaPostscreenWatchdogTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_watchdog_timeout.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1939)
    public Map<String,Object> unsetMtaPostscreenWatchdogTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWatchdogTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @return zimbraMtaPostscreenWhitelistInterfaces, or "static:all" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public String getMtaPostscreenWhitelistInterfaces() {
        return getAttr(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, "static:all", true);
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @param zimbraMtaPostscreenWhitelistInterfaces new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public void setMtaPostscreenWhitelistInterfaces(String zimbraMtaPostscreenWhitelistInterfaces) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, zimbraMtaPostscreenWhitelistInterfaces);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @param zimbraMtaPostscreenWhitelistInterfaces new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public Map<String,Object> setMtaPostscreenWhitelistInterfaces(String zimbraMtaPostscreenWhitelistInterfaces, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, zimbraMtaPostscreenWhitelistInterfaces);
        return attrs;
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public void unsetMtaPostscreenWhitelistInterfaces() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf postscreen_whitelist_interfaces. Single valued,
     * comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1940)
    public Map<String,Object> unsetMtaPostscreenWhitelistInterfaces(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPostscreenWhitelistInterfaces, "");
        return attrs;
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [canonical, virtual, alias, forward, include, generic]
     *
     * @return zimbraMtaPropagateUnmatchedExtensions, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public String[] getMtaPropagateUnmatchedExtensionsAsString() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, true, true); return value.length > 0 ? value : new String[] {"canonical"};
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [canonical, virtual, alias, forward, include, generic]
     *
     * @param zimbraMtaPropagateUnmatchedExtensions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public void setMtaPropagateUnmatchedExtensions(ZAttrProvisioning.MtaPropagateUnmatchedExtensions zimbraMtaPropagateUnmatchedExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, zimbraMtaPropagateUnmatchedExtensions.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [canonical, virtual, alias, forward, include, generic]
     *
     * @param zimbraMtaPropagateUnmatchedExtensions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public Map<String,Object> setMtaPropagateUnmatchedExtensions(ZAttrProvisioning.MtaPropagateUnmatchedExtensions zimbraMtaPropagateUnmatchedExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, zimbraMtaPropagateUnmatchedExtensions.toString());
        return attrs;
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [canonical, virtual, alias, forward, include, generic]
     *
     * @param zimbraMtaPropagateUnmatchedExtensions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public void setMtaPropagateUnmatchedExtensionsAsString(String[] zimbraMtaPropagateUnmatchedExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, zimbraMtaPropagateUnmatchedExtensions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [canonical, virtual, alias, forward, include, generic]
     *
     * @param zimbraMtaPropagateUnmatchedExtensions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public Map<String,Object> setMtaPropagateUnmatchedExtensionsAsString(String[] zimbraMtaPropagateUnmatchedExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, zimbraMtaPropagateUnmatchedExtensions);
        return attrs;
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [canonical, virtual, alias, forward, include, generic]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public void unsetMtaPropagateUnmatchedExtensions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf propagate_unmatched_extensions
     *
     * <p>Valid values: [canonical, virtual, alias, forward, include, generic]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1547)
    public Map<String,Object> unsetMtaPropagateUnmatchedExtensions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaPropagateUnmatchedExtensions, "");
        return attrs;
    }

    /**
     * Value for postconf queue_directory
     *
     * @return zimbraMtaQueueDirectory, or "/opt/zimbra/data/postfix/spool" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public String getMtaQueueDirectory() {
        return getAttr(Provisioning.A_zimbraMtaQueueDirectory, "/opt/zimbra/data/postfix/spool", true);
    }

    /**
     * Value for postconf queue_directory
     *
     * @param zimbraMtaQueueDirectory new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public void setMtaQueueDirectory(String zimbraMtaQueueDirectory) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueDirectory, zimbraMtaQueueDirectory);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf queue_directory
     *
     * @param zimbraMtaQueueDirectory new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public Map<String,Object> setMtaQueueDirectory(String zimbraMtaQueueDirectory, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueDirectory, zimbraMtaQueueDirectory);
        return attrs;
    }

    /**
     * Value for postconf queue_directory
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public void unsetMtaQueueDirectory() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueDirectory, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf queue_directory
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1511)
    public Map<String,Object> unsetMtaQueueDirectory(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueDirectory, "");
        return attrs;
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @return zimbraMtaQueueRunDelay, or "300s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public String getMtaQueueRunDelay() {
        return getAttr(Provisioning.A_zimbraMtaQueueRunDelay, "300s", true);
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @param zimbraMtaQueueRunDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public void setMtaQueueRunDelay(String zimbraMtaQueueRunDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueRunDelay, zimbraMtaQueueRunDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @param zimbraMtaQueueRunDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public Map<String,Object> setMtaQueueRunDelay(String zimbraMtaQueueRunDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueRunDelay, zimbraMtaQueueRunDelay);
        return attrs;
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public void unsetMtaQueueRunDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueRunDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf queue_run_delay
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1519)
    public Map<String,Object> unsetMtaQueueRunDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaQueueRunDelay, "");
        return attrs;
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @return zimbraMtaRecipientDelimiter, or empty array if unset
     */
    @ZAttr(id=306)
    public String[] getMtaRecipientDelimiter() {
        return getMultiAttr(Provisioning.A_zimbraMtaRecipientDelimiter, true, true);
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @param zimbraMtaRecipientDelimiter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=306)
    public void setMtaRecipientDelimiter(String[] zimbraMtaRecipientDelimiter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRecipientDelimiter, zimbraMtaRecipientDelimiter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @param zimbraMtaRecipientDelimiter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=306)
    public Map<String,Object> setMtaRecipientDelimiter(String[] zimbraMtaRecipientDelimiter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRecipientDelimiter, zimbraMtaRecipientDelimiter);
        return attrs;
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @param zimbraMtaRecipientDelimiter new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=306)
    public void addMtaRecipientDelimiter(String zimbraMtaRecipientDelimiter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRecipientDelimiter, zimbraMtaRecipientDelimiter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @param zimbraMtaRecipientDelimiter new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=306)
    public Map<String,Object> addMtaRecipientDelimiter(String zimbraMtaRecipientDelimiter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRecipientDelimiter, zimbraMtaRecipientDelimiter);
        return attrs;
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @param zimbraMtaRecipientDelimiter existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=306)
    public void removeMtaRecipientDelimiter(String zimbraMtaRecipientDelimiter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRecipientDelimiter, zimbraMtaRecipientDelimiter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @param zimbraMtaRecipientDelimiter existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=306)
    public Map<String,Object> removeMtaRecipientDelimiter(String zimbraMtaRecipientDelimiter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRecipientDelimiter, zimbraMtaRecipientDelimiter);
        return attrs;
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=306)
    public void unsetMtaRecipientDelimiter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRecipientDelimiter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf recipient_delimiter. Also used by ZCS LMTP server
     * to check if it should accept messages to addresses with extensions.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=306)
    public Map<String,Object> unsetMtaRecipientDelimiter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRecipientDelimiter, "");
        return attrs;
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @return zimbraMtaRelayHost, or empty array if unset
     */
    @ZAttr(id=199)
    public String[] getMtaRelayHost() {
        return getMultiAttr(Provisioning.A_zimbraMtaRelayHost, true, true);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=199)
    public void setMtaRelayHost(String[] zimbraMtaRelayHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=199)
    public Map<String,Object> setMtaRelayHost(String[] zimbraMtaRelayHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        return attrs;
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=199)
    public void addMtaRelayHost(String zimbraMtaRelayHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=199)
    public Map<String,Object> addMtaRelayHost(String zimbraMtaRelayHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        return attrs;
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=199)
    public void removeMtaRelayHost(String zimbraMtaRelayHost) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param zimbraMtaRelayHost existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=199)
    public Map<String,Object> removeMtaRelayHost(String zimbraMtaRelayHost, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRelayHost, zimbraMtaRelayHost);
        return attrs;
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=199)
    public void unsetMtaRelayHost() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRelayHost, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf relayhost. Note: there can be only one value on
     * this attribute, see bug 50697.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=199)
    public Map<String,Object> unsetMtaRelayHost(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRelayHost, "");
        return attrs;
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @return zimbraMtaRestriction, or empty array if unset
     */
    @ZAttr(id=226)
    public String[] getMtaRestriction() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaRestriction, true, true); return value.length > 0 ? value : new String[] {"reject_invalid_helo_hostname","reject_non_fqdn_sender"};
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=226)
    public void setMtaRestriction(String[] zimbraMtaRestriction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=226)
    public Map<String,Object> setMtaRestriction(String[] zimbraMtaRestriction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        return attrs;
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=226)
    public void addMtaRestriction(String zimbraMtaRestriction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=226)
    public Map<String,Object> addMtaRestriction(String zimbraMtaRestriction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        return attrs;
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=226)
    public void removeMtaRestriction(String zimbraMtaRestriction) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param zimbraMtaRestriction existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=226)
    public Map<String,Object> removeMtaRestriction(String zimbraMtaRestriction, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaRestriction, zimbraMtaRestriction);
        return attrs;
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=226)
    public void unsetMtaRestriction() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRestriction, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * smtpd_recipient_restrictions used to reject email in various scenarios
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=226)
    public Map<String,Object> unsetMtaRestriction(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaRestriction, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSaslAuthEnable, or ZAttrProvisioning.MtaSaslAuthEnable.yes if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public ZAttrProvisioning.MtaSaslAuthEnable getMtaSaslAuthEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSaslAuthEnable, true, true); return v == null ? ZAttrProvisioning.MtaSaslAuthEnable.yes : ZAttrProvisioning.MtaSaslAuthEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSaslAuthEnable.yes; }
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSaslAuthEnable, or "yes" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public String getMtaSaslAuthEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaSaslAuthEnable, "yes", true);
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSaslAuthEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public void setMtaSaslAuthEnable(ZAttrProvisioning.MtaSaslAuthEnable zimbraMtaSaslAuthEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, zimbraMtaSaslAuthEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSaslAuthEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public Map<String,Object> setMtaSaslAuthEnable(ZAttrProvisioning.MtaSaslAuthEnable zimbraMtaSaslAuthEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, zimbraMtaSaslAuthEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSaslAuthEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public void setMtaSaslAuthEnableAsString(String zimbraMtaSaslAuthEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, zimbraMtaSaslAuthEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSaslAuthEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public Map<String,Object> setMtaSaslAuthEnableAsString(String zimbraMtaSaslAuthEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, zimbraMtaSaslAuthEnable);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public void unsetMtaSaslAuthEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=796)
    public Map<String,Object> unsetMtaSaslAuthEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslAuthEnable, "");
        return attrs;
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @return zimbraMtaSaslSmtpdMechList, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public String[] getMtaSaslSmtpdMechList() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaSaslSmtpdMechList, true, true); return value.length > 0 ? value : new String[] {"PLAIN","LOGIN"};
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public void setMtaSaslSmtpdMechList(String[] zimbraMtaSaslSmtpdMechList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public Map<String,Object> setMtaSaslSmtpdMechList(String[] zimbraMtaSaslSmtpdMechList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        return attrs;
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public void addMtaSaslSmtpdMechList(String zimbraMtaSaslSmtpdMechList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public Map<String,Object> addMtaSaslSmtpdMechList(String zimbraMtaSaslSmtpdMechList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        return attrs;
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public void removeMtaSaslSmtpdMechList(String zimbraMtaSaslSmtpdMechList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param zimbraMtaSaslSmtpdMechList existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public Map<String,Object> removeMtaSaslSmtpdMechList(String zimbraMtaSaslSmtpdMechList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSaslSmtpdMechList, zimbraMtaSaslSmtpdMechList);
        return attrs;
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public void unsetMtaSaslSmtpdMechList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslSmtpdMechList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Supported SASL mechanisms for use with the MTA. One attribute value
     * per mechanism.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1560)
    public Map<String,Object> unsetMtaSaslSmtpdMechList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSaslSmtpdMechList, "");
        return attrs;
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @return zimbraMtaSenderCanonicalMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public String getMtaSenderCanonicalMaps() {
        return getAttr(Provisioning.A_zimbraMtaSenderCanonicalMaps, null, true);
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @param zimbraMtaSenderCanonicalMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public void setMtaSenderCanonicalMaps(String zimbraMtaSenderCanonicalMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSenderCanonicalMaps, zimbraMtaSenderCanonicalMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @param zimbraMtaSenderCanonicalMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public Map<String,Object> setMtaSenderCanonicalMaps(String zimbraMtaSenderCanonicalMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSenderCanonicalMaps, zimbraMtaSenderCanonicalMaps);
        return attrs;
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public void unsetMtaSenderCanonicalMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSenderCanonicalMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf sender_canonical_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1548)
    public Map<String,Object> unsetMtaSenderCanonicalMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSenderCanonicalMaps, "");
        return attrs;
    }

    /**
     * Value for postconf sendmail_path
     *
     * @return zimbraMtaSendmailPath, or "/opt/zimbra/common/sbin/sendmail" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public String getMtaSendmailPath() {
        return getAttr(Provisioning.A_zimbraMtaSendmailPath, "/opt/zimbra/common/sbin/sendmail", true);
    }

    /**
     * Value for postconf sendmail_path
     *
     * @param zimbraMtaSendmailPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public void setMtaSendmailPath(String zimbraMtaSendmailPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSendmailPath, zimbraMtaSendmailPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf sendmail_path
     *
     * @param zimbraMtaSendmailPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public Map<String,Object> setMtaSendmailPath(String zimbraMtaSendmailPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSendmailPath, zimbraMtaSendmailPath);
        return attrs;
    }

    /**
     * Value for postconf sendmail_path
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public void unsetMtaSendmailPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSendmailPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf sendmail_path
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1512)
    public Map<String,Object> unsetMtaSendmailPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSendmailPath, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpCnameOverridesServername, or ZAttrProvisioning.MtaSmtpCnameOverridesServername.no if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public ZAttrProvisioning.MtaSmtpCnameOverridesServername getMtaSmtpCnameOverridesServername() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, true, true); return v == null ? ZAttrProvisioning.MtaSmtpCnameOverridesServername.no : ZAttrProvisioning.MtaSmtpCnameOverridesServername.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpCnameOverridesServername.no; }
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpCnameOverridesServername, or "no" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public String getMtaSmtpCnameOverridesServernameAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, "no", true);
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpCnameOverridesServername new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public void setMtaSmtpCnameOverridesServername(ZAttrProvisioning.MtaSmtpCnameOverridesServername zimbraMtaSmtpCnameOverridesServername) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, zimbraMtaSmtpCnameOverridesServername.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpCnameOverridesServername new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public Map<String,Object> setMtaSmtpCnameOverridesServername(ZAttrProvisioning.MtaSmtpCnameOverridesServername zimbraMtaSmtpCnameOverridesServername, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, zimbraMtaSmtpCnameOverridesServername.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpCnameOverridesServername new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public void setMtaSmtpCnameOverridesServernameAsString(String zimbraMtaSmtpCnameOverridesServername) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, zimbraMtaSmtpCnameOverridesServername);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpCnameOverridesServername new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public Map<String,Object> setMtaSmtpCnameOverridesServernameAsString(String zimbraMtaSmtpCnameOverridesServername, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, zimbraMtaSmtpCnameOverridesServername);
        return attrs;
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public void unsetMtaSmtpCnameOverridesServername() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_cname_overrides_servername
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1524)
    public Map<String,Object> unsetMtaSmtpCnameOverridesServername(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpCnameOverridesServername, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_dns_support_level
     *
     * <p>Valid values: [disabled, enabled, dnssec]
     *
     * @return zimbraMtaSmtpDnsSupportLevel, or ZAttrProvisioning.MtaSmtpDnsSupportLevel.enabled if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2075)
    public ZAttrProvisioning.MtaSmtpDnsSupportLevel getMtaSmtpDnsSupportLevel() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpDnsSupportLevel, true, true); return v == null ? ZAttrProvisioning.MtaSmtpDnsSupportLevel.enabled : ZAttrProvisioning.MtaSmtpDnsSupportLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpDnsSupportLevel.enabled; }
    }

    /**
     * Value for postconf smtp_dns_support_level
     *
     * <p>Valid values: [disabled, enabled, dnssec]
     *
     * @return zimbraMtaSmtpDnsSupportLevel, or "enabled" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2075)
    public String getMtaSmtpDnsSupportLevelAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpDnsSupportLevel, "enabled", true);
    }

    /**
     * Value for postconf smtp_dns_support_level
     *
     * <p>Valid values: [disabled, enabled, dnssec]
     *
     * @param zimbraMtaSmtpDnsSupportLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2075)
    public void setMtaSmtpDnsSupportLevel(ZAttrProvisioning.MtaSmtpDnsSupportLevel zimbraMtaSmtpDnsSupportLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpDnsSupportLevel, zimbraMtaSmtpDnsSupportLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_dns_support_level
     *
     * <p>Valid values: [disabled, enabled, dnssec]
     *
     * @param zimbraMtaSmtpDnsSupportLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2075)
    public Map<String,Object> setMtaSmtpDnsSupportLevel(ZAttrProvisioning.MtaSmtpDnsSupportLevel zimbraMtaSmtpDnsSupportLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpDnsSupportLevel, zimbraMtaSmtpDnsSupportLevel.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_dns_support_level
     *
     * <p>Valid values: [disabled, enabled, dnssec]
     *
     * @param zimbraMtaSmtpDnsSupportLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2075)
    public void setMtaSmtpDnsSupportLevelAsString(String zimbraMtaSmtpDnsSupportLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpDnsSupportLevel, zimbraMtaSmtpDnsSupportLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_dns_support_level
     *
     * <p>Valid values: [disabled, enabled, dnssec]
     *
     * @param zimbraMtaSmtpDnsSupportLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2075)
    public Map<String,Object> setMtaSmtpDnsSupportLevelAsString(String zimbraMtaSmtpDnsSupportLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpDnsSupportLevel, zimbraMtaSmtpDnsSupportLevel);
        return attrs;
    }

    /**
     * Value for postconf smtp_dns_support_level
     *
     * <p>Valid values: [disabled, enabled, dnssec]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2075)
    public void unsetMtaSmtpDnsSupportLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpDnsSupportLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_dns_support_level
     *
     * <p>Valid values: [disabled, enabled, dnssec]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2075)
    public Map<String,Object> unsetMtaSmtpDnsSupportLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpDnsSupportLevel, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @return zimbraMtaSmtpGenericMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public String getMtaSmtpGenericMaps() {
        return getAttr(Provisioning.A_zimbraMtaSmtpGenericMaps, null, true);
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @param zimbraMtaSmtpGenericMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public void setMtaSmtpGenericMaps(String zimbraMtaSmtpGenericMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpGenericMaps, zimbraMtaSmtpGenericMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @param zimbraMtaSmtpGenericMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public Map<String,Object> setMtaSmtpGenericMaps(String zimbraMtaSmtpGenericMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpGenericMaps, zimbraMtaSmtpGenericMaps);
        return attrs;
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public void unsetMtaSmtpGenericMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpGenericMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_generic_maps
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1645)
    public Map<String,Object> unsetMtaSmtpGenericMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpGenericMaps, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @return zimbraMtaSmtpHeloName, or "$myhostname" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public String getMtaSmtpHeloName() {
        return getAttr(Provisioning.A_zimbraMtaSmtpHeloName, "$myhostname", true);
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @param zimbraMtaSmtpHeloName new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public void setMtaSmtpHeloName(String zimbraMtaSmtpHeloName) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpHeloName, zimbraMtaSmtpHeloName);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @param zimbraMtaSmtpHeloName new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public Map<String,Object> setMtaSmtpHeloName(String zimbraMtaSmtpHeloName, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpHeloName, zimbraMtaSmtpHeloName);
        return attrs;
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public void unsetMtaSmtpHeloName() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpHeloName, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_helo_name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1525)
    public Map<String,Object> unsetMtaSmtpHeloName(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpHeloName, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpSaslAuthEnable, or ZAttrProvisioning.MtaSmtpSaslAuthEnable.no if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public ZAttrProvisioning.MtaSmtpSaslAuthEnable getMtaSmtpSaslAuthEnable() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, true, true); return v == null ? ZAttrProvisioning.MtaSmtpSaslAuthEnable.no : ZAttrProvisioning.MtaSmtpSaslAuthEnable.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpSaslAuthEnable.no; }
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpSaslAuthEnable, or "no" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public String getMtaSmtpSaslAuthEnableAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, "no", true);
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpSaslAuthEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public void setMtaSmtpSaslAuthEnable(ZAttrProvisioning.MtaSmtpSaslAuthEnable zimbraMtaSmtpSaslAuthEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, zimbraMtaSmtpSaslAuthEnable.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpSaslAuthEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public Map<String,Object> setMtaSmtpSaslAuthEnable(ZAttrProvisioning.MtaSmtpSaslAuthEnable zimbraMtaSmtpSaslAuthEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, zimbraMtaSmtpSaslAuthEnable.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpSaslAuthEnable new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public void setMtaSmtpSaslAuthEnableAsString(String zimbraMtaSmtpSaslAuthEnable) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, zimbraMtaSmtpSaslAuthEnable);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpSaslAuthEnable new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public Map<String,Object> setMtaSmtpSaslAuthEnableAsString(String zimbraMtaSmtpSaslAuthEnable, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, zimbraMtaSmtpSaslAuthEnable);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public void unsetMtaSmtpSaslAuthEnable() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_auth_enable
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1526)
    public Map<String,Object> unsetMtaSmtpSaslAuthEnable(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslAuthEnable, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @return zimbraMtaSmtpSaslMechanismFilter, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public String[] getMtaSmtpSaslMechanismFilter() {
        return getMultiAttr(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, true, true);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public void setMtaSmtpSaslMechanismFilter(String[] zimbraMtaSmtpSaslMechanismFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public Map<String,Object> setMtaSmtpSaslMechanismFilter(String[] zimbraMtaSmtpSaslMechanismFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public void addMtaSmtpSaslMechanismFilter(String zimbraMtaSmtpSaslMechanismFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public Map<String,Object> addMtaSmtpSaslMechanismFilter(String zimbraMtaSmtpSaslMechanismFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public void removeMtaSmtpSaslMechanismFilter(String zimbraMtaSmtpSaslMechanismFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param zimbraMtaSmtpSaslMechanismFilter existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public Map<String,Object> removeMtaSmtpSaslMechanismFilter(String zimbraMtaSmtpSaslMechanismFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, zimbraMtaSmtpSaslMechanismFilter);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public void unsetMtaSmtpSaslMechanismFilter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_mechanism_filter
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1528)
    public Map<String,Object> unsetMtaSmtpSaslMechanismFilter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslMechanismFilter, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @return zimbraMtaSmtpSaslPasswordMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public String getMtaSmtpSaslPasswordMaps() {
        return getAttr(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, null, true);
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @param zimbraMtaSmtpSaslPasswordMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public void setMtaSmtpSaslPasswordMaps(String zimbraMtaSmtpSaslPasswordMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, zimbraMtaSmtpSaslPasswordMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @param zimbraMtaSmtpSaslPasswordMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public Map<String,Object> setMtaSmtpSaslPasswordMaps(String zimbraMtaSmtpSaslPasswordMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, zimbraMtaSmtpSaslPasswordMaps);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public void unsetMtaSmtpSaslPasswordMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_password_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1529)
    public Map<String,Object> unsetMtaSmtpSaslPasswordMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslPasswordMaps, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @return zimbraMtaSmtpSaslSecurityOptions, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public String[] getMtaSmtpSaslSecurityOptionsAsString() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, true, true); return value.length > 0 ? value : new String[] {"noplaintext,noanonymous"};
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpSaslSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public void setMtaSmtpSaslSecurityOptions(ZAttrProvisioning.MtaSmtpSaslSecurityOptions zimbraMtaSmtpSaslSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, zimbraMtaSmtpSaslSecurityOptions.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpSaslSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public Map<String,Object> setMtaSmtpSaslSecurityOptions(ZAttrProvisioning.MtaSmtpSaslSecurityOptions zimbraMtaSmtpSaslSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, zimbraMtaSmtpSaslSecurityOptions.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpSaslSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public void setMtaSmtpSaslSecurityOptionsAsString(String[] zimbraMtaSmtpSaslSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, zimbraMtaSmtpSaslSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpSaslSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public Map<String,Object> setMtaSmtpSaslSecurityOptionsAsString(String[] zimbraMtaSmtpSaslSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, zimbraMtaSmtpSaslSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public void unsetMtaSmtpSaslSecurityOptions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1549)
    public Map<String,Object> unsetMtaSmtpSaslSecurityOptions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpSaslSecurityOptions, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @return zimbraMtaSmtpTlsCAfile, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public String getMtaSmtpTlsCAfile() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsCAfile, null, true);
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @param zimbraMtaSmtpTlsCAfile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public void setMtaSmtpTlsCAfile(String zimbraMtaSmtpTlsCAfile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCAfile, zimbraMtaSmtpTlsCAfile);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @param zimbraMtaSmtpTlsCAfile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public Map<String,Object> setMtaSmtpTlsCAfile(String zimbraMtaSmtpTlsCAfile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCAfile, zimbraMtaSmtpTlsCAfile);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public void unsetMtaSmtpTlsCAfile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCAfile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_CAfile
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1565)
    public Map<String,Object> unsetMtaSmtpTlsCAfile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCAfile, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @return zimbraMtaSmtpTlsCApath, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public String getMtaSmtpTlsCApath() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsCApath, null, true);
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @param zimbraMtaSmtpTlsCApath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public void setMtaSmtpTlsCApath(String zimbraMtaSmtpTlsCApath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCApath, zimbraMtaSmtpTlsCApath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @param zimbraMtaSmtpTlsCApath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public Map<String,Object> setMtaSmtpTlsCApath(String zimbraMtaSmtpTlsCApath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCApath, zimbraMtaSmtpTlsCApath);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public void unsetMtaSmtpTlsCApath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCApath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_CApath
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1566)
    public Map<String,Object> unsetMtaSmtpTlsCApath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCApath, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaSmtpTlsCiphers, or ZAttrProvisioning.MtaSmtpTlsCiphers.export if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public ZAttrProvisioning.MtaSmtpTlsCiphers getMtaSmtpTlsCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpTlsCiphers, true, true); return v == null ? ZAttrProvisioning.MtaSmtpTlsCiphers.export : ZAttrProvisioning.MtaSmtpTlsCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpTlsCiphers.export; }
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaSmtpTlsCiphers, or "export" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public String getMtaSmtpTlsCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsCiphers, "export", true);
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public void setMtaSmtpTlsCiphers(ZAttrProvisioning.MtaSmtpTlsCiphers zimbraMtaSmtpTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, zimbraMtaSmtpTlsCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public Map<String,Object> setMtaSmtpTlsCiphers(ZAttrProvisioning.MtaSmtpTlsCiphers zimbraMtaSmtpTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, zimbraMtaSmtpTlsCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public void setMtaSmtpTlsCiphersAsString(String zimbraMtaSmtpTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, zimbraMtaSmtpTlsCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public Map<String,Object> setMtaSmtpTlsCiphersAsString(String zimbraMtaSmtpTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, zimbraMtaSmtpTlsCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public void unsetMtaSmtpTlsCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1513)
    public Map<String,Object> unsetMtaSmtpTlsCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_dane_insecure_mx_policy.
     *
     * <p>Valid values: [may, encrypt, dane]
     *
     * @return zimbraMtaSmtpTlsDaneInsecureMXPolicy, or ZAttrProvisioning.MtaSmtpTlsDaneInsecureMXPolicy.dane if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2085)
    public ZAttrProvisioning.MtaSmtpTlsDaneInsecureMXPolicy getMtaSmtpTlsDaneInsecureMXPolicy() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpTlsDaneInsecureMXPolicy, true, true); return v == null ? ZAttrProvisioning.MtaSmtpTlsDaneInsecureMXPolicy.dane : ZAttrProvisioning.MtaSmtpTlsDaneInsecureMXPolicy.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpTlsDaneInsecureMXPolicy.dane; }
    }

    /**
     * Value for postconf smtp_tls_dane_insecure_mx_policy.
     *
     * <p>Valid values: [may, encrypt, dane]
     *
     * @return zimbraMtaSmtpTlsDaneInsecureMXPolicy, or "dane" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2085)
    public String getMtaSmtpTlsDaneInsecureMXPolicyAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsDaneInsecureMXPolicy, "dane", true);
    }

    /**
     * Value for postconf smtp_tls_dane_insecure_mx_policy.
     *
     * <p>Valid values: [may, encrypt, dane]
     *
     * @param zimbraMtaSmtpTlsDaneInsecureMXPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2085)
    public void setMtaSmtpTlsDaneInsecureMXPolicy(ZAttrProvisioning.MtaSmtpTlsDaneInsecureMXPolicy zimbraMtaSmtpTlsDaneInsecureMXPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsDaneInsecureMXPolicy, zimbraMtaSmtpTlsDaneInsecureMXPolicy.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_dane_insecure_mx_policy.
     *
     * <p>Valid values: [may, encrypt, dane]
     *
     * @param zimbraMtaSmtpTlsDaneInsecureMXPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2085)
    public Map<String,Object> setMtaSmtpTlsDaneInsecureMXPolicy(ZAttrProvisioning.MtaSmtpTlsDaneInsecureMXPolicy zimbraMtaSmtpTlsDaneInsecureMXPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsDaneInsecureMXPolicy, zimbraMtaSmtpTlsDaneInsecureMXPolicy.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_dane_insecure_mx_policy.
     *
     * <p>Valid values: [may, encrypt, dane]
     *
     * @param zimbraMtaSmtpTlsDaneInsecureMXPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2085)
    public void setMtaSmtpTlsDaneInsecureMXPolicyAsString(String zimbraMtaSmtpTlsDaneInsecureMXPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsDaneInsecureMXPolicy, zimbraMtaSmtpTlsDaneInsecureMXPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_dane_insecure_mx_policy.
     *
     * <p>Valid values: [may, encrypt, dane]
     *
     * @param zimbraMtaSmtpTlsDaneInsecureMXPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2085)
    public Map<String,Object> setMtaSmtpTlsDaneInsecureMXPolicyAsString(String zimbraMtaSmtpTlsDaneInsecureMXPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsDaneInsecureMXPolicy, zimbraMtaSmtpTlsDaneInsecureMXPolicy);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_dane_insecure_mx_policy.
     *
     * <p>Valid values: [may, encrypt, dane]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2085)
    public void unsetMtaSmtpTlsDaneInsecureMXPolicy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsDaneInsecureMXPolicy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_dane_insecure_mx_policy.
     *
     * <p>Valid values: [may, encrypt, dane]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2085)
    public Map<String,Object> unsetMtaSmtpTlsDaneInsecureMXPolicy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsDaneInsecureMXPolicy, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @return zimbraMtaSmtpTlsLoglevel, or 0 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public int getMtaSmtpTlsLoglevel() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpTlsLoglevel, 0, true);
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param zimbraMtaSmtpTlsLoglevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public void setMtaSmtpTlsLoglevel(int zimbraMtaSmtpTlsLoglevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsLoglevel, Integer.toString(zimbraMtaSmtpTlsLoglevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param zimbraMtaSmtpTlsLoglevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public Map<String,Object> setMtaSmtpTlsLoglevel(int zimbraMtaSmtpTlsLoglevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsLoglevel, Integer.toString(zimbraMtaSmtpTlsLoglevel));
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public void unsetMtaSmtpTlsLoglevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsLoglevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_loglevel. Defaults to 0. Valid range is
     * 0-4
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1568)
    public Map<String,Object> unsetMtaSmtpTlsLoglevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsLoglevel, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaSmtpTlsMandatoryCiphers, or ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers.medium if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers getMtaSmtpTlsMandatoryCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, true, true); return v == null ? ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers.medium : ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers.medium; }
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaSmtpTlsMandatoryCiphers, or "medium" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public String getMtaSmtpTlsMandatoryCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, "medium", true);
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public void setMtaSmtpTlsMandatoryCiphers(ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers zimbraMtaSmtpTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, zimbraMtaSmtpTlsMandatoryCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public Map<String,Object> setMtaSmtpTlsMandatoryCiphers(ZAttrProvisioning.MtaSmtpTlsMandatoryCiphers zimbraMtaSmtpTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, zimbraMtaSmtpTlsMandatoryCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public void setMtaSmtpTlsMandatoryCiphersAsString(String zimbraMtaSmtpTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, zimbraMtaSmtpTlsMandatoryCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public Map<String,Object> setMtaSmtpTlsMandatoryCiphersAsString(String zimbraMtaSmtpTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, zimbraMtaSmtpTlsMandatoryCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public void unsetMtaSmtpTlsMandatoryCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1514)
    public Map<String,Object> unsetMtaSmtpTlsMandatoryCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @return zimbraMtaSmtpTlsMandatoryProtocols, or "!SSLv2, !SSLv3" if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1782)
    public String getMtaSmtpTlsMandatoryProtocols() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, "!SSLv2, !SSLv3", true);
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @param zimbraMtaSmtpTlsMandatoryProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1782)
    public void setMtaSmtpTlsMandatoryProtocols(String zimbraMtaSmtpTlsMandatoryProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, zimbraMtaSmtpTlsMandatoryProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @param zimbraMtaSmtpTlsMandatoryProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1782)
    public Map<String,Object> setMtaSmtpTlsMandatoryProtocols(String zimbraMtaSmtpTlsMandatoryProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, zimbraMtaSmtpTlsMandatoryProtocols);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1782)
    public void unsetMtaSmtpTlsMandatoryProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_mandatory_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1782)
    public Map<String,Object> unsetMtaSmtpTlsMandatoryProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsMandatoryProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @return zimbraMtaSmtpTlsProtocols, or "!SSLv2, !SSLv3" if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public String getMtaSmtpTlsProtocols() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsProtocols, "!SSLv2, !SSLv3", true);
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @param zimbraMtaSmtpTlsProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public void setMtaSmtpTlsProtocols(String zimbraMtaSmtpTlsProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsProtocols, zimbraMtaSmtpTlsProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @param zimbraMtaSmtpTlsProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public Map<String,Object> setMtaSmtpTlsProtocols(String zimbraMtaSmtpTlsProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsProtocols, zimbraMtaSmtpTlsProtocols);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public void unsetMtaSmtpTlsProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1670)
    public Map<String,Object> unsetMtaSmtpTlsProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @return zimbraMtaSmtpTlsSecurityLevel, or ZAttrProvisioning.MtaSmtpTlsSecurityLevel.may if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public ZAttrProvisioning.MtaSmtpTlsSecurityLevel getMtaSmtpTlsSecurityLevel() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, true, true); return v == null ? ZAttrProvisioning.MtaSmtpTlsSecurityLevel.may : ZAttrProvisioning.MtaSmtpTlsSecurityLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpTlsSecurityLevel.may; }
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @return zimbraMtaSmtpTlsSecurityLevel, or "may" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public String getMtaSmtpTlsSecurityLevelAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, "may", true);
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param zimbraMtaSmtpTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public void setMtaSmtpTlsSecurityLevel(ZAttrProvisioning.MtaSmtpTlsSecurityLevel zimbraMtaSmtpTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, zimbraMtaSmtpTlsSecurityLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param zimbraMtaSmtpTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public Map<String,Object> setMtaSmtpTlsSecurityLevel(ZAttrProvisioning.MtaSmtpTlsSecurityLevel zimbraMtaSmtpTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, zimbraMtaSmtpTlsSecurityLevel.toString());
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param zimbraMtaSmtpTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public void setMtaSmtpTlsSecurityLevelAsString(String zimbraMtaSmtpTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, zimbraMtaSmtpTlsSecurityLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param zimbraMtaSmtpTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public Map<String,Object> setMtaSmtpTlsSecurityLevelAsString(String zimbraMtaSmtpTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, zimbraMtaSmtpTlsSecurityLevel);
        return attrs;
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public void unsetMtaSmtpTlsSecurityLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_tls_security_level
     *
     * <p>Valid values: [none, may, encrypt, dane, dane-only, fingerprint, verify, secure]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1527)
    public Map<String,Object> unsetMtaSmtpTlsSecurityLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTlsSecurityLevel, "");
        return attrs;
    }

    /**
     * Value for postconf smtp_transport_rate_delay.
     *
     * @return zimbraMtaSmtpTransportRateDelay, or "$default_transport_rate_delay" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2081)
    public String getMtaSmtpTransportRateDelay() {
        return getAttr(Provisioning.A_zimbraMtaSmtpTransportRateDelay, "$default_transport_rate_delay", true);
    }

    /**
     * Value for postconf smtp_transport_rate_delay.
     *
     * @param zimbraMtaSmtpTransportRateDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2081)
    public void setMtaSmtpTransportRateDelay(String zimbraMtaSmtpTransportRateDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTransportRateDelay, zimbraMtaSmtpTransportRateDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_transport_rate_delay.
     *
     * @param zimbraMtaSmtpTransportRateDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2081)
    public Map<String,Object> setMtaSmtpTransportRateDelay(String zimbraMtaSmtpTransportRateDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTransportRateDelay, zimbraMtaSmtpTransportRateDelay);
        return attrs;
    }

    /**
     * Value for postconf smtp_transport_rate_delay.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2081)
    public void unsetMtaSmtpTransportRateDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTransportRateDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtp_transport_rate_delay.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2081)
    public Map<String,Object> unsetMtaSmtpTransportRateDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpTransportRateDelay, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @return zimbraMtaSmtpdBanner, or "$myhostname ESMTP $mail_name" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public String getMtaSmtpdBanner() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdBanner, "$myhostname ESMTP $mail_name", true);
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @param zimbraMtaSmtpdBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public void setMtaSmtpdBanner(String zimbraMtaSmtpdBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdBanner, zimbraMtaSmtpdBanner);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @param zimbraMtaSmtpdBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public Map<String,Object> setMtaSmtpdBanner(String zimbraMtaSmtpdBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdBanner, zimbraMtaSmtpdBanner);
        return attrs;
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public void unsetMtaSmtpdBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_banner
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1532)
    public Map<String,Object> unsetMtaSmtpdBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdBanner, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_auth_rate_limit.
     *
     * @return zimbraMtaSmtpdClientAuthRateLimit, or 0 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2084)
    public int getMtaSmtpdClientAuthRateLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpdClientAuthRateLimit, 0, true);
    }

    /**
     * Value for postconf smtpd_client_auth_rate_limit.
     *
     * @param zimbraMtaSmtpdClientAuthRateLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2084)
    public void setMtaSmtpdClientAuthRateLimit(int zimbraMtaSmtpdClientAuthRateLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientAuthRateLimit, Integer.toString(zimbraMtaSmtpdClientAuthRateLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_auth_rate_limit.
     *
     * @param zimbraMtaSmtpdClientAuthRateLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2084)
    public Map<String,Object> setMtaSmtpdClientAuthRateLimit(int zimbraMtaSmtpdClientAuthRateLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientAuthRateLimit, Integer.toString(zimbraMtaSmtpdClientAuthRateLimit));
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_auth_rate_limit.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2084)
    public void unsetMtaSmtpdClientAuthRateLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientAuthRateLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_auth_rate_limit.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2084)
    public Map<String,Object> unsetMtaSmtpdClientAuthRateLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientAuthRateLimit, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdClientPortLogging, or ZAttrProvisioning.MtaSmtpdClientPortLogging.no if unset and/or has invalid value
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public ZAttrProvisioning.MtaSmtpdClientPortLogging getMtaSmtpdClientPortLogging() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdClientPortLogging, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdClientPortLogging.no : ZAttrProvisioning.MtaSmtpdClientPortLogging.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdClientPortLogging.no; }
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdClientPortLogging, or "no" if unset
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public String getMtaSmtpdClientPortLoggingAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdClientPortLogging, "no", true);
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdClientPortLogging new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public void setMtaSmtpdClientPortLogging(ZAttrProvisioning.MtaSmtpdClientPortLogging zimbraMtaSmtpdClientPortLogging) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, zimbraMtaSmtpdClientPortLogging.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdClientPortLogging new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public Map<String,Object> setMtaSmtpdClientPortLogging(ZAttrProvisioning.MtaSmtpdClientPortLogging zimbraMtaSmtpdClientPortLogging, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, zimbraMtaSmtpdClientPortLogging.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdClientPortLogging new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public void setMtaSmtpdClientPortLoggingAsString(String zimbraMtaSmtpdClientPortLogging) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, zimbraMtaSmtpdClientPortLogging);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdClientPortLogging new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public Map<String,Object> setMtaSmtpdClientPortLoggingAsString(String zimbraMtaSmtpdClientPortLogging, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, zimbraMtaSmtpdClientPortLogging);
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public void unsetMtaSmtpdClientPortLogging() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_port_logging. Defaults to no
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1588)
    public Map<String,Object> unsetMtaSmtpdClientPortLogging(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientPortLogging, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @return zimbraMtaSmtpdClientRestrictions, or "reject_unauth_pipelining" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public String getMtaSmtpdClientRestrictions() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdClientRestrictions, "reject_unauth_pipelining", true);
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @param zimbraMtaSmtpdClientRestrictions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public void setMtaSmtpdClientRestrictions(String zimbraMtaSmtpdClientRestrictions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientRestrictions, zimbraMtaSmtpdClientRestrictions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @param zimbraMtaSmtpdClientRestrictions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public Map<String,Object> setMtaSmtpdClientRestrictions(String zimbraMtaSmtpdClientRestrictions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientRestrictions, zimbraMtaSmtpdClientRestrictions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public void unsetMtaSmtpdClientRestrictions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientRestrictions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_client_restrictions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1553)
    public Map<String,Object> unsetMtaSmtpdClientRestrictions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdClientRestrictions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @return zimbraMtaSmtpdDataRestrictions, or "reject_unauth_pipelining" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public String getMtaSmtpdDataRestrictions() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdDataRestrictions, "reject_unauth_pipelining", true);
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @param zimbraMtaSmtpdDataRestrictions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public void setMtaSmtpdDataRestrictions(String zimbraMtaSmtpdDataRestrictions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdDataRestrictions, zimbraMtaSmtpdDataRestrictions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @param zimbraMtaSmtpdDataRestrictions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public Map<String,Object> setMtaSmtpdDataRestrictions(String zimbraMtaSmtpdDataRestrictions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdDataRestrictions, zimbraMtaSmtpdDataRestrictions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public void unsetMtaSmtpdDataRestrictions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdDataRestrictions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_data_restrictions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1554)
    public Map<String,Object> unsetMtaSmtpdDataRestrictions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdDataRestrictions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @return zimbraMtaSmtpdErrorSleepTime, or "1s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public String getMtaSmtpdErrorSleepTime() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, "1s", true);
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @param zimbraMtaSmtpdErrorSleepTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public void setMtaSmtpdErrorSleepTime(String zimbraMtaSmtpdErrorSleepTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, zimbraMtaSmtpdErrorSleepTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @param zimbraMtaSmtpdErrorSleepTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public Map<String,Object> setMtaSmtpdErrorSleepTime(String zimbraMtaSmtpdErrorSleepTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, zimbraMtaSmtpdErrorSleepTime);
        return attrs;
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public void unsetMtaSmtpdErrorSleepTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_error_sleep_time
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1539)
    public Map<String,Object> unsetMtaSmtpdErrorSleepTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdErrorSleepTime, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @return zimbraMtaSmtpdHardErrorLimit, or 20 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public int getMtaSmtpdHardErrorLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, 20, true);
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @param zimbraMtaSmtpdHardErrorLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public void setMtaSmtpdHardErrorLimit(int zimbraMtaSmtpdHardErrorLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, Integer.toString(zimbraMtaSmtpdHardErrorLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @param zimbraMtaSmtpdHardErrorLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public Map<String,Object> setMtaSmtpdHardErrorLimit(int zimbraMtaSmtpdHardErrorLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, Integer.toString(zimbraMtaSmtpdHardErrorLimit));
        return attrs;
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public void unsetMtaSmtpdHardErrorLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_hard_error_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1537)
    public Map<String,Object> unsetMtaSmtpdHardErrorLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHardErrorLimit, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdHeloRequired, or ZAttrProvisioning.MtaSmtpdHeloRequired.yes if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public ZAttrProvisioning.MtaSmtpdHeloRequired getMtaSmtpdHeloRequired() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdHeloRequired, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdHeloRequired.yes : ZAttrProvisioning.MtaSmtpdHeloRequired.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdHeloRequired.yes; }
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdHeloRequired, or "yes" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public String getMtaSmtpdHeloRequiredAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdHeloRequired, "yes", true);
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdHeloRequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public void setMtaSmtpdHeloRequired(ZAttrProvisioning.MtaSmtpdHeloRequired zimbraMtaSmtpdHeloRequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, zimbraMtaSmtpdHeloRequired.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdHeloRequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public Map<String,Object> setMtaSmtpdHeloRequired(ZAttrProvisioning.MtaSmtpdHeloRequired zimbraMtaSmtpdHeloRequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, zimbraMtaSmtpdHeloRequired.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdHeloRequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public void setMtaSmtpdHeloRequiredAsString(String zimbraMtaSmtpdHeloRequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, zimbraMtaSmtpdHeloRequired);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdHeloRequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public Map<String,Object> setMtaSmtpdHeloRequiredAsString(String zimbraMtaSmtpdHeloRequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, zimbraMtaSmtpdHeloRequired);
        return attrs;
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public void unsetMtaSmtpdHeloRequired() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_helo_required
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1540)
    public Map<String,Object> unsetMtaSmtpdHeloRequired(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdHeloRequired, "");
        return attrs;
    }

    /**
     * value for postfix smtpd_milters
     *
     * @return zimbraMtaSmtpdMilters, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public String getMtaSmtpdMilters() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdMilters, null, true);
    }

    /**
     * value for postfix smtpd_milters
     *
     * @param zimbraMtaSmtpdMilters new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public void setMtaSmtpdMilters(String zimbraMtaSmtpdMilters) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdMilters, zimbraMtaSmtpdMilters);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for postfix smtpd_milters
     *
     * @param zimbraMtaSmtpdMilters new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public Map<String,Object> setMtaSmtpdMilters(String zimbraMtaSmtpdMilters, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdMilters, zimbraMtaSmtpdMilters);
        return attrs;
    }

    /**
     * value for postfix smtpd_milters
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public void unsetMtaSmtpdMilters() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdMilters, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for postfix smtpd_milters
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=672)
    public Map<String,Object> unsetMtaSmtpdMilters(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdMilters, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @return zimbraMtaSmtpdProxyTimeout, or "100s" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public String getMtaSmtpdProxyTimeout() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdProxyTimeout, "100s", true);
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @param zimbraMtaSmtpdProxyTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public void setMtaSmtpdProxyTimeout(String zimbraMtaSmtpdProxyTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdProxyTimeout, zimbraMtaSmtpdProxyTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @param zimbraMtaSmtpdProxyTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public Map<String,Object> setMtaSmtpdProxyTimeout(String zimbraMtaSmtpdProxyTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdProxyTimeout, zimbraMtaSmtpdProxyTimeout);
        return attrs;
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public void unsetMtaSmtpdProxyTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdProxyTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_proxy_timeout
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1533)
    public Map<String,Object> unsetMtaSmtpdProxyTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdProxyTimeout, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdRejectUnlistedRecipient, or ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient.no if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient getMtaSmtpdRejectUnlistedRecipient() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient.no : ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient.no; }
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdRejectUnlistedRecipient, or "no" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public String getMtaSmtpdRejectUnlistedRecipientAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, "no", true);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdRejectUnlistedRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public void setMtaSmtpdRejectUnlistedRecipient(ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient zimbraMtaSmtpdRejectUnlistedRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, zimbraMtaSmtpdRejectUnlistedRecipient.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdRejectUnlistedRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public Map<String,Object> setMtaSmtpdRejectUnlistedRecipient(ZAttrProvisioning.MtaSmtpdRejectUnlistedRecipient zimbraMtaSmtpdRejectUnlistedRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, zimbraMtaSmtpdRejectUnlistedRecipient.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdRejectUnlistedRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public void setMtaSmtpdRejectUnlistedRecipientAsString(String zimbraMtaSmtpdRejectUnlistedRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, zimbraMtaSmtpdRejectUnlistedRecipient);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdRejectUnlistedRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public Map<String,Object> setMtaSmtpdRejectUnlistedRecipientAsString(String zimbraMtaSmtpdRejectUnlistedRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, zimbraMtaSmtpdRejectUnlistedRecipient);
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public void unsetMtaSmtpdRejectUnlistedRecipient() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_recipient
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1534)
    public Map<String,Object> unsetMtaSmtpdRejectUnlistedRecipient(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedRecipient, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdRejectUnlistedSender, or ZAttrProvisioning.MtaSmtpdRejectUnlistedSender.no if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public ZAttrProvisioning.MtaSmtpdRejectUnlistedSender getMtaSmtpdRejectUnlistedSender() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdRejectUnlistedSender.no : ZAttrProvisioning.MtaSmtpdRejectUnlistedSender.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdRejectUnlistedSender.no; }
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdRejectUnlistedSender, or "no" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public String getMtaSmtpdRejectUnlistedSenderAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, "no", true);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdRejectUnlistedSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public void setMtaSmtpdRejectUnlistedSender(ZAttrProvisioning.MtaSmtpdRejectUnlistedSender zimbraMtaSmtpdRejectUnlistedSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, zimbraMtaSmtpdRejectUnlistedSender.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdRejectUnlistedSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public Map<String,Object> setMtaSmtpdRejectUnlistedSender(ZAttrProvisioning.MtaSmtpdRejectUnlistedSender zimbraMtaSmtpdRejectUnlistedSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, zimbraMtaSmtpdRejectUnlistedSender.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdRejectUnlistedSender new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public void setMtaSmtpdRejectUnlistedSenderAsString(String zimbraMtaSmtpdRejectUnlistedSender) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, zimbraMtaSmtpdRejectUnlistedSender);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdRejectUnlistedSender new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public Map<String,Object> setMtaSmtpdRejectUnlistedSenderAsString(String zimbraMtaSmtpdRejectUnlistedSender, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, zimbraMtaSmtpdRejectUnlistedSender);
        return attrs;
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public void unsetMtaSmtpdRejectUnlistedSender() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_reject_unlisted_sender
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1535)
    public Map<String,Object> unsetMtaSmtpdRejectUnlistedSender(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdRejectUnlistedSender, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdSaslAuthenticatedHeader, or ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader.no if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader getMtaSmtpdSaslAuthenticatedHeader() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader.no : ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader.no; }
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdSaslAuthenticatedHeader, or "no" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public String getMtaSmtpdSaslAuthenticatedHeaderAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, "no", true);
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdSaslAuthenticatedHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public void setMtaSmtpdSaslAuthenticatedHeader(ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader zimbraMtaSmtpdSaslAuthenticatedHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, zimbraMtaSmtpdSaslAuthenticatedHeader.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdSaslAuthenticatedHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public Map<String,Object> setMtaSmtpdSaslAuthenticatedHeader(ZAttrProvisioning.MtaSmtpdSaslAuthenticatedHeader zimbraMtaSmtpdSaslAuthenticatedHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, zimbraMtaSmtpdSaslAuthenticatedHeader.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdSaslAuthenticatedHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public void setMtaSmtpdSaslAuthenticatedHeaderAsString(String zimbraMtaSmtpdSaslAuthenticatedHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, zimbraMtaSmtpdSaslAuthenticatedHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdSaslAuthenticatedHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public Map<String,Object> setMtaSmtpdSaslAuthenticatedHeaderAsString(String zimbraMtaSmtpdSaslAuthenticatedHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, zimbraMtaSmtpdSaslAuthenticatedHeader);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public void unsetMtaSmtpdSaslAuthenticatedHeader() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_authenticated_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1536)
    public Map<String,Object> unsetMtaSmtpdSaslAuthenticatedHeader(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslAuthenticatedHeader, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @return zimbraMtaSmtpdSaslSecurityOptions, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public String[] getMtaSmtpdSaslSecurityOptionsAsString() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, true, true); return value.length > 0 ? value : new String[] {"noanonymous"};
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpdSaslSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public void setMtaSmtpdSaslSecurityOptions(ZAttrProvisioning.MtaSmtpdSaslSecurityOptions zimbraMtaSmtpdSaslSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, zimbraMtaSmtpdSaslSecurityOptions.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpdSaslSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public Map<String,Object> setMtaSmtpdSaslSecurityOptions(ZAttrProvisioning.MtaSmtpdSaslSecurityOptions zimbraMtaSmtpdSaslSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, zimbraMtaSmtpdSaslSecurityOptions.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpdSaslSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public void setMtaSmtpdSaslSecurityOptionsAsString(String[] zimbraMtaSmtpdSaslSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, zimbraMtaSmtpdSaslSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param zimbraMtaSmtpdSaslSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public Map<String,Object> setMtaSmtpdSaslSecurityOptionsAsString(String[] zimbraMtaSmtpdSaslSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, zimbraMtaSmtpdSaslSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public void unsetMtaSmtpdSaslSecurityOptions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_security_options
     *
     * <p>Valid values: [noplaintext, noactive, nodictionary, noanonymous, mutual_auth]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1550)
    public Map<String,Object> unsetMtaSmtpdSaslSecurityOptions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslSecurityOptions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @return zimbraMtaSmtpdSaslTlsSecurityOptions, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public String[] getMtaSmtpdSaslTlsSecurityOptions() {
        String[] value = getMultiAttr(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, true, true); return value.length > 0 ? value : new String[] {"$smtpd_sasl_security_options"};
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public void setMtaSmtpdSaslTlsSecurityOptions(String[] zimbraMtaSmtpdSaslTlsSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public Map<String,Object> setMtaSmtpdSaslTlsSecurityOptions(String[] zimbraMtaSmtpdSaslTlsSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public void addMtaSmtpdSaslTlsSecurityOptions(String zimbraMtaSmtpdSaslTlsSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public Map<String,Object> addMtaSmtpdSaslTlsSecurityOptions(String zimbraMtaSmtpdSaslTlsSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public void removeMtaSmtpdSaslTlsSecurityOptions(String zimbraMtaSmtpdSaslTlsSecurityOptions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param zimbraMtaSmtpdSaslTlsSecurityOptions existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public Map<String,Object> removeMtaSmtpdSaslTlsSecurityOptions(String zimbraMtaSmtpdSaslTlsSecurityOptions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, zimbraMtaSmtpdSaslTlsSecurityOptions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public void unsetMtaSmtpdSaslTlsSecurityOptions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sasl_tls_security_options
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1552)
    public Map<String,Object> unsetMtaSmtpdSaslTlsSecurityOptions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSaslTlsSecurityOptions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @return zimbraMtaSmtpdSenderLoginMaps, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public String getMtaSmtpdSenderLoginMaps() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, null, true);
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @param zimbraMtaSmtpdSenderLoginMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public void setMtaSmtpdSenderLoginMaps(String zimbraMtaSmtpdSenderLoginMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, zimbraMtaSmtpdSenderLoginMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @param zimbraMtaSmtpdSenderLoginMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public Map<String,Object> setMtaSmtpdSenderLoginMaps(String zimbraMtaSmtpdSenderLoginMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, zimbraMtaSmtpdSenderLoginMaps);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public void unsetMtaSmtpdSenderLoginMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sender_login_maps
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1591)
    public Map<String,Object> unsetMtaSmtpdSenderLoginMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderLoginMaps, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @return zimbraMtaSmtpdSenderRestrictions, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public String getMtaSmtpdSenderRestrictions() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, null, true);
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @param zimbraMtaSmtpdSenderRestrictions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public void setMtaSmtpdSenderRestrictions(String zimbraMtaSmtpdSenderRestrictions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, zimbraMtaSmtpdSenderRestrictions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @param zimbraMtaSmtpdSenderRestrictions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public Map<String,Object> setMtaSmtpdSenderRestrictions(String zimbraMtaSmtpdSenderRestrictions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, zimbraMtaSmtpdSenderRestrictions);
        return attrs;
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public void unsetMtaSmtpdSenderRestrictions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_sender_restrictions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1590)
    public Map<String,Object> unsetMtaSmtpdSenderRestrictions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSenderRestrictions, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @return zimbraMtaSmtpdSoftErrorLimit, or 10 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2077)
    public int getMtaSmtpdSoftErrorLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpdSoftErrorLimit, 10, true);
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @param zimbraMtaSmtpdSoftErrorLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2077)
    public void setMtaSmtpdSoftErrorLimit(int zimbraMtaSmtpdSoftErrorLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSoftErrorLimit, Integer.toString(zimbraMtaSmtpdSoftErrorLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @param zimbraMtaSmtpdSoftErrorLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2077)
    public Map<String,Object> setMtaSmtpdSoftErrorLimit(int zimbraMtaSmtpdSoftErrorLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSoftErrorLimit, Integer.toString(zimbraMtaSmtpdSoftErrorLimit));
        return attrs;
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2077)
    public void unsetMtaSmtpdSoftErrorLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSoftErrorLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_soft_error_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2077)
    public Map<String,Object> unsetMtaSmtpdSoftErrorLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdSoftErrorLimit, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdTlsAskCcert, or ZAttrProvisioning.MtaSmtpdTlsAskCcert.no if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public ZAttrProvisioning.MtaSmtpdTlsAskCcert getMtaSmtpdTlsAskCcert() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdTlsAskCcert.no : ZAttrProvisioning.MtaSmtpdTlsAskCcert.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdTlsAskCcert.no; }
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdTlsAskCcert, or "no" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public String getMtaSmtpdTlsAskCcertAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, "no", true);
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdTlsAskCcert new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public void setMtaSmtpdTlsAskCcert(ZAttrProvisioning.MtaSmtpdTlsAskCcert zimbraMtaSmtpdTlsAskCcert) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, zimbraMtaSmtpdTlsAskCcert.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdTlsAskCcert new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public Map<String,Object> setMtaSmtpdTlsAskCcert(ZAttrProvisioning.MtaSmtpdTlsAskCcert zimbraMtaSmtpdTlsAskCcert, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, zimbraMtaSmtpdTlsAskCcert.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdTlsAskCcert new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public void setMtaSmtpdTlsAskCcertAsString(String zimbraMtaSmtpdTlsAskCcert) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, zimbraMtaSmtpdTlsAskCcert);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdTlsAskCcert new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public Map<String,Object> setMtaSmtpdTlsAskCcertAsString(String zimbraMtaSmtpdTlsAskCcert, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, zimbraMtaSmtpdTlsAskCcert);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public void unsetMtaSmtpdTlsAskCcert() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ask_ccert
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1542)
    public Map<String,Object> unsetMtaSmtpdTlsAskCcert(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsAskCcert, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @return zimbraMtaSmtpdTlsCAfile, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public String getMtaSmtpdTlsCAfile() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsCAfile, null, true);
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @param zimbraMtaSmtpdTlsCAfile new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public void setMtaSmtpdTlsCAfile(String zimbraMtaSmtpdTlsCAfile) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCAfile, zimbraMtaSmtpdTlsCAfile);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @param zimbraMtaSmtpdTlsCAfile new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public Map<String,Object> setMtaSmtpdTlsCAfile(String zimbraMtaSmtpdTlsCAfile, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCAfile, zimbraMtaSmtpdTlsCAfile);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public void unsetMtaSmtpdTlsCAfile() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCAfile, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_CAfile
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1563)
    public Map<String,Object> unsetMtaSmtpdTlsCAfile(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCAfile, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @return zimbraMtaSmtpdTlsCApath, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public String getMtaSmtpdTlsCApath() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsCApath, null, true);
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @param zimbraMtaSmtpdTlsCApath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public void setMtaSmtpdTlsCApath(String zimbraMtaSmtpdTlsCApath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCApath, zimbraMtaSmtpdTlsCApath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @param zimbraMtaSmtpdTlsCApath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public Map<String,Object> setMtaSmtpdTlsCApath(String zimbraMtaSmtpdTlsCApath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCApath, zimbraMtaSmtpdTlsCApath);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public void unsetMtaSmtpdTlsCApath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCApath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_CApath
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1564)
    public Map<String,Object> unsetMtaSmtpdTlsCApath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCApath, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @return zimbraMtaSmtpdTlsCcertVerifydepth, or 9 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public int getMtaSmtpdTlsCcertVerifydepth() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, 9, true);
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @param zimbraMtaSmtpdTlsCcertVerifydepth new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public void setMtaSmtpdTlsCcertVerifydepth(int zimbraMtaSmtpdTlsCcertVerifydepth) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, Integer.toString(zimbraMtaSmtpdTlsCcertVerifydepth));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @param zimbraMtaSmtpdTlsCcertVerifydepth new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public Map<String,Object> setMtaSmtpdTlsCcertVerifydepth(int zimbraMtaSmtpdTlsCcertVerifydepth, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, Integer.toString(zimbraMtaSmtpdTlsCcertVerifydepth));
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public void unsetMtaSmtpdTlsCcertVerifydepth() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ccert_verifydepth
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1543)
    public Map<String,Object> unsetMtaSmtpdTlsCcertVerifydepth(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCcertVerifydepth, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaSmtpdTlsCiphers, or ZAttrProvisioning.MtaSmtpdTlsCiphers.export if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public ZAttrProvisioning.MtaSmtpdTlsCiphers getMtaSmtpdTlsCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdTlsCiphers, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdTlsCiphers.export : ZAttrProvisioning.MtaSmtpdTlsCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdTlsCiphers.export; }
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaSmtpdTlsCiphers, or "export" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public String getMtaSmtpdTlsCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsCiphers, "export", true);
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpdTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public void setMtaSmtpdTlsCiphers(ZAttrProvisioning.MtaSmtpdTlsCiphers zimbraMtaSmtpdTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, zimbraMtaSmtpdTlsCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpdTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public Map<String,Object> setMtaSmtpdTlsCiphers(ZAttrProvisioning.MtaSmtpdTlsCiphers zimbraMtaSmtpdTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, zimbraMtaSmtpdTlsCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpdTlsCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public void setMtaSmtpdTlsCiphersAsString(String zimbraMtaSmtpdTlsCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, zimbraMtaSmtpdTlsCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpdTlsCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public Map<String,Object> setMtaSmtpdTlsCiphersAsString(String zimbraMtaSmtpdTlsCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, zimbraMtaSmtpdTlsCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public void unsetMtaSmtpdTlsCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1515)
    public Map<String,Object> unsetMtaSmtpdTlsCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @return zimbraMtaSmtpdTlsExcludeCiphers, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public String getMtaSmtpdTlsExcludeCiphers() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, null, true);
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @param zimbraMtaSmtpdTlsExcludeCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public void setMtaSmtpdTlsExcludeCiphers(String zimbraMtaSmtpdTlsExcludeCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, zimbraMtaSmtpdTlsExcludeCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @param zimbraMtaSmtpdTlsExcludeCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public Map<String,Object> setMtaSmtpdTlsExcludeCiphers(String zimbraMtaSmtpdTlsExcludeCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, zimbraMtaSmtpdTlsExcludeCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public void unsetMtaSmtpdTlsExcludeCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_exclude_ciphers
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1647)
    public Map<String,Object> unsetMtaSmtpdTlsExcludeCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsExcludeCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @return zimbraMtaSmtpdTlsLoglevel, or 1 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public int getMtaSmtpdTlsLoglevel() {
        return getIntAttr(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, 1, true);
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @param zimbraMtaSmtpdTlsLoglevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public void setMtaSmtpdTlsLoglevel(int zimbraMtaSmtpdTlsLoglevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, Integer.toString(zimbraMtaSmtpdTlsLoglevel));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @param zimbraMtaSmtpdTlsLoglevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public Map<String,Object> setMtaSmtpdTlsLoglevel(int zimbraMtaSmtpdTlsLoglevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, Integer.toString(zimbraMtaSmtpdTlsLoglevel));
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public void unsetMtaSmtpdTlsLoglevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_loglevel. Default is 1. Valid range is
     * 1-4.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1541)
    public Map<String,Object> unsetMtaSmtpdTlsLoglevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsLoglevel, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaSmtpdTlsMandatoryCiphers, or ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers.medium if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers getMtaSmtpdTlsMandatoryCiphers() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers.medium : ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers.medium; }
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @return zimbraMtaSmtpdTlsMandatoryCiphers, or "medium" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public String getMtaSmtpdTlsMandatoryCiphersAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, "medium", true);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpdTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public void setMtaSmtpdTlsMandatoryCiphers(ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers zimbraMtaSmtpdTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, zimbraMtaSmtpdTlsMandatoryCiphers.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpdTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public Map<String,Object> setMtaSmtpdTlsMandatoryCiphers(ZAttrProvisioning.MtaSmtpdTlsMandatoryCiphers zimbraMtaSmtpdTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, zimbraMtaSmtpdTlsMandatoryCiphers.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpdTlsMandatoryCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public void setMtaSmtpdTlsMandatoryCiphersAsString(String zimbraMtaSmtpdTlsMandatoryCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, zimbraMtaSmtpdTlsMandatoryCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param zimbraMtaSmtpdTlsMandatoryCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public Map<String,Object> setMtaSmtpdTlsMandatoryCiphersAsString(String zimbraMtaSmtpdTlsMandatoryCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, zimbraMtaSmtpdTlsMandatoryCiphers);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public void unsetMtaSmtpdTlsMandatoryCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_ciphers
     *
     * <p>Valid values: [export, low, medium, high, null]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1516)
    public Map<String,Object> unsetMtaSmtpdTlsMandatoryCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryCiphers, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @return zimbraMtaSmtpdTlsMandatoryProtocols, or "!SSLv2, !SSLv3" if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1783)
    public String getMtaSmtpdTlsMandatoryProtocols() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, "!SSLv2, !SSLv3", true);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @param zimbraMtaSmtpdTlsMandatoryProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1783)
    public void setMtaSmtpdTlsMandatoryProtocols(String zimbraMtaSmtpdTlsMandatoryProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, zimbraMtaSmtpdTlsMandatoryProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @param zimbraMtaSmtpdTlsMandatoryProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1783)
    public Map<String,Object> setMtaSmtpdTlsMandatoryProtocols(String zimbraMtaSmtpdTlsMandatoryProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, zimbraMtaSmtpdTlsMandatoryProtocols);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1783)
    public void unsetMtaSmtpdTlsMandatoryProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_mandatory_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1783)
    public Map<String,Object> unsetMtaSmtpdTlsMandatoryProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsMandatoryProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @return zimbraMtaSmtpdTlsProtocols, or "!SSLv2, !SSLv3" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public String getMtaSmtpdTlsProtocols() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsProtocols, "!SSLv2, !SSLv3", true);
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @param zimbraMtaSmtpdTlsProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public void setMtaSmtpdTlsProtocols(String zimbraMtaSmtpdTlsProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsProtocols, zimbraMtaSmtpdTlsProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @param zimbraMtaSmtpdTlsProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public Map<String,Object> setMtaSmtpdTlsProtocols(String zimbraMtaSmtpdTlsProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsProtocols, zimbraMtaSmtpdTlsProtocols);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public void unsetMtaSmtpdTlsProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_protocols
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1646)
    public Map<String,Object> unsetMtaSmtpdTlsProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsProtocols, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_received_header
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdTlsReceivedHeader, or ZAttrProvisioning.MtaSmtpdTlsReceivedHeader.no if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2076)
    public ZAttrProvisioning.MtaSmtpdTlsReceivedHeader getMtaSmtpdTlsReceivedHeader() {
        try { String v = getAttr(Provisioning.A_zimbraMtaSmtpdTlsReceivedHeader, true, true); return v == null ? ZAttrProvisioning.MtaSmtpdTlsReceivedHeader.no : ZAttrProvisioning.MtaSmtpdTlsReceivedHeader.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaSmtpdTlsReceivedHeader.no; }
    }

    /**
     * Value for postconf smtpd_tls_received_header
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaSmtpdTlsReceivedHeader, or "no" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2076)
    public String getMtaSmtpdTlsReceivedHeaderAsString() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdTlsReceivedHeader, "no", true);
    }

    /**
     * Value for postconf smtpd_tls_received_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdTlsReceivedHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2076)
    public void setMtaSmtpdTlsReceivedHeader(ZAttrProvisioning.MtaSmtpdTlsReceivedHeader zimbraMtaSmtpdTlsReceivedHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsReceivedHeader, zimbraMtaSmtpdTlsReceivedHeader.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_received_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdTlsReceivedHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2076)
    public Map<String,Object> setMtaSmtpdTlsReceivedHeader(ZAttrProvisioning.MtaSmtpdTlsReceivedHeader zimbraMtaSmtpdTlsReceivedHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsReceivedHeader, zimbraMtaSmtpdTlsReceivedHeader.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_received_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdTlsReceivedHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2076)
    public void setMtaSmtpdTlsReceivedHeaderAsString(String zimbraMtaSmtpdTlsReceivedHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsReceivedHeader, zimbraMtaSmtpdTlsReceivedHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_received_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaSmtpdTlsReceivedHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2076)
    public Map<String,Object> setMtaSmtpdTlsReceivedHeaderAsString(String zimbraMtaSmtpdTlsReceivedHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsReceivedHeader, zimbraMtaSmtpdTlsReceivedHeader);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_received_header
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2076)
    public void unsetMtaSmtpdTlsReceivedHeader() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsReceivedHeader, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_received_header
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2076)
    public Map<String,Object> unsetMtaSmtpdTlsReceivedHeader(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdTlsReceivedHeader, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_transport
     *
     * @return zimbraMtaSmtpdVirtualTransport, or "error" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public String getMtaSmtpdVirtualTransport() {
        return getAttr(Provisioning.A_zimbraMtaSmtpdVirtualTransport, "error", true);
    }

    /**
     * Value for postconf virtual_transport
     *
     * @param zimbraMtaSmtpdVirtualTransport new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public void setMtaSmtpdVirtualTransport(String zimbraMtaSmtpdVirtualTransport) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdVirtualTransport, zimbraMtaSmtpdVirtualTransport);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_transport
     *
     * @param zimbraMtaSmtpdVirtualTransport new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public Map<String,Object> setMtaSmtpdVirtualTransport(String zimbraMtaSmtpdVirtualTransport, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdVirtualTransport, zimbraMtaSmtpdVirtualTransport);
        return attrs;
    }

    /**
     * Value for postconf virtual_transport
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public void unsetMtaSmtpdVirtualTransport() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdVirtualTransport, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_transport
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1545)
    public Map<String,Object> unsetMtaSmtpdVirtualTransport(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaSmtpdVirtualTransport, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0_BETA2. use zimbraMtaSmtpdSoftErrorLimit
     * instead. Orig desc: Value for postconf smtpd_soft_error_limit
     *
     * @return zimbraMtaStpdSoftErrorLimit, or 10 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public int getMtaStpdSoftErrorLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaStpdSoftErrorLimit, 10, true);
    }

    /**
     * Deprecated since: 8.7.0_BETA2. use zimbraMtaSmtpdSoftErrorLimit
     * instead. Orig desc: Value for postconf smtpd_soft_error_limit
     *
     * @param zimbraMtaStpdSoftErrorLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public void setMtaStpdSoftErrorLimit(int zimbraMtaStpdSoftErrorLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaStpdSoftErrorLimit, Integer.toString(zimbraMtaStpdSoftErrorLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0_BETA2. use zimbraMtaSmtpdSoftErrorLimit
     * instead. Orig desc: Value for postconf smtpd_soft_error_limit
     *
     * @param zimbraMtaStpdSoftErrorLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public Map<String,Object> setMtaStpdSoftErrorLimit(int zimbraMtaStpdSoftErrorLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaStpdSoftErrorLimit, Integer.toString(zimbraMtaStpdSoftErrorLimit));
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0_BETA2. use zimbraMtaSmtpdSoftErrorLimit
     * instead. Orig desc: Value for postconf smtpd_soft_error_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public void unsetMtaStpdSoftErrorLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaStpdSoftErrorLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0_BETA2. use zimbraMtaSmtpdSoftErrorLimit
     * instead. Orig desc: Value for postconf smtpd_soft_error_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1538)
    public Map<String,Object> unsetMtaStpdSoftErrorLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaStpdSoftErrorLimit, "");
        return attrs;
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaTlsAppendDefaultCA, or ZAttrProvisioning.MtaTlsAppendDefaultCA.no if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public ZAttrProvisioning.MtaTlsAppendDefaultCA getMtaTlsAppendDefaultCA() {
        try { String v = getAttr(Provisioning.A_zimbraMtaTlsAppendDefaultCA, true, true); return v == null ? ZAttrProvisioning.MtaTlsAppendDefaultCA.no : ZAttrProvisioning.MtaTlsAppendDefaultCA.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaTlsAppendDefaultCA.no; }
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [yes, no]
     *
     * @return zimbraMtaTlsAppendDefaultCA, or "no" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public String getMtaTlsAppendDefaultCAAsString() {
        return getAttr(Provisioning.A_zimbraMtaTlsAppendDefaultCA, "no", true);
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaTlsAppendDefaultCA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public void setMtaTlsAppendDefaultCA(ZAttrProvisioning.MtaTlsAppendDefaultCA zimbraMtaTlsAppendDefaultCA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, zimbraMtaTlsAppendDefaultCA.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaTlsAppendDefaultCA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public Map<String,Object> setMtaTlsAppendDefaultCA(ZAttrProvisioning.MtaTlsAppendDefaultCA zimbraMtaTlsAppendDefaultCA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, zimbraMtaTlsAppendDefaultCA.toString());
        return attrs;
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaTlsAppendDefaultCA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public void setMtaTlsAppendDefaultCAAsString(String zimbraMtaTlsAppendDefaultCA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, zimbraMtaTlsAppendDefaultCA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [yes, no]
     *
     * @param zimbraMtaTlsAppendDefaultCA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public Map<String,Object> setMtaTlsAppendDefaultCAAsString(String zimbraMtaTlsAppendDefaultCA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, zimbraMtaTlsAppendDefaultCA);
        return attrs;
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [yes, no]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public void unsetMtaTlsAppendDefaultCA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf tls_append_default_CA
     *
     * <p>Valid values: [yes, no]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1567)
    public Map<String,Object> unsetMtaTlsAppendDefaultCA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAppendDefaultCA, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @return zimbraMtaTlsAuthOnly, or true if unset
     */
    @ZAttr(id=200)
    public boolean isMtaTlsAuthOnly() {
        return getBooleanAttr(Provisioning.A_zimbraMtaTlsAuthOnly, true, true);
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @param zimbraMtaTlsAuthOnly new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=200)
    public void setMtaTlsAuthOnly(boolean zimbraMtaTlsAuthOnly) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAuthOnly, zimbraMtaTlsAuthOnly ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @param zimbraMtaTlsAuthOnly new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=200)
    public Map<String,Object> setMtaTlsAuthOnly(boolean zimbraMtaTlsAuthOnly, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAuthOnly, zimbraMtaTlsAuthOnly ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=200)
    public void unsetMtaTlsAuthOnly() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAuthOnly, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_auth_only
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=200)
    public Map<String,Object> unsetMtaTlsAuthOnly(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsAuthOnly, "");
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @return zimbraMtaTlsSecurityLevel, or ZAttrProvisioning.MtaTlsSecurityLevel.may if unset and/or has invalid value
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public ZAttrProvisioning.MtaTlsSecurityLevel getMtaTlsSecurityLevel() {
        try { String v = getAttr(Provisioning.A_zimbraMtaTlsSecurityLevel, true, true); return v == null ? ZAttrProvisioning.MtaTlsSecurityLevel.may : ZAttrProvisioning.MtaTlsSecurityLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.MtaTlsSecurityLevel.may; }
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @return zimbraMtaTlsSecurityLevel, or "may" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public String getMtaTlsSecurityLevelAsString() {
        return getAttr(Provisioning.A_zimbraMtaTlsSecurityLevel, "may", true);
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param zimbraMtaTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public void setMtaTlsSecurityLevel(ZAttrProvisioning.MtaTlsSecurityLevel zimbraMtaTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, zimbraMtaTlsSecurityLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param zimbraMtaTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public Map<String,Object> setMtaTlsSecurityLevel(ZAttrProvisioning.MtaTlsSecurityLevel zimbraMtaTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, zimbraMtaTlsSecurityLevel.toString());
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param zimbraMtaTlsSecurityLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public void setMtaTlsSecurityLevelAsString(String zimbraMtaTlsSecurityLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, zimbraMtaTlsSecurityLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param zimbraMtaTlsSecurityLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public Map<String,Object> setMtaTlsSecurityLevelAsString(String zimbraMtaTlsSecurityLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, zimbraMtaTlsSecurityLevel);
        return attrs;
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public void unsetMtaTlsSecurityLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf smtpd_tls_security_level
     *
     * <p>Valid values: [may, none]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=795)
    public Map<String,Object> unsetMtaTlsSecurityLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTlsSecurityLevel, "");
        return attrs;
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @return zimbraMtaTransportMaps, or "proxy:ldap:/opt/zimbra/conf/ldap-transport.cf" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public String getMtaTransportMaps() {
        return getAttr(Provisioning.A_zimbraMtaTransportMaps, "proxy:ldap:/opt/zimbra/conf/ldap-transport.cf", true);
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @param zimbraMtaTransportMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public void setMtaTransportMaps(String zimbraMtaTransportMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTransportMaps, zimbraMtaTransportMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @param zimbraMtaTransportMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public Map<String,Object> setMtaTransportMaps(String zimbraMtaTransportMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTransportMaps, zimbraMtaTransportMaps);
        return attrs;
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public void unsetMtaTransportMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTransportMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf transport_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1555)
    public Map<String,Object> unsetMtaTransportMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaTransportMaps, "");
        return attrs;
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @return zimbraMtaUnverifiedRecipientDeferCode, or 250 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public int getMtaUnverifiedRecipientDeferCode() {
        return getIntAttr(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, 250, true);
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @param zimbraMtaUnverifiedRecipientDeferCode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public void setMtaUnverifiedRecipientDeferCode(int zimbraMtaUnverifiedRecipientDeferCode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, Integer.toString(zimbraMtaUnverifiedRecipientDeferCode));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @param zimbraMtaUnverifiedRecipientDeferCode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public Map<String,Object> setMtaUnverifiedRecipientDeferCode(int zimbraMtaUnverifiedRecipientDeferCode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, Integer.toString(zimbraMtaUnverifiedRecipientDeferCode));
        return attrs;
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public void unsetMtaUnverifiedRecipientDeferCode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf unverified_recipient_defer_code
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1606)
    public Map<String,Object> unsetMtaUnverifiedRecipientDeferCode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaUnverifiedRecipientDeferCode, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @return zimbraMtaVirtualAliasDomains, or "proxy:ldap:/opt/zimbra/conf/ldap-vad.cf" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public String getMtaVirtualAliasDomains() {
        return getAttr(Provisioning.A_zimbraMtaVirtualAliasDomains, "proxy:ldap:/opt/zimbra/conf/ldap-vad.cf", true);
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @param zimbraMtaVirtualAliasDomains new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public void setMtaVirtualAliasDomains(String zimbraMtaVirtualAliasDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasDomains, zimbraMtaVirtualAliasDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @param zimbraMtaVirtualAliasDomains new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public Map<String,Object> setMtaVirtualAliasDomains(String zimbraMtaVirtualAliasDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasDomains, zimbraMtaVirtualAliasDomains);
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public void unsetMtaVirtualAliasDomains() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasDomains, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_domains. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1556)
    public Map<String,Object> unsetMtaVirtualAliasDomains(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasDomains, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @return zimbraMtaVirtualAliasExpansionLimit, or 10000 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public int getMtaVirtualAliasExpansionLimit() {
        return getIntAttr(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, 10000, true);
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @param zimbraMtaVirtualAliasExpansionLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public void setMtaVirtualAliasExpansionLimit(int zimbraMtaVirtualAliasExpansionLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, Integer.toString(zimbraMtaVirtualAliasExpansionLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @param zimbraMtaVirtualAliasExpansionLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public Map<String,Object> setMtaVirtualAliasExpansionLimit(int zimbraMtaVirtualAliasExpansionLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, Integer.toString(zimbraMtaVirtualAliasExpansionLimit));
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public void unsetMtaVirtualAliasExpansionLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_expansion_limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1544)
    public Map<String,Object> unsetMtaVirtualAliasExpansionLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasExpansionLimit, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @return zimbraMtaVirtualAliasMaps, or "proxy:ldap:/opt/zimbra/conf/ldap-vam.cf" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public String getMtaVirtualAliasMaps() {
        return getAttr(Provisioning.A_zimbraMtaVirtualAliasMaps, "proxy:ldap:/opt/zimbra/conf/ldap-vam.cf", true);
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @param zimbraMtaVirtualAliasMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public void setMtaVirtualAliasMaps(String zimbraMtaVirtualAliasMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasMaps, zimbraMtaVirtualAliasMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @param zimbraMtaVirtualAliasMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public Map<String,Object> setMtaVirtualAliasMaps(String zimbraMtaVirtualAliasMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasMaps, zimbraMtaVirtualAliasMaps);
        return attrs;
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public void unsetMtaVirtualAliasMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_alias_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1557)
    public Map<String,Object> unsetMtaVirtualAliasMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualAliasMaps, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @return zimbraMtaVirtualMailboxDomains, or "proxy:ldap:/opt/zimbra/conf/ldap-vmd.cf" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public String getMtaVirtualMailboxDomains() {
        return getAttr(Provisioning.A_zimbraMtaVirtualMailboxDomains, "proxy:ldap:/opt/zimbra/conf/ldap-vmd.cf", true);
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @param zimbraMtaVirtualMailboxDomains new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public void setMtaVirtualMailboxDomains(String zimbraMtaVirtualMailboxDomains) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxDomains, zimbraMtaVirtualMailboxDomains);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @param zimbraMtaVirtualMailboxDomains new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public Map<String,Object> setMtaVirtualMailboxDomains(String zimbraMtaVirtualMailboxDomains, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxDomains, zimbraMtaVirtualMailboxDomains);
        return attrs;
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public void unsetMtaVirtualMailboxDomains() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxDomains, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_mailbox_domains. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1558)
    public Map<String,Object> unsetMtaVirtualMailboxDomains(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxDomains, "");
        return attrs;
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @return zimbraMtaVirtualMailboxMaps, or "proxy:ldap:/opt/zimbra/conf/ldap-vmm.cf" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public String getMtaVirtualMailboxMaps() {
        return getAttr(Provisioning.A_zimbraMtaVirtualMailboxMaps, "proxy:ldap:/opt/zimbra/conf/ldap-vmm.cf", true);
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @param zimbraMtaVirtualMailboxMaps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public void setMtaVirtualMailboxMaps(String zimbraMtaVirtualMailboxMaps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxMaps, zimbraMtaVirtualMailboxMaps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @param zimbraMtaVirtualMailboxMaps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public Map<String,Object> setMtaVirtualMailboxMaps(String zimbraMtaVirtualMailboxMaps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxMaps, zimbraMtaVirtualMailboxMaps);
        return attrs;
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public void unsetMtaVirtualMailboxMaps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxMaps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value for postconf virtual_mailbox_maps. Comma separated list.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1559)
    public Map<String,Object> unsetMtaVirtualMailboxMaps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMtaVirtualMailboxMaps, "");
        return attrs;
    }

    /**
     * certificate to be used for validating the SAML assertions received
     * from myonelogin (tricipher)
     *
     * @return zimbraMyoneloginSamlSigningCert, or null if unset
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1169)
    public String getMyoneloginSamlSigningCert() {
        return getAttr(Provisioning.A_zimbraMyoneloginSamlSigningCert, null, true);
    }

    /**
     * certificate to be used for validating the SAML assertions received
     * from myonelogin (tricipher)
     *
     * @param zimbraMyoneloginSamlSigningCert new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1169)
    public void setMyoneloginSamlSigningCert(String zimbraMyoneloginSamlSigningCert) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMyoneloginSamlSigningCert, zimbraMyoneloginSamlSigningCert);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * certificate to be used for validating the SAML assertions received
     * from myonelogin (tricipher)
     *
     * @param zimbraMyoneloginSamlSigningCert new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1169)
    public Map<String,Object> setMyoneloginSamlSigningCert(String zimbraMyoneloginSamlSigningCert, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMyoneloginSamlSigningCert, zimbraMyoneloginSamlSigningCert);
        return attrs;
    }

    /**
     * certificate to be used for validating the SAML assertions received
     * from myonelogin (tricipher)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1169)
    public void unsetMyoneloginSamlSigningCert() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMyoneloginSamlSigningCert, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * certificate to be used for validating the SAML assertions received
     * from myonelogin (tricipher)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.1
     */
    @ZAttr(id=1169)
    public Map<String,Object> unsetMyoneloginSamlSigningCert(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraMyoneloginSamlSigningCert, "");
        return attrs;
    }

    /**
     * A signed activation key that authorizes this installation.
     *
     * @return zimbraNetworkActivation, or null if unset
     */
    @ZAttr(id=375)
    public String getNetworkActivation() {
        return getAttr(Provisioning.A_zimbraNetworkActivation, null, true);
    }

    /**
     * A signed activation key that authorizes this installation.
     *
     * @param zimbraNetworkActivation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=375)
    public void setNetworkActivation(String zimbraNetworkActivation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkActivation, zimbraNetworkActivation);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A signed activation key that authorizes this installation.
     *
     * @param zimbraNetworkActivation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=375)
    public Map<String,Object> setNetworkActivation(String zimbraNetworkActivation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkActivation, zimbraNetworkActivation);
        return attrs;
    }

    /**
     * A signed activation key that authorizes this installation.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=375)
    public void unsetNetworkActivation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkActivation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * A signed activation key that authorizes this installation.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=375)
    public Map<String,Object> unsetNetworkActivation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkActivation, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.8.5. This attribute has been renamed to
     * zimbraNetworkAdminNGEnabled. Orig desc: Whether to enable old zimbra
     * network admin module.
     *
     * @return zimbraNetworkAdminEnabled, or true if unset
     *
     * @since ZCS 8.8.2
     */
    @ZAttr(id=2119)
    public boolean isNetworkAdminEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraNetworkAdminEnabled, true, true);
    }

    /**
     * Deprecated since: 8.8.5. This attribute has been renamed to
     * zimbraNetworkAdminNGEnabled. Orig desc: Whether to enable old zimbra
     * network admin module.
     *
     * @param zimbraNetworkAdminEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.2
     */
    @ZAttr(id=2119)
    public void setNetworkAdminEnabled(boolean zimbraNetworkAdminEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkAdminEnabled, zimbraNetworkAdminEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.8.5. This attribute has been renamed to
     * zimbraNetworkAdminNGEnabled. Orig desc: Whether to enable old zimbra
     * network admin module.
     *
     * @param zimbraNetworkAdminEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.2
     */
    @ZAttr(id=2119)
    public Map<String,Object> setNetworkAdminEnabled(boolean zimbraNetworkAdminEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkAdminEnabled, zimbraNetworkAdminEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.8.5. This attribute has been renamed to
     * zimbraNetworkAdminNGEnabled. Orig desc: Whether to enable old zimbra
     * network admin module.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.2
     */
    @ZAttr(id=2119)
    public void unsetNetworkAdminEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkAdminEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.8.5. This attribute has been renamed to
     * zimbraNetworkAdminNGEnabled. Orig desc: Whether to enable old zimbra
     * network admin module.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.2
     */
    @ZAttr(id=2119)
    public Map<String,Object> unsetNetworkAdminEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkAdminEnabled, "");
        return attrs;
    }

    /**
     * Whether to enable zimbra network new generation admin module.
     *
     * @return zimbraNetworkAdminNGEnabled, or false if unset
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2130)
    public boolean isNetworkAdminNGEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraNetworkAdminNGEnabled, false, true);
    }

    /**
     * Whether to enable zimbra network new generation admin module.
     *
     * @param zimbraNetworkAdminNGEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2130)
    public void setNetworkAdminNGEnabled(boolean zimbraNetworkAdminNGEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkAdminNGEnabled, zimbraNetworkAdminNGEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable zimbra network new generation admin module.
     *
     * @param zimbraNetworkAdminNGEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2130)
    public Map<String,Object> setNetworkAdminNGEnabled(boolean zimbraNetworkAdminNGEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkAdminNGEnabled, zimbraNetworkAdminNGEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable zimbra network new generation admin module.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2130)
    public void unsetNetworkAdminNGEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkAdminNGEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable zimbra network new generation admin module.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.5
     */
    @ZAttr(id=2130)
    public Map<String,Object> unsetNetworkAdminNGEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkAdminNGEnabled, "");
        return attrs;
    }

    /**
     * Contents of a signed Zimbra license key - an XML string.
     *
     * @return zimbraNetworkLicense, or null if unset
     */
    @ZAttr(id=374)
    public String getNetworkLicense() {
        return getAttr(Provisioning.A_zimbraNetworkLicense, null, true);
    }

    /**
     * Contents of a signed Zimbra license key - an XML string.
     *
     * @param zimbraNetworkLicense new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=374)
    public void setNetworkLicense(String zimbraNetworkLicense) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkLicense, zimbraNetworkLicense);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Contents of a signed Zimbra license key - an XML string.
     *
     * @param zimbraNetworkLicense new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=374)
    public Map<String,Object> setNetworkLicense(String zimbraNetworkLicense, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkLicense, zimbraNetworkLicense);
        return attrs;
    }

    /**
     * Contents of a signed Zimbra license key - an XML string.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=374)
    public void unsetNetworkLicense() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkLicense, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Contents of a signed Zimbra license key - an XML string.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=374)
    public Map<String,Object> unsetNetworkLicense(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkLicense, "");
        return attrs;
    }

    /**
     * Whether to enable zimbra network new generation mobile sync module.
     *
     * @return zimbraNetworkMobileNGEnabled, or false if unset
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2118)
    public boolean isNetworkMobileNGEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraNetworkMobileNGEnabled, false, true);
    }

    /**
     * Whether to enable zimbra network new generation mobile sync module.
     *
     * @param zimbraNetworkMobileNGEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2118)
    public void setNetworkMobileNGEnabled(boolean zimbraNetworkMobileNGEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkMobileNGEnabled, zimbraNetworkMobileNGEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable zimbra network new generation mobile sync module.
     *
     * @param zimbraNetworkMobileNGEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2118)
    public Map<String,Object> setNetworkMobileNGEnabled(boolean zimbraNetworkMobileNGEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkMobileNGEnabled, zimbraNetworkMobileNGEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable zimbra network new generation mobile sync module.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2118)
    public void unsetNetworkMobileNGEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkMobileNGEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable zimbra network new generation mobile sync module.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2118)
    public Map<String,Object> unsetNetworkMobileNGEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkMobileNGEnabled, "");
        return attrs;
    }

    /**
     * Whether to enable zimbra network new generation modules.
     *
     * @return zimbraNetworkModulesNGEnabled, or true if unset
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2117)
    public boolean isNetworkModulesNGEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraNetworkModulesNGEnabled, true, true);
    }

    /**
     * Whether to enable zimbra network new generation modules.
     *
     * @param zimbraNetworkModulesNGEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2117)
    public void setNetworkModulesNGEnabled(boolean zimbraNetworkModulesNGEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkModulesNGEnabled, zimbraNetworkModulesNGEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable zimbra network new generation modules.
     *
     * @param zimbraNetworkModulesNGEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2117)
    public Map<String,Object> setNetworkModulesNGEnabled(boolean zimbraNetworkModulesNGEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkModulesNGEnabled, zimbraNetworkModulesNGEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable zimbra network new generation modules.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2117)
    public void unsetNetworkModulesNGEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkModulesNGEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable zimbra network new generation modules.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.0
     */
    @ZAttr(id=2117)
    public Map<String,Object> unsetNetworkModulesNGEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNetworkModulesNGEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 7.0.0. See bug 39647. Orig desc: Account for storing
     * templates and providing space for public wiki
     *
     * @return zimbraNotebookAccount, or null if unset
     */
    @ZAttr(id=363)
    public String getNotebookAccount() {
        return getAttr(Provisioning.A_zimbraNotebookAccount, null, true);
    }

    /**
     * Deprecated since: 7.0.0. See bug 39647. Orig desc: Account for storing
     * templates and providing space for public wiki
     *
     * @param zimbraNotebookAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=363)
    public void setNotebookAccount(String zimbraNotebookAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookAccount, zimbraNotebookAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 7.0.0. See bug 39647. Orig desc: Account for storing
     * templates and providing space for public wiki
     *
     * @param zimbraNotebookAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=363)
    public Map<String,Object> setNotebookAccount(String zimbraNotebookAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookAccount, zimbraNotebookAccount);
        return attrs;
    }

    /**
     * Deprecated since: 7.0.0. See bug 39647. Orig desc: Account for storing
     * templates and providing space for public wiki
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=363)
    public void unsetNotebookAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 7.0.0. See bug 39647. Orig desc: Account for storing
     * templates and providing space for public wiki
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=363)
    public Map<String,Object> unsetNotebookAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookAccount, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The size of Wiki
     * / Notebook folder cache on the server.
     *
     * @return zimbraNotebookFolderCacheSize, or 1024 if unset
     */
    @ZAttr(id=370)
    public int getNotebookFolderCacheSize() {
        return getIntAttr(Provisioning.A_zimbraNotebookFolderCacheSize, 1024, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The size of Wiki
     * / Notebook folder cache on the server.
     *
     * @param zimbraNotebookFolderCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=370)
    public void setNotebookFolderCacheSize(int zimbraNotebookFolderCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookFolderCacheSize, Integer.toString(zimbraNotebookFolderCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The size of Wiki
     * / Notebook folder cache on the server.
     *
     * @param zimbraNotebookFolderCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=370)
    public Map<String,Object> setNotebookFolderCacheSize(int zimbraNotebookFolderCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookFolderCacheSize, Integer.toString(zimbraNotebookFolderCacheSize));
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The size of Wiki
     * / Notebook folder cache on the server.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=370)
    public void unsetNotebookFolderCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookFolderCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The size of Wiki
     * / Notebook folder cache on the server.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=370)
    public Map<String,Object> unsetNotebookFolderCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookFolderCacheSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The maximum
     * number of cached templates in each Wiki / Notebook folder cache.
     *
     * @return zimbraNotebookMaxCachedTemplatesPerFolder, or 256 if unset
     */
    @ZAttr(id=371)
    public int getNotebookMaxCachedTemplatesPerFolder() {
        return getIntAttr(Provisioning.A_zimbraNotebookMaxCachedTemplatesPerFolder, 256, true);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The maximum
     * number of cached templates in each Wiki / Notebook folder cache.
     *
     * @param zimbraNotebookMaxCachedTemplatesPerFolder new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=371)
    public void setNotebookMaxCachedTemplatesPerFolder(int zimbraNotebookMaxCachedTemplatesPerFolder) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookMaxCachedTemplatesPerFolder, Integer.toString(zimbraNotebookMaxCachedTemplatesPerFolder));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The maximum
     * number of cached templates in each Wiki / Notebook folder cache.
     *
     * @param zimbraNotebookMaxCachedTemplatesPerFolder new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=371)
    public Map<String,Object> setNotebookMaxCachedTemplatesPerFolder(int zimbraNotebookMaxCachedTemplatesPerFolder, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookMaxCachedTemplatesPerFolder, Integer.toString(zimbraNotebookMaxCachedTemplatesPerFolder));
        return attrs;
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The maximum
     * number of cached templates in each Wiki / Notebook folder cache.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=371)
    public void unsetNotebookMaxCachedTemplatesPerFolder() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookMaxCachedTemplatesPerFolder, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 6.0.0_BETA1. deprecated. Orig desc: The maximum
     * number of cached templates in each Wiki / Notebook folder cache.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=371)
    public Map<String,Object> unsetNotebookMaxCachedTemplatesPerFolder(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookMaxCachedTemplatesPerFolder, "");
        return attrs;
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @return zimbraNotebookPageCacheSize, or 10240 if unset
     */
    @ZAttr(id=369)
    public int getNotebookPageCacheSize() {
        return getIntAttr(Provisioning.A_zimbraNotebookPageCacheSize, 10240, true);
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @param zimbraNotebookPageCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=369)
    public void setNotebookPageCacheSize(int zimbraNotebookPageCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookPageCacheSize, Integer.toString(zimbraNotebookPageCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @param zimbraNotebookPageCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=369)
    public Map<String,Object> setNotebookPageCacheSize(int zimbraNotebookPageCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookPageCacheSize, Integer.toString(zimbraNotebookPageCacheSize));
        return attrs;
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=369)
    public void unsetNotebookPageCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookPageCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The size of composed Wiki / Notebook page cache on the server.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=369)
    public Map<String,Object> unsetNotebookPageCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotebookPageCacheSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @return zimbraNotifyBindAddress, or empty array if unset
     */
    @ZAttr(id=317)
    public String[] getNotifyBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraNotifyBindAddress, true, true);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=317)
    public void setNotifyBindAddress(String[] zimbraNotifyBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=317)
    public Map<String,Object> setNotifyBindAddress(String[] zimbraNotifyBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=317)
    public void addNotifyBindAddress(String zimbraNotifyBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=317)
    public Map<String,Object> addNotifyBindAddress(String zimbraNotifyBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=317)
    public void removeNotifyBindAddress(String zimbraNotifyBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param zimbraNotifyBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=317)
    public Map<String,Object> removeNotifyBindAddress(String zimbraNotifyBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraNotifyBindAddress, zimbraNotifyBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=317)
    public void unsetNotifyBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which notification server
     * should listen; if empty, binds to all interfaces.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=317)
    public Map<String,Object> unsetNotifyBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindAddress, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @return zimbraNotifyBindPort, or 7035 if unset
     */
    @ZAttr(id=318)
    public int getNotifyBindPort() {
        return getIntAttr(Provisioning.A_zimbraNotifyBindPort, 7035, true);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @param zimbraNotifyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=318)
    public void setNotifyBindPort(int zimbraNotifyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindPort, Integer.toString(zimbraNotifyBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @param zimbraNotifyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=318)
    public Map<String,Object> setNotifyBindPort(int zimbraNotifyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindPort, Integer.toString(zimbraNotifyBindPort));
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=318)
    public void unsetNotifyBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=318)
    public Map<String,Object> unsetNotifyBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyBindPort, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @return zimbraNotifySSLBindAddress, or empty array if unset
     */
    @ZAttr(id=320)
    public String[] getNotifySSLBindAddress() {
        return getMultiAttr(Provisioning.A_zimbraNotifySSLBindAddress, true, true);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=320)
    public void setNotifySSLBindAddress(String[] zimbraNotifySSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=320)
    public Map<String,Object> setNotifySSLBindAddress(String[] zimbraNotifySSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=320)
    public void addNotifySSLBindAddress(String zimbraNotifySSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=320)
    public Map<String,Object> addNotifySSLBindAddress(String zimbraNotifySSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=320)
    public void removeNotifySSLBindAddress(String zimbraNotifySSLBindAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param zimbraNotifySSLBindAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=320)
    public Map<String,Object> removeNotifySSLBindAddress(String zimbraNotifySSLBindAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraNotifySSLBindAddress, zimbraNotifySSLBindAddress);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=320)
    public void unsetNotifySSLBindAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Network interface on which SSL notification server
     * should listen; if empty, binds to all interfaces
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=320)
    public Map<String,Object> unsetNotifySSLBindAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindAddress, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @return zimbraNotifySSLBindPort, or 7036 if unset
     */
    @ZAttr(id=321)
    public int getNotifySSLBindPort() {
        return getIntAttr(Provisioning.A_zimbraNotifySSLBindPort, 7036, true);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @param zimbraNotifySSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=321)
    public void setNotifySSLBindPort(int zimbraNotifySSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindPort, Integer.toString(zimbraNotifySSLBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @param zimbraNotifySSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=321)
    public Map<String,Object> setNotifySSLBindPort(int zimbraNotifySSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindPort, Integer.toString(zimbraNotifySSLBindPort));
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=321)
    public void unsetNotifySSLBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Port number on which notification server should
     * listen.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=321)
    public Map<String,Object> unsetNotifySSLBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLBindPort, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether SSL notification server should be enabled.
     *
     * @return zimbraNotifySSLServerEnabled, or true if unset
     */
    @ZAttr(id=319)
    public boolean isNotifySSLServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraNotifySSLServerEnabled, true, true);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether SSL notification server should be enabled.
     *
     * @param zimbraNotifySSLServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=319)
    public void setNotifySSLServerEnabled(boolean zimbraNotifySSLServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLServerEnabled, zimbraNotifySSLServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether SSL notification server should be enabled.
     *
     * @param zimbraNotifySSLServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=319)
    public Map<String,Object> setNotifySSLServerEnabled(boolean zimbraNotifySSLServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLServerEnabled, zimbraNotifySSLServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether SSL notification server should be enabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=319)
    public void unsetNotifySSLServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether SSL notification server should be enabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=319)
    public Map<String,Object> unsetNotifySSLServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifySSLServerEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether notification server should be enabled.
     *
     * @return zimbraNotifyServerEnabled, or true if unset
     */
    @ZAttr(id=316)
    public boolean isNotifyServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraNotifyServerEnabled, true, true);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether notification server should be enabled.
     *
     * @param zimbraNotifyServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=316)
    public void setNotifyServerEnabled(boolean zimbraNotifyServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyServerEnabled, zimbraNotifyServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether notification server should be enabled.
     *
     * @param zimbraNotifyServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=316)
    public Map<String,Object> setNotifyServerEnabled(boolean zimbraNotifyServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyServerEnabled, zimbraNotifyServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether notification server should be enabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=316)
    public void unsetNotifyServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.0. was experimental and never part of any shipping
     * feature. Orig desc: Whether notification server should be enabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=316)
    public Map<String,Object> unsetNotifyServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraNotifyServerEnabled, "");
        return attrs;
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @return zimbraOAuthConsumerAPIScope, or empty array if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public String[] getOAuthConsumerAPIScope() {
        return getMultiAttr(Provisioning.A_zimbraOAuthConsumerAPIScope, true, true);
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @param zimbraOAuthConsumerAPIScope new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public void setOAuthConsumerAPIScope(String[] zimbraOAuthConsumerAPIScope) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerAPIScope, zimbraOAuthConsumerAPIScope);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @param zimbraOAuthConsumerAPIScope new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public Map<String,Object> setOAuthConsumerAPIScope(String[] zimbraOAuthConsumerAPIScope, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerAPIScope, zimbraOAuthConsumerAPIScope);
        return attrs;
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @param zimbraOAuthConsumerAPIScope new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public void addOAuthConsumerAPIScope(String zimbraOAuthConsumerAPIScope) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOAuthConsumerAPIScope, zimbraOAuthConsumerAPIScope);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @param zimbraOAuthConsumerAPIScope new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public Map<String,Object> addOAuthConsumerAPIScope(String zimbraOAuthConsumerAPIScope, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOAuthConsumerAPIScope, zimbraOAuthConsumerAPIScope);
        return attrs;
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @param zimbraOAuthConsumerAPIScope existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public void removeOAuthConsumerAPIScope(String zimbraOAuthConsumerAPIScope) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOAuthConsumerAPIScope, zimbraOAuthConsumerAPIScope);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @param zimbraOAuthConsumerAPIScope existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public Map<String,Object> removeOAuthConsumerAPIScope(String zimbraOAuthConsumerAPIScope, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOAuthConsumerAPIScope, zimbraOAuthConsumerAPIScope);
        return attrs;
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public void unsetOAuthConsumerAPIScope() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerAPIScope, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth consumer API scope. It is in the format of apiscope1{separator
     * character}apiscope2:consumer-app-name. The separator between apiscope1
     * and apiscope2 is consumer-app specific
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3026)
    public Map<String,Object> unsetOAuthConsumerAPIScope(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerAPIScope, "");
        return attrs;
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @return zimbraOAuthConsumerCredentials, or empty array if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public String[] getOAuthConsumerCredentials() {
        return getMultiAttr(Provisioning.A_zimbraOAuthConsumerCredentials, true, true);
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @param zimbraOAuthConsumerCredentials new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public void setOAuthConsumerCredentials(String[] zimbraOAuthConsumerCredentials) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerCredentials, zimbraOAuthConsumerCredentials);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @param zimbraOAuthConsumerCredentials new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public Map<String,Object> setOAuthConsumerCredentials(String[] zimbraOAuthConsumerCredentials, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerCredentials, zimbraOAuthConsumerCredentials);
        return attrs;
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @param zimbraOAuthConsumerCredentials new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public void addOAuthConsumerCredentials(String zimbraOAuthConsumerCredentials) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOAuthConsumerCredentials, zimbraOAuthConsumerCredentials);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @param zimbraOAuthConsumerCredentials new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public Map<String,Object> addOAuthConsumerCredentials(String zimbraOAuthConsumerCredentials, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOAuthConsumerCredentials, zimbraOAuthConsumerCredentials);
        return attrs;
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @param zimbraOAuthConsumerCredentials existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public void removeOAuthConsumerCredentials(String zimbraOAuthConsumerCredentials) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOAuthConsumerCredentials, zimbraOAuthConsumerCredentials);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @param zimbraOAuthConsumerCredentials existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public Map<String,Object> removeOAuthConsumerCredentials(String zimbraOAuthConsumerCredentials, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOAuthConsumerCredentials, zimbraOAuthConsumerCredentials);
        return attrs;
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public void unsetOAuthConsumerCredentials() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerCredentials, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth Consumer id, secret, and application name. It is in the format
     * of {consumer-id}:{secret}:{consumer-app-name}
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1131)
    public Map<String,Object> unsetOAuthConsumerCredentials(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerCredentials, "");
        return attrs;
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @return zimbraOAuthConsumerRedirectUri, or empty array if unset
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public String[] getOAuthConsumerRedirectUri() {
        return getMultiAttr(Provisioning.A_zimbraOAuthConsumerRedirectUri, true, true);
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @param zimbraOAuthConsumerRedirectUri new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public void setOAuthConsumerRedirectUri(String[] zimbraOAuthConsumerRedirectUri) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerRedirectUri, zimbraOAuthConsumerRedirectUri);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @param zimbraOAuthConsumerRedirectUri new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public Map<String,Object> setOAuthConsumerRedirectUri(String[] zimbraOAuthConsumerRedirectUri, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerRedirectUri, zimbraOAuthConsumerRedirectUri);
        return attrs;
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @param zimbraOAuthConsumerRedirectUri new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public void addOAuthConsumerRedirectUri(String zimbraOAuthConsumerRedirectUri) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOAuthConsumerRedirectUri, zimbraOAuthConsumerRedirectUri);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @param zimbraOAuthConsumerRedirectUri new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public Map<String,Object> addOAuthConsumerRedirectUri(String zimbraOAuthConsumerRedirectUri, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOAuthConsumerRedirectUri, zimbraOAuthConsumerRedirectUri);
        return attrs;
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @param zimbraOAuthConsumerRedirectUri existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public void removeOAuthConsumerRedirectUri(String zimbraOAuthConsumerRedirectUri) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOAuthConsumerRedirectUri, zimbraOAuthConsumerRedirectUri);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @param zimbraOAuthConsumerRedirectUri existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public Map<String,Object> removeOAuthConsumerRedirectUri(String zimbraOAuthConsumerRedirectUri, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOAuthConsumerRedirectUri, zimbraOAuthConsumerRedirectUri);
        return attrs;
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public void unsetOAuthConsumerRedirectUri() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerRedirectUri, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * OAuth redirectURI. It is in the format of
     * redirectURI:consumer-app-name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.9
     */
    @ZAttr(id=3025)
    public Map<String,Object> unsetOAuthConsumerRedirectUri(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOAuthConsumerRedirectUri, "");
        return attrs;
    }

    /**
     * The max number of IMAP messages returned by OpenImapFolderRequest
     * before pagination begins
     *
     * @return zimbraOpenImapFolderRequestChunkSize, or 1000 if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3012)
    public int getOpenImapFolderRequestChunkSize() {
        return getIntAttr(Provisioning.A_zimbraOpenImapFolderRequestChunkSize, 1000, true);
    }

    /**
     * The max number of IMAP messages returned by OpenImapFolderRequest
     * before pagination begins
     *
     * @param zimbraOpenImapFolderRequestChunkSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3012)
    public void setOpenImapFolderRequestChunkSize(int zimbraOpenImapFolderRequestChunkSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenImapFolderRequestChunkSize, Integer.toString(zimbraOpenImapFolderRequestChunkSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The max number of IMAP messages returned by OpenImapFolderRequest
     * before pagination begins
     *
     * @param zimbraOpenImapFolderRequestChunkSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3012)
    public Map<String,Object> setOpenImapFolderRequestChunkSize(int zimbraOpenImapFolderRequestChunkSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenImapFolderRequestChunkSize, Integer.toString(zimbraOpenImapFolderRequestChunkSize));
        return attrs;
    }

    /**
     * The max number of IMAP messages returned by OpenImapFolderRequest
     * before pagination begins
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3012)
    public void unsetOpenImapFolderRequestChunkSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenImapFolderRequestChunkSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The max number of IMAP messages returned by OpenImapFolderRequest
     * before pagination begins
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3012)
    public Map<String,Object> unsetOpenImapFolderRequestChunkSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenImapFolderRequestChunkSize, "");
        return attrs;
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @return zimbraOpenidConsumerAllowedOPEndpointURL, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public String[] getOpenidConsumerAllowedOPEndpointURL() {
        return getMultiAttr(Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, true, true);
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @param zimbraOpenidConsumerAllowedOPEndpointURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public void setOpenidConsumerAllowedOPEndpointURL(String[] zimbraOpenidConsumerAllowedOPEndpointURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, zimbraOpenidConsumerAllowedOPEndpointURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @param zimbraOpenidConsumerAllowedOPEndpointURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public Map<String,Object> setOpenidConsumerAllowedOPEndpointURL(String[] zimbraOpenidConsumerAllowedOPEndpointURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, zimbraOpenidConsumerAllowedOPEndpointURL);
        return attrs;
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @param zimbraOpenidConsumerAllowedOPEndpointURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public void addOpenidConsumerAllowedOPEndpointURL(String zimbraOpenidConsumerAllowedOPEndpointURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, zimbraOpenidConsumerAllowedOPEndpointURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @param zimbraOpenidConsumerAllowedOPEndpointURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public Map<String,Object> addOpenidConsumerAllowedOPEndpointURL(String zimbraOpenidConsumerAllowedOPEndpointURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, zimbraOpenidConsumerAllowedOPEndpointURL);
        return attrs;
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @param zimbraOpenidConsumerAllowedOPEndpointURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public void removeOpenidConsumerAllowedOPEndpointURL(String zimbraOpenidConsumerAllowedOPEndpointURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, zimbraOpenidConsumerAllowedOPEndpointURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @param zimbraOpenidConsumerAllowedOPEndpointURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public Map<String,Object> removeOpenidConsumerAllowedOPEndpointURL(String zimbraOpenidConsumerAllowedOPEndpointURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, zimbraOpenidConsumerAllowedOPEndpointURL);
        return attrs;
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public void unsetOpenidConsumerAllowedOPEndpointURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * allowed OpenID Provider Endpoint URLs for authentication
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1191)
    public Map<String,Object> unsetOpenidConsumerAllowedOPEndpointURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerAllowedOPEndpointURL, "");
        return attrs;
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @return zimbraOpenidConsumerStatelessModeEnabled, or true if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public boolean isOpenidConsumerStatelessModeEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, true, true);
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @param zimbraOpenidConsumerStatelessModeEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public void setOpenidConsumerStatelessModeEnabled(boolean zimbraOpenidConsumerStatelessModeEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, zimbraOpenidConsumerStatelessModeEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @param zimbraOpenidConsumerStatelessModeEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public Map<String,Object> setOpenidConsumerStatelessModeEnabled(boolean zimbraOpenidConsumerStatelessModeEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, zimbraOpenidConsumerStatelessModeEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public void unsetOpenidConsumerStatelessModeEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether stateless mode (not establishing an association with the
     * OpenID Provider) in OpenID Consumer is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1189)
    public Map<String,Object> unsetOpenidConsumerStatelessModeEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraOpenidConsumerStatelessModeEnabled, "");
        return attrs;
    }

    /**
     * registered change password listener name
     *
     * @return zimbraPasswordChangeListener, or null if unset
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=586)
    public String getPasswordChangeListener() {
        return getAttr(Provisioning.A_zimbraPasswordChangeListener, null, true);
    }

    /**
     * registered change password listener name
     *
     * @param zimbraPasswordChangeListener new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=586)
    public void setPasswordChangeListener(String zimbraPasswordChangeListener) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordChangeListener, zimbraPasswordChangeListener);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * registered change password listener name
     *
     * @param zimbraPasswordChangeListener new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=586)
    public Map<String,Object> setPasswordChangeListener(String zimbraPasswordChangeListener, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordChangeListener, zimbraPasswordChangeListener);
        return attrs;
    }

    /**
     * registered change password listener name
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=586)
    public void unsetPasswordChangeListener() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordChangeListener, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * registered change password listener name
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=586)
    public Map<String,Object> unsetPasswordChangeListener(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPasswordChangeListener, "");
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @return zimbraPop3BindOnStartup, or true if unset
     */
    @ZAttr(id=271)
    public boolean isPop3BindOnStartup() {
        return getBooleanAttr(Provisioning.A_zimbraPop3BindOnStartup, true, true);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraPop3BindOnStartup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=271)
    public void setPop3BindOnStartup(boolean zimbraPop3BindOnStartup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindOnStartup, zimbraPop3BindOnStartup ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraPop3BindOnStartup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=271)
    public Map<String,Object> setPop3BindOnStartup(boolean zimbraPop3BindOnStartup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindOnStartup, zimbraPop3BindOnStartup ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=271)
    public void unsetPop3BindOnStartup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindOnStartup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=271)
    public Map<String,Object> unsetPop3BindOnStartup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindOnStartup, "");
        return attrs;
    }

    /**
     * port number on which POP3 server should listen
     *
     * <p>Use getPop3BindPortAsString to access value as a string.
     *
     * @see #getPop3BindPortAsString()
     *
     * @return zimbraPop3BindPort, or 7110 if unset
     */
    @ZAttr(id=94)
    public int getPop3BindPort() {
        return getIntAttr(Provisioning.A_zimbraPop3BindPort, 7110, true);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @return zimbraPop3BindPort, or "7110" if unset
     */
    @ZAttr(id=94)
    public String getPop3BindPortAsString() {
        return getAttr(Provisioning.A_zimbraPop3BindPort, "7110", true);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param zimbraPop3BindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=94)
    public void setPop3BindPort(int zimbraPop3BindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindPort, Integer.toString(zimbraPop3BindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param zimbraPop3BindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=94)
    public Map<String,Object> setPop3BindPort(int zimbraPop3BindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindPort, Integer.toString(zimbraPop3BindPort));
        return attrs;
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param zimbraPop3BindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=94)
    public void setPop3BindPortAsString(String zimbraPop3BindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindPort, zimbraPop3BindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param zimbraPop3BindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=94)
    public Map<String,Object> setPop3BindPortAsString(String zimbraPop3BindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindPort, zimbraPop3BindPort);
        return attrs;
    }

    /**
     * port number on which POP3 server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=94)
    public void unsetPop3BindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=94)
    public Map<String,Object> unsetPop3BindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3BindPort, "");
        return attrs;
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @return zimbraPop3CleartextLoginEnabled, or false if unset
     */
    @ZAttr(id=189)
    public boolean isPop3CleartextLoginEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPop3CleartextLoginEnabled, false, true);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param zimbraPop3CleartextLoginEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=189)
    public void setPop3CleartextLoginEnabled(boolean zimbraPop3CleartextLoginEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3CleartextLoginEnabled, zimbraPop3CleartextLoginEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param zimbraPop3CleartextLoginEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=189)
    public Map<String,Object> setPop3CleartextLoginEnabled(boolean zimbraPop3CleartextLoginEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3CleartextLoginEnabled, zimbraPop3CleartextLoginEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=189)
    public void unsetPop3CleartextLoginEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3CleartextLoginEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether or not to allow cleartext logins over a non SSL/TLS connection
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=189)
    public Map<String,Object> unsetPop3CleartextLoginEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3CleartextLoginEnabled, "");
        return attrs;
    }

    /**
     * Whether to expose version on POP3 banner
     *
     * @return zimbraPop3ExposeVersionOnBanner, or false if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=692)
    public boolean isPop3ExposeVersionOnBanner() {
        return getBooleanAttr(Provisioning.A_zimbraPop3ExposeVersionOnBanner, false, true);
    }

    /**
     * Whether to expose version on POP3 banner
     *
     * @param zimbraPop3ExposeVersionOnBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=692)
    public void setPop3ExposeVersionOnBanner(boolean zimbraPop3ExposeVersionOnBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ExposeVersionOnBanner, zimbraPop3ExposeVersionOnBanner ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on POP3 banner
     *
     * @param zimbraPop3ExposeVersionOnBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=692)
    public Map<String,Object> setPop3ExposeVersionOnBanner(boolean zimbraPop3ExposeVersionOnBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ExposeVersionOnBanner, zimbraPop3ExposeVersionOnBanner ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to expose version on POP3 banner
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=692)
    public void unsetPop3ExposeVersionOnBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ExposeVersionOnBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on POP3 banner
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=692)
    public Map<String,Object> unsetPop3ExposeVersionOnBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ExposeVersionOnBanner, "");
        return attrs;
    }

    /**
     * Maximum number of concurrent POP3 connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @return zimbraPop3MaxConnections, or 200 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1155)
    public int getPop3MaxConnections() {
        return getIntAttr(Provisioning.A_zimbraPop3MaxConnections, 200, true);
    }

    /**
     * Maximum number of concurrent POP3 connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param zimbraPop3MaxConnections new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1155)
    public void setPop3MaxConnections(int zimbraPop3MaxConnections) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxConnections, Integer.toString(zimbraPop3MaxConnections));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent POP3 connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param zimbraPop3MaxConnections new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1155)
    public Map<String,Object> setPop3MaxConnections(int zimbraPop3MaxConnections, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxConnections, Integer.toString(zimbraPop3MaxConnections));
        return attrs;
    }

    /**
     * Maximum number of concurrent POP3 connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1155)
    public void unsetPop3MaxConnections() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxConnections, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of concurrent POP3 connections allowed. New connections
     * exceeding this limit are rejected.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1155)
    public Map<String,Object> unsetPop3MaxConnections(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3MaxConnections, "");
        return attrs;
    }

    /**
     * number of handler threads
     *
     * @return zimbraPop3NumThreads, or 100 if unset
     */
    @ZAttr(id=96)
    public int getPop3NumThreads() {
        return getIntAttr(Provisioning.A_zimbraPop3NumThreads, 100, true);
    }

    /**
     * number of handler threads
     *
     * @param zimbraPop3NumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=96)
    public void setPop3NumThreads(int zimbraPop3NumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NumThreads, Integer.toString(zimbraPop3NumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads
     *
     * @param zimbraPop3NumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=96)
    public Map<String,Object> setPop3NumThreads(int zimbraPop3NumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NumThreads, Integer.toString(zimbraPop3NumThreads));
        return attrs;
    }

    /**
     * number of handler threads
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=96)
    public void unsetPop3NumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of handler threads
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=96)
    public Map<String,Object> unsetPop3NumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3NumThreads, "");
        return attrs;
    }

    /**
     * port number on which POP3 proxy server should listen
     *
     * <p>Use getPop3ProxyBindPortAsString to access value as a string.
     *
     * @see #getPop3ProxyBindPortAsString()
     *
     * @return zimbraPop3ProxyBindPort, or 110 if unset
     */
    @ZAttr(id=350)
    public int getPop3ProxyBindPort() {
        return getIntAttr(Provisioning.A_zimbraPop3ProxyBindPort, 110, true);
    }

    /**
     * port number on which POP3 proxy server should listen
     *
     * @return zimbraPop3ProxyBindPort, or "110" if unset
     */
    @ZAttr(id=350)
    public String getPop3ProxyBindPortAsString() {
        return getAttr(Provisioning.A_zimbraPop3ProxyBindPort, "110", true);
    }

    /**
     * port number on which POP3 proxy server should listen
     *
     * @param zimbraPop3ProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=350)
    public void setPop3ProxyBindPort(int zimbraPop3ProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ProxyBindPort, Integer.toString(zimbraPop3ProxyBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 proxy server should listen
     *
     * @param zimbraPop3ProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=350)
    public Map<String,Object> setPop3ProxyBindPort(int zimbraPop3ProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ProxyBindPort, Integer.toString(zimbraPop3ProxyBindPort));
        return attrs;
    }

    /**
     * port number on which POP3 proxy server should listen
     *
     * @param zimbraPop3ProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=350)
    public void setPop3ProxyBindPortAsString(String zimbraPop3ProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ProxyBindPort, zimbraPop3ProxyBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 proxy server should listen
     *
     * @param zimbraPop3ProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=350)
    public Map<String,Object> setPop3ProxyBindPortAsString(String zimbraPop3ProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ProxyBindPort, zimbraPop3ProxyBindPort);
        return attrs;
    }

    /**
     * port number on which POP3 proxy server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=350)
    public void unsetPop3ProxyBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ProxyBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 proxy server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=350)
    public Map<String,Object> unsetPop3ProxyBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ProxyBindPort, "");
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @return zimbraPop3SSLBindOnStartup, or true if unset
     */
    @ZAttr(id=272)
    public boolean isPop3SSLBindOnStartup() {
        return getBooleanAttr(Provisioning.A_zimbraPop3SSLBindOnStartup, true, true);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraPop3SSLBindOnStartup new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=272)
    public void setPop3SSLBindOnStartup(boolean zimbraPop3SSLBindOnStartup) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindOnStartup, zimbraPop3SSLBindOnStartup ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param zimbraPop3SSLBindOnStartup new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=272)
    public Map<String,Object> setPop3SSLBindOnStartup(boolean zimbraPop3SSLBindOnStartup, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindOnStartup, zimbraPop3SSLBindOnStartup ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=272)
    public void unsetPop3SSLBindOnStartup() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindOnStartup, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to bind to port on startup irrespective of whether the server
     * is enabled. Useful when port to bind is privileged and must be bound
     * early.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=272)
    public Map<String,Object> unsetPop3SSLBindOnStartup(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindOnStartup, "");
        return attrs;
    }

    /**
     * port number on which POP3 server should listen
     *
     * <p>Use getPop3SSLBindPortAsString to access value as a string.
     *
     * @see #getPop3SSLBindPortAsString()
     *
     * @return zimbraPop3SSLBindPort, or 7995 if unset
     */
    @ZAttr(id=187)
    public int getPop3SSLBindPort() {
        return getIntAttr(Provisioning.A_zimbraPop3SSLBindPort, 7995, true);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @return zimbraPop3SSLBindPort, or "7995" if unset
     */
    @ZAttr(id=187)
    public String getPop3SSLBindPortAsString() {
        return getAttr(Provisioning.A_zimbraPop3SSLBindPort, "7995", true);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param zimbraPop3SSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=187)
    public void setPop3SSLBindPort(int zimbraPop3SSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindPort, Integer.toString(zimbraPop3SSLBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param zimbraPop3SSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=187)
    public Map<String,Object> setPop3SSLBindPort(int zimbraPop3SSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindPort, Integer.toString(zimbraPop3SSLBindPort));
        return attrs;
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param zimbraPop3SSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=187)
    public void setPop3SSLBindPortAsString(String zimbraPop3SSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindPort, zimbraPop3SSLBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param zimbraPop3SSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=187)
    public Map<String,Object> setPop3SSLBindPortAsString(String zimbraPop3SSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindPort, zimbraPop3SSLBindPort);
        return attrs;
    }

    /**
     * port number on which POP3 server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=187)
    public void unsetPop3SSLBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3 server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=187)
    public Map<String,Object> unsetPop3SSLBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLBindPort, "");
        return attrs;
    }

    /**
     * port number on which POP3S proxy server should listen
     *
     * <p>Use getPop3SSLProxyBindPortAsString to access value as a string.
     *
     * @see #getPop3SSLProxyBindPortAsString()
     *
     * @return zimbraPop3SSLProxyBindPort, or 995 if unset
     */
    @ZAttr(id=351)
    public int getPop3SSLProxyBindPort() {
        return getIntAttr(Provisioning.A_zimbraPop3SSLProxyBindPort, 995, true);
    }

    /**
     * port number on which POP3S proxy server should listen
     *
     * @return zimbraPop3SSLProxyBindPort, or "995" if unset
     */
    @ZAttr(id=351)
    public String getPop3SSLProxyBindPortAsString() {
        return getAttr(Provisioning.A_zimbraPop3SSLProxyBindPort, "995", true);
    }

    /**
     * port number on which POP3S proxy server should listen
     *
     * @param zimbraPop3SSLProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=351)
    public void setPop3SSLProxyBindPort(int zimbraPop3SSLProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLProxyBindPort, Integer.toString(zimbraPop3SSLProxyBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3S proxy server should listen
     *
     * @param zimbraPop3SSLProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=351)
    public Map<String,Object> setPop3SSLProxyBindPort(int zimbraPop3SSLProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLProxyBindPort, Integer.toString(zimbraPop3SSLProxyBindPort));
        return attrs;
    }

    /**
     * port number on which POP3S proxy server should listen
     *
     * @param zimbraPop3SSLProxyBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=351)
    public void setPop3SSLProxyBindPortAsString(String zimbraPop3SSLProxyBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLProxyBindPort, zimbraPop3SSLProxyBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3S proxy server should listen
     *
     * @param zimbraPop3SSLProxyBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=351)
    public Map<String,Object> setPop3SSLProxyBindPortAsString(String zimbraPop3SSLProxyBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLProxyBindPort, zimbraPop3SSLProxyBindPort);
        return attrs;
    }

    /**
     * port number on which POP3S proxy server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=351)
    public void unsetPop3SSLProxyBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLProxyBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which POP3S proxy server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=351)
    public Map<String,Object> unsetPop3SSLProxyBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLProxyBindPort, "");
        return attrs;
    }

    /**
     * whether POP3 SSL server is enabled for a server
     *
     * @return zimbraPop3SSLServerEnabled, or true if unset
     */
    @ZAttr(id=188)
    public boolean isPop3SSLServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPop3SSLServerEnabled, true, true);
    }

    /**
     * whether POP3 SSL server is enabled for a server
     *
     * @param zimbraPop3SSLServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=188)
    public void setPop3SSLServerEnabled(boolean zimbraPop3SSLServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLServerEnabled, zimbraPop3SSLServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 SSL server is enabled for a server
     *
     * @param zimbraPop3SSLServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=188)
    public Map<String,Object> setPop3SSLServerEnabled(boolean zimbraPop3SSLServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLServerEnabled, zimbraPop3SSLServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether POP3 SSL server is enabled for a server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=188)
    public void unsetPop3SSLServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 SSL server is enabled for a server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=188)
    public Map<String,Object> unsetPop3SSLServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SSLServerEnabled, "");
        return attrs;
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for a given server
     *
     * @return zimbraPop3SaslGssapiEnabled, or false if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=554)
    public boolean isPop3SaslGssapiEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPop3SaslGssapiEnabled, false, true);
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for a given server
     *
     * @param zimbraPop3SaslGssapiEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=554)
    public void setPop3SaslGssapiEnabled(boolean zimbraPop3SaslGssapiEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SaslGssapiEnabled, zimbraPop3SaslGssapiEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for a given server
     *
     * @param zimbraPop3SaslGssapiEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=554)
    public Map<String,Object> setPop3SaslGssapiEnabled(boolean zimbraPop3SaslGssapiEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SaslGssapiEnabled, zimbraPop3SaslGssapiEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for a given server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=554)
    public void unsetPop3SaslGssapiEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SaslGssapiEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for a given server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=554)
    public Map<String,Object> unsetPop3SaslGssapiEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3SaslGssapiEnabled, "");
        return attrs;
    }

    /**
     * whether POP3 is enabled for a server
     *
     * @return zimbraPop3ServerEnabled, or true if unset
     */
    @ZAttr(id=177)
    public boolean isPop3ServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraPop3ServerEnabled, true, true);
    }

    /**
     * whether POP3 is enabled for a server
     *
     * @param zimbraPop3ServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=177)
    public void setPop3ServerEnabled(boolean zimbraPop3ServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ServerEnabled, zimbraPop3ServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 is enabled for a server
     *
     * @param zimbraPop3ServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=177)
    public Map<String,Object> setPop3ServerEnabled(boolean zimbraPop3ServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ServerEnabled, zimbraPop3ServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether POP3 is enabled for a server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=177)
    public void unsetPop3ServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 is enabled for a server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=177)
    public Map<String,Object> unsetPop3ServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ServerEnabled, "");
        return attrs;
    }

    /**
     * number of seconds to wait before forcing POP3 server shutdown
     *
     * @return zimbraPop3ShutdownGraceSeconds, or 10 if unset
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1081)
    public int getPop3ShutdownGraceSeconds() {
        return getIntAttr(Provisioning.A_zimbraPop3ShutdownGraceSeconds, 10, true);
    }

    /**
     * number of seconds to wait before forcing POP3 server shutdown
     *
     * @param zimbraPop3ShutdownGraceSeconds new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1081)
    public void setPop3ShutdownGraceSeconds(int zimbraPop3ShutdownGraceSeconds) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ShutdownGraceSeconds, Integer.toString(zimbraPop3ShutdownGraceSeconds));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing POP3 server shutdown
     *
     * @param zimbraPop3ShutdownGraceSeconds new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1081)
    public Map<String,Object> setPop3ShutdownGraceSeconds(int zimbraPop3ShutdownGraceSeconds, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ShutdownGraceSeconds, Integer.toString(zimbraPop3ShutdownGraceSeconds));
        return attrs;
    }

    /**
     * number of seconds to wait before forcing POP3 server shutdown
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1081)
    public void unsetPop3ShutdownGraceSeconds() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ShutdownGraceSeconds, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * number of seconds to wait before forcing POP3 server shutdown
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.7
     */
    @ZAttr(id=1081)
    public Map<String,Object> unsetPop3ShutdownGraceSeconds(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPop3ShutdownGraceSeconds, "");
        return attrs;
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @return zimbraPrevFoldersToTrackMax, or 10 if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public int getPrevFoldersToTrackMax() {
        return getIntAttr(Provisioning.A_zimbraPrevFoldersToTrackMax, 10, true);
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @param zimbraPrevFoldersToTrackMax new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public void setPrevFoldersToTrackMax(int zimbraPrevFoldersToTrackMax) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrevFoldersToTrackMax, Integer.toString(zimbraPrevFoldersToTrackMax));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @param zimbraPrevFoldersToTrackMax new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public Map<String,Object> setPrevFoldersToTrackMax(int zimbraPrevFoldersToTrackMax, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrevFoldersToTrackMax, Integer.toString(zimbraPrevFoldersToTrackMax));
        return attrs;
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public void unsetPrevFoldersToTrackMax() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrevFoldersToTrackMax, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Max number of previous residing folders server tracks for a mail item
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1592)
    public Map<String,Object> unsetPrevFoldersToTrackMax(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPrevFoldersToTrackMax, "");
        return attrs;
    }

    /**
     * URL of the previous ephemeral storage backend
     *
     * @return zimbraPreviousEphemeralBackendURL, or null if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3018)
    public String getPreviousEphemeralBackendURL() {
        return getAttr(Provisioning.A_zimbraPreviousEphemeralBackendURL, null, true);
    }

    /**
     * URL of the previous ephemeral storage backend
     *
     * @param zimbraPreviousEphemeralBackendURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3018)
    public void setPreviousEphemeralBackendURL(String zimbraPreviousEphemeralBackendURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPreviousEphemeralBackendURL, zimbraPreviousEphemeralBackendURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the previous ephemeral storage backend
     *
     * @param zimbraPreviousEphemeralBackendURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3018)
    public Map<String,Object> setPreviousEphemeralBackendURL(String zimbraPreviousEphemeralBackendURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPreviousEphemeralBackendURL, zimbraPreviousEphemeralBackendURL);
        return attrs;
    }

    /**
     * URL of the previous ephemeral storage backend
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3018)
    public void unsetPreviousEphemeralBackendURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPreviousEphemeralBackendURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the previous ephemeral storage backend
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3018)
    public Map<String,Object> unsetPreviousEphemeralBackendURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPreviousEphemeralBackendURL, "");
        return attrs;
    }

    /**
     * whether this instance of Zimbra is running ZCS or some other
     * derivative product
     *
     * <p>Valid values: [ZCS]
     *
     * @return zimbraProduct, or ZAttrProvisioning.Product.ZCS if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1392)
    public ZAttrProvisioning.Product getProduct() {
        try { String v = getAttr(Provisioning.A_zimbraProduct, true, true); return v == null ? ZAttrProvisioning.Product.ZCS : ZAttrProvisioning.Product.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.Product.ZCS; }
    }

    /**
     * whether this instance of Zimbra is running ZCS or some other
     * derivative product
     *
     * <p>Valid values: [ZCS]
     *
     * @return zimbraProduct, or "ZCS" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1392)
    public String getProductAsString() {
        return getAttr(Provisioning.A_zimbraProduct, "ZCS", true);
    }

    /**
     * whether this instance of Zimbra is running ZCS or some other
     * derivative product
     *
     * <p>Valid values: [ZCS]
     *
     * @param zimbraProduct new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1392)
    public void setProduct(ZAttrProvisioning.Product zimbraProduct) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProduct, zimbraProduct.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this instance of Zimbra is running ZCS or some other
     * derivative product
     *
     * <p>Valid values: [ZCS]
     *
     * @param zimbraProduct new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1392)
    public Map<String,Object> setProduct(ZAttrProvisioning.Product zimbraProduct, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProduct, zimbraProduct.toString());
        return attrs;
    }

    /**
     * whether this instance of Zimbra is running ZCS or some other
     * derivative product
     *
     * <p>Valid values: [ZCS]
     *
     * @param zimbraProduct new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1392)
    public void setProductAsString(String zimbraProduct) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProduct, zimbraProduct);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this instance of Zimbra is running ZCS or some other
     * derivative product
     *
     * <p>Valid values: [ZCS]
     *
     * @param zimbraProduct new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1392)
    public Map<String,Object> setProductAsString(String zimbraProduct, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProduct, zimbraProduct);
        return attrs;
    }

    /**
     * whether this instance of Zimbra is running ZCS or some other
     * derivative product
     *
     * <p>Valid values: [ZCS]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1392)
    public void unsetProduct() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProduct, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this instance of Zimbra is running ZCS or some other
     * derivative product
     *
     * <p>Valid values: [ZCS]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1392)
    public Map<String,Object> unsetProduct(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraProduct, "");
        return attrs;
    }

    /**
     * Name to be used in public API such as REST or SOAP proxy.
     *
     * @return zimbraPublicServiceHostname, or null if unset
     */
    @ZAttr(id=377)
    public String getPublicServiceHostname() {
        return getAttr(Provisioning.A_zimbraPublicServiceHostname, null, true);
    }

    /**
     * Name to be used in public API such as REST or SOAP proxy.
     *
     * @param zimbraPublicServiceHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=377)
    public void setPublicServiceHostname(String zimbraPublicServiceHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServiceHostname, zimbraPublicServiceHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Name to be used in public API such as REST or SOAP proxy.
     *
     * @param zimbraPublicServiceHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=377)
    public Map<String,Object> setPublicServiceHostname(String zimbraPublicServiceHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServiceHostname, zimbraPublicServiceHostname);
        return attrs;
    }

    /**
     * Name to be used in public API such as REST or SOAP proxy.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=377)
    public void unsetPublicServiceHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServiceHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Name to be used in public API such as REST or SOAP proxy.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=377)
    public Map<String,Object> unsetPublicServiceHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServiceHostname, "");
        return attrs;
    }

    /**
     * Port to be used in public API such as REST or SOAP proxy.
     *
     * <p>Use getPublicServicePortAsString to access value as a string.
     *
     * @see #getPublicServicePortAsString()
     *
     * @return zimbraPublicServicePort, or -1 if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=699)
    public int getPublicServicePort() {
        return getIntAttr(Provisioning.A_zimbraPublicServicePort, -1, true);
    }

    /**
     * Port to be used in public API such as REST or SOAP proxy.
     *
     * @return zimbraPublicServicePort, or null if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=699)
    public String getPublicServicePortAsString() {
        return getAttr(Provisioning.A_zimbraPublicServicePort, null, true);
    }

    /**
     * Port to be used in public API such as REST or SOAP proxy.
     *
     * @param zimbraPublicServicePort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=699)
    public void setPublicServicePort(int zimbraPublicServicePort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServicePort, Integer.toString(zimbraPublicServicePort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port to be used in public API such as REST or SOAP proxy.
     *
     * @param zimbraPublicServicePort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=699)
    public Map<String,Object> setPublicServicePort(int zimbraPublicServicePort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServicePort, Integer.toString(zimbraPublicServicePort));
        return attrs;
    }

    /**
     * Port to be used in public API such as REST or SOAP proxy.
     *
     * @param zimbraPublicServicePort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=699)
    public void setPublicServicePortAsString(String zimbraPublicServicePort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServicePort, zimbraPublicServicePort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port to be used in public API such as REST or SOAP proxy.
     *
     * @param zimbraPublicServicePort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=699)
    public Map<String,Object> setPublicServicePortAsString(String zimbraPublicServicePort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServicePort, zimbraPublicServicePort);
        return attrs;
    }

    /**
     * Port to be used in public API such as REST or SOAP proxy.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=699)
    public void unsetPublicServicePort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServicePort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port to be used in public API such as REST or SOAP proxy.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=699)
    public Map<String,Object> unsetPublicServicePort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServicePort, "");
        return attrs;
    }

    /**
     * Protocol to be used in public API such as REST or SOAP proxy.
     *
     * @return zimbraPublicServiceProtocol, or null if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=698)
    public String getPublicServiceProtocol() {
        return getAttr(Provisioning.A_zimbraPublicServiceProtocol, null, true);
    }

    /**
     * Protocol to be used in public API such as REST or SOAP proxy.
     *
     * @param zimbraPublicServiceProtocol new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=698)
    public void setPublicServiceProtocol(String zimbraPublicServiceProtocol) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServiceProtocol, zimbraPublicServiceProtocol);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Protocol to be used in public API such as REST or SOAP proxy.
     *
     * @param zimbraPublicServiceProtocol new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=698)
    public Map<String,Object> setPublicServiceProtocol(String zimbraPublicServiceProtocol, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServiceProtocol, zimbraPublicServiceProtocol);
        return attrs;
    }

    /**
     * Protocol to be used in public API such as REST or SOAP proxy.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=698)
    public void unsetPublicServiceProtocol() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServiceProtocol, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Protocol to be used in public API such as REST or SOAP proxy.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=698)
    public Map<String,Object> unsetPublicServiceProtocol(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPublicServiceProtocol, "");
        return attrs;
    }

    /**
     * The total size (in bytes) of the in-memory queue of conversations to
     * be purged for each data source
     *
     * @return zimbraPurgedConversationsQueueSize, or 1000000 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2017)
    public long getPurgedConversationsQueueSize() {
        return getLongAttr(Provisioning.A_zimbraPurgedConversationsQueueSize, 1000000L, true);
    }

    /**
     * The total size (in bytes) of the in-memory queue of conversations to
     * be purged for each data source
     *
     * @param zimbraPurgedConversationsQueueSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2017)
    public void setPurgedConversationsQueueSize(long zimbraPurgedConversationsQueueSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPurgedConversationsQueueSize, Long.toString(zimbraPurgedConversationsQueueSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The total size (in bytes) of the in-memory queue of conversations to
     * be purged for each data source
     *
     * @param zimbraPurgedConversationsQueueSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2017)
    public Map<String,Object> setPurgedConversationsQueueSize(long zimbraPurgedConversationsQueueSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPurgedConversationsQueueSize, Long.toString(zimbraPurgedConversationsQueueSize));
        return attrs;
    }

    /**
     * The total size (in bytes) of the in-memory queue of conversations to
     * be purged for each data source
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2017)
    public void unsetPurgedConversationsQueueSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPurgedConversationsQueueSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The total size (in bytes) of the in-memory queue of conversations to
     * be purged for each data source
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2017)
    public Map<String,Object> unsetPurgedConversationsQueueSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraPurgedConversationsQueueSize, "");
        return attrs;
    }

    /**
     * redolog rollover destination
     *
     * @return zimbraRedoLogArchiveDir, or "redolog/archive" if unset
     */
    @ZAttr(id=76)
    public String getRedoLogArchiveDir() {
        return getAttr(Provisioning.A_zimbraRedoLogArchiveDir, "redolog/archive", true);
    }

    /**
     * redolog rollover destination
     *
     * @param zimbraRedoLogArchiveDir new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=76)
    public void setRedoLogArchiveDir(String zimbraRedoLogArchiveDir) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogArchiveDir, zimbraRedoLogArchiveDir);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redolog rollover destination
     *
     * @param zimbraRedoLogArchiveDir new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=76)
    public Map<String,Object> setRedoLogArchiveDir(String zimbraRedoLogArchiveDir, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogArchiveDir, zimbraRedoLogArchiveDir);
        return attrs;
    }

    /**
     * redolog rollover destination
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=76)
    public void unsetRedoLogArchiveDir() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogArchiveDir, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redolog rollover destination
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=76)
    public Map<String,Object> unsetRedoLogArchiveDir(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogArchiveDir, "");
        return attrs;
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @return zimbraRedoLogCrashRecoveryLookbackSec, or 10 if unset
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public int getRedoLogCrashRecoveryLookbackSec() {
        return getIntAttr(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, 10, true);
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @param zimbraRedoLogCrashRecoveryLookbackSec new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public void setRedoLogCrashRecoveryLookbackSec(int zimbraRedoLogCrashRecoveryLookbackSec) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, Integer.toString(zimbraRedoLogCrashRecoveryLookbackSec));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @param zimbraRedoLogCrashRecoveryLookbackSec new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public Map<String,Object> setRedoLogCrashRecoveryLookbackSec(int zimbraRedoLogCrashRecoveryLookbackSec, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, Integer.toString(zimbraRedoLogCrashRecoveryLookbackSec));
        return attrs;
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public void unsetRedoLogCrashRecoveryLookbackSec() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how many seconds worth of committed redo ops to re-execute during
     * crash recovery; related to mysql parameter
     * innodb_flush_log_at_trx_commit=0
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA2
     */
    @ZAttr(id=1009)
    public Map<String,Object> unsetRedoLogCrashRecoveryLookbackSec(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogCrashRecoveryLookbackSec, "");
        return attrs;
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @return zimbraRedoLogDeleteOnRollover, or true if unset
     */
    @ZAttr(id=251)
    public boolean isRedoLogDeleteOnRollover() {
        return getBooleanAttr(Provisioning.A_zimbraRedoLogDeleteOnRollover, true, true);
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @param zimbraRedoLogDeleteOnRollover new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=251)
    public void setRedoLogDeleteOnRollover(boolean zimbraRedoLogDeleteOnRollover) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogDeleteOnRollover, zimbraRedoLogDeleteOnRollover ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @param zimbraRedoLogDeleteOnRollover new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=251)
    public Map<String,Object> setRedoLogDeleteOnRollover(boolean zimbraRedoLogDeleteOnRollover, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogDeleteOnRollover, zimbraRedoLogDeleteOnRollover ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=251)
    public void unsetRedoLogDeleteOnRollover() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogDeleteOnRollover, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether logs are delete on rollover or archived
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=251)
    public Map<String,Object> unsetRedoLogDeleteOnRollover(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogDeleteOnRollover, "");
        return attrs;
    }

    /**
     * whether redo logging is enabled
     *
     * @return zimbraRedoLogEnabled, or true if unset
     */
    @ZAttr(id=74)
    public boolean isRedoLogEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraRedoLogEnabled, true, true);
    }

    /**
     * whether redo logging is enabled
     *
     * @param zimbraRedoLogEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=74)
    public void setRedoLogEnabled(boolean zimbraRedoLogEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogEnabled, zimbraRedoLogEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether redo logging is enabled
     *
     * @param zimbraRedoLogEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=74)
    public Map<String,Object> setRedoLogEnabled(boolean zimbraRedoLogEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogEnabled, zimbraRedoLogEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether redo logging is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=74)
    public void unsetRedoLogEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether redo logging is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=74)
    public Map<String,Object> unsetRedoLogEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogEnabled, "");
        return attrs;
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @return zimbraRedoLogFsyncIntervalMS, or 10 if unset
     */
    @ZAttr(id=79)
    public int getRedoLogFsyncIntervalMS() {
        return getIntAttr(Provisioning.A_zimbraRedoLogFsyncIntervalMS, 10, true);
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @param zimbraRedoLogFsyncIntervalMS new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=79)
    public void setRedoLogFsyncIntervalMS(int zimbraRedoLogFsyncIntervalMS) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogFsyncIntervalMS, Integer.toString(zimbraRedoLogFsyncIntervalMS));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @param zimbraRedoLogFsyncIntervalMS new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=79)
    public Map<String,Object> setRedoLogFsyncIntervalMS(int zimbraRedoLogFsyncIntervalMS, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogFsyncIntervalMS, Integer.toString(zimbraRedoLogFsyncIntervalMS));
        return attrs;
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=79)
    public void unsetRedoLogFsyncIntervalMS() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogFsyncIntervalMS, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how frequently writes to redo log get fsynced to disk
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=79)
    public Map<String,Object> unsetRedoLogFsyncIntervalMS(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogFsyncIntervalMS, "");
        return attrs;
    }

    /**
     * name and location of the redolog file
     *
     * @return zimbraRedoLogLogPath, or "redolog/redo.log" if unset
     */
    @ZAttr(id=75)
    public String getRedoLogLogPath() {
        return getAttr(Provisioning.A_zimbraRedoLogLogPath, "redolog/redo.log", true);
    }

    /**
     * name and location of the redolog file
     *
     * @param zimbraRedoLogLogPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=75)
    public void setRedoLogLogPath(String zimbraRedoLogLogPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogLogPath, zimbraRedoLogLogPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name and location of the redolog file
     *
     * @param zimbraRedoLogLogPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=75)
    public Map<String,Object> setRedoLogLogPath(String zimbraRedoLogLogPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogLogPath, zimbraRedoLogLogPath);
        return attrs;
    }

    /**
     * name and location of the redolog file
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=75)
    public void unsetRedoLogLogPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogLogPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * name and location of the redolog file
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=75)
    public Map<String,Object> unsetRedoLogLogPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogLogPath, "");
        return attrs;
    }

    /**
     * provider class name for redo logging
     *
     * @return zimbraRedoLogProvider, or empty array if unset
     */
    @ZAttr(id=225)
    public String[] getRedoLogProvider() {
        return getMultiAttr(Provisioning.A_zimbraRedoLogProvider, true, true);
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=225)
    public void setRedoLogProvider(String[] zimbraRedoLogProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=225)
    public Map<String,Object> setRedoLogProvider(String[] zimbraRedoLogProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        return attrs;
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=225)
    public void addRedoLogProvider(String zimbraRedoLogProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=225)
    public Map<String,Object> addRedoLogProvider(String zimbraRedoLogProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        return attrs;
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=225)
    public void removeRedoLogProvider(String zimbraRedoLogProvider) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * provider class name for redo logging
     *
     * @param zimbraRedoLogProvider existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=225)
    public Map<String,Object> removeRedoLogProvider(String zimbraRedoLogProvider, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraRedoLogProvider, zimbraRedoLogProvider);
        return attrs;
    }

    /**
     * provider class name for redo logging
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=225)
    public void unsetRedoLogProvider() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogProvider, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * provider class name for redo logging
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=225)
    public Map<String,Object> unsetRedoLogProvider(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogProvider, "");
        return attrs;
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @return zimbraRedoLogRolloverFileSizeKB, or 1048576 if unset
     */
    @ZAttr(id=78)
    public int getRedoLogRolloverFileSizeKB() {
        return getIntAttr(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, 1048576, true);
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @param zimbraRedoLogRolloverFileSizeKB new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=78)
    public void setRedoLogRolloverFileSizeKB(int zimbraRedoLogRolloverFileSizeKB) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, Integer.toString(zimbraRedoLogRolloverFileSizeKB));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @param zimbraRedoLogRolloverFileSizeKB new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=78)
    public Map<String,Object> setRedoLogRolloverFileSizeKB(int zimbraRedoLogRolloverFileSizeKB, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, Integer.toString(zimbraRedoLogRolloverFileSizeKB));
        return attrs;
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=78)
    public void unsetRedoLogRolloverFileSizeKB() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redo.log file becomes eligible for rollover over when it goes over
     * this size
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=78)
    public Map<String,Object> unsetRedoLogRolloverFileSizeKB(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverFileSizeKB, "");
        return attrs;
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @return zimbraRedoLogRolloverHardMaxFileSizeKB, or 4194304 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public int getRedoLogRolloverHardMaxFileSizeKB() {
        return getIntAttr(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, 4194304, true);
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @param zimbraRedoLogRolloverHardMaxFileSizeKB new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public void setRedoLogRolloverHardMaxFileSizeKB(int zimbraRedoLogRolloverHardMaxFileSizeKB) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, Integer.toString(zimbraRedoLogRolloverHardMaxFileSizeKB));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @param zimbraRedoLogRolloverHardMaxFileSizeKB new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public Map<String,Object> setRedoLogRolloverHardMaxFileSizeKB(int zimbraRedoLogRolloverHardMaxFileSizeKB, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, Integer.toString(zimbraRedoLogRolloverHardMaxFileSizeKB));
        return attrs;
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public void unsetRedoLogRolloverHardMaxFileSizeKB() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * redo.log file rolls over when it goes over this size, even if it does
     * not meet the minimum file age requirement
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1021)
    public Map<String,Object> unsetRedoLogRolloverHardMaxFileSizeKB(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverHardMaxFileSizeKB, "");
        return attrs;
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @return zimbraRedoLogRolloverMinFileAge, or 60 if unset
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public int getRedoLogRolloverMinFileAge() {
        return getIntAttr(Provisioning.A_zimbraRedoLogRolloverMinFileAge, 60, true);
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @param zimbraRedoLogRolloverMinFileAge new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public void setRedoLogRolloverMinFileAge(int zimbraRedoLogRolloverMinFileAge) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverMinFileAge, Integer.toString(zimbraRedoLogRolloverMinFileAge));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @param zimbraRedoLogRolloverMinFileAge new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public Map<String,Object> setRedoLogRolloverMinFileAge(int zimbraRedoLogRolloverMinFileAge, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverMinFileAge, Integer.toString(zimbraRedoLogRolloverMinFileAge));
        return attrs;
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public void unsetRedoLogRolloverMinFileAge() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverMinFileAge, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * minimum age in minutes for redo.log file before it becomes eligible
     * for rollover based on size
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.17
     */
    @ZAttr(id=1020)
    public Map<String,Object> unsetRedoLogRolloverMinFileAge(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRedoLogRolloverMinFileAge, "");
        return attrs;
    }

    /**
     * This attribute is used to limit the amount of computation allowed when
     * matching regex expressions. For example as part of the IMAP LIST
     * command. Set to a higher value if legitimate IMAP list commands fail
     * throwing TooManyAccessesToMatchTargetException.
     *
     * @return zimbraRegexMaxAccessesWhenMatching, or 1000000 if unset
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1643)
    public int getRegexMaxAccessesWhenMatching() {
        return getIntAttr(Provisioning.A_zimbraRegexMaxAccessesWhenMatching, 1000000, true);
    }

    /**
     * This attribute is used to limit the amount of computation allowed when
     * matching regex expressions. For example as part of the IMAP LIST
     * command. Set to a higher value if legitimate IMAP list commands fail
     * throwing TooManyAccessesToMatchTargetException.
     *
     * @param zimbraRegexMaxAccessesWhenMatching new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1643)
    public void setRegexMaxAccessesWhenMatching(int zimbraRegexMaxAccessesWhenMatching) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRegexMaxAccessesWhenMatching, Integer.toString(zimbraRegexMaxAccessesWhenMatching));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used to limit the amount of computation allowed when
     * matching regex expressions. For example as part of the IMAP LIST
     * command. Set to a higher value if legitimate IMAP list commands fail
     * throwing TooManyAccessesToMatchTargetException.
     *
     * @param zimbraRegexMaxAccessesWhenMatching new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1643)
    public Map<String,Object> setRegexMaxAccessesWhenMatching(int zimbraRegexMaxAccessesWhenMatching, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRegexMaxAccessesWhenMatching, Integer.toString(zimbraRegexMaxAccessesWhenMatching));
        return attrs;
    }

    /**
     * This attribute is used to limit the amount of computation allowed when
     * matching regex expressions. For example as part of the IMAP LIST
     * command. Set to a higher value if legitimate IMAP list commands fail
     * throwing TooManyAccessesToMatchTargetException.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1643)
    public void unsetRegexMaxAccessesWhenMatching() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRegexMaxAccessesWhenMatching, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * This attribute is used to limit the amount of computation allowed when
     * matching regex expressions. For example as part of the IMAP LIST
     * command. Set to a higher value if legitimate IMAP list commands fail
     * throwing TooManyAccessesToMatchTargetException.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.8,8.5.0
     */
    @ZAttr(id=1643)
    public Map<String,Object> unsetRegexMaxAccessesWhenMatching(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRegexMaxAccessesWhenMatching, "");
        return attrs;
    }

    /**
     * port number on which the remote IMAP server should listen
     *
     * <p>Use getRemoteImapBindPortAsString to access value as a string.
     *
     * @see #getRemoteImapBindPortAsString()
     *
     * @return zimbraRemoteImapBindPort, or 8143 if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3015)
    public int getRemoteImapBindPort() {
        return getIntAttr(Provisioning.A_zimbraRemoteImapBindPort, 8143, true);
    }

    /**
     * port number on which the remote IMAP server should listen
     *
     * @return zimbraRemoteImapBindPort, or "8143" if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3015)
    public String getRemoteImapBindPortAsString() {
        return getAttr(Provisioning.A_zimbraRemoteImapBindPort, "8143", true);
    }

    /**
     * port number on which the remote IMAP server should listen
     *
     * @param zimbraRemoteImapBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3015)
    public void setRemoteImapBindPort(int zimbraRemoteImapBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapBindPort, Integer.toString(zimbraRemoteImapBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which the remote IMAP server should listen
     *
     * @param zimbraRemoteImapBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3015)
    public Map<String,Object> setRemoteImapBindPort(int zimbraRemoteImapBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapBindPort, Integer.toString(zimbraRemoteImapBindPort));
        return attrs;
    }

    /**
     * port number on which the remote IMAP server should listen
     *
     * @param zimbraRemoteImapBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3015)
    public void setRemoteImapBindPortAsString(String zimbraRemoteImapBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapBindPort, zimbraRemoteImapBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which the remote IMAP server should listen
     *
     * @param zimbraRemoteImapBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3015)
    public Map<String,Object> setRemoteImapBindPortAsString(String zimbraRemoteImapBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapBindPort, zimbraRemoteImapBindPort);
        return attrs;
    }

    /**
     * port number on which the remote IMAP server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3015)
    public void unsetRemoteImapBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which the remote IMAP server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3015)
    public Map<String,Object> unsetRemoteImapBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapBindPort, "");
        return attrs;
    }

    /**
     * port number on which the remote IMAP SSL server should listen
     *
     * <p>Use getRemoteImapSSLBindPortAsString to access value as a string.
     *
     * @see #getRemoteImapSSLBindPortAsString()
     *
     * @return zimbraRemoteImapSSLBindPort, or 8993 if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3016)
    public int getRemoteImapSSLBindPort() {
        return getIntAttr(Provisioning.A_zimbraRemoteImapSSLBindPort, 8993, true);
    }

    /**
     * port number on which the remote IMAP SSL server should listen
     *
     * @return zimbraRemoteImapSSLBindPort, or "8993" if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3016)
    public String getRemoteImapSSLBindPortAsString() {
        return getAttr(Provisioning.A_zimbraRemoteImapSSLBindPort, "8993", true);
    }

    /**
     * port number on which the remote IMAP SSL server should listen
     *
     * @param zimbraRemoteImapSSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3016)
    public void setRemoteImapSSLBindPort(int zimbraRemoteImapSSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLBindPort, Integer.toString(zimbraRemoteImapSSLBindPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which the remote IMAP SSL server should listen
     *
     * @param zimbraRemoteImapSSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3016)
    public Map<String,Object> setRemoteImapSSLBindPort(int zimbraRemoteImapSSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLBindPort, Integer.toString(zimbraRemoteImapSSLBindPort));
        return attrs;
    }

    /**
     * port number on which the remote IMAP SSL server should listen
     *
     * @param zimbraRemoteImapSSLBindPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3016)
    public void setRemoteImapSSLBindPortAsString(String zimbraRemoteImapSSLBindPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLBindPort, zimbraRemoteImapSSLBindPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which the remote IMAP SSL server should listen
     *
     * @param zimbraRemoteImapSSLBindPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3016)
    public Map<String,Object> setRemoteImapSSLBindPortAsString(String zimbraRemoteImapSSLBindPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLBindPort, zimbraRemoteImapSSLBindPort);
        return attrs;
    }

    /**
     * port number on which the remote IMAP SSL server should listen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3016)
    public void unsetRemoteImapSSLBindPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLBindPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * port number on which the remote IMAP SSL server should listen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3016)
    public Map<String,Object> unsetRemoteImapSSLBindPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLBindPort, "");
        return attrs;
    }

    /**
     * Controls if the remote IMAP SSL server is enabled for a given server.
     * See also zimbraRemoteImapServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @return zimbraRemoteImapSSLServerEnabled, or false if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3014)
    public boolean isRemoteImapSSLServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraRemoteImapSSLServerEnabled, false, true);
    }

    /**
     * Controls if the remote IMAP SSL server is enabled for a given server.
     * See also zimbraRemoteImapServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @param zimbraRemoteImapSSLServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3014)
    public void setRemoteImapSSLServerEnabled(boolean zimbraRemoteImapSSLServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLServerEnabled, zimbraRemoteImapSSLServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Controls if the remote IMAP SSL server is enabled for a given server.
     * See also zimbraRemoteImapServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @param zimbraRemoteImapSSLServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3014)
    public Map<String,Object> setRemoteImapSSLServerEnabled(boolean zimbraRemoteImapSSLServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLServerEnabled, zimbraRemoteImapSSLServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Controls if the remote IMAP SSL server is enabled for a given server.
     * See also zimbraRemoteImapServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3014)
    public void unsetRemoteImapSSLServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Controls if the remote IMAP SSL server is enabled for a given server.
     * See also zimbraRemoteImapServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3014)
    public Map<String,Object> unsetRemoteImapSSLServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapSSLServerEnabled, "");
        return attrs;
    }

    /**
     * Controls if the remote IMAP (non-SSL) service is enabled for a given
     * server. See also zimbraRemoteImapSSLServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @return zimbraRemoteImapServerEnabled, or false if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3013)
    public boolean isRemoteImapServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraRemoteImapServerEnabled, false, true);
    }

    /**
     * Controls if the remote IMAP (non-SSL) service is enabled for a given
     * server. See also zimbraRemoteImapSSLServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @param zimbraRemoteImapServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3013)
    public void setRemoteImapServerEnabled(boolean zimbraRemoteImapServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapServerEnabled, zimbraRemoteImapServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Controls if the remote IMAP (non-SSL) service is enabled for a given
     * server. See also zimbraRemoteImapSSLServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @param zimbraRemoteImapServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3013)
    public Map<String,Object> setRemoteImapServerEnabled(boolean zimbraRemoteImapServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapServerEnabled, zimbraRemoteImapServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Controls if the remote IMAP (non-SSL) service is enabled for a given
     * server. See also zimbraRemoteImapSSLServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3013)
    public void unsetRemoteImapServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Controls if the remote IMAP (non-SSL) service is enabled for a given
     * server. See also zimbraRemoteImapSSLServerEnabled and
     * zimbraReverseProxyUpstreamImapServers.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3013)
    public Map<String,Object> unsetRemoteImapServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteImapServerEnabled, "");
        return attrs;
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @return zimbraRemoteManagementCommand, or "/opt/zimbra/libexec/zmrcd" if unset
     */
    @ZAttr(id=336)
    public String getRemoteManagementCommand() {
        return getAttr(Provisioning.A_zimbraRemoteManagementCommand, "/opt/zimbra/libexec/zmrcd", true);
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @param zimbraRemoteManagementCommand new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=336)
    public void setRemoteManagementCommand(String zimbraRemoteManagementCommand) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementCommand, zimbraRemoteManagementCommand);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @param zimbraRemoteManagementCommand new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=336)
    public Map<String,Object> setRemoteManagementCommand(String zimbraRemoteManagementCommand, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementCommand, zimbraRemoteManagementCommand);
        return attrs;
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=336)
    public void unsetRemoteManagementCommand() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementCommand, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Path to remote management command to execute on this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=336)
    public Map<String,Object> unsetRemoteManagementCommand(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementCommand, "");
        return attrs;
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @return zimbraRemoteManagementPort, or 22 if unset
     */
    @ZAttr(id=339)
    public int getRemoteManagementPort() {
        return getIntAttr(Provisioning.A_zimbraRemoteManagementPort, 22, true);
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @param zimbraRemoteManagementPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=339)
    public void setRemoteManagementPort(int zimbraRemoteManagementPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPort, Integer.toString(zimbraRemoteManagementPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @param zimbraRemoteManagementPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=339)
    public Map<String,Object> setRemoteManagementPort(int zimbraRemoteManagementPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPort, Integer.toString(zimbraRemoteManagementPort));
        return attrs;
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=339)
    public void unsetRemoteManagementPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port on which remote management sshd listening on this server.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=339)
    public Map<String,Object> unsetRemoteManagementPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPort, "");
        return attrs;
    }

    /**
     * Private key this server should use to access another server
     *
     * @return zimbraRemoteManagementPrivateKeyPath, or "/opt/zimbra/.ssh/zimbra_identity" if unset
     */
    @ZAttr(id=338)
    public String getRemoteManagementPrivateKeyPath() {
        return getAttr(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, "/opt/zimbra/.ssh/zimbra_identity", true);
    }

    /**
     * Private key this server should use to access another server
     *
     * @param zimbraRemoteManagementPrivateKeyPath new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=338)
    public void setRemoteManagementPrivateKeyPath(String zimbraRemoteManagementPrivateKeyPath) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, zimbraRemoteManagementPrivateKeyPath);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Private key this server should use to access another server
     *
     * @param zimbraRemoteManagementPrivateKeyPath new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=338)
    public Map<String,Object> setRemoteManagementPrivateKeyPath(String zimbraRemoteManagementPrivateKeyPath, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, zimbraRemoteManagementPrivateKeyPath);
        return attrs;
    }

    /**
     * Private key this server should use to access another server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=338)
    public void unsetRemoteManagementPrivateKeyPath() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Private key this server should use to access another server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=338)
    public Map<String,Object> unsetRemoteManagementPrivateKeyPath(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementPrivateKeyPath, "");
        return attrs;
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @return zimbraRemoteManagementUser, or "zimbra" if unset
     */
    @ZAttr(id=337)
    public String getRemoteManagementUser() {
        return getAttr(Provisioning.A_zimbraRemoteManagementUser, "zimbra", true);
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @param zimbraRemoteManagementUser new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=337)
    public void setRemoteManagementUser(String zimbraRemoteManagementUser) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementUser, zimbraRemoteManagementUser);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @param zimbraRemoteManagementUser new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=337)
    public Map<String,Object> setRemoteManagementUser(String zimbraRemoteManagementUser, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementUser, zimbraRemoteManagementUser);
        return attrs;
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=337)
    public void unsetRemoteManagementUser() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementUser, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Login name of user allowed to execute remote management command
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=337)
    public Map<String,Object> unsetRemoteManagementUser(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraRemoteManagementUser, "");
        return attrs;
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @return zimbraResponseHeader, or empty array if unset
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public String[] getResponseHeader() {
        return getMultiAttr(Provisioning.A_zimbraResponseHeader, true, true);
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @param zimbraResponseHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public void setResponseHeader(String[] zimbraResponseHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResponseHeader, zimbraResponseHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @param zimbraResponseHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public Map<String,Object> setResponseHeader(String[] zimbraResponseHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResponseHeader, zimbraResponseHeader);
        return attrs;
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @param zimbraResponseHeader new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public void addResponseHeader(String zimbraResponseHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraResponseHeader, zimbraResponseHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @param zimbraResponseHeader new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public Map<String,Object> addResponseHeader(String zimbraResponseHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraResponseHeader, zimbraResponseHeader);
        return attrs;
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @param zimbraResponseHeader existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public void removeResponseHeader(String zimbraResponseHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraResponseHeader, zimbraResponseHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @param zimbraResponseHeader existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public Map<String,Object> removeResponseHeader(String zimbraResponseHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraResponseHeader, zimbraResponseHeader);
        return attrs;
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public void unsetResponseHeader() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResponseHeader, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom response headers. For example, can be used to add a P3P header
     * for user agents to understand the sites privacy policy. Note: the
     * value MUST be the entire header line (e.g. X-Foo: Bar).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.5
     */
    @ZAttr(id=1074)
    public Map<String,Object> unsetResponseHeader(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraResponseHeader, "");
        return attrs;
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [on, off]
     *
     * @return zimbraReverseProxyAcceptMutex, or ZAttrProvisioning.ReverseProxyAcceptMutex.on if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public ZAttrProvisioning.ReverseProxyAcceptMutex getReverseProxyAcceptMutex() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyAcceptMutex, true, true); return v == null ? ZAttrProvisioning.ReverseProxyAcceptMutex.on : ZAttrProvisioning.ReverseProxyAcceptMutex.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ReverseProxyAcceptMutex.on; }
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [on, off]
     *
     * @return zimbraReverseProxyAcceptMutex, or "on" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public String getReverseProxyAcceptMutexAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyAcceptMutex, "on", true);
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [on, off]
     *
     * @param zimbraReverseProxyAcceptMutex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public void setReverseProxyAcceptMutex(ZAttrProvisioning.ReverseProxyAcceptMutex zimbraReverseProxyAcceptMutex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, zimbraReverseProxyAcceptMutex.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [on, off]
     *
     * @param zimbraReverseProxyAcceptMutex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public Map<String,Object> setReverseProxyAcceptMutex(ZAttrProvisioning.ReverseProxyAcceptMutex zimbraReverseProxyAcceptMutex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, zimbraReverseProxyAcceptMutex.toString());
        return attrs;
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [on, off]
     *
     * @param zimbraReverseProxyAcceptMutex new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public void setReverseProxyAcceptMutexAsString(String zimbraReverseProxyAcceptMutex) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, zimbraReverseProxyAcceptMutex);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [on, off]
     *
     * @param zimbraReverseProxyAcceptMutex new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public Map<String,Object> setReverseProxyAcceptMutexAsString(String zimbraReverseProxyAcceptMutex, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, zimbraReverseProxyAcceptMutex);
        return attrs;
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [on, off]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public void unsetReverseProxyAcceptMutex() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - accept_mutex flag &#039;on&#039; for the reverse proxy. This is
     * default. off - accept_mutex flag &#039;off&#039; for the reverse
     * proxy. Turning it off will get much better distribution of client
     * connections between workers.
     *
     * <p>Valid values: [on, off]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1594)
    public Map<String,Object> unsetReverseProxyAcceptMutex(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAcceptMutex, "");
        return attrs;
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @return zimbraReverseProxyAdminEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public boolean isReverseProxyAdminEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyAdminEnabled, false, true);
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @param zimbraReverseProxyAdminEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public void setReverseProxyAdminEnabled(boolean zimbraReverseProxyAdminEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminEnabled, zimbraReverseProxyAdminEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @param zimbraReverseProxyAdminEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public Map<String,Object> setReverseProxyAdminEnabled(boolean zimbraReverseProxyAdminEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminEnabled, zimbraReverseProxyAdminEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public void unsetReverseProxyAdminEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * indicate whether to turn on admin console proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1321)
    public Map<String,Object> unsetReverseProxyAdminEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminEnabled, "");
        return attrs;
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @return zimbraReverseProxyAdminIPAddress, or empty array if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public String[] getReverseProxyAdminIPAddress() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyAdminIPAddress, true, true);
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @param zimbraReverseProxyAdminIPAddress new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public void setReverseProxyAdminIPAddress(String[] zimbraReverseProxyAdminIPAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminIPAddress, zimbraReverseProxyAdminIPAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @param zimbraReverseProxyAdminIPAddress new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public Map<String,Object> setReverseProxyAdminIPAddress(String[] zimbraReverseProxyAdminIPAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminIPAddress, zimbraReverseProxyAdminIPAddress);
        return attrs;
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @param zimbraReverseProxyAdminIPAddress new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public void addReverseProxyAdminIPAddress(String zimbraReverseProxyAdminIPAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyAdminIPAddress, zimbraReverseProxyAdminIPAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @param zimbraReverseProxyAdminIPAddress new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public Map<String,Object> addReverseProxyAdminIPAddress(String zimbraReverseProxyAdminIPAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyAdminIPAddress, zimbraReverseProxyAdminIPAddress);
        return attrs;
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @param zimbraReverseProxyAdminIPAddress existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public void removeReverseProxyAdminIPAddress(String zimbraReverseProxyAdminIPAddress) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyAdminIPAddress, zimbraReverseProxyAdminIPAddress);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @param zimbraReverseProxyAdminIPAddress existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public Map<String,Object> removeReverseProxyAdminIPAddress(String zimbraReverseProxyAdminIPAddress, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyAdminIPAddress, zimbraReverseProxyAdminIPAddress);
        return attrs;
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public void unsetReverseProxyAdminIPAddress() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminIPAddress, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Allowed reverse proxy IP addresses. Lookup servlet will only generate
     * authtokens if request was made from one of these IP addresses
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=697)
    public Map<String,Object> unsetReverseProxyAdminIPAddress(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminIPAddress, "");
        return attrs;
    }

    /**
     * the attribute that identifies the zimbra admin bind port
     *
     * @return zimbraReverseProxyAdminPortAttribute, or "zimbraAdminPort" if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=700)
    public String getReverseProxyAdminPortAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyAdminPortAttribute, "zimbraAdminPort", true);
    }

    /**
     * the attribute that identifies the zimbra admin bind port
     *
     * @param zimbraReverseProxyAdminPortAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=700)
    public void setReverseProxyAdminPortAttribute(String zimbraReverseProxyAdminPortAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminPortAttribute, zimbraReverseProxyAdminPortAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the attribute that identifies the zimbra admin bind port
     *
     * @param zimbraReverseProxyAdminPortAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=700)
    public Map<String,Object> setReverseProxyAdminPortAttribute(String zimbraReverseProxyAdminPortAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminPortAttribute, zimbraReverseProxyAdminPortAttribute);
        return attrs;
    }

    /**
     * the attribute that identifies the zimbra admin bind port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=700)
    public void unsetReverseProxyAdminPortAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminPortAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the attribute that identifies the zimbra admin bind port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=700)
    public Map<String,Object> unsetReverseProxyAdminPortAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAdminPortAttribute, "");
        return attrs;
    }

    /**
     * wait duration before nginx sending back the NO response for failed
     * imap/pop3 reverse proxy lookups. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyAuthWaitIntervalAsString to access value as a string.
     *
     * @see #getReverseProxyAuthWaitIntervalAsString()
     *
     * @return zimbraReverseProxyAuthWaitInterval in millseconds, or 10000 (10s)  if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=569)
    public long getReverseProxyAuthWaitInterval() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyAuthWaitInterval, 10000L, true);
    }

    /**
     * wait duration before nginx sending back the NO response for failed
     * imap/pop3 reverse proxy lookups. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyAuthWaitInterval, or "10s" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=569)
    public String getReverseProxyAuthWaitIntervalAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyAuthWaitInterval, "10s", true);
    }

    /**
     * wait duration before nginx sending back the NO response for failed
     * imap/pop3 reverse proxy lookups. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyAuthWaitInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=569)
    public void setReverseProxyAuthWaitInterval(String zimbraReverseProxyAuthWaitInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAuthWaitInterval, zimbraReverseProxyAuthWaitInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * wait duration before nginx sending back the NO response for failed
     * imap/pop3 reverse proxy lookups. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyAuthWaitInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=569)
    public Map<String,Object> setReverseProxyAuthWaitInterval(String zimbraReverseProxyAuthWaitInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAuthWaitInterval, zimbraReverseProxyAuthWaitInterval);
        return attrs;
    }

    /**
     * wait duration before nginx sending back the NO response for failed
     * imap/pop3 reverse proxy lookups. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=569)
    public void unsetReverseProxyAuthWaitInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAuthWaitInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * wait duration before nginx sending back the NO response for failed
     * imap/pop3 reverse proxy lookups. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=569)
    public Map<String,Object> unsetReverseProxyAuthWaitInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAuthWaitInterval, "");
        return attrs;
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @return zimbraReverseProxyAvailableLookupTargets, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public String[] getReverseProxyAvailableLookupTargets() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, true, true);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public void setReverseProxyAvailableLookupTargets(String[] zimbraReverseProxyAvailableLookupTargets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public Map<String,Object> setReverseProxyAvailableLookupTargets(String[] zimbraReverseProxyAvailableLookupTargets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        return attrs;
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public void addReverseProxyAvailableLookupTargets(String zimbraReverseProxyAvailableLookupTargets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public Map<String,Object> addReverseProxyAvailableLookupTargets(String zimbraReverseProxyAvailableLookupTargets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        return attrs;
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public void removeReverseProxyAvailableLookupTargets(String zimbraReverseProxyAvailableLookupTargets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param zimbraReverseProxyAvailableLookupTargets existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public Map<String,Object> removeReverseProxyAvailableLookupTargets(String zimbraReverseProxyAvailableLookupTargets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyAvailableLookupTargets, zimbraReverseProxyAvailableLookupTargets);
        return attrs;
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public void unsetReverseProxyAvailableLookupTargets() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the proxy lookup handlers list. Proxy
     * will only use the servers specified here to do the lookup. Leaving
     * empty means using all the servers whose zimbraReverseProxyLookupTarget
     * is TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1379)
    public Map<String,Object> unsetReverseProxyAvailableLookupTargets(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyAvailableLookupTargets, "");
        return attrs;
    }

    /**
     * time interval that an entry cached by NGINX will remain in the cache.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxyCacheEntryTTLAsString to access value as a string.
     *
     * @see #getReverseProxyCacheEntryTTLAsString()
     *
     * @return zimbraReverseProxyCacheEntryTTL in millseconds, or 3600000 (1h)  if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=732)
    public long getReverseProxyCacheEntryTTL() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyCacheEntryTTL, 3600000L, true);
    }

    /**
     * time interval that an entry cached by NGINX will remain in the cache.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxyCacheEntryTTL, or "1h" if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=732)
    public String getReverseProxyCacheEntryTTLAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyCacheEntryTTL, "1h", true);
    }

    /**
     * time interval that an entry cached by NGINX will remain in the cache.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyCacheEntryTTL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=732)
    public void setReverseProxyCacheEntryTTL(String zimbraReverseProxyCacheEntryTTL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheEntryTTL, zimbraReverseProxyCacheEntryTTL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval that an entry cached by NGINX will remain in the cache.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyCacheEntryTTL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=732)
    public Map<String,Object> setReverseProxyCacheEntryTTL(String zimbraReverseProxyCacheEntryTTL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheEntryTTL, zimbraReverseProxyCacheEntryTTL);
        return attrs;
    }

    /**
     * time interval that an entry cached by NGINX will remain in the cache.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=732)
    public void unsetReverseProxyCacheEntryTTL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheEntryTTL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval that an entry cached by NGINX will remain in the cache.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=732)
    public Map<String,Object> unsetReverseProxyCacheEntryTTL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheEntryTTL, "");
        return attrs;
    }

    /**
     * time interval that NGINX proxy will wait for a cache result, before
     * considering the result as a cache miss. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyCacheFetchTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyCacheFetchTimeoutAsString()
     *
     * @return zimbraReverseProxyCacheFetchTimeout in millseconds, or 3000 (3s)  if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=731)
    public long getReverseProxyCacheFetchTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyCacheFetchTimeout, 3000L, true);
    }

    /**
     * time interval that NGINX proxy will wait for a cache result, before
     * considering the result as a cache miss. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyCacheFetchTimeout, or "3s" if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=731)
    public String getReverseProxyCacheFetchTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyCacheFetchTimeout, "3s", true);
    }

    /**
     * time interval that NGINX proxy will wait for a cache result, before
     * considering the result as a cache miss. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyCacheFetchTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=731)
    public void setReverseProxyCacheFetchTimeout(String zimbraReverseProxyCacheFetchTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheFetchTimeout, zimbraReverseProxyCacheFetchTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval that NGINX proxy will wait for a cache result, before
     * considering the result as a cache miss. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyCacheFetchTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=731)
    public Map<String,Object> setReverseProxyCacheFetchTimeout(String zimbraReverseProxyCacheFetchTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheFetchTimeout, zimbraReverseProxyCacheFetchTimeout);
        return attrs;
    }

    /**
     * time interval that NGINX proxy will wait for a cache result, before
     * considering the result as a cache miss. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=731)
    public void unsetReverseProxyCacheFetchTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheFetchTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval that NGINX proxy will wait for a cache result, before
     * considering the result as a cache miss. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=731)
    public Map<String,Object> unsetReverseProxyCacheFetchTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheFetchTimeout, "");
        return attrs;
    }

    /**
     * time interval that NGINX proxy will wait before attempting to
     * re-establish a connection to a memcache server that disconnected. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxyCacheReconnectIntervalAsString to access value as a string.
     *
     * @see #getReverseProxyCacheReconnectIntervalAsString()
     *
     * @return zimbraReverseProxyCacheReconnectInterval in millseconds, or 60000 (1m)  if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=730)
    public long getReverseProxyCacheReconnectInterval() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyCacheReconnectInterval, 60000L, true);
    }

    /**
     * time interval that NGINX proxy will wait before attempting to
     * re-establish a connection to a memcache server that disconnected. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxyCacheReconnectInterval, or "1m" if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=730)
    public String getReverseProxyCacheReconnectIntervalAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyCacheReconnectInterval, "1m", true);
    }

    /**
     * time interval that NGINX proxy will wait before attempting to
     * re-establish a connection to a memcache server that disconnected. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyCacheReconnectInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=730)
    public void setReverseProxyCacheReconnectInterval(String zimbraReverseProxyCacheReconnectInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheReconnectInterval, zimbraReverseProxyCacheReconnectInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval that NGINX proxy will wait before attempting to
     * re-establish a connection to a memcache server that disconnected. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyCacheReconnectInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=730)
    public Map<String,Object> setReverseProxyCacheReconnectInterval(String zimbraReverseProxyCacheReconnectInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheReconnectInterval, zimbraReverseProxyCacheReconnectInterval);
        return attrs;
    }

    /**
     * time interval that NGINX proxy will wait before attempting to
     * re-establish a connection to a memcache server that disconnected. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=730)
    public void unsetReverseProxyCacheReconnectInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheReconnectInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time interval that NGINX proxy will wait before attempting to
     * re-establish a connection to a memcache server that disconnected. Must
     * be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=730)
    public Map<String,Object> unsetReverseProxyCacheReconnectInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyCacheReconnectInterval, "");
        return attrs;
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @return zimbraReverseProxyClientCertCA, or null if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public String getReverseProxyClientCertCA() {
        return getAttr(Provisioning.A_zimbraReverseProxyClientCertCA, null, true);
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @param zimbraReverseProxyClientCertCA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public void setReverseProxyClientCertCA(String zimbraReverseProxyClientCertCA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertCA, zimbraReverseProxyClientCertCA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @param zimbraReverseProxyClientCertCA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public Map<String,Object> setReverseProxyClientCertCA(String zimbraReverseProxyClientCertCA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertCA, zimbraReverseProxyClientCertCA);
        return attrs;
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public void unsetReverseProxyClientCertCA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertCA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CA certificate for authenticating client certificates in nginx proxy
     * (https only)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1201)
    public Map<String,Object> unsetReverseProxyClientCertCA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertCA, "");
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [on, off, optional]
     *
     * @return zimbraReverseProxyClientCertMode, or ZAttrProvisioning.ReverseProxyClientCertMode.off if unset and/or has invalid value
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public ZAttrProvisioning.ReverseProxyClientCertMode getReverseProxyClientCertMode() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyClientCertMode, true, true); return v == null ? ZAttrProvisioning.ReverseProxyClientCertMode.off : ZAttrProvisioning.ReverseProxyClientCertMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ReverseProxyClientCertMode.off; }
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [on, off, optional]
     *
     * @return zimbraReverseProxyClientCertMode, or "off" if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public String getReverseProxyClientCertModeAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyClientCertMode, "off", true);
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [on, off, optional]
     *
     * @param zimbraReverseProxyClientCertMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public void setReverseProxyClientCertMode(ZAttrProvisioning.ReverseProxyClientCertMode zimbraReverseProxyClientCertMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, zimbraReverseProxyClientCertMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [on, off, optional]
     *
     * @param zimbraReverseProxyClientCertMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public Map<String,Object> setReverseProxyClientCertMode(ZAttrProvisioning.ReverseProxyClientCertMode zimbraReverseProxyClientCertMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, zimbraReverseProxyClientCertMode.toString());
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [on, off, optional]
     *
     * @param zimbraReverseProxyClientCertMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public void setReverseProxyClientCertModeAsString(String zimbraReverseProxyClientCertMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, zimbraReverseProxyClientCertMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [on, off, optional]
     *
     * @param zimbraReverseProxyClientCertMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public Map<String,Object> setReverseProxyClientCertModeAsString(String zimbraReverseProxyClientCertMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, zimbraReverseProxyClientCertMode);
        return attrs;
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [on, off, optional]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public void unsetReverseProxyClientCertMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable authentication via X.509 Client Certificate in nginx proxy
     * (https only)
     *
     * <p>Valid values: [on, off, optional]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1200)
    public Map<String,Object> unsetReverseProxyClientCertMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyClientCertMode, "");
        return attrs;
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxyConnectTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyConnectTimeoutAsString()
     *
     * @return zimbraReverseProxyConnectTimeout in millseconds, or 120000 (120000ms)  if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public long getReverseProxyConnectTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyConnectTimeout, 120000L, true);
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxyConnectTimeout, or "120000ms" if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public String getReverseProxyConnectTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyConnectTimeout, "120000ms", true);
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyConnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public void setReverseProxyConnectTimeout(String zimbraReverseProxyConnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyConnectTimeout, zimbraReverseProxyConnectTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyConnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public Map<String,Object> setReverseProxyConnectTimeout(String zimbraReverseProxyConnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyConnectTimeout, zimbraReverseProxyConnectTimeout);
        return attrs;
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public void unsetReverseProxyConnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyConnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which NGINX mail proxy will disconnect while
     * establishing an upstream IMAP/POP connection. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=797)
    public Map<String,Object> unsetReverseProxyConnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyConnectTimeout, "");
        return attrs;
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @return zimbraReverseProxyDefaultRealm, or null if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public String getReverseProxyDefaultRealm() {
        return getAttr(Provisioning.A_zimbraReverseProxyDefaultRealm, null, true);
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @param zimbraReverseProxyDefaultRealm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public void setReverseProxyDefaultRealm(String zimbraReverseProxyDefaultRealm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDefaultRealm, zimbraReverseProxyDefaultRealm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @param zimbraReverseProxyDefaultRealm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public Map<String,Object> setReverseProxyDefaultRealm(String zimbraReverseProxyDefaultRealm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDefaultRealm, zimbraReverseProxyDefaultRealm);
        return attrs;
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public void unsetReverseProxyDefaultRealm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDefaultRealm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The default realm that will be used by NGINX mail proxy, when the
     * realm is not specified in GSSAPI Authentication
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=703)
    public Map<String,Object> unsetReverseProxyDefaultRealm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDefaultRealm, "");
        return attrs;
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @return zimbraReverseProxyDnsLookupInServerEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public boolean isReverseProxyDnsLookupInServerEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, true, true);
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @param zimbraReverseProxyDnsLookupInServerEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public void setReverseProxyDnsLookupInServerEnabled(boolean zimbraReverseProxyDnsLookupInServerEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, zimbraReverseProxyDnsLookupInServerEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @param zimbraReverseProxyDnsLookupInServerEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public Map<String,Object> setReverseProxyDnsLookupInServerEnabled(boolean zimbraReverseProxyDnsLookupInServerEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, zimbraReverseProxyDnsLookupInServerEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public void unsetReverseProxyDnsLookupInServerEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Control whether force the server side do the DNS lookup and send the
     * result IP back to proxy. If set false, the raw address configured
     * (e.g. zimbraMailHost) is directly sent to proxy.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1384)
    public Map<String,Object> unsetReverseProxyDnsLookupInServerEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDnsLookupInServerEnabled, "");
        return attrs;
    }

    /**
     * LDAP attribute that contains domain name for the domain
     *
     * @return zimbraReverseProxyDomainNameAttribute, or "zimbraDomainName" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=547)
    public String getReverseProxyDomainNameAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyDomainNameAttribute, "zimbraDomainName", true);
    }

    /**
     * LDAP attribute that contains domain name for the domain
     *
     * @param zimbraReverseProxyDomainNameAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=547)
    public void setReverseProxyDomainNameAttribute(String zimbraReverseProxyDomainNameAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameAttribute, zimbraReverseProxyDomainNameAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute that contains domain name for the domain
     *
     * @param zimbraReverseProxyDomainNameAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=547)
    public Map<String,Object> setReverseProxyDomainNameAttribute(String zimbraReverseProxyDomainNameAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameAttribute, zimbraReverseProxyDomainNameAttribute);
        return attrs;
    }

    /**
     * LDAP attribute that contains domain name for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=547)
    public void unsetReverseProxyDomainNameAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute that contains domain name for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=547)
    public Map<String,Object> unsetReverseProxyDomainNameAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameAttribute, "");
        return attrs;
    }

    /**
     * LDAP query to find a domain
     *
     * @return zimbraReverseProxyDomainNameQuery, or "(&(zimbraVirtualIPAddress=${IPADDR})(objectClass=zimbraDomain))" if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=545)
    public String getReverseProxyDomainNameQuery() {
        return getAttr(Provisioning.A_zimbraReverseProxyDomainNameQuery, "(&(zimbraVirtualIPAddress=${IPADDR})(objectClass=zimbraDomain))", true);
    }

    /**
     * LDAP query to find a domain
     *
     * @param zimbraReverseProxyDomainNameQuery new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=545)
    public void setReverseProxyDomainNameQuery(String zimbraReverseProxyDomainNameQuery) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameQuery, zimbraReverseProxyDomainNameQuery);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP query to find a domain
     *
     * @param zimbraReverseProxyDomainNameQuery new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=545)
    public Map<String,Object> setReverseProxyDomainNameQuery(String zimbraReverseProxyDomainNameQuery, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameQuery, zimbraReverseProxyDomainNameQuery);
        return attrs;
    }

    /**
     * LDAP query to find a domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=545)
    public void unsetReverseProxyDomainNameQuery() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameQuery, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP query to find a domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=545)
    public Map<String,Object> unsetReverseProxyDomainNameQuery(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameQuery, "");
        return attrs;
    }

    /**
     * search base for zimbraReverseProxyDomainNameQuery
     *
     * @return zimbraReverseProxyDomainNameSearchBase, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=546)
    public String getReverseProxyDomainNameSearchBase() {
        return getAttr(Provisioning.A_zimbraReverseProxyDomainNameSearchBase, null, true);
    }

    /**
     * search base for zimbraReverseProxyDomainNameQuery
     *
     * @param zimbraReverseProxyDomainNameSearchBase new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=546)
    public void setReverseProxyDomainNameSearchBase(String zimbraReverseProxyDomainNameSearchBase) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameSearchBase, zimbraReverseProxyDomainNameSearchBase);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * search base for zimbraReverseProxyDomainNameQuery
     *
     * @param zimbraReverseProxyDomainNameSearchBase new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=546)
    public Map<String,Object> setReverseProxyDomainNameSearchBase(String zimbraReverseProxyDomainNameSearchBase, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameSearchBase, zimbraReverseProxyDomainNameSearchBase);
        return attrs;
    }

    /**
     * search base for zimbraReverseProxyDomainNameQuery
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=546)
    public void unsetReverseProxyDomainNameSearchBase() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameSearchBase, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * search base for zimbraReverseProxyDomainNameQuery
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=546)
    public Map<String,Object> unsetReverseProxyDomainNameSearchBase(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyDomainNameSearchBase, "");
        return attrs;
    }

    /**
     * the URL of customized proxy error handler. If set, when errors happen
     * in proxy, proxy will redirect to this URL with two paras - err: error
     * code; up: the addr of upstream server connecting to which the error
     * happens
     *
     * @return zimbraReverseProxyErrorHandlerURL, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1332)
    public String getReverseProxyErrorHandlerURL() {
        return getAttr(Provisioning.A_zimbraReverseProxyErrorHandlerURL, null, true);
    }

    /**
     * the URL of customized proxy error handler. If set, when errors happen
     * in proxy, proxy will redirect to this URL with two paras - err: error
     * code; up: the addr of upstream server connecting to which the error
     * happens
     *
     * @param zimbraReverseProxyErrorHandlerURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1332)
    public void setReverseProxyErrorHandlerURL(String zimbraReverseProxyErrorHandlerURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyErrorHandlerURL, zimbraReverseProxyErrorHandlerURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the URL of customized proxy error handler. If set, when errors happen
     * in proxy, proxy will redirect to this URL with two paras - err: error
     * code; up: the addr of upstream server connecting to which the error
     * happens
     *
     * @param zimbraReverseProxyErrorHandlerURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1332)
    public Map<String,Object> setReverseProxyErrorHandlerURL(String zimbraReverseProxyErrorHandlerURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyErrorHandlerURL, zimbraReverseProxyErrorHandlerURL);
        return attrs;
    }

    /**
     * the URL of customized proxy error handler. If set, when errors happen
     * in proxy, proxy will redirect to this URL with two paras - err: error
     * code; up: the addr of upstream server connecting to which the error
     * happens
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1332)
    public void unsetReverseProxyErrorHandlerURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyErrorHandlerURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the URL of customized proxy error handler. If set, when errors happen
     * in proxy, proxy will redirect to this URL with two paras - err: error
     * code; up: the addr of upstream server connecting to which the error
     * happens
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1332)
    public Map<String,Object> unsetReverseProxyErrorHandlerURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyErrorHandlerURL, "");
        return attrs;
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [on, off]
     *
     * @return zimbraReverseProxyExactServerVersionCheck, or ZAttrProvisioning.ReverseProxyExactServerVersionCheck.on if unset and/or has invalid value
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public ZAttrProvisioning.ReverseProxyExactServerVersionCheck getReverseProxyExactServerVersionCheck() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, true, true); return v == null ? ZAttrProvisioning.ReverseProxyExactServerVersionCheck.on : ZAttrProvisioning.ReverseProxyExactServerVersionCheck.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ReverseProxyExactServerVersionCheck.on; }
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [on, off]
     *
     * @return zimbraReverseProxyExactServerVersionCheck, or "on" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public String getReverseProxyExactServerVersionCheckAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, "on", true);
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [on, off]
     *
     * @param zimbraReverseProxyExactServerVersionCheck new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public void setReverseProxyExactServerVersionCheck(ZAttrProvisioning.ReverseProxyExactServerVersionCheck zimbraReverseProxyExactServerVersionCheck) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, zimbraReverseProxyExactServerVersionCheck.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [on, off]
     *
     * @param zimbraReverseProxyExactServerVersionCheck new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public Map<String,Object> setReverseProxyExactServerVersionCheck(ZAttrProvisioning.ReverseProxyExactServerVersionCheck zimbraReverseProxyExactServerVersionCheck, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, zimbraReverseProxyExactServerVersionCheck.toString());
        return attrs;
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [on, off]
     *
     * @param zimbraReverseProxyExactServerVersionCheck new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public void setReverseProxyExactServerVersionCheckAsString(String zimbraReverseProxyExactServerVersionCheck) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, zimbraReverseProxyExactServerVersionCheck);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [on, off]
     *
     * @param zimbraReverseProxyExactServerVersionCheck new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public Map<String,Object> setReverseProxyExactServerVersionCheckAsString(String zimbraReverseProxyExactServerVersionCheck, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, zimbraReverseProxyExactServerVersionCheck);
        return attrs;
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [on, off]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public void unsetReverseProxyExactServerVersionCheck() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether nginx will match exact server version against the version
     * received in the client request (in ZM_AUTH_TOKEN). Defaults to on.
     * Setting this to off will make nginx compare only the major and minor
     * server versions (eg. all 8.5.x will be treated same by nginx)
     *
     * <p>Valid values: [on, off]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1616)
    public Map<String,Object> unsetReverseProxyExactServerVersionCheck(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExactServerVersionCheck, "");
        return attrs;
    }

    /**
     * During migrations Nginx lookup handler rewrites non-qualified username
     * to fully qualified breaking proxy to external legacy mail platform.
     * When zimbraReverseProxyUseExternalRoute is set to TRUE and
     * zimbraReverseProxyExternalRouteIncludeOriginalAuthusername is set to
     * FALSE nginx lookup handler drops the domain name from the userAccount
     * and returns just the username.
     *
     * @return zimbraReverseProxyExternalRouteIncludeOriginalAuthusername, or false if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1454)
    public boolean isReverseProxyExternalRouteIncludeOriginalAuthusername() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyExternalRouteIncludeOriginalAuthusername, false, true);
    }

    /**
     * During migrations Nginx lookup handler rewrites non-qualified username
     * to fully qualified breaking proxy to external legacy mail platform.
     * When zimbraReverseProxyUseExternalRoute is set to TRUE and
     * zimbraReverseProxyExternalRouteIncludeOriginalAuthusername is set to
     * FALSE nginx lookup handler drops the domain name from the userAccount
     * and returns just the username.
     *
     * @param zimbraReverseProxyExternalRouteIncludeOriginalAuthusername new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1454)
    public void setReverseProxyExternalRouteIncludeOriginalAuthusername(boolean zimbraReverseProxyExternalRouteIncludeOriginalAuthusername) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExternalRouteIncludeOriginalAuthusername, zimbraReverseProxyExternalRouteIncludeOriginalAuthusername ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * During migrations Nginx lookup handler rewrites non-qualified username
     * to fully qualified breaking proxy to external legacy mail platform.
     * When zimbraReverseProxyUseExternalRoute is set to TRUE and
     * zimbraReverseProxyExternalRouteIncludeOriginalAuthusername is set to
     * FALSE nginx lookup handler drops the domain name from the userAccount
     * and returns just the username.
     *
     * @param zimbraReverseProxyExternalRouteIncludeOriginalAuthusername new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1454)
    public Map<String,Object> setReverseProxyExternalRouteIncludeOriginalAuthusername(boolean zimbraReverseProxyExternalRouteIncludeOriginalAuthusername, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExternalRouteIncludeOriginalAuthusername, zimbraReverseProxyExternalRouteIncludeOriginalAuthusername ? TRUE : FALSE);
        return attrs;
    }

    /**
     * During migrations Nginx lookup handler rewrites non-qualified username
     * to fully qualified breaking proxy to external legacy mail platform.
     * When zimbraReverseProxyUseExternalRoute is set to TRUE and
     * zimbraReverseProxyExternalRouteIncludeOriginalAuthusername is set to
     * FALSE nginx lookup handler drops the domain name from the userAccount
     * and returns just the username.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1454)
    public void unsetReverseProxyExternalRouteIncludeOriginalAuthusername() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExternalRouteIncludeOriginalAuthusername, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * During migrations Nginx lookup handler rewrites non-qualified username
     * to fully qualified breaking proxy to external legacy mail platform.
     * When zimbraReverseProxyUseExternalRoute is set to TRUE and
     * zimbraReverseProxyExternalRouteIncludeOriginalAuthusername is set to
     * FALSE nginx lookup handler drops the domain name from the userAccount
     * and returns just the username.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1454)
    public Map<String,Object> unsetReverseProxyExternalRouteIncludeOriginalAuthusername(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyExternalRouteIncludeOriginalAuthusername, "");
        return attrs;
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @return zimbraReverseProxyGenConfigPerVirtualHostname, or true if unset
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public boolean isReverseProxyGenConfigPerVirtualHostname() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, true, true);
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @param zimbraReverseProxyGenConfigPerVirtualHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public void setReverseProxyGenConfigPerVirtualHostname(boolean zimbraReverseProxyGenConfigPerVirtualHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, zimbraReverseProxyGenConfigPerVirtualHostname ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @param zimbraReverseProxyGenConfigPerVirtualHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public Map<String,Object> setReverseProxyGenConfigPerVirtualHostname(boolean zimbraReverseProxyGenConfigPerVirtualHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, zimbraReverseProxyGenConfigPerVirtualHostname ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public void unsetReverseProxyGenConfigPerVirtualHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Control whether to generate per virtual hostname nginx configuration.
     * This would be helpful when multiple virtual host names are defined,
     * but they are actually share the same configuration (like ssl cert,
     * client CA, ...). This attr has to be set as &quot;TRUE&quot; to enable
     * the features like cert per domain.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.0
     */
    @ZAttr(id=1374)
    public Map<String,Object> unsetReverseProxyGenConfigPerVirtualHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyGenConfigPerVirtualHostname, "");
        return attrs;
    }

    /**
     * Whether to enable HTTP proxy
     *
     * @return zimbraReverseProxyHttpEnabled, or true if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=628)
    public boolean isReverseProxyHttpEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyHttpEnabled, true, true);
    }

    /**
     * Whether to enable HTTP proxy
     *
     * @param zimbraReverseProxyHttpEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=628)
    public void setReverseProxyHttpEnabled(boolean zimbraReverseProxyHttpEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpEnabled, zimbraReverseProxyHttpEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable HTTP proxy
     *
     * @param zimbraReverseProxyHttpEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=628)
    public Map<String,Object> setReverseProxyHttpEnabled(boolean zimbraReverseProxyHttpEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpEnabled, zimbraReverseProxyHttpEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable HTTP proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=628)
    public void unsetReverseProxyHttpEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable HTTP proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=628)
    public Map<String,Object> unsetReverseProxyHttpEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpEnabled, "");
        return attrs;
    }

    /**
     * attribute that contains http bind port
     *
     * @return zimbraReverseProxyHttpPortAttribute, or "zimbraMailPort" if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=632)
    public String getReverseProxyHttpPortAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyHttpPortAttribute, "zimbraMailPort", true);
    }

    /**
     * attribute that contains http bind port
     *
     * @param zimbraReverseProxyHttpPortAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=632)
    public void setReverseProxyHttpPortAttribute(String zimbraReverseProxyHttpPortAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpPortAttribute, zimbraReverseProxyHttpPortAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains http bind port
     *
     * @param zimbraReverseProxyHttpPortAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=632)
    public Map<String,Object> setReverseProxyHttpPortAttribute(String zimbraReverseProxyHttpPortAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpPortAttribute, zimbraReverseProxyHttpPortAttribute);
        return attrs;
    }

    /**
     * attribute that contains http bind port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=632)
    public void unsetReverseProxyHttpPortAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpPortAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains http bind port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=632)
    public Map<String,Object> unsetReverseProxyHttpPortAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpPortAttribute, "");
        return attrs;
    }

    /**
     * attribute that contains http ssl bind port
     *
     * @return zimbraReverseProxyHttpSSLPortAttribute, or "zimbraMailSSLPort" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1359)
    public String getReverseProxyHttpSSLPortAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyHttpSSLPortAttribute, "zimbraMailSSLPort", true);
    }

    /**
     * attribute that contains http ssl bind port
     *
     * @param zimbraReverseProxyHttpSSLPortAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1359)
    public void setReverseProxyHttpSSLPortAttribute(String zimbraReverseProxyHttpSSLPortAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpSSLPortAttribute, zimbraReverseProxyHttpSSLPortAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains http ssl bind port
     *
     * @param zimbraReverseProxyHttpSSLPortAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1359)
    public Map<String,Object> setReverseProxyHttpSSLPortAttribute(String zimbraReverseProxyHttpSSLPortAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpSSLPortAttribute, zimbraReverseProxyHttpSSLPortAttribute);
        return attrs;
    }

    /**
     * attribute that contains http ssl bind port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1359)
    public void unsetReverseProxyHttpSSLPortAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpSSLPortAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains http ssl bind port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1359)
    public Map<String,Object> unsetReverseProxyHttpSSLPortAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyHttpSSLPortAttribute, "");
        return attrs;
    }

    /**
     * Sets the upper limit on logins from a remote IP via IMAP to this proxy
     * server after which login is rejected with an IMAP bye response. This
     * counter is cumulative for all users that appear to the proxy to be
     * logging in from the same IP address and IMAP/IMAPS protocol. If
     * multiple users appear to the proxy to be logging in from the same IP
     * address (usual with NATing), then each of the different users login
     * will contribute to increasing the hit counter for the IP address and
     * IMAP combination, and when the counter eventually exceeds the limit,
     * then the connections from that IP address will be throttled for
     * IMAP/IMAPS only. Therefore, all IMAP users from the same IP will
     * contribute to (and be affected by) this counter. If this value is set
     * to 0, then the value of zimbraReverseProxyIPLoginLimit will be used to
     * determine possible throttling behavior for the IMAP protocol.
     *
     * @return zimbraReverseProxyIPLoginImapLimit, or 0 if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2996)
    public int getReverseProxyIPLoginImapLimit() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyIPLoginImapLimit, 0, true);
    }

    /**
     * Sets the upper limit on logins from a remote IP via IMAP to this proxy
     * server after which login is rejected with an IMAP bye response. This
     * counter is cumulative for all users that appear to the proxy to be
     * logging in from the same IP address and IMAP/IMAPS protocol. If
     * multiple users appear to the proxy to be logging in from the same IP
     * address (usual with NATing), then each of the different users login
     * will contribute to increasing the hit counter for the IP address and
     * IMAP combination, and when the counter eventually exceeds the limit,
     * then the connections from that IP address will be throttled for
     * IMAP/IMAPS only. Therefore, all IMAP users from the same IP will
     * contribute to (and be affected by) this counter. If this value is set
     * to 0, then the value of zimbraReverseProxyIPLoginLimit will be used to
     * determine possible throttling behavior for the IMAP protocol.
     *
     * @param zimbraReverseProxyIPLoginImapLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2996)
    public void setReverseProxyIPLoginImapLimit(int zimbraReverseProxyIPLoginImapLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginImapLimit, Integer.toString(zimbraReverseProxyIPLoginImapLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the upper limit on logins from a remote IP via IMAP to this proxy
     * server after which login is rejected with an IMAP bye response. This
     * counter is cumulative for all users that appear to the proxy to be
     * logging in from the same IP address and IMAP/IMAPS protocol. If
     * multiple users appear to the proxy to be logging in from the same IP
     * address (usual with NATing), then each of the different users login
     * will contribute to increasing the hit counter for the IP address and
     * IMAP combination, and when the counter eventually exceeds the limit,
     * then the connections from that IP address will be throttled for
     * IMAP/IMAPS only. Therefore, all IMAP users from the same IP will
     * contribute to (and be affected by) this counter. If this value is set
     * to 0, then the value of zimbraReverseProxyIPLoginLimit will be used to
     * determine possible throttling behavior for the IMAP protocol.
     *
     * @param zimbraReverseProxyIPLoginImapLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2996)
    public Map<String,Object> setReverseProxyIPLoginImapLimit(int zimbraReverseProxyIPLoginImapLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginImapLimit, Integer.toString(zimbraReverseProxyIPLoginImapLimit));
        return attrs;
    }

    /**
     * Sets the upper limit on logins from a remote IP via IMAP to this proxy
     * server after which login is rejected with an IMAP bye response. This
     * counter is cumulative for all users that appear to the proxy to be
     * logging in from the same IP address and IMAP/IMAPS protocol. If
     * multiple users appear to the proxy to be logging in from the same IP
     * address (usual with NATing), then each of the different users login
     * will contribute to increasing the hit counter for the IP address and
     * IMAP combination, and when the counter eventually exceeds the limit,
     * then the connections from that IP address will be throttled for
     * IMAP/IMAPS only. Therefore, all IMAP users from the same IP will
     * contribute to (and be affected by) this counter. If this value is set
     * to 0, then the value of zimbraReverseProxyIPLoginLimit will be used to
     * determine possible throttling behavior for the IMAP protocol.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2996)
    public void unsetReverseProxyIPLoginImapLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginImapLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the upper limit on logins from a remote IP via IMAP to this proxy
     * server after which login is rejected with an IMAP bye response. This
     * counter is cumulative for all users that appear to the proxy to be
     * logging in from the same IP address and IMAP/IMAPS protocol. If
     * multiple users appear to the proxy to be logging in from the same IP
     * address (usual with NATing), then each of the different users login
     * will contribute to increasing the hit counter for the IP address and
     * IMAP combination, and when the counter eventually exceeds the limit,
     * then the connections from that IP address will be throttled for
     * IMAP/IMAPS only. Therefore, all IMAP users from the same IP will
     * contribute to (and be affected by) this counter. If this value is set
     * to 0, then the value of zimbraReverseProxyIPLoginLimit will be used to
     * determine possible throttling behavior for the IMAP protocol.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2996)
    public Map<String,Object> unsetReverseProxyIPLoginImapLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginImapLimit, "");
        return attrs;
    }

    /**
     * Sets the time-to-live for the hit counter for IP based IMAP login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @return zimbraReverseProxyIPLoginImapLimitTime, or 3600 if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2997)
    public int getReverseProxyIPLoginImapLimitTime() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyIPLoginImapLimitTime, 3600, true);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based IMAP login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param zimbraReverseProxyIPLoginImapLimitTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2997)
    public void setReverseProxyIPLoginImapLimitTime(int zimbraReverseProxyIPLoginImapLimitTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginImapLimitTime, Integer.toString(zimbraReverseProxyIPLoginImapLimitTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based IMAP login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param zimbraReverseProxyIPLoginImapLimitTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2997)
    public Map<String,Object> setReverseProxyIPLoginImapLimitTime(int zimbraReverseProxyIPLoginImapLimitTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginImapLimitTime, Integer.toString(zimbraReverseProxyIPLoginImapLimitTime));
        return attrs;
    }

    /**
     * Sets the time-to-live for the hit counter for IP based IMAP login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2997)
    public void unsetReverseProxyIPLoginImapLimitTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginImapLimitTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based IMAP login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2997)
    public Map<String,Object> unsetReverseProxyIPLoginImapLimitTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginImapLimitTime, "");
        return attrs;
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP or IMAP to
     * this proxy server after which login is rejected with an appropriate
     * protocol specific bye response. This counter is cumulative for all
     * users that appear to the proxy to be logging in from the same IP
     * address. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing) and protocol, then each of the
     * different users login will contribute to increasing the hit counter
     * for that IP address and protocol combination, and when the counter
     * eventually exceeds the limit, then the connections from that IP
     * address will be throttled for that protocol. Therefore, all users from
     * the same IP will contribute to (and be affected by) this counter.
     * Logins using all protocols (POP3/POP3S/IMAP/IMAPS) will affect this
     * counter but each protocol will have it&#039;s own limit counter. If
     * this value is set to 0, then no limiting will take place for any IP
     * unless it is overridden with zimbraReverseProxyIPLoginPop3Limit or
     * zimbraReverseProxyIPLoginImapLimit. Note: If the protocol specific
     * configuration items (zimbraReverseProxyIPLoginPop3Limit,
     * zimbraReverseProxyIPLoginImapLimit) are set to a non-zero positive
     * value then this option will not apply to those protocols.
     *
     * @return zimbraReverseProxyIPLoginLimit, or 0 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=622)
    public int getReverseProxyIPLoginLimit() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyIPLoginLimit, 0, true);
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP or IMAP to
     * this proxy server after which login is rejected with an appropriate
     * protocol specific bye response. This counter is cumulative for all
     * users that appear to the proxy to be logging in from the same IP
     * address. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing) and protocol, then each of the
     * different users login will contribute to increasing the hit counter
     * for that IP address and protocol combination, and when the counter
     * eventually exceeds the limit, then the connections from that IP
     * address will be throttled for that protocol. Therefore, all users from
     * the same IP will contribute to (and be affected by) this counter.
     * Logins using all protocols (POP3/POP3S/IMAP/IMAPS) will affect this
     * counter but each protocol will have it&#039;s own limit counter. If
     * this value is set to 0, then no limiting will take place for any IP
     * unless it is overridden with zimbraReverseProxyIPLoginPop3Limit or
     * zimbraReverseProxyIPLoginImapLimit. Note: If the protocol specific
     * configuration items (zimbraReverseProxyIPLoginPop3Limit,
     * zimbraReverseProxyIPLoginImapLimit) are set to a non-zero positive
     * value then this option will not apply to those protocols.
     *
     * @param zimbraReverseProxyIPLoginLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=622)
    public void setReverseProxyIPLoginLimit(int zimbraReverseProxyIPLoginLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginLimit, Integer.toString(zimbraReverseProxyIPLoginLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP or IMAP to
     * this proxy server after which login is rejected with an appropriate
     * protocol specific bye response. This counter is cumulative for all
     * users that appear to the proxy to be logging in from the same IP
     * address. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing) and protocol, then each of the
     * different users login will contribute to increasing the hit counter
     * for that IP address and protocol combination, and when the counter
     * eventually exceeds the limit, then the connections from that IP
     * address will be throttled for that protocol. Therefore, all users from
     * the same IP will contribute to (and be affected by) this counter.
     * Logins using all protocols (POP3/POP3S/IMAP/IMAPS) will affect this
     * counter but each protocol will have it&#039;s own limit counter. If
     * this value is set to 0, then no limiting will take place for any IP
     * unless it is overridden with zimbraReverseProxyIPLoginPop3Limit or
     * zimbraReverseProxyIPLoginImapLimit. Note: If the protocol specific
     * configuration items (zimbraReverseProxyIPLoginPop3Limit,
     * zimbraReverseProxyIPLoginImapLimit) are set to a non-zero positive
     * value then this option will not apply to those protocols.
     *
     * @param zimbraReverseProxyIPLoginLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=622)
    public Map<String,Object> setReverseProxyIPLoginLimit(int zimbraReverseProxyIPLoginLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginLimit, Integer.toString(zimbraReverseProxyIPLoginLimit));
        return attrs;
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP or IMAP to
     * this proxy server after which login is rejected with an appropriate
     * protocol specific bye response. This counter is cumulative for all
     * users that appear to the proxy to be logging in from the same IP
     * address. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing) and protocol, then each of the
     * different users login will contribute to increasing the hit counter
     * for that IP address and protocol combination, and when the counter
     * eventually exceeds the limit, then the connections from that IP
     * address will be throttled for that protocol. Therefore, all users from
     * the same IP will contribute to (and be affected by) this counter.
     * Logins using all protocols (POP3/POP3S/IMAP/IMAPS) will affect this
     * counter but each protocol will have it&#039;s own limit counter. If
     * this value is set to 0, then no limiting will take place for any IP
     * unless it is overridden with zimbraReverseProxyIPLoginPop3Limit or
     * zimbraReverseProxyIPLoginImapLimit. Note: If the protocol specific
     * configuration items (zimbraReverseProxyIPLoginPop3Limit,
     * zimbraReverseProxyIPLoginImapLimit) are set to a non-zero positive
     * value then this option will not apply to those protocols.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=622)
    public void unsetReverseProxyIPLoginLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP or IMAP to
     * this proxy server after which login is rejected with an appropriate
     * protocol specific bye response. This counter is cumulative for all
     * users that appear to the proxy to be logging in from the same IP
     * address. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing) and protocol, then each of the
     * different users login will contribute to increasing the hit counter
     * for that IP address and protocol combination, and when the counter
     * eventually exceeds the limit, then the connections from that IP
     * address will be throttled for that protocol. Therefore, all users from
     * the same IP will contribute to (and be affected by) this counter.
     * Logins using all protocols (POP3/POP3S/IMAP/IMAPS) will affect this
     * counter but each protocol will have it&#039;s own limit counter. If
     * this value is set to 0, then no limiting will take place for any IP
     * unless it is overridden with zimbraReverseProxyIPLoginPop3Limit or
     * zimbraReverseProxyIPLoginImapLimit. Note: If the protocol specific
     * configuration items (zimbraReverseProxyIPLoginPop3Limit,
     * zimbraReverseProxyIPLoginImapLimit) are set to a non-zero positive
     * value then this option will not apply to those protocols.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=622)
    public Map<String,Object> unsetReverseProxyIPLoginLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginLimit, "");
        return attrs;
    }

    /**
     * Sets the time-to-live for the hit counter for IP based login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @return zimbraReverseProxyIPLoginLimitTime, or 3600 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=623)
    public int getReverseProxyIPLoginLimitTime() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyIPLoginLimitTime, 3600, true);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param zimbraReverseProxyIPLoginLimitTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=623)
    public void setReverseProxyIPLoginLimitTime(int zimbraReverseProxyIPLoginLimitTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginLimitTime, Integer.toString(zimbraReverseProxyIPLoginLimitTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param zimbraReverseProxyIPLoginLimitTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=623)
    public Map<String,Object> setReverseProxyIPLoginLimitTime(int zimbraReverseProxyIPLoginLimitTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginLimitTime, Integer.toString(zimbraReverseProxyIPLoginLimitTime));
        return attrs;
    }

    /**
     * Sets the time-to-live for the hit counter for IP based login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=623)
    public void unsetReverseProxyIPLoginLimitTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginLimitTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=623)
    public Map<String,Object> unsetReverseProxyIPLoginLimitTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginLimitTime, "");
        return attrs;
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP3 to this proxy
     * server after which login is rejected with an appropriate POP3 bye
     * response. This counter is cumulative for all users that appear to the
     * proxy to be logging in from the same IP address for the POP3/POP3S
     * protocol. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing), then each of the different
     * users login will contribute to increasing the hit counter for that IP
     * address, and when the counter eventually exceeds the limit, then the
     * connections from that IP address will be throttled for POP3/POP3S.
     * Therefore, all users from the same IP will contribute to (and be
     * affected by) this counter. If this value is set to 0, then the value
     * of zimbraReverseProxyIPLoginLimit will be used to determine possible
     * throttling behavior for the POP3 protocol.
     *
     * @return zimbraReverseProxyIPLoginPop3Limit, or 0 if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2998)
    public int getReverseProxyIPLoginPop3Limit() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyIPLoginPop3Limit, 0, true);
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP3 to this proxy
     * server after which login is rejected with an appropriate POP3 bye
     * response. This counter is cumulative for all users that appear to the
     * proxy to be logging in from the same IP address for the POP3/POP3S
     * protocol. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing), then each of the different
     * users login will contribute to increasing the hit counter for that IP
     * address, and when the counter eventually exceeds the limit, then the
     * connections from that IP address will be throttled for POP3/POP3S.
     * Therefore, all users from the same IP will contribute to (and be
     * affected by) this counter. If this value is set to 0, then the value
     * of zimbraReverseProxyIPLoginLimit will be used to determine possible
     * throttling behavior for the POP3 protocol.
     *
     * @param zimbraReverseProxyIPLoginPop3Limit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2998)
    public void setReverseProxyIPLoginPop3Limit(int zimbraReverseProxyIPLoginPop3Limit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginPop3Limit, Integer.toString(zimbraReverseProxyIPLoginPop3Limit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP3 to this proxy
     * server after which login is rejected with an appropriate POP3 bye
     * response. This counter is cumulative for all users that appear to the
     * proxy to be logging in from the same IP address for the POP3/POP3S
     * protocol. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing), then each of the different
     * users login will contribute to increasing the hit counter for that IP
     * address, and when the counter eventually exceeds the limit, then the
     * connections from that IP address will be throttled for POP3/POP3S.
     * Therefore, all users from the same IP will contribute to (and be
     * affected by) this counter. If this value is set to 0, then the value
     * of zimbraReverseProxyIPLoginLimit will be used to determine possible
     * throttling behavior for the POP3 protocol.
     *
     * @param zimbraReverseProxyIPLoginPop3Limit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2998)
    public Map<String,Object> setReverseProxyIPLoginPop3Limit(int zimbraReverseProxyIPLoginPop3Limit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginPop3Limit, Integer.toString(zimbraReverseProxyIPLoginPop3Limit));
        return attrs;
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP3 to this proxy
     * server after which login is rejected with an appropriate POP3 bye
     * response. This counter is cumulative for all users that appear to the
     * proxy to be logging in from the same IP address for the POP3/POP3S
     * protocol. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing), then each of the different
     * users login will contribute to increasing the hit counter for that IP
     * address, and when the counter eventually exceeds the limit, then the
     * connections from that IP address will be throttled for POP3/POP3S.
     * Therefore, all users from the same IP will contribute to (and be
     * affected by) this counter. If this value is set to 0, then the value
     * of zimbraReverseProxyIPLoginLimit will be used to determine possible
     * throttling behavior for the POP3 protocol.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2998)
    public void unsetReverseProxyIPLoginPop3Limit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginPop3Limit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the upper limit on logins from a remote IP via POP3 to this proxy
     * server after which login is rejected with an appropriate POP3 bye
     * response. This counter is cumulative for all users that appear to the
     * proxy to be logging in from the same IP address for the POP3/POP3S
     * protocol. If multiple users appear to the proxy to be logging in from
     * the same IP address (usual with NATing), then each of the different
     * users login will contribute to increasing the hit counter for that IP
     * address, and when the counter eventually exceeds the limit, then the
     * connections from that IP address will be throttled for POP3/POP3S.
     * Therefore, all users from the same IP will contribute to (and be
     * affected by) this counter. If this value is set to 0, then the value
     * of zimbraReverseProxyIPLoginLimit will be used to determine possible
     * throttling behavior for the POP3 protocol.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2998)
    public Map<String,Object> unsetReverseProxyIPLoginPop3Limit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginPop3Limit, "");
        return attrs;
    }

    /**
     * Sets the time-to-live for the hit counter for IP based POP3 login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @return zimbraReverseProxyIPLoginPop3LimitTime, or 3600 if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2999)
    public int getReverseProxyIPLoginPop3LimitTime() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyIPLoginPop3LimitTime, 3600, true);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based POP3 login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param zimbraReverseProxyIPLoginPop3LimitTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2999)
    public void setReverseProxyIPLoginPop3LimitTime(int zimbraReverseProxyIPLoginPop3LimitTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginPop3LimitTime, Integer.toString(zimbraReverseProxyIPLoginPop3LimitTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based POP3 login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param zimbraReverseProxyIPLoginPop3LimitTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2999)
    public Map<String,Object> setReverseProxyIPLoginPop3LimitTime(int zimbraReverseProxyIPLoginPop3LimitTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginPop3LimitTime, Integer.toString(zimbraReverseProxyIPLoginPop3LimitTime));
        return attrs;
    }

    /**
     * Sets the time-to-live for the hit counter for IP based POP3 login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2999)
    public void unsetReverseProxyIPLoginPop3LimitTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginPop3LimitTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for the hit counter for IP based POP3 login
     * throttling. If time is set to 3600 and limit is set to 1000, then it
     * means that NGINX should not allow more than 1000 users to log in via
     * the proxy from the same IP, within the time interval of an hour. The
     * semantics for such a configuration would then be: allow maximum 1000
     * users per hour from any given IP address.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=2999)
    public Map<String,Object> unsetReverseProxyIPLoginPop3LimitTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPLoginPop3LimitTime, "");
        return attrs;
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @return zimbraReverseProxyIPThrottleWhitelist, or empty array if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public String[] getReverseProxyIPThrottleWhitelist() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, true, true);
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @param zimbraReverseProxyIPThrottleWhitelist new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public void setReverseProxyIPThrottleWhitelist(String[] zimbraReverseProxyIPThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, zimbraReverseProxyIPThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @param zimbraReverseProxyIPThrottleWhitelist new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public Map<String,Object> setReverseProxyIPThrottleWhitelist(String[] zimbraReverseProxyIPThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, zimbraReverseProxyIPThrottleWhitelist);
        return attrs;
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @param zimbraReverseProxyIPThrottleWhitelist new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public void addReverseProxyIPThrottleWhitelist(String zimbraReverseProxyIPThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, zimbraReverseProxyIPThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @param zimbraReverseProxyIPThrottleWhitelist new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public Map<String,Object> addReverseProxyIPThrottleWhitelist(String zimbraReverseProxyIPThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, zimbraReverseProxyIPThrottleWhitelist);
        return attrs;
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @param zimbraReverseProxyIPThrottleWhitelist existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public void removeReverseProxyIPThrottleWhitelist(String zimbraReverseProxyIPThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, zimbraReverseProxyIPThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @param zimbraReverseProxyIPThrottleWhitelist existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public Map<String,Object> removeReverseProxyIPThrottleWhitelist(String zimbraReverseProxyIPThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, zimbraReverseProxyIPThrottleWhitelist);
        return attrs;
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public void unsetReverseProxyIPThrottleWhitelist() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Client IP/IPRange whitelist for exclusion from IP throttling. Value
     * may be either an IP or an IPRange in CIDR notation e.g:192.168.1.0/24.
     * IPV6 is supported as well.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3000)
    public Map<String,Object> unsetReverseProxyIPThrottleWhitelist(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPThrottleWhitelist, "");
        return attrs;
    }

    /**
     * Sets the time-to-live for mail_whitelist_ip_ttl in nginx. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxyIPThrottleWhitelistTimeAsString to access value as a string.
     *
     * @see #getReverseProxyIPThrottleWhitelistTimeAsString()
     *
     * @return zimbraReverseProxyIPThrottleWhitelistTime in millseconds, or 300000 (300s)  if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3007)
    public long getReverseProxyIPThrottleWhitelistTime() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyIPThrottleWhitelistTime, 300000L, true);
    }

    /**
     * Sets the time-to-live for mail_whitelist_ip_ttl in nginx. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxyIPThrottleWhitelistTime, or "300s" if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3007)
    public String getReverseProxyIPThrottleWhitelistTimeAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyIPThrottleWhitelistTime, "300s", true);
    }

    /**
     * Sets the time-to-live for mail_whitelist_ip_ttl in nginx. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyIPThrottleWhitelistTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3007)
    public void setReverseProxyIPThrottleWhitelistTime(String zimbraReverseProxyIPThrottleWhitelistTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPThrottleWhitelistTime, zimbraReverseProxyIPThrottleWhitelistTime);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for mail_whitelist_ip_ttl in nginx. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyIPThrottleWhitelistTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3007)
    public Map<String,Object> setReverseProxyIPThrottleWhitelistTime(String zimbraReverseProxyIPThrottleWhitelistTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPThrottleWhitelistTime, zimbraReverseProxyIPThrottleWhitelistTime);
        return attrs;
    }

    /**
     * Sets the time-to-live for mail_whitelist_ip_ttl in nginx. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3007)
    public void unsetReverseProxyIPThrottleWhitelistTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPThrottleWhitelistTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for mail_whitelist_ip_ttl in nginx. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3007)
    public Map<String,Object> unsetReverseProxyIPThrottleWhitelistTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIPThrottleWhitelistTime, "");
        return attrs;
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @return zimbraReverseProxyImapEnabledCapability, or empty array if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public String[] getReverseProxyImapEnabledCapability() {
        String[] value = getMultiAttr(Provisioning.A_zimbraReverseProxyImapEnabledCapability, true, true); return value.length > 0 ? value : new String[] {"IMAP4rev1","ACL","BINARY","CATENATE","CHILDREN","CONDSTORE","ENABLE","ESEARCH","ESORT","I18NLEVEL=1","ID","IDLE","LIST-EXTENDED","LIST-STATUS","LITERAL+","MULTIAPPEND","NAMESPACE","QRESYNC","QUOTA","RIGHTS=ektx","SASL-IR","SEARCHRES","SORT","THREAD=ORDEREDSUBJECT","UIDPLUS","UNSELECT","WITHIN","XLIST"};
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public void setReverseProxyImapEnabledCapability(String[] zimbraReverseProxyImapEnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public Map<String,Object> setReverseProxyImapEnabledCapability(String[] zimbraReverseProxyImapEnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public void addReverseProxyImapEnabledCapability(String zimbraReverseProxyImapEnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public Map<String,Object> addReverseProxyImapEnabledCapability(String zimbraReverseProxyImapEnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public void removeReverseProxyImapEnabledCapability(String zimbraReverseProxyImapEnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param zimbraReverseProxyImapEnabledCapability existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public Map<String,Object> removeReverseProxyImapEnabledCapability(String zimbraReverseProxyImapEnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyImapEnabledCapability, zimbraReverseProxyImapEnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public void unsetReverseProxyImapEnabledCapability() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapEnabledCapability, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy imap capabilities
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=719)
    public Map<String,Object> unsetReverseProxyImapEnabledCapability(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapEnabledCapability, "");
        return attrs;
    }

    /**
     * Whether to expose version on Proxy IMAP banner
     *
     * @return zimbraReverseProxyImapExposeVersionOnBanner, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=713)
    public boolean isReverseProxyImapExposeVersionOnBanner() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyImapExposeVersionOnBanner, false, true);
    }

    /**
     * Whether to expose version on Proxy IMAP banner
     *
     * @param zimbraReverseProxyImapExposeVersionOnBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=713)
    public void setReverseProxyImapExposeVersionOnBanner(boolean zimbraReverseProxyImapExposeVersionOnBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapExposeVersionOnBanner, zimbraReverseProxyImapExposeVersionOnBanner ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on Proxy IMAP banner
     *
     * @param zimbraReverseProxyImapExposeVersionOnBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=713)
    public Map<String,Object> setReverseProxyImapExposeVersionOnBanner(boolean zimbraReverseProxyImapExposeVersionOnBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapExposeVersionOnBanner, zimbraReverseProxyImapExposeVersionOnBanner ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to expose version on Proxy IMAP banner
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=713)
    public void unsetReverseProxyImapExposeVersionOnBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapExposeVersionOnBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on Proxy IMAP banner
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=713)
    public Map<String,Object> unsetReverseProxyImapExposeVersionOnBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapExposeVersionOnBanner, "");
        return attrs;
    }

    /**
     * attribute that contains imap bind port
     *
     * @return zimbraReverseProxyImapPortAttribute, or "zimbraImapBindPort" if unset
     */
    @ZAttr(id=479)
    public String getReverseProxyImapPortAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyImapPortAttribute, "zimbraImapBindPort", true);
    }

    /**
     * attribute that contains imap bind port
     *
     * @param zimbraReverseProxyImapPortAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=479)
    public void setReverseProxyImapPortAttribute(String zimbraReverseProxyImapPortAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapPortAttribute, zimbraReverseProxyImapPortAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains imap bind port
     *
     * @param zimbraReverseProxyImapPortAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=479)
    public Map<String,Object> setReverseProxyImapPortAttribute(String zimbraReverseProxyImapPortAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapPortAttribute, zimbraReverseProxyImapPortAttribute);
        return attrs;
    }

    /**
     * attribute that contains imap bind port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=479)
    public void unsetReverseProxyImapPortAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapPortAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains imap bind port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=479)
    public Map<String,Object> unsetReverseProxyImapPortAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapPortAttribute, "");
        return attrs;
    }

    /**
     * attribute that contains imap bind port for SSL
     *
     * @return zimbraReverseProxyImapSSLPortAttribute, or "zimbraImapSSLBindPort" if unset
     */
    @ZAttr(id=480)
    public String getReverseProxyImapSSLPortAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyImapSSLPortAttribute, "zimbraImapSSLBindPort", true);
    }

    /**
     * attribute that contains imap bind port for SSL
     *
     * @param zimbraReverseProxyImapSSLPortAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=480)
    public void setReverseProxyImapSSLPortAttribute(String zimbraReverseProxyImapSSLPortAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSSLPortAttribute, zimbraReverseProxyImapSSLPortAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains imap bind port for SSL
     *
     * @param zimbraReverseProxyImapSSLPortAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=480)
    public Map<String,Object> setReverseProxyImapSSLPortAttribute(String zimbraReverseProxyImapSSLPortAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSSLPortAttribute, zimbraReverseProxyImapSSLPortAttribute);
        return attrs;
    }

    /**
     * attribute that contains imap bind port for SSL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=480)
    public void unsetReverseProxyImapSSLPortAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSSLPortAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains imap bind port for SSL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=480)
    public Map<String,Object> unsetReverseProxyImapSSLPortAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSSLPortAttribute, "");
        return attrs;
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for reverse proxy
     *
     * @return zimbraReverseProxyImapSaslGssapiEnabled, or false if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=643)
    public boolean isReverseProxyImapSaslGssapiEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyImapSaslGssapiEnabled, false, true);
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for reverse proxy
     *
     * @param zimbraReverseProxyImapSaslGssapiEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=643)
    public void setReverseProxyImapSaslGssapiEnabled(boolean zimbraReverseProxyImapSaslGssapiEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslGssapiEnabled, zimbraReverseProxyImapSaslGssapiEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for reverse proxy
     *
     * @param zimbraReverseProxyImapSaslGssapiEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=643)
    public Map<String,Object> setReverseProxyImapSaslGssapiEnabled(boolean zimbraReverseProxyImapSaslGssapiEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslGssapiEnabled, zimbraReverseProxyImapSaslGssapiEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for reverse proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=643)
    public void unsetReverseProxyImapSaslGssapiEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslGssapiEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SASL GSSAPI is enabled for reverse proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=643)
    public Map<String,Object> unsetReverseProxyImapSaslGssapiEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslGssapiEnabled, "");
        return attrs;
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @return zimbraReverseProxyImapSaslPlainEnabled, or true if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public boolean isReverseProxyImapSaslPlainEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, true, true);
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @param zimbraReverseProxyImapSaslPlainEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public void setReverseProxyImapSaslPlainEnabled(boolean zimbraReverseProxyImapSaslPlainEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, zimbraReverseProxyImapSaslPlainEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @param zimbraReverseProxyImapSaslPlainEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public Map<String,Object> setReverseProxyImapSaslPlainEnabled(boolean zimbraReverseProxyImapSaslPlainEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, zimbraReverseProxyImapSaslPlainEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public void unsetReverseProxyImapSaslPlainEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether IMAP SASL PLAIN is enabled for reverse proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=728)
    public Map<String,Object> unsetReverseProxyImapSaslPlainEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapSaslPlainEnabled, "");
        return attrs;
    }

    /**
     * on - on the plain IMAP port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @return zimbraReverseProxyImapStartTlsMode, or ZAttrProvisioning.ReverseProxyImapStartTlsMode.only if unset and/or has invalid value
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=641)
    public ZAttrProvisioning.ReverseProxyImapStartTlsMode getReverseProxyImapStartTlsMode() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyImapStartTlsMode, true, true); return v == null ? ZAttrProvisioning.ReverseProxyImapStartTlsMode.only : ZAttrProvisioning.ReverseProxyImapStartTlsMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ReverseProxyImapStartTlsMode.only; }
    }

    /**
     * on - on the plain IMAP port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @return zimbraReverseProxyImapStartTlsMode, or "only" if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=641)
    public String getReverseProxyImapStartTlsModeAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyImapStartTlsMode, "only", true);
    }

    /**
     * on - on the plain IMAP port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param zimbraReverseProxyImapStartTlsMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=641)
    public void setReverseProxyImapStartTlsMode(ZAttrProvisioning.ReverseProxyImapStartTlsMode zimbraReverseProxyImapStartTlsMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapStartTlsMode, zimbraReverseProxyImapStartTlsMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - on the plain IMAP port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param zimbraReverseProxyImapStartTlsMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=641)
    public Map<String,Object> setReverseProxyImapStartTlsMode(ZAttrProvisioning.ReverseProxyImapStartTlsMode zimbraReverseProxyImapStartTlsMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapStartTlsMode, zimbraReverseProxyImapStartTlsMode.toString());
        return attrs;
    }

    /**
     * on - on the plain IMAP port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param zimbraReverseProxyImapStartTlsMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=641)
    public void setReverseProxyImapStartTlsModeAsString(String zimbraReverseProxyImapStartTlsMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapStartTlsMode, zimbraReverseProxyImapStartTlsMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - on the plain IMAP port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param zimbraReverseProxyImapStartTlsMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=641)
    public Map<String,Object> setReverseProxyImapStartTlsModeAsString(String zimbraReverseProxyImapStartTlsMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapStartTlsMode, zimbraReverseProxyImapStartTlsMode);
        return attrs;
    }

    /**
     * on - on the plain IMAP port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=641)
    public void unsetReverseProxyImapStartTlsMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapStartTlsMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - on the plain IMAP port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=641)
    public Map<String,Object> unsetReverseProxyImapStartTlsMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyImapStartTlsMode, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyInactivityTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyInactivityTimeoutAsString()
     *
     * @return zimbraReverseProxyInactivityTimeout in millseconds, or 3600000 (1h)  if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public long getReverseProxyInactivityTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyInactivityTimeout, 3600000L, true);
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyInactivityTimeout, or "1h" if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public String getReverseProxyInactivityTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyInactivityTimeout, "1h", true);
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyInactivityTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public void setReverseProxyInactivityTimeout(String zimbraReverseProxyInactivityTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyInactivityTimeout, zimbraReverseProxyInactivityTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyInactivityTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public Map<String,Object> setReverseProxyInactivityTimeout(String zimbraReverseProxyInactivityTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyInactivityTimeout, zimbraReverseProxyInactivityTimeout);
        return attrs;
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public void unsetReverseProxyInactivityTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyInactivityTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.0.0. deprecated in favor of local config
     * &quot;imap_max_idle_time&quot;, &quot;pop3_max_idle_time&quot;,
     * &quot;imap_authenticated_max_idle_time&quot; in bug 59685. Orig desc:
     * Time interval after which NGINX mail proxy will disconnect an inactive
     * IMAP/POP connection. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=735)
    public Map<String,Object> unsetReverseProxyInactivityTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyInactivityTimeout, "");
        return attrs;
    }

    /**
     * The error message with which a connection attempt from an IP address
     * will be throttled, if the connection count exceeds the configured
     * limit
     *
     * @return zimbraReverseProxyIpThrottleMsg, or "Login rejected from this IP" if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=727)
    public String getReverseProxyIpThrottleMsg() {
        return getAttr(Provisioning.A_zimbraReverseProxyIpThrottleMsg, "Login rejected from this IP", true);
    }

    /**
     * The error message with which a connection attempt from an IP address
     * will be throttled, if the connection count exceeds the configured
     * limit
     *
     * @param zimbraReverseProxyIpThrottleMsg new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=727)
    public void setReverseProxyIpThrottleMsg(String zimbraReverseProxyIpThrottleMsg) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIpThrottleMsg, zimbraReverseProxyIpThrottleMsg);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The error message with which a connection attempt from an IP address
     * will be throttled, if the connection count exceeds the configured
     * limit
     *
     * @param zimbraReverseProxyIpThrottleMsg new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=727)
    public Map<String,Object> setReverseProxyIpThrottleMsg(String zimbraReverseProxyIpThrottleMsg, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIpThrottleMsg, zimbraReverseProxyIpThrottleMsg);
        return attrs;
    }

    /**
     * The error message with which a connection attempt from an IP address
     * will be throttled, if the connection count exceeds the configured
     * limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=727)
    public void unsetReverseProxyIpThrottleMsg() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIpThrottleMsg, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The error message with which a connection attempt from an IP address
     * will be throttled, if the connection count exceeds the configured
     * limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=727)
    public Map<String,Object> unsetReverseProxyIpThrottleMsg(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyIpThrottleMsg, "");
        return attrs;
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [debug, info, notice, warn, error, crit, debug_http, debug_mail, debug_core, debug_zimbra]
     *
     * @return zimbraReverseProxyLogLevel, or ZAttrProvisioning.ReverseProxyLogLevel.info if unset and/or has invalid value
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public ZAttrProvisioning.ReverseProxyLogLevel getReverseProxyLogLevel() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyLogLevel, true, true); return v == null ? ZAttrProvisioning.ReverseProxyLogLevel.info : ZAttrProvisioning.ReverseProxyLogLevel.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ReverseProxyLogLevel.info; }
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [debug, info, notice, warn, error, crit, debug_http, debug_mail, debug_core, debug_zimbra]
     *
     * @return zimbraReverseProxyLogLevel, or "info" if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public String getReverseProxyLogLevelAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyLogLevel, "info", true);
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [debug, info, notice, warn, error, crit, debug_http, debug_mail, debug_core, debug_zimbra]
     *
     * @param zimbraReverseProxyLogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public void setReverseProxyLogLevel(ZAttrProvisioning.ReverseProxyLogLevel zimbraReverseProxyLogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, zimbraReverseProxyLogLevel.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [debug, info, notice, warn, error, crit, debug_http, debug_mail, debug_core, debug_zimbra]
     *
     * @param zimbraReverseProxyLogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public Map<String,Object> setReverseProxyLogLevel(ZAttrProvisioning.ReverseProxyLogLevel zimbraReverseProxyLogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, zimbraReverseProxyLogLevel.toString());
        return attrs;
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [debug, info, notice, warn, error, crit, debug_http, debug_mail, debug_core, debug_zimbra]
     *
     * @param zimbraReverseProxyLogLevel new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public void setReverseProxyLogLevelAsString(String zimbraReverseProxyLogLevel) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, zimbraReverseProxyLogLevel);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [debug, info, notice, warn, error, crit, debug_http, debug_mail, debug_core, debug_zimbra]
     *
     * @param zimbraReverseProxyLogLevel new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public Map<String,Object> setReverseProxyLogLevelAsString(String zimbraReverseProxyLogLevel, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, zimbraReverseProxyLogLevel);
        return attrs;
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [debug, info, notice, warn, error, crit, debug_http, debug_mail, debug_core, debug_zimbra]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public void unsetReverseProxyLogLevel() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Log level for NGINX Proxy error log
     *
     * <p>Valid values: [debug, info, notice, warn, error, crit, debug_http, debug_mail, debug_core, debug_zimbra]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=723)
    public Map<String,Object> unsetReverseProxyLogLevel(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLogLevel, "");
        return attrs;
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @return zimbraReverseProxyLookupTarget, or false if unset
     */
    @ZAttr(id=504)
    public boolean isReverseProxyLookupTarget() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyLookupTarget, false, true);
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @param zimbraReverseProxyLookupTarget new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=504)
    public void setReverseProxyLookupTarget(boolean zimbraReverseProxyLookupTarget) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLookupTarget, zimbraReverseProxyLookupTarget ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @param zimbraReverseProxyLookupTarget new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=504)
    public Map<String,Object> setReverseProxyLookupTarget(boolean zimbraReverseProxyLookupTarget, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLookupTarget, zimbraReverseProxyLookupTarget ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=504)
    public void unsetReverseProxyLookupTarget() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLookupTarget, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether this server is a valid upstream and needs to be included in
     * the upstream config of the reverse proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=504)
    public Map<String,Object> unsetReverseProxyLookupTarget(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyLookupTarget, "");
        return attrs;
    }

    /**
     * Whether to enable IMAP/POP proxy
     *
     * @return zimbraReverseProxyMailEnabled, or true if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=629)
    public boolean isReverseProxyMailEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyMailEnabled, true, true);
    }

    /**
     * Whether to enable IMAP/POP proxy
     *
     * @param zimbraReverseProxyMailEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=629)
    public void setReverseProxyMailEnabled(boolean zimbraReverseProxyMailEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailEnabled, zimbraReverseProxyMailEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAP/POP proxy
     *
     * @param zimbraReverseProxyMailEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=629)
    public Map<String,Object> setReverseProxyMailEnabled(boolean zimbraReverseProxyMailEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailEnabled, zimbraReverseProxyMailEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable IMAP/POP proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=629)
    public void unsetReverseProxyMailEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAP/POP proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=629)
    public Map<String,Object> unsetReverseProxyMailEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailEnabled, "");
        return attrs;
    }

    /**
     * LDAP attribute that contains mailhost for the user
     *
     * @return zimbraReverseProxyMailHostAttribute, or "zimbraMailHost" if unset
     */
    @ZAttr(id=474)
    public String getReverseProxyMailHostAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyMailHostAttribute, "zimbraMailHost", true);
    }

    /**
     * LDAP attribute that contains mailhost for the user
     *
     * @param zimbraReverseProxyMailHostAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=474)
    public void setReverseProxyMailHostAttribute(String zimbraReverseProxyMailHostAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostAttribute, zimbraReverseProxyMailHostAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute that contains mailhost for the user
     *
     * @param zimbraReverseProxyMailHostAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=474)
    public Map<String,Object> setReverseProxyMailHostAttribute(String zimbraReverseProxyMailHostAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostAttribute, zimbraReverseProxyMailHostAttribute);
        return attrs;
    }

    /**
     * LDAP attribute that contains mailhost for the user
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=474)
    public void unsetReverseProxyMailHostAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute that contains mailhost for the user
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=474)
    public Map<String,Object> unsetReverseProxyMailHostAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostAttribute, "");
        return attrs;
    }

    /**
     * LDAP query to find a user
     *
     * @return zimbraReverseProxyMailHostQuery, or "(|(zimbraMailDeliveryAddress=${USER})(zimbraMailAlias=${USER})(zimbraId=${USER}))" if unset
     */
    @ZAttr(id=472)
    public String getReverseProxyMailHostQuery() {
        return getAttr(Provisioning.A_zimbraReverseProxyMailHostQuery, "(|(zimbraMailDeliveryAddress=${USER})(zimbraMailAlias=${USER})(zimbraId=${USER}))", true);
    }

    /**
     * LDAP query to find a user
     *
     * @param zimbraReverseProxyMailHostQuery new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=472)
    public void setReverseProxyMailHostQuery(String zimbraReverseProxyMailHostQuery) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostQuery, zimbraReverseProxyMailHostQuery);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP query to find a user
     *
     * @param zimbraReverseProxyMailHostQuery new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=472)
    public Map<String,Object> setReverseProxyMailHostQuery(String zimbraReverseProxyMailHostQuery, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostQuery, zimbraReverseProxyMailHostQuery);
        return attrs;
    }

    /**
     * LDAP query to find a user
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=472)
    public void unsetReverseProxyMailHostQuery() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostQuery, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP query to find a user
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=472)
    public Map<String,Object> unsetReverseProxyMailHostQuery(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostQuery, "");
        return attrs;
    }

    /**
     * search base for zimbraReverseProxyMailHostQuery
     *
     * @return zimbraReverseProxyMailHostSearchBase, or null if unset
     */
    @ZAttr(id=473)
    public String getReverseProxyMailHostSearchBase() {
        return getAttr(Provisioning.A_zimbraReverseProxyMailHostSearchBase, null, true);
    }

    /**
     * search base for zimbraReverseProxyMailHostQuery
     *
     * @param zimbraReverseProxyMailHostSearchBase new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=473)
    public void setReverseProxyMailHostSearchBase(String zimbraReverseProxyMailHostSearchBase) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostSearchBase, zimbraReverseProxyMailHostSearchBase);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * search base for zimbraReverseProxyMailHostQuery
     *
     * @param zimbraReverseProxyMailHostSearchBase new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=473)
    public Map<String,Object> setReverseProxyMailHostSearchBase(String zimbraReverseProxyMailHostSearchBase, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostSearchBase, zimbraReverseProxyMailHostSearchBase);
        return attrs;
    }

    /**
     * search base for zimbraReverseProxyMailHostQuery
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=473)
    public void unsetReverseProxyMailHostSearchBase() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostSearchBase, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * search base for zimbraReverseProxyMailHostQuery
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=473)
    public Map<String,Object> unsetReverseProxyMailHostSearchBase(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailHostSearchBase, "");
        return attrs;
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @return zimbraReverseProxyMailImapEnabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public boolean isReverseProxyMailImapEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyMailImapEnabled, true, true);
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @param zimbraReverseProxyMailImapEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public void setReverseProxyMailImapEnabled(boolean zimbraReverseProxyMailImapEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapEnabled, zimbraReverseProxyMailImapEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @param zimbraReverseProxyMailImapEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public Map<String,Object> setReverseProxyMailImapEnabled(boolean zimbraReverseProxyMailImapEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapEnabled, zimbraReverseProxyMailImapEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public void unsetReverseProxyMailImapEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAP proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1621)
    public Map<String,Object> unsetReverseProxyMailImapEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapEnabled, "");
        return attrs;
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @return zimbraReverseProxyMailImapsEnabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public boolean isReverseProxyMailImapsEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyMailImapsEnabled, true, true);
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @param zimbraReverseProxyMailImapsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public void setReverseProxyMailImapsEnabled(boolean zimbraReverseProxyMailImapsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapsEnabled, zimbraReverseProxyMailImapsEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @param zimbraReverseProxyMailImapsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public Map<String,Object> setReverseProxyMailImapsEnabled(boolean zimbraReverseProxyMailImapsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapsEnabled, zimbraReverseProxyMailImapsEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public void unsetReverseProxyMailImapsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable IMAPs proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1622)
    public Map<String,Object> unsetReverseProxyMailImapsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailImapsEnabled, "");
        return attrs;
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @return zimbraReverseProxyMailMode, or null if unset and/or has invalid value
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public ZAttrProvisioning.ReverseProxyMailMode getReverseProxyMailMode() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyMailMode, true, true); return v == null ? null : ZAttrProvisioning.ReverseProxyMailMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return null; }
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @return zimbraReverseProxyMailMode, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public String getReverseProxyMailModeAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyMailMode, null, true);
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param zimbraReverseProxyMailMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public void setReverseProxyMailMode(ZAttrProvisioning.ReverseProxyMailMode zimbraReverseProxyMailMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, zimbraReverseProxyMailMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param zimbraReverseProxyMailMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public Map<String,Object> setReverseProxyMailMode(ZAttrProvisioning.ReverseProxyMailMode zimbraReverseProxyMailMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, zimbraReverseProxyMailMode.toString());
        return attrs;
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param zimbraReverseProxyMailMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public void setReverseProxyMailModeAsString(String zimbraReverseProxyMailMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, zimbraReverseProxyMailMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param zimbraReverseProxyMailMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public Map<String,Object> setReverseProxyMailModeAsString(String zimbraReverseProxyMailMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, zimbraReverseProxyMailMode);
        return attrs;
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public void unsetReverseProxyMailMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to run proxy in HTTP, HTTPS, both, mixed, or redirect mode.
     * See also related attributes zimbraMailProxyPort and
     * zimbraMailSSLProxyPort
     *
     * <p>Valid values: [http, https, both, mixed, redirect]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=685)
    public Map<String,Object> unsetReverseProxyMailMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailMode, "");
        return attrs;
    }

    /**
     * Whether to enable Pop3 proxy
     *
     * @return zimbraReverseProxyMailPop3Enabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1623)
    public boolean isReverseProxyMailPop3Enabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyMailPop3Enabled, true, true);
    }

    /**
     * Whether to enable Pop3 proxy
     *
     * @param zimbraReverseProxyMailPop3Enabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1623)
    public void setReverseProxyMailPop3Enabled(boolean zimbraReverseProxyMailPop3Enabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailPop3Enabled, zimbraReverseProxyMailPop3Enabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable Pop3 proxy
     *
     * @param zimbraReverseProxyMailPop3Enabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1623)
    public Map<String,Object> setReverseProxyMailPop3Enabled(boolean zimbraReverseProxyMailPop3Enabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailPop3Enabled, zimbraReverseProxyMailPop3Enabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable Pop3 proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1623)
    public void unsetReverseProxyMailPop3Enabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailPop3Enabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable Pop3 proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1623)
    public Map<String,Object> unsetReverseProxyMailPop3Enabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailPop3Enabled, "");
        return attrs;
    }

    /**
     * Whether to enable Pop3s proxy
     *
     * @return zimbraReverseProxyMailPop3sEnabled, or true if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1624)
    public boolean isReverseProxyMailPop3sEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyMailPop3sEnabled, true, true);
    }

    /**
     * Whether to enable Pop3s proxy
     *
     * @param zimbraReverseProxyMailPop3sEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1624)
    public void setReverseProxyMailPop3sEnabled(boolean zimbraReverseProxyMailPop3sEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailPop3sEnabled, zimbraReverseProxyMailPop3sEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable Pop3s proxy
     *
     * @param zimbraReverseProxyMailPop3sEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1624)
    public Map<String,Object> setReverseProxyMailPop3sEnabled(boolean zimbraReverseProxyMailPop3sEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailPop3sEnabled, zimbraReverseProxyMailPop3sEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable Pop3s proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1624)
    public void unsetReverseProxyMailPop3sEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailPop3sEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable Pop3s proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1624)
    public Map<String,Object> unsetReverseProxyMailPop3sEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyMailPop3sEnabled, "");
        return attrs;
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @return zimbraReverseProxyPassErrors, or true if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public boolean isReverseProxyPassErrors() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyPassErrors, true, true);
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @param zimbraReverseProxyPassErrors new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public void setReverseProxyPassErrors(boolean zimbraReverseProxyPassErrors) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPassErrors, zimbraReverseProxyPassErrors ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @param zimbraReverseProxyPassErrors new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public Map<String,Object> setReverseProxyPassErrors(boolean zimbraReverseProxyPassErrors, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPassErrors, zimbraReverseProxyPassErrors ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public void unsetReverseProxyPassErrors() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPassErrors, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether NGINX mail proxy will pass upstream server errors back to the
     * downstream email clients
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=736)
    public Map<String,Object> unsetReverseProxyPassErrors(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPassErrors, "");
        return attrs;
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @return zimbraReverseProxyPop3EnabledCapability, or empty array if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public String[] getReverseProxyPop3EnabledCapability() {
        String[] value = getMultiAttr(Provisioning.A_zimbraReverseProxyPop3EnabledCapability, true, true); return value.length > 0 ? value : new String[] {"TOP","USER","UIDL","EXPIRE 31 USER","XOIP"};
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @param zimbraReverseProxyPop3EnabledCapability new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public void setReverseProxyPop3EnabledCapability(String[] zimbraReverseProxyPop3EnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3EnabledCapability, zimbraReverseProxyPop3EnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @param zimbraReverseProxyPop3EnabledCapability new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public Map<String,Object> setReverseProxyPop3EnabledCapability(String[] zimbraReverseProxyPop3EnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3EnabledCapability, zimbraReverseProxyPop3EnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @param zimbraReverseProxyPop3EnabledCapability new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public void addReverseProxyPop3EnabledCapability(String zimbraReverseProxyPop3EnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyPop3EnabledCapability, zimbraReverseProxyPop3EnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @param zimbraReverseProxyPop3EnabledCapability new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public Map<String,Object> addReverseProxyPop3EnabledCapability(String zimbraReverseProxyPop3EnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyPop3EnabledCapability, zimbraReverseProxyPop3EnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @param zimbraReverseProxyPop3EnabledCapability existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public void removeReverseProxyPop3EnabledCapability(String zimbraReverseProxyPop3EnabledCapability) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyPop3EnabledCapability, zimbraReverseProxyPop3EnabledCapability);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @param zimbraReverseProxyPop3EnabledCapability existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public Map<String,Object> removeReverseProxyPop3EnabledCapability(String zimbraReverseProxyPop3EnabledCapability, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyPop3EnabledCapability, zimbraReverseProxyPop3EnabledCapability);
        return attrs;
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public void unsetReverseProxyPop3EnabledCapability() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3EnabledCapability, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * NGINX reverse proxy pop3 capabilities
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=721)
    public Map<String,Object> unsetReverseProxyPop3EnabledCapability(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3EnabledCapability, "");
        return attrs;
    }

    /**
     * Whether to expose version on Proxy POP3 banner
     *
     * @return zimbraReverseProxyPop3ExposeVersionOnBanner, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=712)
    public boolean isReverseProxyPop3ExposeVersionOnBanner() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyPop3ExposeVersionOnBanner, false, true);
    }

    /**
     * Whether to expose version on Proxy POP3 banner
     *
     * @param zimbraReverseProxyPop3ExposeVersionOnBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=712)
    public void setReverseProxyPop3ExposeVersionOnBanner(boolean zimbraReverseProxyPop3ExposeVersionOnBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3ExposeVersionOnBanner, zimbraReverseProxyPop3ExposeVersionOnBanner ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on Proxy POP3 banner
     *
     * @param zimbraReverseProxyPop3ExposeVersionOnBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=712)
    public Map<String,Object> setReverseProxyPop3ExposeVersionOnBanner(boolean zimbraReverseProxyPop3ExposeVersionOnBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3ExposeVersionOnBanner, zimbraReverseProxyPop3ExposeVersionOnBanner ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to expose version on Proxy POP3 banner
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=712)
    public void unsetReverseProxyPop3ExposeVersionOnBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3ExposeVersionOnBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to expose version on Proxy POP3 banner
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=712)
    public Map<String,Object> unsetReverseProxyPop3ExposeVersionOnBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3ExposeVersionOnBanner, "");
        return attrs;
    }

    /**
     * attribute that contains pop3 bind port
     *
     * @return zimbraReverseProxyPop3PortAttribute, or "zimbraPop3BindPort" if unset
     */
    @ZAttr(id=477)
    public String getReverseProxyPop3PortAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyPop3PortAttribute, "zimbraPop3BindPort", true);
    }

    /**
     * attribute that contains pop3 bind port
     *
     * @param zimbraReverseProxyPop3PortAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=477)
    public void setReverseProxyPop3PortAttribute(String zimbraReverseProxyPop3PortAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3PortAttribute, zimbraReverseProxyPop3PortAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains pop3 bind port
     *
     * @param zimbraReverseProxyPop3PortAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=477)
    public Map<String,Object> setReverseProxyPop3PortAttribute(String zimbraReverseProxyPop3PortAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3PortAttribute, zimbraReverseProxyPop3PortAttribute);
        return attrs;
    }

    /**
     * attribute that contains pop3 bind port
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=477)
    public void unsetReverseProxyPop3PortAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3PortAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains pop3 bind port
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=477)
    public Map<String,Object> unsetReverseProxyPop3PortAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3PortAttribute, "");
        return attrs;
    }

    /**
     * attribute that contains pop3 bind port for SSL
     *
     * @return zimbraReverseProxyPop3SSLPortAttribute, or "zimbraPop3SSLBindPort" if unset
     */
    @ZAttr(id=478)
    public String getReverseProxyPop3SSLPortAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyPop3SSLPortAttribute, "zimbraPop3SSLBindPort", true);
    }

    /**
     * attribute that contains pop3 bind port for SSL
     *
     * @param zimbraReverseProxyPop3SSLPortAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=478)
    public void setReverseProxyPop3SSLPortAttribute(String zimbraReverseProxyPop3SSLPortAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SSLPortAttribute, zimbraReverseProxyPop3SSLPortAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains pop3 bind port for SSL
     *
     * @param zimbraReverseProxyPop3SSLPortAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=478)
    public Map<String,Object> setReverseProxyPop3SSLPortAttribute(String zimbraReverseProxyPop3SSLPortAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SSLPortAttribute, zimbraReverseProxyPop3SSLPortAttribute);
        return attrs;
    }

    /**
     * attribute that contains pop3 bind port for SSL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=478)
    public void unsetReverseProxyPop3SSLPortAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SSLPortAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * attribute that contains pop3 bind port for SSL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=478)
    public Map<String,Object> unsetReverseProxyPop3SSLPortAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SSLPortAttribute, "");
        return attrs;
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for reverse proxy
     *
     * @return zimbraReverseProxyPop3SaslGssapiEnabled, or false if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=644)
    public boolean isReverseProxyPop3SaslGssapiEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyPop3SaslGssapiEnabled, false, true);
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for reverse proxy
     *
     * @param zimbraReverseProxyPop3SaslGssapiEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=644)
    public void setReverseProxyPop3SaslGssapiEnabled(boolean zimbraReverseProxyPop3SaslGssapiEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SaslGssapiEnabled, zimbraReverseProxyPop3SaslGssapiEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for reverse proxy
     *
     * @param zimbraReverseProxyPop3SaslGssapiEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=644)
    public Map<String,Object> setReverseProxyPop3SaslGssapiEnabled(boolean zimbraReverseProxyPop3SaslGssapiEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SaslGssapiEnabled, zimbraReverseProxyPop3SaslGssapiEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for reverse proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=644)
    public void unsetReverseProxyPop3SaslGssapiEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SaslGssapiEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 SASL GSSAPI is enabled for reverse proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=644)
    public Map<String,Object> unsetReverseProxyPop3SaslGssapiEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SaslGssapiEnabled, "");
        return attrs;
    }

    /**
     * whether POP3 SASL PLAIN is enabled for reverse proxy
     *
     * @return zimbraReverseProxyPop3SaslPlainEnabled, or true if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=729)
    public boolean isReverseProxyPop3SaslPlainEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyPop3SaslPlainEnabled, true, true);
    }

    /**
     * whether POP3 SASL PLAIN is enabled for reverse proxy
     *
     * @param zimbraReverseProxyPop3SaslPlainEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=729)
    public void setReverseProxyPop3SaslPlainEnabled(boolean zimbraReverseProxyPop3SaslPlainEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SaslPlainEnabled, zimbraReverseProxyPop3SaslPlainEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 SASL PLAIN is enabled for reverse proxy
     *
     * @param zimbraReverseProxyPop3SaslPlainEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=729)
    public Map<String,Object> setReverseProxyPop3SaslPlainEnabled(boolean zimbraReverseProxyPop3SaslPlainEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SaslPlainEnabled, zimbraReverseProxyPop3SaslPlainEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether POP3 SASL PLAIN is enabled for reverse proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=729)
    public void unsetReverseProxyPop3SaslPlainEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SaslPlainEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether POP3 SASL PLAIN is enabled for reverse proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=729)
    public Map<String,Object> unsetReverseProxyPop3SaslPlainEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3SaslPlainEnabled, "");
        return attrs;
    }

    /**
     * on - on the plain POP3 port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @return zimbraReverseProxyPop3StartTlsMode, or ZAttrProvisioning.ReverseProxyPop3StartTlsMode.only if unset and/or has invalid value
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=642)
    public ZAttrProvisioning.ReverseProxyPop3StartTlsMode getReverseProxyPop3StartTlsMode() {
        try { String v = getAttr(Provisioning.A_zimbraReverseProxyPop3StartTlsMode, true, true); return v == null ? ZAttrProvisioning.ReverseProxyPop3StartTlsMode.only : ZAttrProvisioning.ReverseProxyPop3StartTlsMode.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ReverseProxyPop3StartTlsMode.only; }
    }

    /**
     * on - on the plain POP3 port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @return zimbraReverseProxyPop3StartTlsMode, or "only" if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=642)
    public String getReverseProxyPop3StartTlsModeAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyPop3StartTlsMode, "only", true);
    }

    /**
     * on - on the plain POP3 port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param zimbraReverseProxyPop3StartTlsMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=642)
    public void setReverseProxyPop3StartTlsMode(ZAttrProvisioning.ReverseProxyPop3StartTlsMode zimbraReverseProxyPop3StartTlsMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3StartTlsMode, zimbraReverseProxyPop3StartTlsMode.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - on the plain POP3 port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param zimbraReverseProxyPop3StartTlsMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=642)
    public Map<String,Object> setReverseProxyPop3StartTlsMode(ZAttrProvisioning.ReverseProxyPop3StartTlsMode zimbraReverseProxyPop3StartTlsMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3StartTlsMode, zimbraReverseProxyPop3StartTlsMode.toString());
        return attrs;
    }

    /**
     * on - on the plain POP3 port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param zimbraReverseProxyPop3StartTlsMode new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=642)
    public void setReverseProxyPop3StartTlsModeAsString(String zimbraReverseProxyPop3StartTlsMode) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3StartTlsMode, zimbraReverseProxyPop3StartTlsMode);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - on the plain POP3 port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param zimbraReverseProxyPop3StartTlsMode new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=642)
    public Map<String,Object> setReverseProxyPop3StartTlsModeAsString(String zimbraReverseProxyPop3StartTlsMode, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3StartTlsMode, zimbraReverseProxyPop3StartTlsMode);
        return attrs;
    }

    /**
     * on - on the plain POP3 port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=642)
    public void unsetReverseProxyPop3StartTlsMode() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3StartTlsMode, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * on - on the plain POP3 port, starttls is allowed off - no starttls is
     * offered on plain port only - you have to use starttls before clear
     * text login
     *
     * <p>Valid values: [on, off, only]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=642)
    public Map<String,Object> unsetReverseProxyPop3StartTlsMode(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPop3StartTlsMode, "");
        return attrs;
    }

    /**
     * LDAP query to find server object
     *
     * @return zimbraReverseProxyPortQuery, or "(&(zimbraServiceHostname=${MAILHOST})(objectClass=zimbraServer))" if unset
     */
    @ZAttr(id=475)
    public String getReverseProxyPortQuery() {
        return getAttr(Provisioning.A_zimbraReverseProxyPortQuery, "(&(zimbraServiceHostname=${MAILHOST})(objectClass=zimbraServer))", true);
    }

    /**
     * LDAP query to find server object
     *
     * @param zimbraReverseProxyPortQuery new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=475)
    public void setReverseProxyPortQuery(String zimbraReverseProxyPortQuery) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPortQuery, zimbraReverseProxyPortQuery);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP query to find server object
     *
     * @param zimbraReverseProxyPortQuery new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=475)
    public Map<String,Object> setReverseProxyPortQuery(String zimbraReverseProxyPortQuery, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPortQuery, zimbraReverseProxyPortQuery);
        return attrs;
    }

    /**
     * LDAP query to find server object
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=475)
    public void unsetReverseProxyPortQuery() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPortQuery, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP query to find server object
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=475)
    public Map<String,Object> unsetReverseProxyPortQuery(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPortQuery, "");
        return attrs;
    }

    /**
     * search base for zimbraReverseProxyPortQuery
     *
     * @return zimbraReverseProxyPortSearchBase, or null if unset
     */
    @ZAttr(id=476)
    public String getReverseProxyPortSearchBase() {
        return getAttr(Provisioning.A_zimbraReverseProxyPortSearchBase, null, true);
    }

    /**
     * search base for zimbraReverseProxyPortQuery
     *
     * @param zimbraReverseProxyPortSearchBase new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=476)
    public void setReverseProxyPortSearchBase(String zimbraReverseProxyPortSearchBase) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPortSearchBase, zimbraReverseProxyPortSearchBase);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * search base for zimbraReverseProxyPortQuery
     *
     * @param zimbraReverseProxyPortSearchBase new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=476)
    public Map<String,Object> setReverseProxyPortSearchBase(String zimbraReverseProxyPortSearchBase, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPortSearchBase, zimbraReverseProxyPortSearchBase);
        return attrs;
    }

    /**
     * search base for zimbraReverseProxyPortQuery
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=476)
    public void unsetReverseProxyPortSearchBase() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPortSearchBase, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * search base for zimbraReverseProxyPortQuery
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=476)
    public Map<String,Object> unsetReverseProxyPortSearchBase(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyPortSearchBase, "");
        return attrs;
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @return zimbraReverseProxyResponseHeaders, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public String[] getReverseProxyResponseHeaders() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyResponseHeaders, true, true);
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @param zimbraReverseProxyResponseHeaders new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public void setReverseProxyResponseHeaders(String[] zimbraReverseProxyResponseHeaders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyResponseHeaders, zimbraReverseProxyResponseHeaders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @param zimbraReverseProxyResponseHeaders new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public Map<String,Object> setReverseProxyResponseHeaders(String[] zimbraReverseProxyResponseHeaders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyResponseHeaders, zimbraReverseProxyResponseHeaders);
        return attrs;
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @param zimbraReverseProxyResponseHeaders new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public void addReverseProxyResponseHeaders(String zimbraReverseProxyResponseHeaders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyResponseHeaders, zimbraReverseProxyResponseHeaders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @param zimbraReverseProxyResponseHeaders new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public Map<String,Object> addReverseProxyResponseHeaders(String zimbraReverseProxyResponseHeaders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyResponseHeaders, zimbraReverseProxyResponseHeaders);
        return attrs;
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @param zimbraReverseProxyResponseHeaders existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public void removeReverseProxyResponseHeaders(String zimbraReverseProxyResponseHeaders) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyResponseHeaders, zimbraReverseProxyResponseHeaders);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @param zimbraReverseProxyResponseHeaders existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public Map<String,Object> removeReverseProxyResponseHeaders(String zimbraReverseProxyResponseHeaders, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyResponseHeaders, zimbraReverseProxyResponseHeaders);
        return attrs;
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public void unsetReverseProxyResponseHeaders() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyResponseHeaders, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Custom response headers to be added by the proxy. For example, can be
     * used to add a HSTS header that will enforce SSL usage on the client
     * side. Note: the value MUST be the entire header line (e.g. X-Foo: Bar,
     * X-Zoo: &quot;Bar1; Bar2&quot;).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1973)
    public Map<String,Object> unsetReverseProxyResponseHeaders(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyResponseHeaders, "");
        return attrs;
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyRouteLookupTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyRouteLookupTimeoutAsString()
     *
     * @return zimbraReverseProxyRouteLookupTimeout in millseconds, or 15000 (15s)  if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public long getReverseProxyRouteLookupTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, 15000L, true);
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyRouteLookupTimeout, or "15s" if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public String getReverseProxyRouteLookupTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, "15s", true);
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyRouteLookupTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public void setReverseProxyRouteLookupTimeout(String zimbraReverseProxyRouteLookupTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, zimbraReverseProxyRouteLookupTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyRouteLookupTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public Map<String,Object> setReverseProxyRouteLookupTimeout(String zimbraReverseProxyRouteLookupTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, zimbraReverseProxyRouteLookupTimeout);
        return attrs;
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public void unsetReverseProxyRouteLookupTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which NGINX will fail over to the next route
     * lookup handler, if a handler does not respond to the route lookup
     * request within this time. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=745)
    public Map<String,Object> unsetReverseProxyRouteLookupTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeout, "");
        return attrs;
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyRouteLookupTimeoutCacheAsString to access value as a string.
     *
     * @see #getReverseProxyRouteLookupTimeoutCacheAsString()
     *
     * @return zimbraReverseProxyRouteLookupTimeoutCache in millseconds, or 60000 (60s)  if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public long getReverseProxyRouteLookupTimeoutCache() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, 60000L, true);
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyRouteLookupTimeoutCache, or "60s" if unset
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public String getReverseProxyRouteLookupTimeoutCacheAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, "60s", true);
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyRouteLookupTimeoutCache new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public void setReverseProxyRouteLookupTimeoutCache(String zimbraReverseProxyRouteLookupTimeoutCache) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, zimbraReverseProxyRouteLookupTimeoutCache);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyRouteLookupTimeoutCache new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public Map<String,Object> setReverseProxyRouteLookupTimeoutCache(String zimbraReverseProxyRouteLookupTimeoutCache, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, zimbraReverseProxyRouteLookupTimeoutCache);
        return attrs;
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public void unsetReverseProxyRouteLookupTimeoutCache() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval (ms) given to mail route lookup handler to cache a
     * failed response to route a previous lookup request (after this time
     * elapses, Proxy retries this host). Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.12
     */
    @ZAttr(id=778)
    public Map<String,Object> unsetReverseProxyRouteLookupTimeoutCache(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyRouteLookupTimeoutCache, "");
        return attrs;
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @return zimbraReverseProxySNIEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1818)
    public boolean isReverseProxySNIEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxySNIEnabled, false, true);
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @param zimbraReverseProxySNIEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1818)
    public void setReverseProxySNIEnabled(boolean zimbraReverseProxySNIEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySNIEnabled, zimbraReverseProxySNIEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @param zimbraReverseProxySNIEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1818)
    public Map<String,Object> setReverseProxySNIEnabled(boolean zimbraReverseProxySNIEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySNIEnabled, zimbraReverseProxySNIEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1818)
    public void unsetReverseProxySNIEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySNIEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Enable the use of Server Name Indication (SNI) TLS extension in the
     * proxy. When set to TRUE, and using SNI capable clients, there is no
     * need for a separate IP address per domain (zimbraVirtualIPAddress)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1818)
    public Map<String,Object> unsetReverseProxySNIEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySNIEnabled, "");
        return attrs;
    }

    /**
     * permitted ciphers for reverse proxy. Ciphers are in the formats
     * supported by OpenSSL e.g.
     * ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; if not set,
     * default ciphers permitted by nginx will apply
     *
     * @return zimbraReverseProxySSLCiphers, or "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128:AES256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4" if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=640)
    public String getReverseProxySSLCiphers() {
        return getAttr(Provisioning.A_zimbraReverseProxySSLCiphers, "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128:AES256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4", true);
    }

    /**
     * permitted ciphers for reverse proxy. Ciphers are in the formats
     * supported by OpenSSL e.g.
     * ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; if not set,
     * default ciphers permitted by nginx will apply
     *
     * @param zimbraReverseProxySSLCiphers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=640)
    public void setReverseProxySSLCiphers(String zimbraReverseProxySSLCiphers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLCiphers, zimbraReverseProxySSLCiphers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * permitted ciphers for reverse proxy. Ciphers are in the formats
     * supported by OpenSSL e.g.
     * ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; if not set,
     * default ciphers permitted by nginx will apply
     *
     * @param zimbraReverseProxySSLCiphers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=640)
    public Map<String,Object> setReverseProxySSLCiphers(String zimbraReverseProxySSLCiphers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLCiphers, zimbraReverseProxySSLCiphers);
        return attrs;
    }

    /**
     * permitted ciphers for reverse proxy. Ciphers are in the formats
     * supported by OpenSSL e.g.
     * ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; if not set,
     * default ciphers permitted by nginx will apply
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=640)
    public void unsetReverseProxySSLCiphers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLCiphers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * permitted ciphers for reverse proxy. Ciphers are in the formats
     * supported by OpenSSL e.g.
     * ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; if not set,
     * default ciphers permitted by nginx will apply
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=640)
    public Map<String,Object> unsetReverseProxySSLCiphers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLCiphers, "");
        return attrs;
    }

    /**
     * SSL ECDH cipher curve for web proxy
     *
     * @return zimbraReverseProxySSLECDHCurve, or "prime256v1" if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1626)
    public String getReverseProxySSLECDHCurve() {
        return getAttr(Provisioning.A_zimbraReverseProxySSLECDHCurve, "prime256v1", true);
    }

    /**
     * SSL ECDH cipher curve for web proxy
     *
     * @param zimbraReverseProxySSLECDHCurve new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1626)
    public void setReverseProxySSLECDHCurve(String zimbraReverseProxySSLECDHCurve) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLECDHCurve, zimbraReverseProxySSLECDHCurve);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL ECDH cipher curve for web proxy
     *
     * @param zimbraReverseProxySSLECDHCurve new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1626)
    public Map<String,Object> setReverseProxySSLECDHCurve(String zimbraReverseProxySSLECDHCurve, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLECDHCurve, zimbraReverseProxySSLECDHCurve);
        return attrs;
    }

    /**
     * SSL ECDH cipher curve for web proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1626)
    public void unsetReverseProxySSLECDHCurve() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLECDHCurve, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL ECDH cipher curve for web proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1626)
    public Map<String,Object> unsetReverseProxySSLECDHCurve(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLECDHCurve, "");
        return attrs;
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @return zimbraReverseProxySSLProtocols, or empty array if unset
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public String[] getReverseProxySSLProtocols() {
        String[] value = getMultiAttr(Provisioning.A_zimbraReverseProxySSLProtocols, true, true); return value.length > 0 ? value : new String[] {"TLSv1","TLSv1.1","TLSv1.2"};
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public void setReverseProxySSLProtocols(String[] zimbraReverseProxySSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public Map<String,Object> setReverseProxySSLProtocols(String[] zimbraReverseProxySSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        return attrs;
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public void addReverseProxySSLProtocols(String zimbraReverseProxySSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public Map<String,Object> addReverseProxySSLProtocols(String zimbraReverseProxySSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        return attrs;
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public void removeReverseProxySSLProtocols(String zimbraReverseProxySSLProtocols) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param zimbraReverseProxySSLProtocols existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public Map<String,Object> removeReverseProxySSLProtocols(String zimbraReverseProxySSLProtocols, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxySSLProtocols, zimbraReverseProxySSLProtocols);
        return attrs;
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public void unsetReverseProxySSLProtocols() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLProtocols, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL protocols enabled for the proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.6.0
     */
    @ZAttr(id=1653)
    public Map<String,Object> unsetReverseProxySSLProtocols(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLProtocols, "");
        return attrs;
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @return zimbraReverseProxySSLSessionCacheSize, or "10m" if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1680)
    public String getReverseProxySSLSessionCacheSize() {
        return getAttr(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, "10m", true);
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @param zimbraReverseProxySSLSessionCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1680)
    public void setReverseProxySSLSessionCacheSize(String zimbraReverseProxySSLSessionCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, zimbraReverseProxySSLSessionCacheSize);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @param zimbraReverseProxySSLSessionCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1680)
    public Map<String,Object> setReverseProxySSLSessionCacheSize(String zimbraReverseProxySSLSessionCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, zimbraReverseProxySSLSessionCacheSize);
        return attrs;
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1680)
    public void unsetReverseProxySSLSessionCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL session cache size in megabytes. Need to have &#039;m&#039; (for
     * megabytes) suffix at the end
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1680)
    public Map<String,Object> unsetReverseProxySSLSessionCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionCacheSize, "");
        return attrs;
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxySSLSessionTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxySSLSessionTimeoutAsString()
     *
     * @return zimbraReverseProxySSLSessionTimeout in millseconds, or 600000 (10m)  if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1679)
    public long getReverseProxySSLSessionTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxySSLSessionTimeout, 600000L, true);
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxySSLSessionTimeout, or "10m" if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1679)
    public String getReverseProxySSLSessionTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxySSLSessionTimeout, "10m", true);
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxySSLSessionTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1679)
    public void setReverseProxySSLSessionTimeout(String zimbraReverseProxySSLSessionTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionTimeout, zimbraReverseProxySSLSessionTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxySSLSessionTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1679)
    public Map<String,Object> setReverseProxySSLSessionTimeout(String zimbraReverseProxySSLSessionTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionTimeout, zimbraReverseProxySSLSessionTimeout);
        return attrs;
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1679)
    public void unsetReverseProxySSLSessionTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL session timeout value for the proxy in minutes. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1679)
    public Map<String,Object> unsetReverseProxySSLSessionTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLSessionTimeout, "");
        return attrs;
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @return zimbraReverseProxySSLToUpstreamEnabled, or true if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public boolean isReverseProxySSLToUpstreamEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, true, true);
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @param zimbraReverseProxySSLToUpstreamEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public void setReverseProxySSLToUpstreamEnabled(boolean zimbraReverseProxySSLToUpstreamEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, zimbraReverseProxySSLToUpstreamEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @param zimbraReverseProxySSLToUpstreamEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public Map<String,Object> setReverseProxySSLToUpstreamEnabled(boolean zimbraReverseProxySSLToUpstreamEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, zimbraReverseProxySSLToUpstreamEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public void unsetReverseProxySSLToUpstreamEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If set as TRUE, proxy will use SSL to connect to the upstream mail
     * servers for web and mail proxy. Note admin console proxy always use
     * https no matter how this attr is set.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1360)
    public Map<String,Object> unsetReverseProxySSLToUpstreamEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySSLToUpstreamEnabled, "");
        return attrs;
    }

    /**
     * whether nginx should send ID command for imap
     *
     * @return zimbraReverseProxySendImapId, or true if unset
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=588)
    public boolean isReverseProxySendImapId() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxySendImapId, true, true);
    }

    /**
     * whether nginx should send ID command for imap
     *
     * @param zimbraReverseProxySendImapId new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=588)
    public void setReverseProxySendImapId(boolean zimbraReverseProxySendImapId) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySendImapId, zimbraReverseProxySendImapId ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx should send ID command for imap
     *
     * @param zimbraReverseProxySendImapId new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=588)
    public Map<String,Object> setReverseProxySendImapId(boolean zimbraReverseProxySendImapId, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySendImapId, zimbraReverseProxySendImapId ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether nginx should send ID command for imap
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=588)
    public void unsetReverseProxySendImapId() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySendImapId, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx should send ID command for imap
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=588)
    public Map<String,Object> unsetReverseProxySendImapId(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySendImapId, "");
        return attrs;
    }

    /**
     * whether nginx should send XOIP command for pop3
     *
     * @return zimbraReverseProxySendPop3Xoip, or true if unset
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=587)
    public boolean isReverseProxySendPop3Xoip() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxySendPop3Xoip, true, true);
    }

    /**
     * whether nginx should send XOIP command for pop3
     *
     * @param zimbraReverseProxySendPop3Xoip new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=587)
    public void setReverseProxySendPop3Xoip(boolean zimbraReverseProxySendPop3Xoip) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySendPop3Xoip, zimbraReverseProxySendPop3Xoip ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx should send XOIP command for pop3
     *
     * @param zimbraReverseProxySendPop3Xoip new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=587)
    public Map<String,Object> setReverseProxySendPop3Xoip(boolean zimbraReverseProxySendPop3Xoip, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySendPop3Xoip, zimbraReverseProxySendPop3Xoip ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether nginx should send XOIP command for pop3
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=587)
    public void unsetReverseProxySendPop3Xoip() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySendPop3Xoip, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx should send XOIP command for pop3
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.1
     */
    @ZAttr(id=587)
    public Map<String,Object> unsetReverseProxySendPop3Xoip(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxySendPop3Xoip, "");
        return attrs;
    }

    /**
     * Configure the default server block in
     * &#039;nginx.conf.web.https?.default.template&#039; to return a default
     * HTTP response for all unconfigured host names. See also related
     * attributes &#039;zimbraVirtualHostname&#039; and
     * &#039;zimbraVirtualIPAddress&#039;.
     *
     * @return zimbraReverseProxyStrictServerNameEnabled, or true if unset
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=3020)
    public boolean isReverseProxyStrictServerNameEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyStrictServerNameEnabled, true, true);
    }

    /**
     * Configure the default server block in
     * &#039;nginx.conf.web.https?.default.template&#039; to return a default
     * HTTP response for all unconfigured host names. See also related
     * attributes &#039;zimbraVirtualHostname&#039; and
     * &#039;zimbraVirtualIPAddress&#039;.
     *
     * @param zimbraReverseProxyStrictServerNameEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=3020)
    public void setReverseProxyStrictServerNameEnabled(boolean zimbraReverseProxyStrictServerNameEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyStrictServerNameEnabled, zimbraReverseProxyStrictServerNameEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Configure the default server block in
     * &#039;nginx.conf.web.https?.default.template&#039; to return a default
     * HTTP response for all unconfigured host names. See also related
     * attributes &#039;zimbraVirtualHostname&#039; and
     * &#039;zimbraVirtualIPAddress&#039;.
     *
     * @param zimbraReverseProxyStrictServerNameEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=3020)
    public Map<String,Object> setReverseProxyStrictServerNameEnabled(boolean zimbraReverseProxyStrictServerNameEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyStrictServerNameEnabled, zimbraReverseProxyStrictServerNameEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Configure the default server block in
     * &#039;nginx.conf.web.https?.default.template&#039; to return a default
     * HTTP response for all unconfigured host names. See also related
     * attributes &#039;zimbraVirtualHostname&#039; and
     * &#039;zimbraVirtualIPAddress&#039;.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=3020)
    public void unsetReverseProxyStrictServerNameEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyStrictServerNameEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Configure the default server block in
     * &#039;nginx.conf.web.https?.default.template&#039; to return a default
     * HTTP response for all unconfigured host names. See also related
     * attributes &#039;zimbraVirtualHostname&#039; and
     * &#039;zimbraVirtualIPAddress&#039;.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.6
     */
    @ZAttr(id=3020)
    public Map<String,Object> unsetReverseProxyStrictServerNameEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyStrictServerNameEnabled, "");
        return attrs;
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @return zimbraReverseProxyUpstreamConnectTimeout, or 25 if unset
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public int getReverseProxyUpstreamConnectTimeout() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, 25, true);
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @param zimbraReverseProxyUpstreamConnectTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public void setReverseProxyUpstreamConnectTimeout(int zimbraReverseProxyUpstreamConnectTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, Integer.toString(zimbraReverseProxyUpstreamConnectTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @param zimbraReverseProxyUpstreamConnectTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public Map<String,Object> setReverseProxyUpstreamConnectTimeout(int zimbraReverseProxyUpstreamConnectTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, Integer.toString(zimbraReverseProxyUpstreamConnectTimeout));
        return attrs;
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public void unsetReverseProxyUpstreamConnectTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The connect timeout is the time interval after which NGINX will
     * disconnect while establishing an upstream HTTP connection. Measured in
     * seconds, should not be more than 75 seconds.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.4
     */
    @ZAttr(id=1440)
    public Map<String,Object> unsetReverseProxyUpstreamConnectTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamConnectTimeout, "");
        return attrs;
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @return zimbraReverseProxyUpstreamEwsServers, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public String[] getReverseProxyUpstreamEwsServers() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, true, true);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public void setReverseProxyUpstreamEwsServers(String[] zimbraReverseProxyUpstreamEwsServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public Map<String,Object> setReverseProxyUpstreamEwsServers(String[] zimbraReverseProxyUpstreamEwsServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        return attrs;
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public void addReverseProxyUpstreamEwsServers(String zimbraReverseProxyUpstreamEwsServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public Map<String,Object> addReverseProxyUpstreamEwsServers(String zimbraReverseProxyUpstreamEwsServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        return attrs;
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public void removeReverseProxyUpstreamEwsServers(String zimbraReverseProxyUpstreamEwsServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param zimbraReverseProxyUpstreamEwsServers existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public Map<String,Object> removeReverseProxyUpstreamEwsServers(String zimbraReverseProxyUpstreamEwsServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamEwsServers, zimbraReverseProxyUpstreamEwsServers);
        return attrs;
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public void unsetReverseProxyUpstreamEwsServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers running mailbox with EWS functionality to be included in
     * the &quot;ews&quot; block in the nginx web proxy config file
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1595)
    public Map<String,Object> unsetReverseProxyUpstreamEwsServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamEwsServers, "");
        return attrs;
    }

    /**
     * Configures the &#039;upstream_fair_shm_size&#039; value used by Nginx
     * to set the size of shared memory for storing information about the
     * busy-ness of backends. Values are in kilobytes.
     *
     * @return zimbraReverseProxyUpstreamFairShmSize, or 32 if unset
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3017)
    public int getReverseProxyUpstreamFairShmSize() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyUpstreamFairShmSize, 32, true);
    }

    /**
     * Configures the &#039;upstream_fair_shm_size&#039; value used by Nginx
     * to set the size of shared memory for storing information about the
     * busy-ness of backends. Values are in kilobytes.
     *
     * @param zimbraReverseProxyUpstreamFairShmSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3017)
    public void setReverseProxyUpstreamFairShmSize(int zimbraReverseProxyUpstreamFairShmSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamFairShmSize, Integer.toString(zimbraReverseProxyUpstreamFairShmSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Configures the &#039;upstream_fair_shm_size&#039; value used by Nginx
     * to set the size of shared memory for storing information about the
     * busy-ness of backends. Values are in kilobytes.
     *
     * @param zimbraReverseProxyUpstreamFairShmSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3017)
    public Map<String,Object> setReverseProxyUpstreamFairShmSize(int zimbraReverseProxyUpstreamFairShmSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamFairShmSize, Integer.toString(zimbraReverseProxyUpstreamFairShmSize));
        return attrs;
    }

    /**
     * Configures the &#039;upstream_fair_shm_size&#039; value used by Nginx
     * to set the size of shared memory for storing information about the
     * busy-ness of backends. Values are in kilobytes.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3017)
    public void unsetReverseProxyUpstreamFairShmSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamFairShmSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Configures the &#039;upstream_fair_shm_size&#039; value used by Nginx
     * to set the size of shared memory for storing information about the
     * busy-ness of backends. Values are in kilobytes.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.8.1
     */
    @ZAttr(id=3017)
    public Map<String,Object> unsetReverseProxyUpstreamFairShmSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamFairShmSize, "");
        return attrs;
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @return zimbraReverseProxyUpstreamImapServers, or empty array if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public String[] getReverseProxyUpstreamImapServers() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyUpstreamImapServers, true, true);
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @param zimbraReverseProxyUpstreamImapServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public void setReverseProxyUpstreamImapServers(String[] zimbraReverseProxyUpstreamImapServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamImapServers, zimbraReverseProxyUpstreamImapServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @param zimbraReverseProxyUpstreamImapServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public Map<String,Object> setReverseProxyUpstreamImapServers(String[] zimbraReverseProxyUpstreamImapServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamImapServers, zimbraReverseProxyUpstreamImapServers);
        return attrs;
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @param zimbraReverseProxyUpstreamImapServers new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public void addReverseProxyUpstreamImapServers(String zimbraReverseProxyUpstreamImapServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamImapServers, zimbraReverseProxyUpstreamImapServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @param zimbraReverseProxyUpstreamImapServers new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public Map<String,Object> addReverseProxyUpstreamImapServers(String zimbraReverseProxyUpstreamImapServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamImapServers, zimbraReverseProxyUpstreamImapServers);
        return attrs;
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @param zimbraReverseProxyUpstreamImapServers existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public void removeReverseProxyUpstreamImapServers(String zimbraReverseProxyUpstreamImapServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamImapServers, zimbraReverseProxyUpstreamImapServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @param zimbraReverseProxyUpstreamImapServers existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public Map<String,Object> removeReverseProxyUpstreamImapServers(String zimbraReverseProxyUpstreamImapServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamImapServers, zimbraReverseProxyUpstreamImapServers);
        return attrs;
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public void unsetReverseProxyUpstreamImapServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamImapServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The pool of servers that are available to the proxy for handling IMAP
     * sessions. If empty, the NginxLookupExtension will select the mailbox
     * server that hosts the account.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3008)
    public Map<String,Object> unsetReverseProxyUpstreamImapServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamImapServers, "");
        return attrs;
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @return zimbraReverseProxyUpstreamLoginServers, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public String[] getReverseProxyUpstreamLoginServers() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, true, true);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public void setReverseProxyUpstreamLoginServers(String[] zimbraReverseProxyUpstreamLoginServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public Map<String,Object> setReverseProxyUpstreamLoginServers(String[] zimbraReverseProxyUpstreamLoginServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        return attrs;
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public void addReverseProxyUpstreamLoginServers(String zimbraReverseProxyUpstreamLoginServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public Map<String,Object> addReverseProxyUpstreamLoginServers(String zimbraReverseProxyUpstreamLoginServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        return attrs;
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public void removeReverseProxyUpstreamLoginServers(String zimbraReverseProxyUpstreamLoginServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param zimbraReverseProxyUpstreamLoginServers existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public Map<String,Object> removeReverseProxyUpstreamLoginServers(String zimbraReverseProxyUpstreamLoginServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamLoginServers, zimbraReverseProxyUpstreamLoginServers);
        return attrs;
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public void unsetReverseProxyUpstreamLoginServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The servers to be included in the login block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * login URL requests.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1603)
    public Map<String,Object> unsetReverseProxyUpstreamLoginServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamLoginServers, "");
        return attrs;
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyUpstreamPollingTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyUpstreamPollingTimeoutAsString()
     *
     * @return zimbraReverseProxyUpstreamPollingTimeout in millseconds, or 3600000 (1h)  if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public long getReverseProxyUpstreamPollingTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, 3600000L, true);
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyUpstreamPollingTimeout, or "1h" if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public String getReverseProxyUpstreamPollingTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, "1h", true);
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyUpstreamPollingTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public void setReverseProxyUpstreamPollingTimeout(String zimbraReverseProxyUpstreamPollingTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, zimbraReverseProxyUpstreamPollingTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyUpstreamPollingTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public Map<String,Object> setReverseProxyUpstreamPollingTimeout(String zimbraReverseProxyUpstreamPollingTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, zimbraReverseProxyUpstreamPollingTimeout);
        return attrs;
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public void unsetReverseProxyUpstreamPollingTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The read timeout for long polling support by proxy, e.g. ActiveSync
     * for mobile devices. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1337)
    public Map<String,Object> unsetReverseProxyUpstreamPollingTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamPollingTimeout, "");
        return attrs;
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxyUpstreamReadTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyUpstreamReadTimeoutAsString()
     *
     * @return zimbraReverseProxyUpstreamReadTimeout in millseconds, or 60000 (60s)  if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public long getReverseProxyUpstreamReadTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, 60000L, true);
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxyUpstreamReadTimeout, or "60s" if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public String getReverseProxyUpstreamReadTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, "60s", true);
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyUpstreamReadTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public void setReverseProxyUpstreamReadTimeout(String zimbraReverseProxyUpstreamReadTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, zimbraReverseProxyUpstreamReadTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyUpstreamReadTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public Map<String,Object> setReverseProxyUpstreamReadTimeout(String zimbraReverseProxyUpstreamReadTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, zimbraReverseProxyUpstreamReadTimeout);
        return attrs;
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public void unsetReverseProxyUpstreamReadTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The read timeout for the response of upstream server, which determines
     * how long nginx will wait to get the response to a request. . Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1335)
    public Map<String,Object> unsetReverseProxyUpstreamReadTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamReadTimeout, "");
        return attrs;
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getReverseProxyUpstreamSendTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyUpstreamSendTimeoutAsString()
     *
     * @return zimbraReverseProxyUpstreamSendTimeout in millseconds, or 60000 (60s)  if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public long getReverseProxyUpstreamSendTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, 60000L, true);
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraReverseProxyUpstreamSendTimeout, or "60s" if unset
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public String getReverseProxyUpstreamSendTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, "60s", true);
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyUpstreamSendTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public void setReverseProxyUpstreamSendTimeout(String zimbraReverseProxyUpstreamSendTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, zimbraReverseProxyUpstreamSendTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraReverseProxyUpstreamSendTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public Map<String,Object> setReverseProxyUpstreamSendTimeout(String zimbraReverseProxyUpstreamSendTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, zimbraReverseProxyUpstreamSendTimeout);
        return attrs;
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public void unsetReverseProxyUpstreamSendTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The send timeout of transfering a request to the upstream server. If
     * after this time the upstream server doesn&#039;t take new data, proxy
     * will close the connection. . Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.4
     */
    @ZAttr(id=1336)
    public Map<String,Object> unsetReverseProxyUpstreamSendTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamSendTimeout, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @return zimbraReverseProxyUpstreamServers, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public String[] getReverseProxyUpstreamServers() {
        return getMultiAttr(Provisioning.A_zimbraReverseProxyUpstreamServers, true, true);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public void setReverseProxyUpstreamServers(String[] zimbraReverseProxyUpstreamServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public Map<String,Object> setReverseProxyUpstreamServers(String[] zimbraReverseProxyUpstreamServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public void addReverseProxyUpstreamServers(String zimbraReverseProxyUpstreamServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public Map<String,Object> addReverseProxyUpstreamServers(String zimbraReverseProxyUpstreamServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public void removeReverseProxyUpstreamServers(String zimbraReverseProxyUpstreamServers) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param zimbraReverseProxyUpstreamServers existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public Map<String,Object> removeReverseProxyUpstreamServers(String zimbraReverseProxyUpstreamServers, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraReverseProxyUpstreamServers, zimbraReverseProxyUpstreamServers);
        return attrs;
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public void unsetReverseProxyUpstreamServers() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamServers, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.5.0. Configuration for pre-login upstream is now
     * handled via zimbraReverseProxyUpstreamLoginServers. Post-login
     * upstreams are now automatically configured per-webapp based on what is
     * present in zimbraServiceEnabled.. Orig desc: The servers to be
     * included in the &quot;upstream&quot; block in the nginx web proxy
     * config file. The servers configured here will only affect the proxy of
     * pre-login requests. Leaving empty means using all the servers whose
     * zimbraReverseProxyLookupTarget is TRUE.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1378)
    public Map<String,Object> unsetReverseProxyUpstreamServers(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUpstreamServers, "");
        return attrs;
    }

    /**
     * Limit how many times a user can login via the proxy. Setting limit to
     * 100 and time to 3600 means: allow maximum 100 logins per hour for any
     * user. As with the ip counterparts, the user hit counter and timeout
     * are cumulative for all protocols. Also, for a given users login, both
     * counters are checked in succession, with the IP counter being checked
     * first. A login may be rejected (throttled) because the IP is
     * over-usage, or because the login name itself is over-usage. A value of
     * 0 indicates that no throttling will take place for any user.
     *
     * @return zimbraReverseProxyUserLoginLimit, or 0 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=624)
    public int getReverseProxyUserLoginLimit() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyUserLoginLimit, 0, true);
    }

    /**
     * Limit how many times a user can login via the proxy. Setting limit to
     * 100 and time to 3600 means: allow maximum 100 logins per hour for any
     * user. As with the ip counterparts, the user hit counter and timeout
     * are cumulative for all protocols. Also, for a given users login, both
     * counters are checked in succession, with the IP counter being checked
     * first. A login may be rejected (throttled) because the IP is
     * over-usage, or because the login name itself is over-usage. A value of
     * 0 indicates that no throttling will take place for any user.
     *
     * @param zimbraReverseProxyUserLoginLimit new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=624)
    public void setReverseProxyUserLoginLimit(int zimbraReverseProxyUserLoginLimit) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserLoginLimit, Integer.toString(zimbraReverseProxyUserLoginLimit));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Limit how many times a user can login via the proxy. Setting limit to
     * 100 and time to 3600 means: allow maximum 100 logins per hour for any
     * user. As with the ip counterparts, the user hit counter and timeout
     * are cumulative for all protocols. Also, for a given users login, both
     * counters are checked in succession, with the IP counter being checked
     * first. A login may be rejected (throttled) because the IP is
     * over-usage, or because the login name itself is over-usage. A value of
     * 0 indicates that no throttling will take place for any user.
     *
     * @param zimbraReverseProxyUserLoginLimit new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=624)
    public Map<String,Object> setReverseProxyUserLoginLimit(int zimbraReverseProxyUserLoginLimit, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserLoginLimit, Integer.toString(zimbraReverseProxyUserLoginLimit));
        return attrs;
    }

    /**
     * Limit how many times a user can login via the proxy. Setting limit to
     * 100 and time to 3600 means: allow maximum 100 logins per hour for any
     * user. As with the ip counterparts, the user hit counter and timeout
     * are cumulative for all protocols. Also, for a given users login, both
     * counters are checked in succession, with the IP counter being checked
     * first. A login may be rejected (throttled) because the IP is
     * over-usage, or because the login name itself is over-usage. A value of
     * 0 indicates that no throttling will take place for any user.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=624)
    public void unsetReverseProxyUserLoginLimit() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserLoginLimit, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Limit how many times a user can login via the proxy. Setting limit to
     * 100 and time to 3600 means: allow maximum 100 logins per hour for any
     * user. As with the ip counterparts, the user hit counter and timeout
     * are cumulative for all protocols. Also, for a given users login, both
     * counters are checked in succession, with the IP counter being checked
     * first. A login may be rejected (throttled) because the IP is
     * over-usage, or because the login name itself is over-usage. A value of
     * 0 indicates that no throttling will take place for any user.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=624)
    public Map<String,Object> unsetReverseProxyUserLoginLimit(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserLoginLimit, "");
        return attrs;
    }

    /**
     * Sets the time-to-live for the hit counter for per user login
     * throttling.
     *
     * @return zimbraReverseProxyUserLoginLimitTime, or 3600 if unset
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=625)
    public int getReverseProxyUserLoginLimitTime() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyUserLoginLimitTime, 3600, true);
    }

    /**
     * Sets the time-to-live for the hit counter for per user login
     * throttling.
     *
     * @param zimbraReverseProxyUserLoginLimitTime new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=625)
    public void setReverseProxyUserLoginLimitTime(int zimbraReverseProxyUserLoginLimitTime) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserLoginLimitTime, Integer.toString(zimbraReverseProxyUserLoginLimitTime));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for the hit counter for per user login
     * throttling.
     *
     * @param zimbraReverseProxyUserLoginLimitTime new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=625)
    public Map<String,Object> setReverseProxyUserLoginLimitTime(int zimbraReverseProxyUserLoginLimitTime, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserLoginLimitTime, Integer.toString(zimbraReverseProxyUserLoginLimitTime));
        return attrs;
    }

    /**
     * Sets the time-to-live for the hit counter for per user login
     * throttling.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=625)
    public void unsetReverseProxyUserLoginLimitTime() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserLoginLimitTime, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Sets the time-to-live for the hit counter for per user login
     * throttling.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.3
     */
    @ZAttr(id=625)
    public Map<String,Object> unsetReverseProxyUserLoginLimitTime(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserLoginLimitTime, "");
        return attrs;
    }

    /**
     * LDAP attribute that contains user name for the principal
     *
     * @return zimbraReverseProxyUserNameAttribute, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=572)
    public String getReverseProxyUserNameAttribute() {
        return getAttr(Provisioning.A_zimbraReverseProxyUserNameAttribute, null, true);
    }

    /**
     * LDAP attribute that contains user name for the principal
     *
     * @param zimbraReverseProxyUserNameAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=572)
    public void setReverseProxyUserNameAttribute(String zimbraReverseProxyUserNameAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserNameAttribute, zimbraReverseProxyUserNameAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute that contains user name for the principal
     *
     * @param zimbraReverseProxyUserNameAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=572)
    public Map<String,Object> setReverseProxyUserNameAttribute(String zimbraReverseProxyUserNameAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserNameAttribute, zimbraReverseProxyUserNameAttribute);
        return attrs;
    }

    /**
     * LDAP attribute that contains user name for the principal
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=572)
    public void unsetReverseProxyUserNameAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserNameAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute that contains user name for the principal
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=572)
    public Map<String,Object> unsetReverseProxyUserNameAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserNameAttribute, "");
        return attrs;
    }

    /**
     * The error message with which a login attempt by a user will be
     * throttled, if the attempt count exceeds the configured limit
     *
     * @return zimbraReverseProxyUserThrottleMsg, or "Login rejected for this user" if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=726)
    public String getReverseProxyUserThrottleMsg() {
        return getAttr(Provisioning.A_zimbraReverseProxyUserThrottleMsg, "Login rejected for this user", true);
    }

    /**
     * The error message with which a login attempt by a user will be
     * throttled, if the attempt count exceeds the configured limit
     *
     * @param zimbraReverseProxyUserThrottleMsg new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=726)
    public void setReverseProxyUserThrottleMsg(String zimbraReverseProxyUserThrottleMsg) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserThrottleMsg, zimbraReverseProxyUserThrottleMsg);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The error message with which a login attempt by a user will be
     * throttled, if the attempt count exceeds the configured limit
     *
     * @param zimbraReverseProxyUserThrottleMsg new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=726)
    public Map<String,Object> setReverseProxyUserThrottleMsg(String zimbraReverseProxyUserThrottleMsg, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserThrottleMsg, zimbraReverseProxyUserThrottleMsg);
        return attrs;
    }

    /**
     * The error message with which a login attempt by a user will be
     * throttled, if the attempt count exceeds the configured limit
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=726)
    public void unsetReverseProxyUserThrottleMsg() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserThrottleMsg, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The error message with which a login attempt by a user will be
     * throttled, if the attempt count exceeds the configured limit
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=726)
    public Map<String,Object> unsetReverseProxyUserThrottleMsg(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyUserThrottleMsg, "");
        return attrs;
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @return zimbraReverseProxyWorkerConnections, or 10240 if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public int getReverseProxyWorkerConnections() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyWorkerConnections, 10240, true);
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @param zimbraReverseProxyWorkerConnections new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public void setReverseProxyWorkerConnections(int zimbraReverseProxyWorkerConnections) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerConnections, Integer.toString(zimbraReverseProxyWorkerConnections));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @param zimbraReverseProxyWorkerConnections new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public Map<String,Object> setReverseProxyWorkerConnections(int zimbraReverseProxyWorkerConnections, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerConnections, Integer.toString(zimbraReverseProxyWorkerConnections));
        return attrs;
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public void unsetReverseProxyWorkerConnections() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerConnections, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of connections that an NGINX Proxy worker process is
     * allowed to handle
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=725)
    public Map<String,Object> unsetReverseProxyWorkerConnections(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerConnections, "");
        return attrs;
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @return zimbraReverseProxyWorkerProcesses, or 4 if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public int getReverseProxyWorkerProcesses() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyWorkerProcesses, 4, true);
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @param zimbraReverseProxyWorkerProcesses new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public void setReverseProxyWorkerProcesses(int zimbraReverseProxyWorkerProcesses) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerProcesses, Integer.toString(zimbraReverseProxyWorkerProcesses));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @param zimbraReverseProxyWorkerProcesses new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public Map<String,Object> setReverseProxyWorkerProcesses(int zimbraReverseProxyWorkerProcesses, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerProcesses, Integer.toString(zimbraReverseProxyWorkerProcesses));
        return attrs;
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public void unsetReverseProxyWorkerProcesses() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerProcesses, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Number of worker processes of NGINX Proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=724)
    public Map<String,Object> unsetReverseProxyWorkerProcesses(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyWorkerProcesses, "");
        return attrs;
    }

    /**
     * Whether to enable XMPP/BOSH proxy
     *
     * @return zimbraReverseProxyXmppBoshEnabled, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2065)
    public boolean isReverseProxyXmppBoshEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyXmppBoshEnabled, false, true);
    }

    /**
     * Whether to enable XMPP/BOSH proxy
     *
     * @param zimbraReverseProxyXmppBoshEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2065)
    public void setReverseProxyXmppBoshEnabled(boolean zimbraReverseProxyXmppBoshEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshEnabled, zimbraReverseProxyXmppBoshEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable XMPP/BOSH proxy
     *
     * @param zimbraReverseProxyXmppBoshEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2065)
    public Map<String,Object> setReverseProxyXmppBoshEnabled(boolean zimbraReverseProxyXmppBoshEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshEnabled, zimbraReverseProxyXmppBoshEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable XMPP/BOSH proxy
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2065)
    public void unsetReverseProxyXmppBoshEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable XMPP/BOSH proxy
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2065)
    public Map<String,Object> unsetReverseProxyXmppBoshEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshEnabled, "");
        return attrs;
    }

    /**
     * Hostname of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @return zimbraReverseProxyXmppBoshHostname, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1959)
    public String getReverseProxyXmppBoshHostname() {
        return getAttr(Provisioning.A_zimbraReverseProxyXmppBoshHostname, null, true);
    }

    /**
     * Hostname of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @param zimbraReverseProxyXmppBoshHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1959)
    public void setReverseProxyXmppBoshHostname(String zimbraReverseProxyXmppBoshHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshHostname, zimbraReverseProxyXmppBoshHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hostname of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @param zimbraReverseProxyXmppBoshHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1959)
    public Map<String,Object> setReverseProxyXmppBoshHostname(String zimbraReverseProxyXmppBoshHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshHostname, zimbraReverseProxyXmppBoshHostname);
        return attrs;
    }

    /**
     * Hostname of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1959)
    public void unsetReverseProxyXmppBoshHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hostname of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1959)
    public Map<String,Object> unsetReverseProxyXmppBoshHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshHostname, "");
        return attrs;
    }

    /**
     * Local HTTP-BIND URL prefix where ZWC sends XMPP over BOSH requests
     *
     * @return zimbraReverseProxyXmppBoshLocalHttpBindURL, or "/http-bind" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1957)
    public String getReverseProxyXmppBoshLocalHttpBindURL() {
        return getAttr(Provisioning.A_zimbraReverseProxyXmppBoshLocalHttpBindURL, "/http-bind", true);
    }

    /**
     * Local HTTP-BIND URL prefix where ZWC sends XMPP over BOSH requests
     *
     * @param zimbraReverseProxyXmppBoshLocalHttpBindURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1957)
    public void setReverseProxyXmppBoshLocalHttpBindURL(String zimbraReverseProxyXmppBoshLocalHttpBindURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshLocalHttpBindURL, zimbraReverseProxyXmppBoshLocalHttpBindURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Local HTTP-BIND URL prefix where ZWC sends XMPP over BOSH requests
     *
     * @param zimbraReverseProxyXmppBoshLocalHttpBindURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1957)
    public Map<String,Object> setReverseProxyXmppBoshLocalHttpBindURL(String zimbraReverseProxyXmppBoshLocalHttpBindURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshLocalHttpBindURL, zimbraReverseProxyXmppBoshLocalHttpBindURL);
        return attrs;
    }

    /**
     * Local HTTP-BIND URL prefix where ZWC sends XMPP over BOSH requests
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1957)
    public void unsetReverseProxyXmppBoshLocalHttpBindURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshLocalHttpBindURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Local HTTP-BIND URL prefix where ZWC sends XMPP over BOSH requests
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1957)
    public Map<String,Object> unsetReverseProxyXmppBoshLocalHttpBindURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshLocalHttpBindURL, "");
        return attrs;
    }

    /**
     * Port number of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * <p>Use getReverseProxyXmppBoshPortAsString to access value as a string.
     *
     * @see #getReverseProxyXmppBoshPortAsString()
     *
     * @return zimbraReverseProxyXmppBoshPort, or -1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1960)
    public int getReverseProxyXmppBoshPort() {
        return getIntAttr(Provisioning.A_zimbraReverseProxyXmppBoshPort, -1, true);
    }

    /**
     * Port number of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @return zimbraReverseProxyXmppBoshPort, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1960)
    public String getReverseProxyXmppBoshPortAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyXmppBoshPort, null, true);
    }

    /**
     * Port number of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @param zimbraReverseProxyXmppBoshPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1960)
    public void setReverseProxyXmppBoshPort(int zimbraReverseProxyXmppBoshPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshPort, Integer.toString(zimbraReverseProxyXmppBoshPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port number of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @param zimbraReverseProxyXmppBoshPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1960)
    public Map<String,Object> setReverseProxyXmppBoshPort(int zimbraReverseProxyXmppBoshPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshPort, Integer.toString(zimbraReverseProxyXmppBoshPort));
        return attrs;
    }

    /**
     * Port number of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @param zimbraReverseProxyXmppBoshPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1960)
    public void setReverseProxyXmppBoshPortAsString(String zimbraReverseProxyXmppBoshPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshPort, zimbraReverseProxyXmppBoshPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port number of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @param zimbraReverseProxyXmppBoshPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1960)
    public Map<String,Object> setReverseProxyXmppBoshPortAsString(String zimbraReverseProxyXmppBoshPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshPort, zimbraReverseProxyXmppBoshPort);
        return attrs;
    }

    /**
     * Port number of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1960)
    public void unsetReverseProxyXmppBoshPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Port number of the external XMPP server where XMPP over BOSH requests
     * need to be proxied
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1960)
    public Map<String,Object> unsetReverseProxyXmppBoshPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshPort, "");
        return attrs;
    }

    /**
     * Remote HTTP-BIND URL prefix for an external XMPP server where XMPP
     * over BOSH requests need to be proxied. This needs to be configured
     * only if its different from zimbraReverseProxyXmppBoshLocalHttpBindURL
     *
     * @return zimbraReverseProxyXmppBoshRemoteHttpBindURL, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1958)
    public String getReverseProxyXmppBoshRemoteHttpBindURL() {
        return getAttr(Provisioning.A_zimbraReverseProxyXmppBoshRemoteHttpBindURL, null, true);
    }

    /**
     * Remote HTTP-BIND URL prefix for an external XMPP server where XMPP
     * over BOSH requests need to be proxied. This needs to be configured
     * only if its different from zimbraReverseProxyXmppBoshLocalHttpBindURL
     *
     * @param zimbraReverseProxyXmppBoshRemoteHttpBindURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1958)
    public void setReverseProxyXmppBoshRemoteHttpBindURL(String zimbraReverseProxyXmppBoshRemoteHttpBindURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshRemoteHttpBindURL, zimbraReverseProxyXmppBoshRemoteHttpBindURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Remote HTTP-BIND URL prefix for an external XMPP server where XMPP
     * over BOSH requests need to be proxied. This needs to be configured
     * only if its different from zimbraReverseProxyXmppBoshLocalHttpBindURL
     *
     * @param zimbraReverseProxyXmppBoshRemoteHttpBindURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1958)
    public Map<String,Object> setReverseProxyXmppBoshRemoteHttpBindURL(String zimbraReverseProxyXmppBoshRemoteHttpBindURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshRemoteHttpBindURL, zimbraReverseProxyXmppBoshRemoteHttpBindURL);
        return attrs;
    }

    /**
     * Remote HTTP-BIND URL prefix for an external XMPP server where XMPP
     * over BOSH requests need to be proxied. This needs to be configured
     * only if its different from zimbraReverseProxyXmppBoshLocalHttpBindURL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1958)
    public void unsetReverseProxyXmppBoshRemoteHttpBindURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshRemoteHttpBindURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Remote HTTP-BIND URL prefix for an external XMPP server where XMPP
     * over BOSH requests need to be proxied. This needs to be configured
     * only if its different from zimbraReverseProxyXmppBoshLocalHttpBindURL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1958)
    public Map<String,Object> unsetReverseProxyXmppBoshRemoteHttpBindURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshRemoteHttpBindURL, "");
        return attrs;
    }

    /**
     * Whether to use SSL to connect to upstream XMPP/Bosh server
     *
     * @return zimbraReverseProxyXmppBoshSSL, or false if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2066)
    public boolean isReverseProxyXmppBoshSSL() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyXmppBoshSSL, false, true);
    }

    /**
     * Whether to use SSL to connect to upstream XMPP/Bosh server
     *
     * @param zimbraReverseProxyXmppBoshSSL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2066)
    public void setReverseProxyXmppBoshSSL(boolean zimbraReverseProxyXmppBoshSSL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshSSL, zimbraReverseProxyXmppBoshSSL ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use SSL to connect to upstream XMPP/Bosh server
     *
     * @param zimbraReverseProxyXmppBoshSSL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2066)
    public Map<String,Object> setReverseProxyXmppBoshSSL(boolean zimbraReverseProxyXmppBoshSSL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshSSL, zimbraReverseProxyXmppBoshSSL ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to use SSL to connect to upstream XMPP/Bosh server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2066)
    public void unsetReverseProxyXmppBoshSSL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshSSL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use SSL to connect to upstream XMPP/Bosh server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2066)
    public Map<String,Object> unsetReverseProxyXmppBoshSSL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshSSL, "");
        return attrs;
    }

    /**
     * the response timeout for an external XMPP/BOSH server. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getReverseProxyXmppBoshTimeoutAsString to access value as a string.
     *
     * @see #getReverseProxyXmppBoshTimeoutAsString()
     *
     * @return zimbraReverseProxyXmppBoshTimeout in millseconds, or 90000 (90s)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2064)
    public long getReverseProxyXmppBoshTimeout() {
        return getTimeInterval(Provisioning.A_zimbraReverseProxyXmppBoshTimeout, 90000L, true);
    }

    /**
     * the response timeout for an external XMPP/BOSH server. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraReverseProxyXmppBoshTimeout, or "90s" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2064)
    public String getReverseProxyXmppBoshTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraReverseProxyXmppBoshTimeout, "90s", true);
    }

    /**
     * the response timeout for an external XMPP/BOSH server. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyXmppBoshTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2064)
    public void setReverseProxyXmppBoshTimeout(String zimbraReverseProxyXmppBoshTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshTimeout, zimbraReverseProxyXmppBoshTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the response timeout for an external XMPP/BOSH server. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraReverseProxyXmppBoshTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2064)
    public Map<String,Object> setReverseProxyXmppBoshTimeout(String zimbraReverseProxyXmppBoshTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshTimeout, zimbraReverseProxyXmppBoshTimeout);
        return attrs;
    }

    /**
     * the response timeout for an external XMPP/BOSH server. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2064)
    public void unsetReverseProxyXmppBoshTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the response timeout for an external XMPP/BOSH server. Must be in
     * valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2064)
    public Map<String,Object> unsetReverseProxyXmppBoshTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyXmppBoshTimeout, "");
        return attrs;
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @return zimbraReverseProxyZmlookupCachingEnabled, or true if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1785)
    public boolean isReverseProxyZmlookupCachingEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, true, true);
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @param zimbraReverseProxyZmlookupCachingEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1785)
    public void setReverseProxyZmlookupCachingEnabled(boolean zimbraReverseProxyZmlookupCachingEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, zimbraReverseProxyZmlookupCachingEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @param zimbraReverseProxyZmlookupCachingEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1785)
    public Map<String,Object> setReverseProxyZmlookupCachingEnabled(boolean zimbraReverseProxyZmlookupCachingEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, zimbraReverseProxyZmlookupCachingEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1785)
    public void unsetReverseProxyZmlookupCachingEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether nginx should cache upstream routes in memcache
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1785)
    public Map<String,Object> unsetReverseProxyZmlookupCachingEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraReverseProxyZmlookupCachingEnabled, "");
        return attrs;
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @return zimbraSMIMELdapAttribute, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public String[] getSMIMELdapAttribute() {
        return getMultiAttr(Provisioning.A_zimbraSMIMELdapAttribute, true, true);
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapAttribute new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public void setSMIMELdapAttribute(String[] zimbraSMIMELdapAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapAttribute, zimbraSMIMELdapAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapAttribute new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public Map<String,Object> setSMIMELdapAttribute(String[] zimbraSMIMELdapAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapAttribute, zimbraSMIMELdapAttribute);
        return attrs;
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapAttribute new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public void addSMIMELdapAttribute(String zimbraSMIMELdapAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapAttribute, zimbraSMIMELdapAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapAttribute new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public Map<String,Object> addSMIMELdapAttribute(String zimbraSMIMELdapAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapAttribute, zimbraSMIMELdapAttribute);
        return attrs;
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapAttribute existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public void removeSMIMELdapAttribute(String zimbraSMIMELdapAttribute) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapAttribute, zimbraSMIMELdapAttribute);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapAttribute existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public Map<String,Object> removeSMIMELdapAttribute(String zimbraSMIMELdapAttribute, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapAttribute, zimbraSMIMELdapAttribute);
        return attrs;
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public void unsetSMIMELdapAttribute() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapAttribute, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP attribute(s) for public key lookup for S/MIME via external LDAP.
     * Multiple attributes can be separated by comma. All SMIME attributes
     * are in the format of {config-name}:{value}. A &#039;SMIME config&#039;
     * is a set of SMIME attribute values with the same {config-name}.
     * Multiple SMIME configs can be configured on a domain or on
     * globalconfig. Note: SMIME attributes on domains do not inherited
     * values from globalconfig, they are not domain-inherited attributes.
     * During SMIME public key lookup, if there are any SMIME config on the
     * domain of the account, they are used. SMIME configs on globalconfig
     * will be used only when there is no SMIME config on the domain. SMIME
     * attributes cannot be modified directly with zmprov md/mcf commands.
     * Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1182)
    public Map<String,Object> unsetSMIMELdapAttribute(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapAttribute, "");
        return attrs;
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @return zimbraSMIMELdapBindDn, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public String[] getSMIMELdapBindDn() {
        return getMultiAttr(Provisioning.A_zimbraSMIMELdapBindDn, true, true);
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindDn new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public void setSMIMELdapBindDn(String[] zimbraSMIMELdapBindDn) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapBindDn, zimbraSMIMELdapBindDn);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindDn new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public Map<String,Object> setSMIMELdapBindDn(String[] zimbraSMIMELdapBindDn, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapBindDn, zimbraSMIMELdapBindDn);
        return attrs;
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindDn new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public void addSMIMELdapBindDn(String zimbraSMIMELdapBindDn) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapBindDn, zimbraSMIMELdapBindDn);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindDn new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public Map<String,Object> addSMIMELdapBindDn(String zimbraSMIMELdapBindDn, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapBindDn, zimbraSMIMELdapBindDn);
        return attrs;
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindDn existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public void removeSMIMELdapBindDn(String zimbraSMIMELdapBindDn) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapBindDn, zimbraSMIMELdapBindDn);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindDn existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public Map<String,Object> removeSMIMELdapBindDn(String zimbraSMIMELdapBindDn, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapBindDn, zimbraSMIMELdapBindDn);
        return attrs;
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public void unsetSMIMELdapBindDn() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapBindDn, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP bind DN for public key lookup for S/MIME via external LDAP. Can
     * be empty for anonymous bind. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1178)
    public Map<String,Object> unsetSMIMELdapBindDn(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapBindDn, "");
        return attrs;
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @return zimbraSMIMELdapBindPassword, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public String[] getSMIMELdapBindPassword() {
        return getMultiAttr(Provisioning.A_zimbraSMIMELdapBindPassword, true, true);
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public void setSMIMELdapBindPassword(String[] zimbraSMIMELdapBindPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapBindPassword, zimbraSMIMELdapBindPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public Map<String,Object> setSMIMELdapBindPassword(String[] zimbraSMIMELdapBindPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapBindPassword, zimbraSMIMELdapBindPassword);
        return attrs;
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindPassword new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public void addSMIMELdapBindPassword(String zimbraSMIMELdapBindPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapBindPassword, zimbraSMIMELdapBindPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindPassword new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public Map<String,Object> addSMIMELdapBindPassword(String zimbraSMIMELdapBindPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapBindPassword, zimbraSMIMELdapBindPassword);
        return attrs;
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindPassword existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public void removeSMIMELdapBindPassword(String zimbraSMIMELdapBindPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapBindPassword, zimbraSMIMELdapBindPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapBindPassword existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public Map<String,Object> removeSMIMELdapBindPassword(String zimbraSMIMELdapBindPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapBindPassword, zimbraSMIMELdapBindPassword);
        return attrs;
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public void unsetSMIMELdapBindPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapBindPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP bind password for public key lookup for S/MIME via external LDAP.
     * Can be empty for anonymous bind. All SMIME attributes are in the
     * format of {config-name}:{value}. A &#039;SMIME config&#039; is a set
     * of SMIME attribute values with the same {config-name}. Multiple SMIME
     * configs can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1179)
    public Map<String,Object> unsetSMIMELdapBindPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapBindPassword, "");
        return attrs;
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @return zimbraSMIMELdapDiscoverSearchBaseEnabled, or empty array if unset
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public String[] getSMIMELdapDiscoverSearchBaseEnabled() {
        return getMultiAttr(Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, true, true);
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapDiscoverSearchBaseEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public void setSMIMELdapDiscoverSearchBaseEnabled(String[] zimbraSMIMELdapDiscoverSearchBaseEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, zimbraSMIMELdapDiscoverSearchBaseEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapDiscoverSearchBaseEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public Map<String,Object> setSMIMELdapDiscoverSearchBaseEnabled(String[] zimbraSMIMELdapDiscoverSearchBaseEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, zimbraSMIMELdapDiscoverSearchBaseEnabled);
        return attrs;
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapDiscoverSearchBaseEnabled new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public void addSMIMELdapDiscoverSearchBaseEnabled(String zimbraSMIMELdapDiscoverSearchBaseEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, zimbraSMIMELdapDiscoverSearchBaseEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapDiscoverSearchBaseEnabled new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public Map<String,Object> addSMIMELdapDiscoverSearchBaseEnabled(String zimbraSMIMELdapDiscoverSearchBaseEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, zimbraSMIMELdapDiscoverSearchBaseEnabled);
        return attrs;
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapDiscoverSearchBaseEnabled existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public void removeSMIMELdapDiscoverSearchBaseEnabled(String zimbraSMIMELdapDiscoverSearchBaseEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, zimbraSMIMELdapDiscoverSearchBaseEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapDiscoverSearchBaseEnabled existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public Map<String,Object> removeSMIMELdapDiscoverSearchBaseEnabled(String zimbraSMIMELdapDiscoverSearchBaseEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, zimbraSMIMELdapDiscoverSearchBaseEnabled);
        return attrs;
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public void unsetSMIMELdapDiscoverSearchBaseEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to discover search base DNs if
     * zimbraSMIMELdapSearchBase is not set. Allowed values are TRUE or
     * FALSE. If zimbraSMIMELdapSearchBase is set for a config, this
     * attribute is ignored for the config. If not set, default for the
     * config is FALSE. In that case, if zimbraSMIMELdapSearchBase is not
     * set, the search will default to the rootDSE. If multiple DNs are
     * discovered, the ldap search will use them one by one until a hit is
     * returned. All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.1
     */
    @ZAttr(id=1209)
    public Map<String,Object> unsetSMIMELdapDiscoverSearchBaseEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapDiscoverSearchBaseEnabled, "");
        return attrs;
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @return zimbraSMIMELdapFilter, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public String[] getSMIMELdapFilter() {
        return getMultiAttr(Provisioning.A_zimbraSMIMELdapFilter, true, true);
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapFilter new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public void setSMIMELdapFilter(String[] zimbraSMIMELdapFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapFilter, zimbraSMIMELdapFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapFilter new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public Map<String,Object> setSMIMELdapFilter(String[] zimbraSMIMELdapFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapFilter, zimbraSMIMELdapFilter);
        return attrs;
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapFilter new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public void addSMIMELdapFilter(String zimbraSMIMELdapFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapFilter, zimbraSMIMELdapFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapFilter new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public Map<String,Object> addSMIMELdapFilter(String zimbraSMIMELdapFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapFilter, zimbraSMIMELdapFilter);
        return attrs;
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapFilter existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public void removeSMIMELdapFilter(String zimbraSMIMELdapFilter) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapFilter, zimbraSMIMELdapFilter);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param zimbraSMIMELdapFilter existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public Map<String,Object> removeSMIMELdapFilter(String zimbraSMIMELdapFilter, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapFilter, zimbraSMIMELdapFilter);
        return attrs;
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public void unsetSMIMELdapFilter() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapFilter, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search filter for public key lookup for S/MIME via external LDAP.
     * Can contain the following conversion variables for expansion: %n -
     * search key with @ (or without, if no @ was specified) %u - with @
     * removed e.g. (mail=%n) All SMIME attributes are in the format of
     * {config-name}:{value}. A &#039;SMIME config&#039; is a set of SMIME
     * attribute values with the same {config-name}. Multiple SMIME configs
     * can be configured on a domain or on globalconfig. Note: SMIME
     * attributes on domains do not inherited values from globalconfig, they
     * are not domain-inherited attributes. During SMIME public key lookup,
     * if there are any SMIME config on the domain of the account, they are
     * used. SMIME configs on globalconfig will be used only when there is no
     * SMIME config on the domain. SMIME attributes cannot be modified
     * directly with zmprov md/mcf commands. Use zmprov
     * gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command instead.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1181)
    public Map<String,Object> unsetSMIMELdapFilter(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapFilter, "");
        return attrs;
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @return zimbraSMIMELdapSearchBase, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public String[] getSMIMELdapSearchBase() {
        return getMultiAttr(Provisioning.A_zimbraSMIMELdapSearchBase, true, true);
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapSearchBase new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public void setSMIMELdapSearchBase(String[] zimbraSMIMELdapSearchBase) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapSearchBase, zimbraSMIMELdapSearchBase);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapSearchBase new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public Map<String,Object> setSMIMELdapSearchBase(String[] zimbraSMIMELdapSearchBase, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapSearchBase, zimbraSMIMELdapSearchBase);
        return attrs;
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapSearchBase new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public void addSMIMELdapSearchBase(String zimbraSMIMELdapSearchBase) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapSearchBase, zimbraSMIMELdapSearchBase);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapSearchBase new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public Map<String,Object> addSMIMELdapSearchBase(String zimbraSMIMELdapSearchBase, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapSearchBase, zimbraSMIMELdapSearchBase);
        return attrs;
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapSearchBase existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public void removeSMIMELdapSearchBase(String zimbraSMIMELdapSearchBase) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapSearchBase, zimbraSMIMELdapSearchBase);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapSearchBase existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public Map<String,Object> removeSMIMELdapSearchBase(String zimbraSMIMELdapSearchBase, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapSearchBase, zimbraSMIMELdapSearchBase);
        return attrs;
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public void unsetSMIMELdapSearchBase() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapSearchBase, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP search base for public key lookup for S/MIME via external LDAP.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1180)
    public Map<String,Object> unsetSMIMELdapSearchBase(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapSearchBase, "");
        return attrs;
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @return zimbraSMIMELdapStartTlsEnabled, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public String[] getSMIMELdapStartTlsEnabled() {
        return getMultiAttr(Provisioning.A_zimbraSMIMELdapStartTlsEnabled, true, true);
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapStartTlsEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public void setSMIMELdapStartTlsEnabled(String[] zimbraSMIMELdapStartTlsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapStartTlsEnabled, zimbraSMIMELdapStartTlsEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapStartTlsEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public Map<String,Object> setSMIMELdapStartTlsEnabled(String[] zimbraSMIMELdapStartTlsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapStartTlsEnabled, zimbraSMIMELdapStartTlsEnabled);
        return attrs;
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapStartTlsEnabled new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public void addSMIMELdapStartTlsEnabled(String zimbraSMIMELdapStartTlsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapStartTlsEnabled, zimbraSMIMELdapStartTlsEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapStartTlsEnabled new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public Map<String,Object> addSMIMELdapStartTlsEnabled(String zimbraSMIMELdapStartTlsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapStartTlsEnabled, zimbraSMIMELdapStartTlsEnabled);
        return attrs;
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapStartTlsEnabled existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public void removeSMIMELdapStartTlsEnabled(String zimbraSMIMELdapStartTlsEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapStartTlsEnabled, zimbraSMIMELdapStartTlsEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapStartTlsEnabled existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public Map<String,Object> removeSMIMELdapStartTlsEnabled(String zimbraSMIMELdapStartTlsEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapStartTlsEnabled, zimbraSMIMELdapStartTlsEnabled);
        return attrs;
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public void unsetSMIMELdapStartTlsEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapStartTlsEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use startTLS for public key lookup for S/MIME via external
     * LDAP. All SMIME attributes are in the format of {config-name}:{value}.
     * A &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1177)
    public Map<String,Object> unsetSMIMELdapStartTlsEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapStartTlsEnabled, "");
        return attrs;
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @return zimbraSMIMELdapURL, or empty array if unset
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public String[] getSMIMELdapURL() {
        return getMultiAttr(Provisioning.A_zimbraSMIMELdapURL, true, true);
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public void setSMIMELdapURL(String[] zimbraSMIMELdapURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapURL, zimbraSMIMELdapURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public Map<String,Object> setSMIMELdapURL(String[] zimbraSMIMELdapURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapURL, zimbraSMIMELdapURL);
        return attrs;
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public void addSMIMELdapURL(String zimbraSMIMELdapURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapURL, zimbraSMIMELdapURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public Map<String,Object> addSMIMELdapURL(String zimbraSMIMELdapURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSMIMELdapURL, zimbraSMIMELdapURL);
        return attrs;
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public void removeSMIMELdapURL(String zimbraSMIMELdapURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapURL, zimbraSMIMELdapURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param zimbraSMIMELdapURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public Map<String,Object> removeSMIMELdapURL(String zimbraSMIMELdapURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSMIMELdapURL, zimbraSMIMELdapURL);
        return attrs;
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public void unsetSMIMELdapURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * LDAP URL(s) for public key lookup for S/MIME via external LDAP.
     * Multiple URLs for error fallback purpose can be separated by space.
     * All SMIME attributes are in the format of {config-name}:{value}. A
     * &#039;SMIME config&#039; is a set of SMIME attribute values with the
     * same {config-name}. Multiple SMIME configs can be configured on a
     * domain or on globalconfig. Note: SMIME attributes on domains do not
     * inherited values from globalconfig, they are not domain-inherited
     * attributes. During SMIME public key lookup, if there are any SMIME
     * config on the domain of the account, they are used. SMIME configs on
     * globalconfig will be used only when there is no SMIME config on the
     * domain. SMIME attributes cannot be modified directly with zmprov
     * md/mcf commands. Use zmprov gcsc/gdsc/mcsc/mdsc/rcsc/rdsc command
     * instead.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.0
     */
    @ZAttr(id=1176)
    public Map<String,Object> unsetSMIMELdapURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSMIMELdapURL, "");
        return attrs;
    }

    /**
     * Specifies the JedisPool size used by SSDBEphemeralStore. Higher pool
     * sizes allow for more simultaneous connections to SSDB. A value of 0
     * will cause the pool size to be unlimited.
     *
     * @return zimbraSSDBResourcePoolSize, or 0 if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3010)
    public int getSSDBResourcePoolSize() {
        return getIntAttr(Provisioning.A_zimbraSSDBResourcePoolSize, 0, true);
    }

    /**
     * Specifies the JedisPool size used by SSDBEphemeralStore. Higher pool
     * sizes allow for more simultaneous connections to SSDB. A value of 0
     * will cause the pool size to be unlimited.
     *
     * @param zimbraSSDBResourcePoolSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3010)
    public void setSSDBResourcePoolSize(int zimbraSSDBResourcePoolSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSDBResourcePoolSize, Integer.toString(zimbraSSDBResourcePoolSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies the JedisPool size used by SSDBEphemeralStore. Higher pool
     * sizes allow for more simultaneous connections to SSDB. A value of 0
     * will cause the pool size to be unlimited.
     *
     * @param zimbraSSDBResourcePoolSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3010)
    public Map<String,Object> setSSDBResourcePoolSize(int zimbraSSDBResourcePoolSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSDBResourcePoolSize, Integer.toString(zimbraSSDBResourcePoolSize));
        return attrs;
    }

    /**
     * Specifies the JedisPool size used by SSDBEphemeralStore. Higher pool
     * sizes allow for more simultaneous connections to SSDB. A value of 0
     * will cause the pool size to be unlimited.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3010)
    public void unsetSSDBResourcePoolSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSDBResourcePoolSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies the JedisPool size used by SSDBEphemeralStore. Higher pool
     * sizes allow for more simultaneous connections to SSDB. A value of 0
     * will cause the pool size to be unlimited.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3010)
    public Map<String,Object> unsetSSDBResourcePoolSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSDBResourcePoolSize, "");
        return attrs;
    }

    /**
     * Specifies the amount of time a thread will wait for a JedisPool
     * resource. A value of 0 will cause the thread to block indefinitely..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getSSDBResourcePoolTimeoutAsString to access value as a string.
     *
     * @see #getSSDBResourcePoolTimeoutAsString()
     *
     * @return zimbraSSDBResourcePoolTimeout in millseconds, or 0 (0)  if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3011)
    public long getSSDBResourcePoolTimeout() {
        return getTimeInterval(Provisioning.A_zimbraSSDBResourcePoolTimeout, 0L, true);
    }

    /**
     * Specifies the amount of time a thread will wait for a JedisPool
     * resource. A value of 0 will cause the thread to block indefinitely..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraSSDBResourcePoolTimeout, or "0" if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3011)
    public String getSSDBResourcePoolTimeoutAsString() {
        return getAttr(Provisioning.A_zimbraSSDBResourcePoolTimeout, "0", true);
    }

    /**
     * Specifies the amount of time a thread will wait for a JedisPool
     * resource. A value of 0 will cause the thread to block indefinitely..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraSSDBResourcePoolTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3011)
    public void setSSDBResourcePoolTimeout(String zimbraSSDBResourcePoolTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSDBResourcePoolTimeout, zimbraSSDBResourcePoolTimeout);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies the amount of time a thread will wait for a JedisPool
     * resource. A value of 0 will cause the thread to block indefinitely..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraSSDBResourcePoolTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3011)
    public Map<String,Object> setSSDBResourcePoolTimeout(String zimbraSSDBResourcePoolTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSDBResourcePoolTimeout, zimbraSSDBResourcePoolTimeout);
        return attrs;
    }

    /**
     * Specifies the amount of time a thread will wait for a JedisPool
     * resource. A value of 0 will cause the thread to block indefinitely..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3011)
    public void unsetSSDBResourcePoolTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSDBResourcePoolTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specifies the amount of time a thread will wait for a JedisPool
     * resource. A value of 0 will cause the thread to block indefinitely..
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=3011)
    public Map<String,Object> unsetSSDBResourcePoolTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSDBResourcePoolTimeout, "");
        return attrs;
    }

    /**
     * SSL certificate
     *
     * @return zimbraSSLCertificate, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=563)
    public String getSSLCertificate() {
        return getAttr(Provisioning.A_zimbraSSLCertificate, null, true);
    }

    /**
     * SSL certificate
     *
     * @param zimbraSSLCertificate new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=563)
    public void setSSLCertificate(String zimbraSSLCertificate) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLCertificate, zimbraSSLCertificate);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL certificate
     *
     * @param zimbraSSLCertificate new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=563)
    public Map<String,Object> setSSLCertificate(String zimbraSSLCertificate, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLCertificate, zimbraSSLCertificate);
        return attrs;
    }

    /**
     * SSL certificate
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=563)
    public void unsetSSLCertificate() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLCertificate, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL certificate
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=563)
    public Map<String,Object> unsetSSLCertificate(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLCertificate, "");
        return attrs;
    }

    /**
     * PEM formatted DH parameters for SSL
     *
     * @return zimbraSSLDHParam, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1968)
    public byte[] getSSLDHParam() {
        return getBinaryAttr(Provisioning.A_zimbraSSLDHParam, true);
    }

    /**
     * PEM formatted DH parameters for SSL
     *
     * @return zimbraSSLDHParam, or null if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1968)
    public String getSSLDHParamAsString() {
        return getAttr(Provisioning.A_zimbraSSLDHParam, null, true);
    }

    /**
     * PEM formatted DH parameters for SSL
     *
     * @param zimbraSSLDHParam new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1968)
    public void setSSLDHParam(byte[] zimbraSSLDHParam) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLDHParam, zimbraSSLDHParam==null ? "" : ByteUtil.encodeLDAPBase64(zimbraSSLDHParam));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * PEM formatted DH parameters for SSL
     *
     * @param zimbraSSLDHParam new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1968)
    public Map<String,Object> setSSLDHParam(byte[] zimbraSSLDHParam, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLDHParam, zimbraSSLDHParam==null ? "" : ByteUtil.encodeLDAPBase64(zimbraSSLDHParam));
        return attrs;
    }

    /**
     * PEM formatted DH parameters for SSL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1968)
    public void unsetSSLDHParam() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLDHParam, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * PEM formatted DH parameters for SSL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1968)
    public Map<String,Object> unsetSSLDHParam(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLDHParam, "");
        return attrs;
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @return zimbraSSLExcludeCipherSuites, or empty array if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public String[] getSSLExcludeCipherSuites() {
        String[] value = getMultiAttr(Provisioning.A_zimbraSSLExcludeCipherSuites, true, true); return value.length > 0 ? value : new String[] {".*_RC4_.*"};
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @param zimbraSSLExcludeCipherSuites new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public void setSSLExcludeCipherSuites(String[] zimbraSSLExcludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLExcludeCipherSuites, zimbraSSLExcludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @param zimbraSSLExcludeCipherSuites new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public Map<String,Object> setSSLExcludeCipherSuites(String[] zimbraSSLExcludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLExcludeCipherSuites, zimbraSSLExcludeCipherSuites);
        return attrs;
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @param zimbraSSLExcludeCipherSuites new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public void addSSLExcludeCipherSuites(String zimbraSSLExcludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSSLExcludeCipherSuites, zimbraSSLExcludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @param zimbraSSLExcludeCipherSuites new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public Map<String,Object> addSSLExcludeCipherSuites(String zimbraSSLExcludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSSLExcludeCipherSuites, zimbraSSLExcludeCipherSuites);
        return attrs;
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @param zimbraSSLExcludeCipherSuites existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public void removeSSLExcludeCipherSuites(String zimbraSSLExcludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSSLExcludeCipherSuites, zimbraSSLExcludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @param zimbraSSLExcludeCipherSuites existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public Map<String,Object> removeSSLExcludeCipherSuites(String zimbraSSLExcludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSSLExcludeCipherSuites, zimbraSSLExcludeCipherSuites);
        return attrs;
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public void unsetSSLExcludeCipherSuites() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLExcludeCipherSuites, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * exact name or regular expression of cipher suites to exclude
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=639)
    public Map<String,Object> unsetSSLExcludeCipherSuites(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLExcludeCipherSuites, "");
        return attrs;
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @return zimbraSSLIncludeCipherSuites, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public String[] getSSLIncludeCipherSuites() {
        return getMultiAttr(Provisioning.A_zimbraSSLIncludeCipherSuites, true, true);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public void setSSLIncludeCipherSuites(String[] zimbraSSLIncludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public Map<String,Object> setSSLIncludeCipherSuites(String[] zimbraSSLIncludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        return attrs;
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public void addSSLIncludeCipherSuites(String zimbraSSLIncludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public Map<String,Object> addSSLIncludeCipherSuites(String zimbraSSLIncludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        return attrs;
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public void removeSSLIncludeCipherSuites(String zimbraSSLIncludeCipherSuites) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param zimbraSSLIncludeCipherSuites existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public Map<String,Object> removeSSLIncludeCipherSuites(String zimbraSSLIncludeCipherSuites, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSSLIncludeCipherSuites, zimbraSSLIncludeCipherSuites);
        return attrs;
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public void unsetSSLIncludeCipherSuites() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLIncludeCipherSuites, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of included cipher suites for Jetty. If any value is set only
     * these ciphers will be used, in effect superseding
     * zimbraSSLExcludeCipherSuites. Order of selection is based on client
     * preference and default Java order since Java SSLEngine does not allow
     * changing the preference order.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1604)
    public Map<String,Object> unsetSSLIncludeCipherSuites(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLIncludeCipherSuites, "");
        return attrs;
    }

    /**
     * SSL private key
     *
     * @return zimbraSSLPrivateKey, or null if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=564)
    public String getSSLPrivateKey() {
        return getAttr(Provisioning.A_zimbraSSLPrivateKey, null, true);
    }

    /**
     * SSL private key
     *
     * @param zimbraSSLPrivateKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=564)
    public void setSSLPrivateKey(String zimbraSSLPrivateKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLPrivateKey, zimbraSSLPrivateKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL private key
     *
     * @param zimbraSSLPrivateKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=564)
    public Map<String,Object> setSSLPrivateKey(String zimbraSSLPrivateKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLPrivateKey, zimbraSSLPrivateKey);
        return attrs;
    }

    /**
     * SSL private key
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=564)
    public void unsetSSLPrivateKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLPrivateKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SSL private key
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=564)
    public Map<String,Object> unsetSSLPrivateKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSSLPrivateKey, "");
        return attrs;
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @return zimbraSaslGssapiRequiresTls, or false if unset
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public boolean isSaslGssapiRequiresTls() {
        return getBooleanAttr(Provisioning.A_zimbraSaslGssapiRequiresTls, false, true);
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @param zimbraSaslGssapiRequiresTls new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public void setSaslGssapiRequiresTls(boolean zimbraSaslGssapiRequiresTls) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSaslGssapiRequiresTls, zimbraSaslGssapiRequiresTls ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @param zimbraSaslGssapiRequiresTls new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public Map<String,Object> setSaslGssapiRequiresTls(boolean zimbraSaslGssapiRequiresTls, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSaslGssapiRequiresTls, zimbraSaslGssapiRequiresTls ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public void unsetSaslGssapiRequiresTls() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSaslGssapiRequiresTls, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether TLS is required for IMAP/POP GSSAPI auth
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.20
     */
    @ZAttr(id=1068)
    public Map<String,Object> unsetSaslGssapiRequiresTls(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSaslGssapiRequiresTls, "");
        return attrs;
    }

    /**
     * The initial retry delay for the exponential backoff algorithm. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getScheduledTaskInitialRetryDelayAsString to access value as a string.
     *
     * @see #getScheduledTaskInitialRetryDelayAsString()
     *
     * @return zimbraScheduledTaskInitialRetryDelay in millseconds, or 5000 (5s)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2069)
    public long getScheduledTaskInitialRetryDelay() {
        return getTimeInterval(Provisioning.A_zimbraScheduledTaskInitialRetryDelay, 5000L, true);
    }

    /**
     * The initial retry delay for the exponential backoff algorithm. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraScheduledTaskInitialRetryDelay, or "5s" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2069)
    public String getScheduledTaskInitialRetryDelayAsString() {
        return getAttr(Provisioning.A_zimbraScheduledTaskInitialRetryDelay, "5s", true);
    }

    /**
     * The initial retry delay for the exponential backoff algorithm. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraScheduledTaskInitialRetryDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2069)
    public void setScheduledTaskInitialRetryDelay(String zimbraScheduledTaskInitialRetryDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskInitialRetryDelay, zimbraScheduledTaskInitialRetryDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The initial retry delay for the exponential backoff algorithm. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraScheduledTaskInitialRetryDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2069)
    public Map<String,Object> setScheduledTaskInitialRetryDelay(String zimbraScheduledTaskInitialRetryDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskInitialRetryDelay, zimbraScheduledTaskInitialRetryDelay);
        return attrs;
    }

    /**
     * The initial retry delay for the exponential backoff algorithm. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2069)
    public void unsetScheduledTaskInitialRetryDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskInitialRetryDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The initial retry delay for the exponential backoff algorithm. Must be
     * in valid duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2069)
    public Map<String,Object> unsetScheduledTaskInitialRetryDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskInitialRetryDelay, "");
        return attrs;
    }

    /**
     * The maximum number of times a scheduled task can be retried upon
     * failure. A value of 0 means no maximum
     *
     * @return zimbraScheduledTaskMaxRetries, or 10 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2068)
    public int getScheduledTaskMaxRetries() {
        return getIntAttr(Provisioning.A_zimbraScheduledTaskMaxRetries, 10, true);
    }

    /**
     * The maximum number of times a scheduled task can be retried upon
     * failure. A value of 0 means no maximum
     *
     * @param zimbraScheduledTaskMaxRetries new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2068)
    public void setScheduledTaskMaxRetries(int zimbraScheduledTaskMaxRetries) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskMaxRetries, Integer.toString(zimbraScheduledTaskMaxRetries));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum number of times a scheduled task can be retried upon
     * failure. A value of 0 means no maximum
     *
     * @param zimbraScheduledTaskMaxRetries new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2068)
    public Map<String,Object> setScheduledTaskMaxRetries(int zimbraScheduledTaskMaxRetries, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskMaxRetries, Integer.toString(zimbraScheduledTaskMaxRetries));
        return attrs;
    }

    /**
     * The maximum number of times a scheduled task can be retried upon
     * failure. A value of 0 means no maximum
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2068)
    public void unsetScheduledTaskMaxRetries() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskMaxRetries, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum number of times a scheduled task can be retried upon
     * failure. A value of 0 means no maximum
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2068)
    public Map<String,Object> unsetScheduledTaskMaxRetries(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskMaxRetries, "");
        return attrs;
    }

    /**
     * The maximum retry delay for the exponential backoff algorithm, or 0
     * for no maximum. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * <p>Use getScheduledTaskMaxRetryDelayAsString to access value as a string.
     *
     * @see #getScheduledTaskMaxRetryDelayAsString()
     *
     * @return zimbraScheduledTaskMaxRetryDelay in millseconds, or 600000 (10m)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2070)
    public long getScheduledTaskMaxRetryDelay() {
        return getTimeInterval(Provisioning.A_zimbraScheduledTaskMaxRetryDelay, 600000L, true);
    }

    /**
     * The maximum retry delay for the exponential backoff algorithm, or 0
     * for no maximum. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @return zimbraScheduledTaskMaxRetryDelay, or "10m" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2070)
    public String getScheduledTaskMaxRetryDelayAsString() {
        return getAttr(Provisioning.A_zimbraScheduledTaskMaxRetryDelay, "10m", true);
    }

    /**
     * The maximum retry delay for the exponential backoff algorithm, or 0
     * for no maximum. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraScheduledTaskMaxRetryDelay new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2070)
    public void setScheduledTaskMaxRetryDelay(String zimbraScheduledTaskMaxRetryDelay) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskMaxRetryDelay, zimbraScheduledTaskMaxRetryDelay);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum retry delay for the exponential backoff algorithm, or 0
     * for no maximum. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param zimbraScheduledTaskMaxRetryDelay new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2070)
    public Map<String,Object> setScheduledTaskMaxRetryDelay(String zimbraScheduledTaskMaxRetryDelay, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskMaxRetryDelay, zimbraScheduledTaskMaxRetryDelay);
        return attrs;
    }

    /**
     * The maximum retry delay for the exponential backoff algorithm, or 0
     * for no maximum. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2070)
    public void unsetScheduledTaskMaxRetryDelay() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskMaxRetryDelay, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The maximum retry delay for the exponential backoff algorithm, or 0
     * for no maximum. Must be in valid duration format: {digits}{time-unit}.
     * digits: 0-9, time-unit: [hmsd]|ms. h - hours, m - minutes, s -
     * seconds, d - days, ms - milliseconds. If time unit is not specified,
     * the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2070)
    public Map<String,Object> unsetScheduledTaskMaxRetryDelay(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskMaxRetryDelay, "");
        return attrs;
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @return zimbraScheduledTaskNumThreads, or 20 if unset
     */
    @ZAttr(id=522)
    public int getScheduledTaskNumThreads() {
        return getIntAttr(Provisioning.A_zimbraScheduledTaskNumThreads, 20, true);
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @param zimbraScheduledTaskNumThreads new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=522)
    public void setScheduledTaskNumThreads(int zimbraScheduledTaskNumThreads) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskNumThreads, Integer.toString(zimbraScheduledTaskNumThreads));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @param zimbraScheduledTaskNumThreads new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=522)
    public Map<String,Object> setScheduledTaskNumThreads(int zimbraScheduledTaskNumThreads, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskNumThreads, Integer.toString(zimbraScheduledTaskNumThreads));
        return attrs;
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=522)
    public void unsetScheduledTaskNumThreads() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskNumThreads, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of scheduled tasks that can run simultaneously.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=522)
    public Map<String,Object> unsetScheduledTaskNumThreads(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskNumThreads, "");
        return attrs;
    }

    /**
     * Whether to retry, after a delay, scheduled tasks upon failure
     *
     * @return zimbraScheduledTaskRetry, or true if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2067)
    public boolean isScheduledTaskRetry() {
        return getBooleanAttr(Provisioning.A_zimbraScheduledTaskRetry, true, true);
    }

    /**
     * Whether to retry, after a delay, scheduled tasks upon failure
     *
     * @param zimbraScheduledTaskRetry new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2067)
    public void setScheduledTaskRetry(boolean zimbraScheduledTaskRetry) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetry, zimbraScheduledTaskRetry ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to retry, after a delay, scheduled tasks upon failure
     *
     * @param zimbraScheduledTaskRetry new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2067)
    public Map<String,Object> setScheduledTaskRetry(boolean zimbraScheduledTaskRetry, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetry, zimbraScheduledTaskRetry ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to retry, after a delay, scheduled tasks upon failure
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2067)
    public void unsetScheduledTaskRetry() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetry, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to retry, after a delay, scheduled tasks upon failure
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2067)
    public Map<String,Object> unsetScheduledTaskRetry(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetry, "");
        return attrs;
    }

    /**
     * The algorithm for determining how long the task scheduler should delay
     * a task attempt upon failure
     *
     * <p>Valid values: [constant, linear, exponential]
     *
     * @return zimbraScheduledTaskRetryPolicy, or ZAttrProvisioning.ScheduledTaskRetryPolicy.exponential if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2071)
    public ZAttrProvisioning.ScheduledTaskRetryPolicy getScheduledTaskRetryPolicy() {
        try { String v = getAttr(Provisioning.A_zimbraScheduledTaskRetryPolicy, true, true); return v == null ? ZAttrProvisioning.ScheduledTaskRetryPolicy.exponential : ZAttrProvisioning.ScheduledTaskRetryPolicy.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ScheduledTaskRetryPolicy.exponential; }
    }

    /**
     * The algorithm for determining how long the task scheduler should delay
     * a task attempt upon failure
     *
     * <p>Valid values: [constant, linear, exponential]
     *
     * @return zimbraScheduledTaskRetryPolicy, or "exponential" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2071)
    public String getScheduledTaskRetryPolicyAsString() {
        return getAttr(Provisioning.A_zimbraScheduledTaskRetryPolicy, "exponential", true);
    }

    /**
     * The algorithm for determining how long the task scheduler should delay
     * a task attempt upon failure
     *
     * <p>Valid values: [constant, linear, exponential]
     *
     * @param zimbraScheduledTaskRetryPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2071)
    public void setScheduledTaskRetryPolicy(ZAttrProvisioning.ScheduledTaskRetryPolicy zimbraScheduledTaskRetryPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetryPolicy, zimbraScheduledTaskRetryPolicy.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The algorithm for determining how long the task scheduler should delay
     * a task attempt upon failure
     *
     * <p>Valid values: [constant, linear, exponential]
     *
     * @param zimbraScheduledTaskRetryPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2071)
    public Map<String,Object> setScheduledTaskRetryPolicy(ZAttrProvisioning.ScheduledTaskRetryPolicy zimbraScheduledTaskRetryPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetryPolicy, zimbraScheduledTaskRetryPolicy.toString());
        return attrs;
    }

    /**
     * The algorithm for determining how long the task scheduler should delay
     * a task attempt upon failure
     *
     * <p>Valid values: [constant, linear, exponential]
     *
     * @param zimbraScheduledTaskRetryPolicy new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2071)
    public void setScheduledTaskRetryPolicyAsString(String zimbraScheduledTaskRetryPolicy) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetryPolicy, zimbraScheduledTaskRetryPolicy);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The algorithm for determining how long the task scheduler should delay
     * a task attempt upon failure
     *
     * <p>Valid values: [constant, linear, exponential]
     *
     * @param zimbraScheduledTaskRetryPolicy new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2071)
    public Map<String,Object> setScheduledTaskRetryPolicyAsString(String zimbraScheduledTaskRetryPolicy, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetryPolicy, zimbraScheduledTaskRetryPolicy);
        return attrs;
    }

    /**
     * The algorithm for determining how long the task scheduler should delay
     * a task attempt upon failure
     *
     * <p>Valid values: [constant, linear, exponential]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2071)
    public void unsetScheduledTaskRetryPolicy() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetryPolicy, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The algorithm for determining how long the task scheduler should delay
     * a task attempt upon failure
     *
     * <p>Valid values: [constant, linear, exponential]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2071)
    public Map<String,Object> unsetScheduledTaskRetryPolicy(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraScheduledTaskRetryPolicy, "");
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @return zimbraServerExtraObjectClass, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public String[] getServerExtraObjectClass() {
        return getMultiAttr(Provisioning.A_zimbraServerExtraObjectClass, true, true);
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @param zimbraServerExtraObjectClass new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public void setServerExtraObjectClass(String[] zimbraServerExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraServerExtraObjectClass, zimbraServerExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @param zimbraServerExtraObjectClass new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public Map<String,Object> setServerExtraObjectClass(String[] zimbraServerExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraServerExtraObjectClass, zimbraServerExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @param zimbraServerExtraObjectClass new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public void addServerExtraObjectClass(String zimbraServerExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraServerExtraObjectClass, zimbraServerExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @param zimbraServerExtraObjectClass new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public Map<String,Object> addServerExtraObjectClass(String zimbraServerExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraServerExtraObjectClass, zimbraServerExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @param zimbraServerExtraObjectClass existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public void removeServerExtraObjectClass(String zimbraServerExtraObjectClass) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraServerExtraObjectClass, zimbraServerExtraObjectClass);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @param zimbraServerExtraObjectClass existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public Map<String,Object> removeServerExtraObjectClass(String zimbraServerExtraObjectClass, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraServerExtraObjectClass, zimbraServerExtraObjectClass);
        return attrs;
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public void unsetServerExtraObjectClass() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraServerExtraObjectClass, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Object classes to add when creating a zimbra server object.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=756)
    public Map<String,Object> unsetServerExtraObjectClass(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraServerExtraObjectClass, "");
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @return zimbraServerInheritedAttr, or empty array if unset
     */
    @ZAttr(id=62)
    public String[] getServerInheritedAttr() {
        return getMultiAttr(Provisioning.A_zimbraServerInheritedAttr, true, true);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @param zimbraServerInheritedAttr new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=62)
    public void setServerInheritedAttr(String[] zimbraServerInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraServerInheritedAttr, zimbraServerInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @param zimbraServerInheritedAttr new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=62)
    public Map<String,Object> setServerInheritedAttr(String[] zimbraServerInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraServerInheritedAttr, zimbraServerInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @param zimbraServerInheritedAttr new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=62)
    public void addServerInheritedAttr(String zimbraServerInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraServerInheritedAttr, zimbraServerInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @param zimbraServerInheritedAttr new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=62)
    public Map<String,Object> addServerInheritedAttr(String zimbraServerInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraServerInheritedAttr, zimbraServerInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @param zimbraServerInheritedAttr existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=62)
    public void removeServerInheritedAttr(String zimbraServerInheritedAttr) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraServerInheritedAttr, zimbraServerInheritedAttr);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @param zimbraServerInheritedAttr existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=62)
    public Map<String,Object> removeServerInheritedAttr(String zimbraServerInheritedAttr, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraServerInheritedAttr, zimbraServerInheritedAttr);
        return attrs;
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=62)
    public void unsetServerInheritedAttr() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraServerInheritedAttr, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 5.0. deprecated in favor of the serverInherited
     * flag. Orig desc: zimbraServer attrs that get inherited from global
     * config
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=62)
    public Map<String,Object> unsetServerInheritedAttr(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraServerInheritedAttr, "");
        return attrs;
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @return zimbraShareNotificationMtaAuthAccount, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public String getShareNotificationMtaAuthAccount() {
        return getAttr(Provisioning.A_zimbraShareNotificationMtaAuthAccount, null, true);
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public void setShareNotificationMtaAuthAccount(String zimbraShareNotificationMtaAuthAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthAccount, zimbraShareNotificationMtaAuthAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public Map<String,Object> setShareNotificationMtaAuthAccount(String zimbraShareNotificationMtaAuthAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthAccount, zimbraShareNotificationMtaAuthAccount);
        return attrs;
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public void unsetShareNotificationMtaAuthAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Account name for authenticating to share notification MTA.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1343)
    public Map<String,Object> unsetShareNotificationMtaAuthAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthAccount, "");
        return attrs;
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @return zimbraShareNotificationMtaAuthPassword, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public String getShareNotificationMtaAuthPassword() {
        return getAttr(Provisioning.A_zimbraShareNotificationMtaAuthPassword, null, true);
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthPassword new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public void setShareNotificationMtaAuthPassword(String zimbraShareNotificationMtaAuthPassword) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthPassword, zimbraShareNotificationMtaAuthPassword);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthPassword new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public Map<String,Object> setShareNotificationMtaAuthPassword(String zimbraShareNotificationMtaAuthPassword, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthPassword, zimbraShareNotificationMtaAuthPassword);
        return attrs;
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public void unsetShareNotificationMtaAuthPassword() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthPassword, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Password for authenticating to share notification MTA.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1344)
    public Map<String,Object> unsetShareNotificationMtaAuthPassword(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthPassword, "");
        return attrs;
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @return zimbraShareNotificationMtaAuthRequired, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public boolean isShareNotificationMtaAuthRequired() {
        return getBooleanAttr(Provisioning.A_zimbraShareNotificationMtaAuthRequired, false, true);
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthRequired new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public void setShareNotificationMtaAuthRequired(boolean zimbraShareNotificationMtaAuthRequired) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthRequired, zimbraShareNotificationMtaAuthRequired ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @param zimbraShareNotificationMtaAuthRequired new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public Map<String,Object> setShareNotificationMtaAuthRequired(boolean zimbraShareNotificationMtaAuthRequired, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthRequired, zimbraShareNotificationMtaAuthRequired ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public void unsetShareNotificationMtaAuthRequired() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthRequired, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to use credential to authenticate to share notification MTA.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1346)
    public Map<String,Object> unsetShareNotificationMtaAuthRequired(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaAuthRequired, "");
        return attrs;
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @return zimbraShareNotificationMtaConnectionType, or ZAttrProvisioning.ShareNotificationMtaConnectionType.CLEARTEXT if unset and/or has invalid value
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public ZAttrProvisioning.ShareNotificationMtaConnectionType getShareNotificationMtaConnectionType() {
        try { String v = getAttr(Provisioning.A_zimbraShareNotificationMtaConnectionType, true, true); return v == null ? ZAttrProvisioning.ShareNotificationMtaConnectionType.CLEARTEXT : ZAttrProvisioning.ShareNotificationMtaConnectionType.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.ShareNotificationMtaConnectionType.CLEARTEXT; }
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @return zimbraShareNotificationMtaConnectionType, or "CLEARTEXT" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public String getShareNotificationMtaConnectionTypeAsString() {
        return getAttr(Provisioning.A_zimbraShareNotificationMtaConnectionType, "CLEARTEXT", true);
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param zimbraShareNotificationMtaConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public void setShareNotificationMtaConnectionType(ZAttrProvisioning.ShareNotificationMtaConnectionType zimbraShareNotificationMtaConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, zimbraShareNotificationMtaConnectionType.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param zimbraShareNotificationMtaConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public Map<String,Object> setShareNotificationMtaConnectionType(ZAttrProvisioning.ShareNotificationMtaConnectionType zimbraShareNotificationMtaConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, zimbraShareNotificationMtaConnectionType.toString());
        return attrs;
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param zimbraShareNotificationMtaConnectionType new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public void setShareNotificationMtaConnectionTypeAsString(String zimbraShareNotificationMtaConnectionType) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, zimbraShareNotificationMtaConnectionType);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param zimbraShareNotificationMtaConnectionType new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public Map<String,Object> setShareNotificationMtaConnectionTypeAsString(String zimbraShareNotificationMtaConnectionType, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, zimbraShareNotificationMtaConnectionType);
        return attrs;
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public void unsetShareNotificationMtaConnectionType() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Connection mode when connecting to share notification MTA.
     *
     * <p>Valid values: [CLEARTEXT, SSL, STARTTLS]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1345)
    public Map<String,Object> unsetShareNotificationMtaConnectionType(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaConnectionType, "");
        return attrs;
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @return zimbraShareNotificationMtaEnabled, or false if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public boolean isShareNotificationMtaEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraShareNotificationMtaEnabled, false, true);
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @param zimbraShareNotificationMtaEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public void setShareNotificationMtaEnabled(boolean zimbraShareNotificationMtaEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaEnabled, zimbraShareNotificationMtaEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @param zimbraShareNotificationMtaEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public Map<String,Object> setShareNotificationMtaEnabled(boolean zimbraShareNotificationMtaEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaEnabled, zimbraShareNotificationMtaEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public void unsetShareNotificationMtaEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether share notification MTA is enabled.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1361)
    public Map<String,Object> unsetShareNotificationMtaEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaEnabled, "");
        return attrs;
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @return zimbraShareNotificationMtaHostname, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public String getShareNotificationMtaHostname() {
        return getAttr(Provisioning.A_zimbraShareNotificationMtaHostname, null, true);
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @param zimbraShareNotificationMtaHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public void setShareNotificationMtaHostname(String zimbraShareNotificationMtaHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaHostname, zimbraShareNotificationMtaHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @param zimbraShareNotificationMtaHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public Map<String,Object> setShareNotificationMtaHostname(String zimbraShareNotificationMtaHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaHostname, zimbraShareNotificationMtaHostname);
        return attrs;
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public void unsetShareNotificationMtaHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP hostname for share notification MTA used for sending email
     * notifications.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1341)
    public Map<String,Object> unsetShareNotificationMtaHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaHostname, "");
        return attrs;
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @return zimbraShareNotificationMtaPort, or -1 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public int getShareNotificationMtaPort() {
        return getIntAttr(Provisioning.A_zimbraShareNotificationMtaPort, -1, true);
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @param zimbraShareNotificationMtaPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public void setShareNotificationMtaPort(int zimbraShareNotificationMtaPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaPort, Integer.toString(zimbraShareNotificationMtaPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @param zimbraShareNotificationMtaPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public Map<String,Object> setShareNotificationMtaPort(int zimbraShareNotificationMtaPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaPort, Integer.toString(zimbraShareNotificationMtaPort));
        return attrs;
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public void unsetShareNotificationMtaPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * SMTP port for share notification MTA used for sending email
     * notifications.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1342)
    public Map<String,Object> unsetShareNotificationMtaPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShareNotificationMtaPort, "");
        return attrs;
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * <p>Use getSharingUpdatePublishIntervalAsString to access value as a string.
     *
     * @see #getSharingUpdatePublishIntervalAsString()
     *
     * @return zimbraSharingUpdatePublishInterval in millseconds, or 900000 (15m)  if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public long getSharingUpdatePublishInterval() {
        return getTimeInterval(Provisioning.A_zimbraSharingUpdatePublishInterval, 900000L, true);
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @return zimbraSharingUpdatePublishInterval, or "15m" if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public String getSharingUpdatePublishIntervalAsString() {
        return getAttr(Provisioning.A_zimbraSharingUpdatePublishInterval, "15m", true);
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraSharingUpdatePublishInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public void setSharingUpdatePublishInterval(String zimbraSharingUpdatePublishInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharingUpdatePublishInterval, zimbraSharingUpdatePublishInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param zimbraSharingUpdatePublishInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public Map<String,Object> setSharingUpdatePublishInterval(String zimbraSharingUpdatePublishInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharingUpdatePublishInterval, zimbraSharingUpdatePublishInterval);
        return attrs;
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public void unsetSharingUpdatePublishInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharingUpdatePublishInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Interval between successive executions of the task that publishes
     * shared item updates to LDAP. Must be in valid duration format:
     * {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h - hours, m -
     * minutes, s - seconds, d - days, ms - milliseconds. If time unit is not
     * specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1220)
    public Map<String,Object> unsetSharingUpdatePublishInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSharingUpdatePublishInterval, "");
        return attrs;
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getShortTermAllEffectiveRightsCacheExpirationAsString to access value as a string.
     *
     * @see #getShortTermAllEffectiveRightsCacheExpirationAsString()
     *
     * @return zimbraShortTermAllEffectiveRightsCacheExpiration in millseconds, or 50000 (50s)  if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1903)
    public long getShortTermAllEffectiveRightsCacheExpiration() {
        return getTimeInterval(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, 50000L, true);
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraShortTermAllEffectiveRightsCacheExpiration, or "50s" if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1903)
    public String getShortTermAllEffectiveRightsCacheExpirationAsString() {
        return getAttr(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, "50s", true);
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraShortTermAllEffectiveRightsCacheExpiration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1903)
    public void setShortTermAllEffectiveRightsCacheExpiration(String zimbraShortTermAllEffectiveRightsCacheExpiration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, zimbraShortTermAllEffectiveRightsCacheExpiration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraShortTermAllEffectiveRightsCacheExpiration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1903)
    public Map<String,Object> setShortTermAllEffectiveRightsCacheExpiration(String zimbraShortTermAllEffectiveRightsCacheExpiration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, zimbraShortTermAllEffectiveRightsCacheExpiration);
        return attrs;
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1903)
    public void unsetShortTermAllEffectiveRightsCacheExpiration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum time an entry in the short term All Effective Rights cache
     * will be regarded as valid. If value is 0, the cache is disabled. The
     * cache is particularly useful when significant use is made of delegated
     * administration. This cache can improve performance by avoiding
     * recomputing All Effective Rights of named entries like accounts
     * frequently in a short period of time. All Effective Rights are
     * computations of the rights that named entries like accounts have -
     * although when used, they are checked separately. The longer the value
     * of this setting is, the more stale the view of the details is likely
     * to be. For this reason, the maximum accepted value is 30m. Larger
     * values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1903)
    public Map<String,Object> unsetShortTermAllEffectiveRightsCacheExpiration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheExpiration, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @return zimbraShortTermAllEffectiveRightsCacheSize, or 128 if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1902)
    public int getShortTermAllEffectiveRightsCacheSize() {
        return getIntAttr(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, 128, true);
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @param zimbraShortTermAllEffectiveRightsCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1902)
    public void setShortTermAllEffectiveRightsCacheSize(int zimbraShortTermAllEffectiveRightsCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, Integer.toString(zimbraShortTermAllEffectiveRightsCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @param zimbraShortTermAllEffectiveRightsCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1902)
    public Map<String,Object> setShortTermAllEffectiveRightsCacheSize(int zimbraShortTermAllEffectiveRightsCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, Integer.toString(zimbraShortTermAllEffectiveRightsCacheSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1902)
    public void unsetShortTermAllEffectiveRightsCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the short term All Effective Rights
     * cache. This cache can improve performance by avoiding recomputing All
     * Effective Rights of named entries like accounts frequently in a short
     * period of time. Can disable the cache be specifying a value of 0
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1902)
    public Map<String,Object> unsetShortTermAllEffectiveRightsCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermAllEffectiveRightsCacheSize, "");
        return attrs;
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getShortTermGranteeCacheExpirationAsString to access value as a string.
     *
     * @see #getShortTermGranteeCacheExpirationAsString()
     *
     * @return zimbraShortTermGranteeCacheExpiration in millseconds, or 50000 (50s)  if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1901)
    public long getShortTermGranteeCacheExpiration() {
        return getTimeInterval(Provisioning.A_zimbraShortTermGranteeCacheExpiration, 50000L, true);
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraShortTermGranteeCacheExpiration, or "50s" if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1901)
    public String getShortTermGranteeCacheExpirationAsString() {
        return getAttr(Provisioning.A_zimbraShortTermGranteeCacheExpiration, "50s", true);
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraShortTermGranteeCacheExpiration new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1901)
    public void setShortTermGranteeCacheExpiration(String zimbraShortTermGranteeCacheExpiration) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheExpiration, zimbraShortTermGranteeCacheExpiration);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraShortTermGranteeCacheExpiration new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1901)
    public Map<String,Object> setShortTermGranteeCacheExpiration(String zimbraShortTermGranteeCacheExpiration, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheExpiration, zimbraShortTermGranteeCacheExpiration);
        return attrs;
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1901)
    public void unsetShortTermGranteeCacheExpiration() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheExpiration, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum time an entry in the Grantee cache will be regarded as valid.
     * If value is 0, the cache is disabled. This cache can improve
     * performance by avoiding recomputing details frequently in a short
     * period of time, for instance for each entry in search results. The
     * cache is particularly useful when significant use is made of delegated
     * administration. Grantees objects provide a view of what rights a
     * grantee has - although those are checked separately. The longer the
     * value of this setting is, the more stale the view of the details is
     * likely to be. For this reason, the maximum accepted value is 30m.
     * Larger values will be treated as being 30m . Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1901)
    public Map<String,Object> unsetShortTermGranteeCacheExpiration(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheExpiration, "");
        return attrs;
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @return zimbraShortTermGranteeCacheSize, or 128 if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1900)
    public int getShortTermGranteeCacheSize() {
        return getIntAttr(Provisioning.A_zimbraShortTermGranteeCacheSize, 128, true);
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @param zimbraShortTermGranteeCacheSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1900)
    public void setShortTermGranteeCacheSize(int zimbraShortTermGranteeCacheSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheSize, Integer.toString(zimbraShortTermGranteeCacheSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @param zimbraShortTermGranteeCacheSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1900)
    public Map<String,Object> setShortTermGranteeCacheSize(int zimbraShortTermGranteeCacheSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheSize, Integer.toString(zimbraShortTermGranteeCacheSize));
        return attrs;
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1900)
    public void unsetShortTermGranteeCacheSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum number of entries in the short term Grantee cache. This cache
     * can improve performance by avoiding recomputing details frequently in
     * a short period of time, for instance for each entry in search results.
     * Can disable the cache be specifying a value of 0
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1900)
    public Map<String,Object> unsetShortTermGranteeCacheSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraShortTermGranteeCacheSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * user-defined sieve rule.
     *
     * @return zimbraSieveFeatureVariablesEnabled, or false if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2096)
    public boolean isSieveFeatureVariablesEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraSieveFeatureVariablesEnabled, false, true);
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * user-defined sieve rule.
     *
     * @param zimbraSieveFeatureVariablesEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2096)
    public void setSieveFeatureVariablesEnabled(boolean zimbraSieveFeatureVariablesEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveFeatureVariablesEnabled, zimbraSieveFeatureVariablesEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * user-defined sieve rule.
     *
     * @param zimbraSieveFeatureVariablesEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2096)
    public Map<String,Object> setSieveFeatureVariablesEnabled(boolean zimbraSieveFeatureVariablesEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveFeatureVariablesEnabled, zimbraSieveFeatureVariablesEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * user-defined sieve rule.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2096)
    public void unsetSieveFeatureVariablesEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveFeatureVariablesEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. Variable feature is always enabled, hence
     * this attribute has been deprecated. Orig desc: Whether to enable the
     * Sieve &quot;Variables&quot; extension defined in RFC 5229 in the
     * user-defined sieve rule.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2096)
    public Map<String,Object> unsetSieveFeatureVariablesEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveFeatureVariablesEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveRejectMailEnabled, which can be used at account level. Orig
     * desc: Whether to enable the Sieve &quot;reject&quot; action defined in
     * RFC 5429.
     *
     * @return zimbraSieveRejectEnabled, or true if unset
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2094)
    public boolean isSieveRejectEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraSieveRejectEnabled, true, true);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveRejectMailEnabled, which can be used at account level. Orig
     * desc: Whether to enable the Sieve &quot;reject&quot; action defined in
     * RFC 5429.
     *
     * @param zimbraSieveRejectEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2094)
    public void setSieveRejectEnabled(boolean zimbraSieveRejectEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRejectEnabled, zimbraSieveRejectEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveRejectMailEnabled, which can be used at account level. Orig
     * desc: Whether to enable the Sieve &quot;reject&quot; action defined in
     * RFC 5429.
     *
     * @param zimbraSieveRejectEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2094)
    public Map<String,Object> setSieveRejectEnabled(boolean zimbraSieveRejectEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRejectEnabled, zimbraSieveRejectEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveRejectMailEnabled, which can be used at account level. Orig
     * desc: Whether to enable the Sieve &quot;reject&quot; action defined in
     * RFC 5429.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2094)
    public void unsetSieveRejectEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRejectEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.8. deprecated in favor of
     * zimbraSieveRejectMailEnabled, which can be used at account level. Orig
     * desc: Whether to enable the Sieve &quot;reject&quot; action defined in
     * RFC 5429.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.6
     */
    @ZAttr(id=2094)
    public Map<String,Object> unsetSieveRejectEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSieveRejectEnabled, "");
        return attrs;
    }

    /**
     * background color for chameleon skin for the domain
     *
     * @return zimbraSkinBackgroundColor, or null if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=648)
    public String getSkinBackgroundColor() {
        return getAttr(Provisioning.A_zimbraSkinBackgroundColor, null, true);
    }

    /**
     * background color for chameleon skin for the domain
     *
     * @param zimbraSkinBackgroundColor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=648)
    public void setSkinBackgroundColor(String zimbraSkinBackgroundColor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinBackgroundColor, zimbraSkinBackgroundColor);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * background color for chameleon skin for the domain
     *
     * @param zimbraSkinBackgroundColor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=648)
    public Map<String,Object> setSkinBackgroundColor(String zimbraSkinBackgroundColor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinBackgroundColor, zimbraSkinBackgroundColor);
        return attrs;
    }

    /**
     * background color for chameleon skin for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=648)
    public void unsetSkinBackgroundColor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinBackgroundColor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * background color for chameleon skin for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=648)
    public Map<String,Object> unsetSkinBackgroundColor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinBackgroundColor, "");
        return attrs;
    }

    /**
     * favicon for chameleon skin for the domain
     *
     * @return zimbraSkinFavicon, or null if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=800)
    public String getSkinFavicon() {
        return getAttr(Provisioning.A_zimbraSkinFavicon, null, true);
    }

    /**
     * favicon for chameleon skin for the domain
     *
     * @param zimbraSkinFavicon new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=800)
    public void setSkinFavicon(String zimbraSkinFavicon) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinFavicon, zimbraSkinFavicon);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * favicon for chameleon skin for the domain
     *
     * @param zimbraSkinFavicon new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=800)
    public Map<String,Object> setSkinFavicon(String zimbraSkinFavicon, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinFavicon, zimbraSkinFavicon);
        return attrs;
    }

    /**
     * favicon for chameleon skin for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=800)
    public void unsetSkinFavicon() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinFavicon, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * favicon for chameleon skin for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=800)
    public Map<String,Object> unsetSkinFavicon(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinFavicon, "");
        return attrs;
    }

    /**
     * foreground color for chameleon skin for the domain
     *
     * @return zimbraSkinForegroundColor, or null if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=647)
    public String getSkinForegroundColor() {
        return getAttr(Provisioning.A_zimbraSkinForegroundColor, null, true);
    }

    /**
     * foreground color for chameleon skin for the domain
     *
     * @param zimbraSkinForegroundColor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=647)
    public void setSkinForegroundColor(String zimbraSkinForegroundColor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinForegroundColor, zimbraSkinForegroundColor);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * foreground color for chameleon skin for the domain
     *
     * @param zimbraSkinForegroundColor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=647)
    public Map<String,Object> setSkinForegroundColor(String zimbraSkinForegroundColor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinForegroundColor, zimbraSkinForegroundColor);
        return attrs;
    }

    /**
     * foreground color for chameleon skin for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=647)
    public void unsetSkinForegroundColor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinForegroundColor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * foreground color for chameleon skin for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=647)
    public Map<String,Object> unsetSkinForegroundColor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinForegroundColor, "");
        return attrs;
    }

    /**
     * logo app banner for chameleon skin for the domain
     *
     * @return zimbraSkinLogoAppBanner, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=671)
    public String getSkinLogoAppBanner() {
        return getAttr(Provisioning.A_zimbraSkinLogoAppBanner, null, true);
    }

    /**
     * logo app banner for chameleon skin for the domain
     *
     * @param zimbraSkinLogoAppBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=671)
    public void setSkinLogoAppBanner(String zimbraSkinLogoAppBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoAppBanner, zimbraSkinLogoAppBanner);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * logo app banner for chameleon skin for the domain
     *
     * @param zimbraSkinLogoAppBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=671)
    public Map<String,Object> setSkinLogoAppBanner(String zimbraSkinLogoAppBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoAppBanner, zimbraSkinLogoAppBanner);
        return attrs;
    }

    /**
     * logo app banner for chameleon skin for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=671)
    public void unsetSkinLogoAppBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoAppBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * logo app banner for chameleon skin for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=671)
    public Map<String,Object> unsetSkinLogoAppBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoAppBanner, "");
        return attrs;
    }

    /**
     * logo login banner for chameleon skin for the domain
     *
     * @return zimbraSkinLogoLoginBanner, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=670)
    public String getSkinLogoLoginBanner() {
        return getAttr(Provisioning.A_zimbraSkinLogoLoginBanner, null, true);
    }

    /**
     * logo login banner for chameleon skin for the domain
     *
     * @param zimbraSkinLogoLoginBanner new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=670)
    public void setSkinLogoLoginBanner(String zimbraSkinLogoLoginBanner) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoLoginBanner, zimbraSkinLogoLoginBanner);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * logo login banner for chameleon skin for the domain
     *
     * @param zimbraSkinLogoLoginBanner new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=670)
    public Map<String,Object> setSkinLogoLoginBanner(String zimbraSkinLogoLoginBanner, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoLoginBanner, zimbraSkinLogoLoginBanner);
        return attrs;
    }

    /**
     * logo login banner for chameleon skin for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=670)
    public void unsetSkinLogoLoginBanner() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoLoginBanner, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * logo login banner for chameleon skin for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=670)
    public Map<String,Object> unsetSkinLogoLoginBanner(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoLoginBanner, "");
        return attrs;
    }

    /**
     * Logo URL for chameleon skin for the domain
     *
     * @return zimbraSkinLogoURL, or null if unset
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=649)
    public String getSkinLogoURL() {
        return getAttr(Provisioning.A_zimbraSkinLogoURL, null, true);
    }

    /**
     * Logo URL for chameleon skin for the domain
     *
     * @param zimbraSkinLogoURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=649)
    public void setSkinLogoURL(String zimbraSkinLogoURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoURL, zimbraSkinLogoURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Logo URL for chameleon skin for the domain
     *
     * @param zimbraSkinLogoURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=649)
    public Map<String,Object> setSkinLogoURL(String zimbraSkinLogoURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoURL, zimbraSkinLogoURL);
        return attrs;
    }

    /**
     * Logo URL for chameleon skin for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=649)
    public void unsetSkinLogoURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Logo URL for chameleon skin for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.6
     */
    @ZAttr(id=649)
    public Map<String,Object> unsetSkinLogoURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinLogoURL, "");
        return attrs;
    }

    /**
     * secondary color for chameleon skin for the domain
     *
     * @return zimbraSkinSecondaryColor, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=668)
    public String getSkinSecondaryColor() {
        return getAttr(Provisioning.A_zimbraSkinSecondaryColor, null, true);
    }

    /**
     * secondary color for chameleon skin for the domain
     *
     * @param zimbraSkinSecondaryColor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=668)
    public void setSkinSecondaryColor(String zimbraSkinSecondaryColor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinSecondaryColor, zimbraSkinSecondaryColor);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * secondary color for chameleon skin for the domain
     *
     * @param zimbraSkinSecondaryColor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=668)
    public Map<String,Object> setSkinSecondaryColor(String zimbraSkinSecondaryColor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinSecondaryColor, zimbraSkinSecondaryColor);
        return attrs;
    }

    /**
     * secondary color for chameleon skin for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=668)
    public void unsetSkinSecondaryColor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinSecondaryColor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * secondary color for chameleon skin for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=668)
    public Map<String,Object> unsetSkinSecondaryColor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinSecondaryColor, "");
        return attrs;
    }

    /**
     * selection color for chameleon skin for the domain
     *
     * @return zimbraSkinSelectionColor, or null if unset
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=669)
    public String getSkinSelectionColor() {
        return getAttr(Provisioning.A_zimbraSkinSelectionColor, null, true);
    }

    /**
     * selection color for chameleon skin for the domain
     *
     * @param zimbraSkinSelectionColor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=669)
    public void setSkinSelectionColor(String zimbraSkinSelectionColor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinSelectionColor, zimbraSkinSelectionColor);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * selection color for chameleon skin for the domain
     *
     * @param zimbraSkinSelectionColor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=669)
    public Map<String,Object> setSkinSelectionColor(String zimbraSkinSelectionColor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinSelectionColor, zimbraSkinSelectionColor);
        return attrs;
    }

    /**
     * selection color for chameleon skin for the domain
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=669)
    public void unsetSkinSelectionColor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinSelectionColor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * selection color for chameleon skin for the domain
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.7
     */
    @ZAttr(id=669)
    public Map<String,Object> unsetSkinSelectionColor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSkinSelectionColor, "");
        return attrs;
    }

    /**
     * enable OCSP support for SMIME.
     *
     * @return zimbraSmimeOCSPEnabled, or true if unset
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2101)
    public boolean isSmimeOCSPEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraSmimeOCSPEnabled, true, true);
    }

    /**
     * enable OCSP support for SMIME.
     *
     * @param zimbraSmimeOCSPEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2101)
    public void setSmimeOCSPEnabled(boolean zimbraSmimeOCSPEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimeOCSPEnabled, zimbraSmimeOCSPEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable OCSP support for SMIME.
     *
     * @param zimbraSmimeOCSPEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2101)
    public Map<String,Object> setSmimeOCSPEnabled(boolean zimbraSmimeOCSPEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimeOCSPEnabled, zimbraSmimeOCSPEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * enable OCSP support for SMIME.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2101)
    public void unsetSmimeOCSPEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimeOCSPEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * enable OCSP support for SMIME.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2101)
    public Map<String,Object> unsetSmimeOCSPEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimeOCSPEnabled, "");
        return attrs;
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @return zimbraSmimePublicCertificateExtensions, or empty array if unset
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public String[] getSmimePublicCertificateExtensions() {
        String[] value = getMultiAttr(Provisioning.A_zimbraSmimePublicCertificateExtensions, true, true); return value.length > 0 ? value : new String[] {"cer","crt","der","spc","p7b","p7r","sst","sto","pem"};
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @param zimbraSmimePublicCertificateExtensions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public void setSmimePublicCertificateExtensions(String[] zimbraSmimePublicCertificateExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimePublicCertificateExtensions, zimbraSmimePublicCertificateExtensions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @param zimbraSmimePublicCertificateExtensions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public Map<String,Object> setSmimePublicCertificateExtensions(String[] zimbraSmimePublicCertificateExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimePublicCertificateExtensions, zimbraSmimePublicCertificateExtensions);
        return attrs;
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @param zimbraSmimePublicCertificateExtensions new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public void addSmimePublicCertificateExtensions(String zimbraSmimePublicCertificateExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSmimePublicCertificateExtensions, zimbraSmimePublicCertificateExtensions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @param zimbraSmimePublicCertificateExtensions new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public Map<String,Object> addSmimePublicCertificateExtensions(String zimbraSmimePublicCertificateExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSmimePublicCertificateExtensions, zimbraSmimePublicCertificateExtensions);
        return attrs;
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @param zimbraSmimePublicCertificateExtensions existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public void removeSmimePublicCertificateExtensions(String zimbraSmimePublicCertificateExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSmimePublicCertificateExtensions, zimbraSmimePublicCertificateExtensions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @param zimbraSmimePublicCertificateExtensions existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public Map<String,Object> removeSmimePublicCertificateExtensions(String zimbraSmimePublicCertificateExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSmimePublicCertificateExtensions, zimbraSmimePublicCertificateExtensions);
        return attrs;
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public void unsetSmimePublicCertificateExtensions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimePublicCertificateExtensions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The supported smime public certificate file extensions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2100)
    public Map<String,Object> unsetSmimePublicCertificateExtensions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimePublicCertificateExtensions, "");
        return attrs;
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @return zimbraSmimeUserCertificateExtensions, or empty array if unset
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public String[] getSmimeUserCertificateExtensions() {
        String[] value = getMultiAttr(Provisioning.A_zimbraSmimeUserCertificateExtensions, true, true); return value.length > 0 ? value : new String[] {"p12","pfx"};
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @param zimbraSmimeUserCertificateExtensions new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public void setSmimeUserCertificateExtensions(String[] zimbraSmimeUserCertificateExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimeUserCertificateExtensions, zimbraSmimeUserCertificateExtensions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @param zimbraSmimeUserCertificateExtensions new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public Map<String,Object> setSmimeUserCertificateExtensions(String[] zimbraSmimeUserCertificateExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimeUserCertificateExtensions, zimbraSmimeUserCertificateExtensions);
        return attrs;
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @param zimbraSmimeUserCertificateExtensions new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public void addSmimeUserCertificateExtensions(String zimbraSmimeUserCertificateExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSmimeUserCertificateExtensions, zimbraSmimeUserCertificateExtensions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @param zimbraSmimeUserCertificateExtensions new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public Map<String,Object> addSmimeUserCertificateExtensions(String zimbraSmimeUserCertificateExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSmimeUserCertificateExtensions, zimbraSmimeUserCertificateExtensions);
        return attrs;
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @param zimbraSmimeUserCertificateExtensions existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public void removeSmimeUserCertificateExtensions(String zimbraSmimeUserCertificateExtensions) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSmimeUserCertificateExtensions, zimbraSmimeUserCertificateExtensions);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @param zimbraSmimeUserCertificateExtensions existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public Map<String,Object> removeSmimeUserCertificateExtensions(String zimbraSmimeUserCertificateExtensions, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSmimeUserCertificateExtensions, zimbraSmimeUserCertificateExtensions);
        return attrs;
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public void unsetSmimeUserCertificateExtensions() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimeUserCertificateExtensions, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The supported smime user certificate file extensions
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.5
     */
    @ZAttr(id=2099)
    public Map<String,Object> unsetSmimeUserCertificateExtensions(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmimeUserCertificateExtensions, "");
        return attrs;
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @return zimbraSmtpHostname, or empty array if unset
     */
    @ZAttr(id=97)
    public String[] getSmtpHostname() {
        String[] value = getMultiAttr(Provisioning.A_zimbraSmtpHostname, true, true); return value.length > 0 ? value : new String[] {"localhost"};
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=97)
    public void setSmtpHostname(String[] zimbraSmtpHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=97)
    public Map<String,Object> setSmtpHostname(String[] zimbraSmtpHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        return attrs;
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=97)
    public void addSmtpHostname(String zimbraSmtpHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=97)
    public Map<String,Object> addSmtpHostname(String zimbraSmtpHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        return attrs;
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=97)
    public void removeSmtpHostname(String zimbraSmtpHostname) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param zimbraSmtpHostname existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=97)
    public Map<String,Object> removeSmtpHostname(String zimbraSmtpHostname, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSmtpHostname, zimbraSmtpHostname);
        return attrs;
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=97)
    public void unsetSmtpHostname() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpHostname, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server to connect to when sending mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=97)
    public Map<String,Object> unsetSmtpHostname(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpHostname, "");
        return attrs;
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * <p>Use getSmtpPortAsString to access value as a string.
     *
     * @see #getSmtpPortAsString()
     *
     * @return zimbraSmtpPort, or 25 if unset
     */
    @ZAttr(id=98)
    public int getSmtpPort() {
        return getIntAttr(Provisioning.A_zimbraSmtpPort, 25, true);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @return zimbraSmtpPort, or "25" if unset
     */
    @ZAttr(id=98)
    public String getSmtpPortAsString() {
        return getAttr(Provisioning.A_zimbraSmtpPort, "25", true);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param zimbraSmtpPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=98)
    public void setSmtpPort(int zimbraSmtpPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, Integer.toString(zimbraSmtpPort));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param zimbraSmtpPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=98)
    public Map<String,Object> setSmtpPort(int zimbraSmtpPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, Integer.toString(zimbraSmtpPort));
        return attrs;
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param zimbraSmtpPort new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=98)
    public void setSmtpPortAsString(String zimbraSmtpPort) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, zimbraSmtpPort);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param zimbraSmtpPort new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=98)
    public Map<String,Object> setSmtpPortAsString(String zimbraSmtpPort, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, zimbraSmtpPort);
        return attrs;
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=98)
    public void unsetSmtpPort() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * the SMTP server port to connect to when sending mail
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=98)
    public Map<String,Object> unsetSmtpPort(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpPort, "");
        return attrs;
    }

    /**
     * If true, an X-Authenticated-User header will be added to messages sent
     * via SendMsgRequest.
     *
     * @return zimbraSmtpSendAddAuthenticatedUser, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=747)
    public boolean isSmtpSendAddAuthenticatedUser() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpSendAddAuthenticatedUser, false, true);
    }

    /**
     * If true, an X-Authenticated-User header will be added to messages sent
     * via SendMsgRequest.
     *
     * @param zimbraSmtpSendAddAuthenticatedUser new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=747)
    public void setSmtpSendAddAuthenticatedUser(boolean zimbraSmtpSendAddAuthenticatedUser) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddAuthenticatedUser, zimbraSmtpSendAddAuthenticatedUser ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, an X-Authenticated-User header will be added to messages sent
     * via SendMsgRequest.
     *
     * @param zimbraSmtpSendAddAuthenticatedUser new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=747)
    public Map<String,Object> setSmtpSendAddAuthenticatedUser(boolean zimbraSmtpSendAddAuthenticatedUser, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddAuthenticatedUser, zimbraSmtpSendAddAuthenticatedUser ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If true, an X-Authenticated-User header will be added to messages sent
     * via SendMsgRequest.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=747)
    public void unsetSmtpSendAddAuthenticatedUser() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddAuthenticatedUser, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If true, an X-Authenticated-User header will be added to messages sent
     * via SendMsgRequest.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=747)
    public Map<String,Object> unsetSmtpSendAddAuthenticatedUser(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddAuthenticatedUser, "");
        return attrs;
    }

    /**
     * Whether X-Mailer will be added to messages sent by Zimbra
     *
     * @return zimbraSmtpSendAddMailer, or true if unset
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=636)
    public boolean isSmtpSendAddMailer() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpSendAddMailer, true, true);
    }

    /**
     * Whether X-Mailer will be added to messages sent by Zimbra
     *
     * @param zimbraSmtpSendAddMailer new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=636)
    public void setSmtpSendAddMailer(boolean zimbraSmtpSendAddMailer) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddMailer, zimbraSmtpSendAddMailer ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether X-Mailer will be added to messages sent by Zimbra
     *
     * @param zimbraSmtpSendAddMailer new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=636)
    public Map<String,Object> setSmtpSendAddMailer(boolean zimbraSmtpSendAddMailer, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddMailer, zimbraSmtpSendAddMailer ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether X-Mailer will be added to messages sent by Zimbra
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=636)
    public void unsetSmtpSendAddMailer() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddMailer, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether X-Mailer will be added to messages sent by Zimbra
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.5
     */
    @ZAttr(id=636)
    public Map<String,Object> unsetSmtpSendAddMailer(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddMailer, "");
        return attrs;
    }

    /**
     * Whether X-Originating-IP will be added to messages sent via
     * SendMsgRequest.
     *
     * @return zimbraSmtpSendAddOriginatingIP, or true if unset
     */
    @ZAttr(id=435)
    public boolean isSmtpSendAddOriginatingIP() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpSendAddOriginatingIP, true, true);
    }

    /**
     * Whether X-Originating-IP will be added to messages sent via
     * SendMsgRequest.
     *
     * @param zimbraSmtpSendAddOriginatingIP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=435)
    public void setSmtpSendAddOriginatingIP(boolean zimbraSmtpSendAddOriginatingIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddOriginatingIP, zimbraSmtpSendAddOriginatingIP ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether X-Originating-IP will be added to messages sent via
     * SendMsgRequest.
     *
     * @param zimbraSmtpSendAddOriginatingIP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=435)
    public Map<String,Object> setSmtpSendAddOriginatingIP(boolean zimbraSmtpSendAddOriginatingIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddOriginatingIP, zimbraSmtpSendAddOriginatingIP ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether X-Originating-IP will be added to messages sent via
     * SendMsgRequest.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=435)
    public void unsetSmtpSendAddOriginatingIP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddOriginatingIP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether X-Originating-IP will be added to messages sent via
     * SendMsgRequest.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=435)
    public Map<String,Object> unsetSmtpSendAddOriginatingIP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendAddOriginatingIP, "");
        return attrs;
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @return zimbraSmtpSendPartial, or false if unset
     */
    @ZAttr(id=249)
    public boolean isSmtpSendPartial() {
        return getBooleanAttr(Provisioning.A_zimbraSmtpSendPartial, false, true);
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @param zimbraSmtpSendPartial new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=249)
    public void setSmtpSendPartial(boolean zimbraSmtpSendPartial) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendPartial, zimbraSmtpSendPartial ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @param zimbraSmtpSendPartial new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=249)
    public Map<String,Object> setSmtpSendPartial(boolean zimbraSmtpSendPartial, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendPartial, zimbraSmtpSendPartial ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=249)
    public void unsetSmtpSendPartial() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendPartial, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Value of the mail.smtp.sendpartial property
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=249)
    public Map<String,Object> unsetSmtpSendPartial(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpSendPartial, "");
        return attrs;
    }

    /**
     * timeout value in seconds
     *
     * @return zimbraSmtpTimeout, or 60 if unset
     */
    @ZAttr(id=99)
    public int getSmtpTimeout() {
        return getIntAttr(Provisioning.A_zimbraSmtpTimeout, 60, true);
    }

    /**
     * timeout value in seconds
     *
     * @param zimbraSmtpTimeout new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=99)
    public void setSmtpTimeout(int zimbraSmtpTimeout) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpTimeout, Integer.toString(zimbraSmtpTimeout));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * timeout value in seconds
     *
     * @param zimbraSmtpTimeout new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=99)
    public Map<String,Object> setSmtpTimeout(int zimbraSmtpTimeout, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpTimeout, Integer.toString(zimbraSmtpTimeout));
        return attrs;
    }

    /**
     * timeout value in seconds
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=99)
    public void unsetSmtpTimeout() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpTimeout, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * timeout value in seconds
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=99)
    public Map<String,Object> unsetSmtpTimeout(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSmtpTimeout, "");
        return attrs;
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @return zimbraSoapExposeVersion, or false if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public boolean isSoapExposeVersion() {
        return getBooleanAttr(Provisioning.A_zimbraSoapExposeVersion, false, true);
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @param zimbraSoapExposeVersion new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public void setSoapExposeVersion(boolean zimbraSoapExposeVersion) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapExposeVersion, zimbraSoapExposeVersion ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @param zimbraSoapExposeVersion new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public Map<String,Object> setSoapExposeVersion(boolean zimbraSoapExposeVersion, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapExposeVersion, zimbraSoapExposeVersion ? TRUE : FALSE);
        return attrs;
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public void unsetSoapExposeVersion() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapExposeVersion, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * If TRUE, enables support for GetVersionInfo for account SOAP requests.
     * If FALSE, GetVersionInfoRequest returns a SOAP fault.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=708)
    public Map<String,Object> unsetSoapExposeVersion(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapExposeVersion, "");
        return attrs;
    }

    /**
     * Maximum size in bytes for incoming SOAP requests. 0 means no limit.
     *
     * @return zimbraSoapRequestMaxSize, or 15360000 if unset
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=557)
    public int getSoapRequestMaxSize() {
        return getIntAttr(Provisioning.A_zimbraSoapRequestMaxSize, 15360000, true);
    }

    /**
     * Maximum size in bytes for incoming SOAP requests. 0 means no limit.
     *
     * @param zimbraSoapRequestMaxSize new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=557)
    public void setSoapRequestMaxSize(int zimbraSoapRequestMaxSize) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapRequestMaxSize, Integer.toString(zimbraSoapRequestMaxSize));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for incoming SOAP requests. 0 means no limit.
     *
     * @param zimbraSoapRequestMaxSize new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=557)
    public Map<String,Object> setSoapRequestMaxSize(int zimbraSoapRequestMaxSize, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapRequestMaxSize, Integer.toString(zimbraSoapRequestMaxSize));
        return attrs;
    }

    /**
     * Maximum size in bytes for incoming SOAP requests. 0 means no limit.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=557)
    public void unsetSoapRequestMaxSize() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapRequestMaxSize, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Maximum size in bytes for incoming SOAP requests. 0 means no limit.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.0
     */
    @ZAttr(id=557)
    public Map<String,Object> unsetSoapRequestMaxSize(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSoapRequestMaxSize, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable spam checking
     *
     * @return zimbraSpamCheckEnabled, or false if unset
     */
    @ZAttr(id=201)
    public boolean isSpamCheckEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraSpamCheckEnabled, false, true);
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable spam checking
     *
     * @param zimbraSpamCheckEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=201)
    public void setSpamCheckEnabled(boolean zimbraSpamCheckEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamCheckEnabled, zimbraSpamCheckEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable spam checking
     *
     * @param zimbraSpamCheckEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=201)
    public Map<String,Object> setSpamCheckEnabled(boolean zimbraSpamCheckEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamCheckEnabled, zimbraSpamCheckEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable spam checking
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=201)
    public void unsetSpamCheckEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamCheckEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable spam checking
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=201)
    public Map<String,Object> unsetSpamCheckEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamCheckEnabled, "");
        return attrs;
    }

    /**
     * mail header name for flagging spam
     *
     * @return zimbraSpamHeader, or "X-Spam-Flag" if unset
     */
    @ZAttr(id=210)
    public String getSpamHeader() {
        return getAttr(Provisioning.A_zimbraSpamHeader, "X-Spam-Flag", true);
    }

    /**
     * mail header name for flagging spam
     *
     * @param zimbraSpamHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=210)
    public void setSpamHeader(String zimbraSpamHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamHeader, zimbraSpamHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail header name for flagging spam
     *
     * @param zimbraSpamHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=210)
    public Map<String,Object> setSpamHeader(String zimbraSpamHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamHeader, zimbraSpamHeader);
        return attrs;
    }

    /**
     * mail header name for flagging spam
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=210)
    public void unsetSpamHeader() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamHeader, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail header name for flagging spam
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=210)
    public Map<String,Object> unsetSpamHeader(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamHeader, "");
        return attrs;
    }

    /**
     * regular expression for matching the spam header
     *
     * @return zimbraSpamHeaderValue, or "YES" if unset
     */
    @ZAttr(id=211)
    public String getSpamHeaderValue() {
        return getAttr(Provisioning.A_zimbraSpamHeaderValue, "YES", true);
    }

    /**
     * regular expression for matching the spam header
     *
     * @param zimbraSpamHeaderValue new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=211)
    public void setSpamHeaderValue(String zimbraSpamHeaderValue) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamHeaderValue, zimbraSpamHeaderValue);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regular expression for matching the spam header
     *
     * @param zimbraSpamHeaderValue new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=211)
    public Map<String,Object> setSpamHeaderValue(String zimbraSpamHeaderValue, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamHeaderValue, zimbraSpamHeaderValue);
        return attrs;
    }

    /**
     * regular expression for matching the spam header
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=211)
    public void unsetSpamHeaderValue() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamHeaderValue, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regular expression for matching the spam header
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=211)
    public Map<String,Object> unsetSpamHeaderValue(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamHeaderValue, "");
        return attrs;
    }

    /**
     * When user classifies a message as not spam forward message via SMTP to
     * this account
     *
     * @return zimbraSpamIsNotSpamAccount, or null if unset
     */
    @ZAttr(id=245)
    public String getSpamIsNotSpamAccount() {
        return getAttr(Provisioning.A_zimbraSpamIsNotSpamAccount, null, true);
    }

    /**
     * When user classifies a message as not spam forward message via SMTP to
     * this account
     *
     * @param zimbraSpamIsNotSpamAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=245)
    public void setSpamIsNotSpamAccount(String zimbraSpamIsNotSpamAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamIsNotSpamAccount, zimbraSpamIsNotSpamAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When user classifies a message as not spam forward message via SMTP to
     * this account
     *
     * @param zimbraSpamIsNotSpamAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=245)
    public Map<String,Object> setSpamIsNotSpamAccount(String zimbraSpamIsNotSpamAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamIsNotSpamAccount, zimbraSpamIsNotSpamAccount);
        return attrs;
    }

    /**
     * When user classifies a message as not spam forward message via SMTP to
     * this account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=245)
    public void unsetSpamIsNotSpamAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamIsNotSpamAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When user classifies a message as not spam forward message via SMTP to
     * this account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=245)
    public Map<String,Object> unsetSpamIsNotSpamAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamIsNotSpamAccount, "");
        return attrs;
    }

    /**
     * When user classifies a message as spam forward message via SMTP to
     * this account
     *
     * @return zimbraSpamIsSpamAccount, or null if unset
     */
    @ZAttr(id=244)
    public String getSpamIsSpamAccount() {
        return getAttr(Provisioning.A_zimbraSpamIsSpamAccount, null, true);
    }

    /**
     * When user classifies a message as spam forward message via SMTP to
     * this account
     *
     * @param zimbraSpamIsSpamAccount new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=244)
    public void setSpamIsSpamAccount(String zimbraSpamIsSpamAccount) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamIsSpamAccount, zimbraSpamIsSpamAccount);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When user classifies a message as spam forward message via SMTP to
     * this account
     *
     * @param zimbraSpamIsSpamAccount new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=244)
    public Map<String,Object> setSpamIsSpamAccount(String zimbraSpamIsSpamAccount, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamIsSpamAccount, zimbraSpamIsSpamAccount);
        return attrs;
    }

    /**
     * When user classifies a message as spam forward message via SMTP to
     * this account
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=244)
    public void unsetSpamIsSpamAccount() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamIsSpamAccount, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * When user classifies a message as spam forward message via SMTP to
     * this account
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=244)
    public Map<String,Object> unsetSpamIsSpamAccount(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamIsSpamAccount, "");
        return attrs;
    }

    /**
     * Spaminess percentage beyond which a message is dropped
     *
     * @return zimbraSpamKillPercent, or 75 if unset
     */
    @ZAttr(id=202)
    public int getSpamKillPercent() {
        return getIntAttr(Provisioning.A_zimbraSpamKillPercent, 75, true);
    }

    /**
     * Spaminess percentage beyond which a message is dropped
     *
     * @param zimbraSpamKillPercent new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=202)
    public void setSpamKillPercent(int zimbraSpamKillPercent) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamKillPercent, Integer.toString(zimbraSpamKillPercent));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Spaminess percentage beyond which a message is dropped
     *
     * @param zimbraSpamKillPercent new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=202)
    public Map<String,Object> setSpamKillPercent(int zimbraSpamKillPercent, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamKillPercent, Integer.toString(zimbraSpamKillPercent));
        return attrs;
    }

    /**
     * Spaminess percentage beyond which a message is dropped
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=202)
    public void unsetSpamKillPercent() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamKillPercent, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Spaminess percentage beyond which a message is dropped
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=202)
    public Map<String,Object> unsetSpamKillPercent(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamKillPercent, "");
        return attrs;
    }

    /**
     * value for envelope from (MAIL FROM) in spam report
     *
     * @return zimbraSpamReportEnvelopeFrom, or "<>" if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1049)
    public String getSpamReportEnvelopeFrom() {
        return getAttr(Provisioning.A_zimbraSpamReportEnvelopeFrom, "<>", true);
    }

    /**
     * value for envelope from (MAIL FROM) in spam report
     *
     * @param zimbraSpamReportEnvelopeFrom new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1049)
    public void setSpamReportEnvelopeFrom(String zimbraSpamReportEnvelopeFrom) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportEnvelopeFrom, zimbraSpamReportEnvelopeFrom);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for envelope from (MAIL FROM) in spam report
     *
     * @param zimbraSpamReportEnvelopeFrom new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1049)
    public Map<String,Object> setSpamReportEnvelopeFrom(String zimbraSpamReportEnvelopeFrom, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportEnvelopeFrom, zimbraSpamReportEnvelopeFrom);
        return attrs;
    }

    /**
     * value for envelope from (MAIL FROM) in spam report
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1049)
    public void unsetSpamReportEnvelopeFrom() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportEnvelopeFrom, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * value for envelope from (MAIL FROM) in spam report
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1049)
    public Map<String,Object> unsetSpamReportEnvelopeFrom(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportEnvelopeFrom, "");
        return attrs;
    }

    /**
     * mail header name for sender in spam report
     *
     * @return zimbraSpamReportSenderHeader, or "X-Zimbra-Spam-Report-Sender" if unset
     */
    @ZAttr(id=465)
    public String getSpamReportSenderHeader() {
        return getAttr(Provisioning.A_zimbraSpamReportSenderHeader, "X-Zimbra-Spam-Report-Sender", true);
    }

    /**
     * mail header name for sender in spam report
     *
     * @param zimbraSpamReportSenderHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=465)
    public void setSpamReportSenderHeader(String zimbraSpamReportSenderHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportSenderHeader, zimbraSpamReportSenderHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail header name for sender in spam report
     *
     * @param zimbraSpamReportSenderHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=465)
    public Map<String,Object> setSpamReportSenderHeader(String zimbraSpamReportSenderHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportSenderHeader, zimbraSpamReportSenderHeader);
        return attrs;
    }

    /**
     * mail header name for sender in spam report
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=465)
    public void unsetSpamReportSenderHeader() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportSenderHeader, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail header name for sender in spam report
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=465)
    public Map<String,Object> unsetSpamReportSenderHeader(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportSenderHeader, "");
        return attrs;
    }

    /**
     * spam report type value for ham
     *
     * @return zimbraSpamReportTypeHam, or "ham" if unset
     */
    @ZAttr(id=468)
    public String getSpamReportTypeHam() {
        return getAttr(Provisioning.A_zimbraSpamReportTypeHam, "ham", true);
    }

    /**
     * spam report type value for ham
     *
     * @param zimbraSpamReportTypeHam new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=468)
    public void setSpamReportTypeHam(String zimbraSpamReportTypeHam) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeHam, zimbraSpamReportTypeHam);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spam report type value for ham
     *
     * @param zimbraSpamReportTypeHam new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=468)
    public Map<String,Object> setSpamReportTypeHam(String zimbraSpamReportTypeHam, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeHam, zimbraSpamReportTypeHam);
        return attrs;
    }

    /**
     * spam report type value for ham
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=468)
    public void unsetSpamReportTypeHam() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeHam, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spam report type value for ham
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=468)
    public Map<String,Object> unsetSpamReportTypeHam(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeHam, "");
        return attrs;
    }

    /**
     * mail header name for report type in spam report
     *
     * @return zimbraSpamReportTypeHeader, or "X-Zimbra-Spam-Report-Type" if unset
     */
    @ZAttr(id=466)
    public String getSpamReportTypeHeader() {
        return getAttr(Provisioning.A_zimbraSpamReportTypeHeader, "X-Zimbra-Spam-Report-Type", true);
    }

    /**
     * mail header name for report type in spam report
     *
     * @param zimbraSpamReportTypeHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=466)
    public void setSpamReportTypeHeader(String zimbraSpamReportTypeHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeHeader, zimbraSpamReportTypeHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail header name for report type in spam report
     *
     * @param zimbraSpamReportTypeHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=466)
    public Map<String,Object> setSpamReportTypeHeader(String zimbraSpamReportTypeHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeHeader, zimbraSpamReportTypeHeader);
        return attrs;
    }

    /**
     * mail header name for report type in spam report
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=466)
    public void unsetSpamReportTypeHeader() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeHeader, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * mail header name for report type in spam report
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=466)
    public Map<String,Object> unsetSpamReportTypeHeader(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeHeader, "");
        return attrs;
    }

    /**
     * spam report type value for spam
     *
     * @return zimbraSpamReportTypeSpam, or "spam" if unset
     */
    @ZAttr(id=467)
    public String getSpamReportTypeSpam() {
        return getAttr(Provisioning.A_zimbraSpamReportTypeSpam, "spam", true);
    }

    /**
     * spam report type value for spam
     *
     * @param zimbraSpamReportTypeSpam new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=467)
    public void setSpamReportTypeSpam(String zimbraSpamReportTypeSpam) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeSpam, zimbraSpamReportTypeSpam);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spam report type value for spam
     *
     * @param zimbraSpamReportTypeSpam new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=467)
    public Map<String,Object> setSpamReportTypeSpam(String zimbraSpamReportTypeSpam, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeSpam, zimbraSpamReportTypeSpam);
        return attrs;
    }

    /**
     * spam report type value for spam
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=467)
    public void unsetSpamReportTypeSpam() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeSpam, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spam report type value for spam
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=467)
    public Map<String,Object> unsetSpamReportTypeSpam(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamReportTypeSpam, "");
        return attrs;
    }

    /**
     * Subject prefix for spam messages
     *
     * @return zimbraSpamSubjectTag, or null if unset
     */
    @ZAttr(id=203)
    public String getSpamSubjectTag() {
        return getAttr(Provisioning.A_zimbraSpamSubjectTag, null, true);
    }

    /**
     * Subject prefix for spam messages
     *
     * @param zimbraSpamSubjectTag new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=203)
    public void setSpamSubjectTag(String zimbraSpamSubjectTag) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamSubjectTag, zimbraSpamSubjectTag);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Subject prefix for spam messages
     *
     * @param zimbraSpamSubjectTag new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=203)
    public Map<String,Object> setSpamSubjectTag(String zimbraSpamSubjectTag, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamSubjectTag, zimbraSpamSubjectTag);
        return attrs;
    }

    /**
     * Subject prefix for spam messages
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=203)
    public void unsetSpamSubjectTag() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamSubjectTag, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Subject prefix for spam messages
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=203)
    public Map<String,Object> unsetSpamSubjectTag(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamSubjectTag, "");
        return attrs;
    }

    /**
     * Spaminess percentage beyond which a message is marked as spam
     *
     * @return zimbraSpamTagPercent, or 33 if unset
     */
    @ZAttr(id=204)
    public int getSpamTagPercent() {
        return getIntAttr(Provisioning.A_zimbraSpamTagPercent, 33, true);
    }

    /**
     * Spaminess percentage beyond which a message is marked as spam
     *
     * @param zimbraSpamTagPercent new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=204)
    public void setSpamTagPercent(int zimbraSpamTagPercent) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTagPercent, Integer.toString(zimbraSpamTagPercent));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Spaminess percentage beyond which a message is marked as spam
     *
     * @param zimbraSpamTagPercent new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=204)
    public Map<String,Object> setSpamTagPercent(int zimbraSpamTagPercent, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTagPercent, Integer.toString(zimbraSpamTagPercent));
        return attrs;
    }

    /**
     * Spaminess percentage beyond which a message is marked as spam
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=204)
    public void unsetSpamTagPercent() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTagPercent, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Spaminess percentage beyond which a message is marked as spam
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=204)
    public Map<String,Object> unsetSpamTagPercent(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTagPercent, "");
        return attrs;
    }

    /**
     * Subject prefix for the spam training messages used to sent to the
     * zimbraSpamIsSpamAccount/zimbraSpamIsNotSpamAccount account.
     *
     * @return zimbraSpamTrainingSubjectPrefix, or "zimbra-spam-report:" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2020)
    public String getSpamTrainingSubjectPrefix() {
        return getAttr(Provisioning.A_zimbraSpamTrainingSubjectPrefix, "zimbra-spam-report:", true);
    }

    /**
     * Subject prefix for the spam training messages used to sent to the
     * zimbraSpamIsSpamAccount/zimbraSpamIsNotSpamAccount account.
     *
     * @param zimbraSpamTrainingSubjectPrefix new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2020)
    public void setSpamTrainingSubjectPrefix(String zimbraSpamTrainingSubjectPrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTrainingSubjectPrefix, zimbraSpamTrainingSubjectPrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Subject prefix for the spam training messages used to sent to the
     * zimbraSpamIsSpamAccount/zimbraSpamIsNotSpamAccount account.
     *
     * @param zimbraSpamTrainingSubjectPrefix new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2020)
    public Map<String,Object> setSpamTrainingSubjectPrefix(String zimbraSpamTrainingSubjectPrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTrainingSubjectPrefix, zimbraSpamTrainingSubjectPrefix);
        return attrs;
    }

    /**
     * Subject prefix for the spam training messages used to sent to the
     * zimbraSpamIsSpamAccount/zimbraSpamIsNotSpamAccount account.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2020)
    public void unsetSpamTrainingSubjectPrefix() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTrainingSubjectPrefix, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Subject prefix for the spam training messages used to sent to the
     * zimbraSpamIsSpamAccount/zimbraSpamIsNotSpamAccount account.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2020)
    public Map<String,Object> unsetSpamTrainingSubjectPrefix(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTrainingSubjectPrefix, "");
        return attrs;
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @return zimbraSpamTrashAlias, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public String[] getSpamTrashAlias() {
        String[] value = getMultiAttr(Provisioning.A_zimbraSpamTrashAlias, true, true); return value.length > 0 ? value : new String[] {"/Deleted Messages","/Deleted Items"};
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @param zimbraSpamTrashAlias new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public void setSpamTrashAlias(String[] zimbraSpamTrashAlias) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTrashAlias, zimbraSpamTrashAlias);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @param zimbraSpamTrashAlias new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public Map<String,Object> setSpamTrashAlias(String[] zimbraSpamTrashAlias, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTrashAlias, zimbraSpamTrashAlias);
        return attrs;
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @param zimbraSpamTrashAlias new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public void addSpamTrashAlias(String zimbraSpamTrashAlias) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpamTrashAlias, zimbraSpamTrashAlias);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @param zimbraSpamTrashAlias new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public Map<String,Object> addSpamTrashAlias(String zimbraSpamTrashAlias, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpamTrashAlias, zimbraSpamTrashAlias);
        return attrs;
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @param zimbraSpamTrashAlias existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public void removeSpamTrashAlias(String zimbraSpamTrashAlias) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpamTrashAlias, zimbraSpamTrashAlias);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @param zimbraSpamTrashAlias existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public Map<String,Object> removeSpamTrashAlias(String zimbraSpamTrashAlias, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpamTrashAlias, zimbraSpamTrashAlias);
        return attrs;
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public void unsetSpamTrashAlias() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTrashAlias, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Aliases of Trash folder. In case some IMAP clients use different
     * folder names other than Trash, the spam filter still special-cases
     * those folders as if they are Trash.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1167)
    public Map<String,Object> unsetSpamTrashAlias(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamTrashAlias, "");
        return attrs;
    }

    /**
     * Mail header name for flagging a message as not spam. If set, this
     * takes precedence over zimbraSpamHeader.
     *
     * @return zimbraSpamWhitelistHeader, or null if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1257)
    public String getSpamWhitelistHeader() {
        return getAttr(Provisioning.A_zimbraSpamWhitelistHeader, null, true);
    }

    /**
     * Mail header name for flagging a message as not spam. If set, this
     * takes precedence over zimbraSpamHeader.
     *
     * @param zimbraSpamWhitelistHeader new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1257)
    public void setSpamWhitelistHeader(String zimbraSpamWhitelistHeader) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamWhitelistHeader, zimbraSpamWhitelistHeader);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mail header name for flagging a message as not spam. If set, this
     * takes precedence over zimbraSpamHeader.
     *
     * @param zimbraSpamWhitelistHeader new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1257)
    public Map<String,Object> setSpamWhitelistHeader(String zimbraSpamWhitelistHeader, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamWhitelistHeader, zimbraSpamWhitelistHeader);
        return attrs;
    }

    /**
     * Mail header name for flagging a message as not spam. If set, this
     * takes precedence over zimbraSpamHeader.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1257)
    public void unsetSpamWhitelistHeader() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamWhitelistHeader, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Mail header name for flagging a message as not spam. If set, this
     * takes precedence over zimbraSpamHeader.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1257)
    public Map<String,Object> unsetSpamWhitelistHeader(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamWhitelistHeader, "");
        return attrs;
    }

    /**
     * regular expression for matching the value of zimbraSpamWhitelistHeader
     * for flagging a message as not spam
     *
     * @return zimbraSpamWhitelistHeaderValue, or null if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1258)
    public String getSpamWhitelistHeaderValue() {
        return getAttr(Provisioning.A_zimbraSpamWhitelistHeaderValue, null, true);
    }

    /**
     * regular expression for matching the value of zimbraSpamWhitelistHeader
     * for flagging a message as not spam
     *
     * @param zimbraSpamWhitelistHeaderValue new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1258)
    public void setSpamWhitelistHeaderValue(String zimbraSpamWhitelistHeaderValue) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamWhitelistHeaderValue, zimbraSpamWhitelistHeaderValue);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regular expression for matching the value of zimbraSpamWhitelistHeader
     * for flagging a message as not spam
     *
     * @param zimbraSpamWhitelistHeaderValue new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1258)
    public Map<String,Object> setSpamWhitelistHeaderValue(String zimbraSpamWhitelistHeaderValue, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamWhitelistHeaderValue, zimbraSpamWhitelistHeaderValue);
        return attrs;
    }

    /**
     * regular expression for matching the value of zimbraSpamWhitelistHeader
     * for flagging a message as not spam
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1258)
    public void unsetSpamWhitelistHeaderValue() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamWhitelistHeaderValue, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regular expression for matching the value of zimbraSpamWhitelistHeader
     * for flagging a message as not spam
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1258)
    public Map<String,Object> unsetSpamWhitelistHeaderValue(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpamWhitelistHeaderValue, "");
        return attrs;
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @return zimbraSpellAvailableDictionary, or empty array if unset
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public String[] getSpellAvailableDictionary() {
        String[] value = getMultiAttr(Provisioning.A_zimbraSpellAvailableDictionary, true, true); return value.length > 0 ? value : new String[] {"en_US"};
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public void setSpellAvailableDictionary(String[] zimbraSpellAvailableDictionary) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public Map<String,Object> setSpellAvailableDictionary(String[] zimbraSpellAvailableDictionary, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        return attrs;
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public void addSpellAvailableDictionary(String zimbraSpellAvailableDictionary) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public Map<String,Object> addSpellAvailableDictionary(String zimbraSpellAvailableDictionary, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        return attrs;
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public void removeSpellAvailableDictionary(String zimbraSpellAvailableDictionary) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param zimbraSpellAvailableDictionary existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public Map<String,Object> removeSpellAvailableDictionary(String zimbraSpellAvailableDictionary, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpellAvailableDictionary, zimbraSpellAvailableDictionary);
        return attrs;
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public void unsetSpellAvailableDictionary() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellAvailableDictionary, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * The list of available dictionaries that can be used for spell
     * checking.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_GA
     */
    @ZAttr(id=1042)
    public Map<String,Object> unsetSpellAvailableDictionary(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellAvailableDictionary, "");
        return attrs;
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @return zimbraSpellCheckURL, or empty array if unset
     */
    @ZAttr(id=267)
    public String[] getSpellCheckURL() {
        return getMultiAttr(Provisioning.A_zimbraSpellCheckURL, true, true);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=267)
    public void setSpellCheckURL(String[] zimbraSpellCheckURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=267)
    public Map<String,Object> setSpellCheckURL(String[] zimbraSpellCheckURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        return attrs;
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=267)
    public void addSpellCheckURL(String zimbraSpellCheckURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=267)
    public Map<String,Object> addSpellCheckURL(String zimbraSpellCheckURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        return attrs;
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=267)
    public void removeSpellCheckURL(String zimbraSpellCheckURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param zimbraSpellCheckURL existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=267)
    public Map<String,Object> removeSpellCheckURL(String zimbraSpellCheckURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraSpellCheckURL, zimbraSpellCheckURL);
        return attrs;
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=267)
    public void unsetSpellCheckURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellCheckURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the server running the spell checking service. Multi-valued
     * attribute that allows multiple spell check servers to be specified. If
     * the request to the first server fails, a request to the second server
     * is sent and so on.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=267)
    public Map<String,Object> unsetSpellCheckURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpellCheckURL, "");
        return attrs;
    }

    /**
     * whether spnego SSO is enabled
     *
     * @return zimbraSpnegoAuthEnabled, or false if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1118)
    public boolean isSpnegoAuthEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraSpnegoAuthEnabled, false, true);
    }

    /**
     * whether spnego SSO is enabled
     *
     * @param zimbraSpnegoAuthEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1118)
    public void setSpnegoAuthEnabled(boolean zimbraSpnegoAuthEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthEnabled, zimbraSpnegoAuthEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether spnego SSO is enabled
     *
     * @param zimbraSpnegoAuthEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1118)
    public Map<String,Object> setSpnegoAuthEnabled(boolean zimbraSpnegoAuthEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthEnabled, zimbraSpnegoAuthEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether spnego SSO is enabled
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1118)
    public void unsetSpnegoAuthEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether spnego SSO is enabled
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1118)
    public Map<String,Object> unsetSpnegoAuthEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthEnabled, "");
        return attrs;
    }

    /**
     * spnego auth error URL
     *
     * @return zimbraSpnegoAuthErrorURL, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1124)
    public String getSpnegoAuthErrorURL() {
        return getAttr(Provisioning.A_zimbraSpnegoAuthErrorURL, null, true);
    }

    /**
     * spnego auth error URL
     *
     * @param zimbraSpnegoAuthErrorURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1124)
    public void setSpnegoAuthErrorURL(String zimbraSpnegoAuthErrorURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthErrorURL, zimbraSpnegoAuthErrorURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spnego auth error URL
     *
     * @param zimbraSpnegoAuthErrorURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1124)
    public Map<String,Object> setSpnegoAuthErrorURL(String zimbraSpnegoAuthErrorURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthErrorURL, zimbraSpnegoAuthErrorURL);
        return attrs;
    }

    /**
     * spnego auth error URL
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1124)
    public void unsetSpnegoAuthErrorURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthErrorURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spnego auth error URL
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1124)
    public Map<String,Object> unsetSpnegoAuthErrorURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthErrorURL, "");
        return attrs;
    }

    /**
     * spnego auth realm
     *
     * @return zimbraSpnegoAuthRealm, or null if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1119)
    public String getSpnegoAuthRealm() {
        return getAttr(Provisioning.A_zimbraSpnegoAuthRealm, null, true);
    }

    /**
     * spnego auth realm
     *
     * @param zimbraSpnegoAuthRealm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1119)
    public void setSpnegoAuthRealm(String zimbraSpnegoAuthRealm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthRealm, zimbraSpnegoAuthRealm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spnego auth realm
     *
     * @param zimbraSpnegoAuthRealm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1119)
    public Map<String,Object> setSpnegoAuthRealm(String zimbraSpnegoAuthRealm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthRealm, zimbraSpnegoAuthRealm);
        return attrs;
    }

    /**
     * spnego auth realm
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1119)
    public void unsetSpnegoAuthRealm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthRealm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * spnego auth realm
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1119)
    public Map<String,Object> unsetSpnegoAuthRealm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSpnegoAuthRealm, "");
        return attrs;
    }

    /**
     * CA Cert used to sign all self signed certs
     *
     * @return zimbraSslCaCert, or null if unset
     */
    @ZAttr(id=277)
    public String getSslCaCert() {
        return getAttr(Provisioning.A_zimbraSslCaCert, null, true);
    }

    /**
     * CA Cert used to sign all self signed certs
     *
     * @param zimbraSslCaCert new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=277)
    public void setSslCaCert(String zimbraSslCaCert) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSslCaCert, zimbraSslCaCert);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CA Cert used to sign all self signed certs
     *
     * @param zimbraSslCaCert new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=277)
    public Map<String,Object> setSslCaCert(String zimbraSslCaCert, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSslCaCert, zimbraSslCaCert);
        return attrs;
    }

    /**
     * CA Cert used to sign all self signed certs
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=277)
    public void unsetSslCaCert() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSslCaCert, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CA Cert used to sign all self signed certs
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=277)
    public Map<String,Object> unsetSslCaCert(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSslCaCert, "");
        return attrs;
    }

    /**
     * CA Key used to sign all self signed certs
     *
     * @return zimbraSslCaKey, or null if unset
     */
    @ZAttr(id=278)
    public String getSslCaKey() {
        return getAttr(Provisioning.A_zimbraSslCaKey, null, true);
    }

    /**
     * CA Key used to sign all self signed certs
     *
     * @param zimbraSslCaKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=278)
    public void setSslCaKey(String zimbraSslCaKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSslCaKey, zimbraSslCaKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CA Key used to sign all self signed certs
     *
     * @param zimbraSslCaKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=278)
    public Map<String,Object> setSslCaKey(String zimbraSslCaKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSslCaKey, zimbraSslCaKey);
        return attrs;
    }

    /**
     * CA Key used to sign all self signed certs
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=278)
    public void unsetSslCaKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSslCaKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * CA Key used to sign all self signed certs
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=278)
    public Map<String,Object> unsetSslCaKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraSslCaKey, "");
        return attrs;
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @return zimbraStatThreadNamePrefix, or empty array if unset
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public String[] getStatThreadNamePrefix() {
        String[] value = getMultiAttr(Provisioning.A_zimbraStatThreadNamePrefix, true, true); return value.length > 0 ? value : new String[] {"btpool","pool","LmtpServer","ImapServer","ImapSSLServer","Pop3Server","Pop3SSLServer","ScheduledTask","Timer","AnonymousIoService","CloudRoutingReaderThread","GC","SocketAcceptor","Thread","qtp"};
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public void setStatThreadNamePrefix(String[] zimbraStatThreadNamePrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public Map<String,Object> setStatThreadNamePrefix(String[] zimbraStatThreadNamePrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        return attrs;
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public void addStatThreadNamePrefix(String zimbraStatThreadNamePrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public Map<String,Object> addStatThreadNamePrefix(String zimbraStatThreadNamePrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        return attrs;
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public void removeStatThreadNamePrefix(String zimbraStatThreadNamePrefix) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param zimbraStatThreadNamePrefix existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public Map<String,Object> removeStatThreadNamePrefix(String zimbraStatThreadNamePrefix, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraStatThreadNamePrefix, zimbraStatThreadNamePrefix);
        return attrs;
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public void unsetStatThreadNamePrefix() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStatThreadNamePrefix, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Prefixes of thread names. Each value is a column in threads.csv that
     * tracks the number of threads whose name starts with the given prefix.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.0_BETA1
     */
    @ZAttr(id=792)
    public Map<String,Object> unsetStatThreadNamePrefix(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraStatThreadNamePrefix, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance will be performed if the
     * number of rows grows by this factor
     *
     * @return zimbraTableMaintenanceGrowthFactor, or 10 if unset
     */
    @ZAttr(id=171)
    public int getTableMaintenanceGrowthFactor() {
        return getIntAttr(Provisioning.A_zimbraTableMaintenanceGrowthFactor, 10, true);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance will be performed if the
     * number of rows grows by this factor
     *
     * @param zimbraTableMaintenanceGrowthFactor new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=171)
    public void setTableMaintenanceGrowthFactor(int zimbraTableMaintenanceGrowthFactor) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceGrowthFactor, Integer.toString(zimbraTableMaintenanceGrowthFactor));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance will be performed if the
     * number of rows grows by this factor
     *
     * @param zimbraTableMaintenanceGrowthFactor new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=171)
    public Map<String,Object> setTableMaintenanceGrowthFactor(int zimbraTableMaintenanceGrowthFactor, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceGrowthFactor, Integer.toString(zimbraTableMaintenanceGrowthFactor));
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance will be performed if the
     * number of rows grows by this factor
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=171)
    public void unsetTableMaintenanceGrowthFactor() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceGrowthFactor, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance will be performed if the
     * number of rows grows by this factor
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=171)
    public Map<String,Object> unsetTableMaintenanceGrowthFactor(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceGrowthFactor, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: maximum number of rows required for database
     * table maintenance
     *
     * @return zimbraTableMaintenanceMaxRows, or 1000000 if unset
     */
    @ZAttr(id=169)
    public int getTableMaintenanceMaxRows() {
        return getIntAttr(Provisioning.A_zimbraTableMaintenanceMaxRows, 1000000, true);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: maximum number of rows required for database
     * table maintenance
     *
     * @param zimbraTableMaintenanceMaxRows new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=169)
    public void setTableMaintenanceMaxRows(int zimbraTableMaintenanceMaxRows) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceMaxRows, Integer.toString(zimbraTableMaintenanceMaxRows));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: maximum number of rows required for database
     * table maintenance
     *
     * @param zimbraTableMaintenanceMaxRows new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=169)
    public Map<String,Object> setTableMaintenanceMaxRows(int zimbraTableMaintenanceMaxRows, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceMaxRows, Integer.toString(zimbraTableMaintenanceMaxRows));
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: maximum number of rows required for database
     * table maintenance
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=169)
    public void unsetTableMaintenanceMaxRows() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceMaxRows, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: maximum number of rows required for database
     * table maintenance
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=169)
    public Map<String,Object> unsetTableMaintenanceMaxRows(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceMaxRows, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: minimum number of rows required for database
     * table maintenance
     *
     * @return zimbraTableMaintenanceMinRows, or 10000 if unset
     */
    @ZAttr(id=168)
    public int getTableMaintenanceMinRows() {
        return getIntAttr(Provisioning.A_zimbraTableMaintenanceMinRows, 10000, true);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: minimum number of rows required for database
     * table maintenance
     *
     * @param zimbraTableMaintenanceMinRows new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=168)
    public void setTableMaintenanceMinRows(int zimbraTableMaintenanceMinRows) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceMinRows, Integer.toString(zimbraTableMaintenanceMinRows));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: minimum number of rows required for database
     * table maintenance
     *
     * @param zimbraTableMaintenanceMinRows new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=168)
    public Map<String,Object> setTableMaintenanceMinRows(int zimbraTableMaintenanceMinRows, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceMinRows, Integer.toString(zimbraTableMaintenanceMinRows));
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: minimum number of rows required for database
     * table maintenance
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=168)
    public void unsetTableMaintenanceMinRows() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceMinRows, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: minimum number of rows required for database
     * table maintenance
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=168)
    public Map<String,Object> unsetTableMaintenanceMinRows(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceMinRows, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance operation that will be
     * performed. Valid options: &quot;ANALYZE&quot;, &quot;OPTIMIZE&quot;
     *
     * <p>Valid values: [ANALYZE, OPTIMIZE]
     *
     * @return zimbraTableMaintenanceOperation, or ZAttrProvisioning.TableMaintenanceOperation.ANALYZE if unset and/or has invalid value
     */
    @ZAttr(id=170)
    public ZAttrProvisioning.TableMaintenanceOperation getTableMaintenanceOperation() {
        try { String v = getAttr(Provisioning.A_zimbraTableMaintenanceOperation, true, true); return v == null ? ZAttrProvisioning.TableMaintenanceOperation.ANALYZE : ZAttrProvisioning.TableMaintenanceOperation.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.TableMaintenanceOperation.ANALYZE; }
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance operation that will be
     * performed. Valid options: &quot;ANALYZE&quot;, &quot;OPTIMIZE&quot;
     *
     * <p>Valid values: [ANALYZE, OPTIMIZE]
     *
     * @return zimbraTableMaintenanceOperation, or "ANALYZE" if unset
     */
    @ZAttr(id=170)
    public String getTableMaintenanceOperationAsString() {
        return getAttr(Provisioning.A_zimbraTableMaintenanceOperation, "ANALYZE", true);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance operation that will be
     * performed. Valid options: &quot;ANALYZE&quot;, &quot;OPTIMIZE&quot;
     *
     * <p>Valid values: [ANALYZE, OPTIMIZE]
     *
     * @param zimbraTableMaintenanceOperation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=170)
    public void setTableMaintenanceOperation(ZAttrProvisioning.TableMaintenanceOperation zimbraTableMaintenanceOperation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceOperation, zimbraTableMaintenanceOperation.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance operation that will be
     * performed. Valid options: &quot;ANALYZE&quot;, &quot;OPTIMIZE&quot;
     *
     * <p>Valid values: [ANALYZE, OPTIMIZE]
     *
     * @param zimbraTableMaintenanceOperation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=170)
    public Map<String,Object> setTableMaintenanceOperation(ZAttrProvisioning.TableMaintenanceOperation zimbraTableMaintenanceOperation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceOperation, zimbraTableMaintenanceOperation.toString());
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance operation that will be
     * performed. Valid options: &quot;ANALYZE&quot;, &quot;OPTIMIZE&quot;
     *
     * <p>Valid values: [ANALYZE, OPTIMIZE]
     *
     * @param zimbraTableMaintenanceOperation new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=170)
    public void setTableMaintenanceOperationAsString(String zimbraTableMaintenanceOperation) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceOperation, zimbraTableMaintenanceOperation);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance operation that will be
     * performed. Valid options: &quot;ANALYZE&quot;, &quot;OPTIMIZE&quot;
     *
     * <p>Valid values: [ANALYZE, OPTIMIZE]
     *
     * @param zimbraTableMaintenanceOperation new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=170)
    public Map<String,Object> setTableMaintenanceOperationAsString(String zimbraTableMaintenanceOperation, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceOperation, zimbraTableMaintenanceOperation);
        return attrs;
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance operation that will be
     * performed. Valid options: &quot;ANALYZE&quot;, &quot;OPTIMIZE&quot;
     *
     * <p>Valid values: [ANALYZE, OPTIMIZE]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=170)
    public void unsetTableMaintenanceOperation() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceOperation, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5.7. We now maintain all tables unconditionally.
     * See bug 19145. Orig desc: table maintenance operation that will be
     * performed. Valid options: &quot;ANALYZE&quot;, &quot;OPTIMIZE&quot;
     *
     * <p>Valid values: [ANALYZE, OPTIMIZE]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=170)
    public Map<String,Object> unsetTableMaintenanceOperation(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTableMaintenanceOperation, "");
        return attrs;
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @return zimbraThreadMonitorEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public boolean isThreadMonitorEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraThreadMonitorEnabled, false, true);
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @param zimbraThreadMonitorEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public void setThreadMonitorEnabled(boolean zimbraThreadMonitorEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThreadMonitorEnabled, zimbraThreadMonitorEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @param zimbraThreadMonitorEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public Map<String,Object> setThreadMonitorEnabled(boolean zimbraThreadMonitorEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThreadMonitorEnabled, zimbraThreadMonitorEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public void unsetThreadMonitorEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThreadMonitorEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not Jetty thread monitor is enabled. Used for debugging
     * Jetty, not recommended for extended use in production environment.
     * Defaults to FALSE
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1583)
    public Map<String,Object> unsetThreadMonitorEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThreadMonitorEnabled, "");
        return attrs;
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @return zimbraThrottleSafeHosts, or empty array if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public String[] getThrottleSafeHosts() {
        return getMultiAttr(Provisioning.A_zimbraThrottleSafeHosts, true, true);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public void setThrottleSafeHosts(String[] zimbraThrottleSafeHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public Map<String,Object> setThrottleSafeHosts(String[] zimbraThrottleSafeHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        return attrs;
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public void addThrottleSafeHosts(String zimbraThrottleSafeHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public Map<String,Object> addThrottleSafeHosts(String zimbraThrottleSafeHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        return attrs;
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public void removeThrottleSafeHosts(String zimbraThrottleSafeHosts) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param zimbraThrottleSafeHosts existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public Map<String,Object> removeThrottleSafeHosts(String zimbraThrottleSafeHosts, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraThrottleSafeHosts, zimbraThrottleSafeHosts);
        return attrs;
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public void unsetThrottleSafeHosts() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleSafeHosts, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to ignore during IP based throttling. Account and command rate
     * limits will still be applied. Typically should list nginx hostname and
     * any other mailbox servers which can proxy to this server
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1383)
    public Map<String,Object> unsetThrottleSafeHosts(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleSafeHosts, "");
        return attrs;
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @return zimbraThrottleWhitelist, or empty array if unset
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public String[] getThrottleWhitelist() {
        return getMultiAttr(Provisioning.A_zimbraThrottleWhitelist, true, true);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public void setThrottleWhitelist(String[] zimbraThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public Map<String,Object> setThrottleWhitelist(String[] zimbraThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        return attrs;
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public void addThrottleWhitelist(String zimbraThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public Map<String,Object> addThrottleWhitelist(String zimbraThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        return attrs;
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public void removeThrottleWhitelist(String zimbraThrottleWhitelist) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param zimbraThrottleWhitelist existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public Map<String,Object> removeThrottleWhitelist(String zimbraThrottleWhitelist, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraThrottleWhitelist, zimbraThrottleWhitelist);
        return attrs;
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public void unsetThrottleWhitelist() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleWhitelist, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hosts to whitelist during IP based throttling. Account and command
     * rate limits will not be applied. This should only be used for internal
     * servers which cannot service end user traffic; e.g. migration or
     * monitoring hosts
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.5
     */
    @ZAttr(id=1449)
    public Map<String,Object> unsetThrottleWhitelist(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraThrottleWhitelist, "");
        return attrs;
    }

    /**
     * Hash algorithm used in TOTP generation. SHA1 is the current accepted
     * standard per RFC 6238. Only consider changing this to another hashing
     * function when working with authenticators that deviate from this
     * standard.
     *
     * <p>Valid values: [SHA1, SHA256, SHA512]
     *
     * @return zimbraTwoFactorAuthHashAlgorithm, or ZAttrProvisioning.TwoFactorAuthHashAlgorithm.SHA1 if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1825)
    public ZAttrProvisioning.TwoFactorAuthHashAlgorithm getTwoFactorAuthHashAlgorithm() {
        try { String v = getAttr(Provisioning.A_zimbraTwoFactorAuthHashAlgorithm, true, true); return v == null ? ZAttrProvisioning.TwoFactorAuthHashAlgorithm.SHA1 : ZAttrProvisioning.TwoFactorAuthHashAlgorithm.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.TwoFactorAuthHashAlgorithm.SHA1; }
    }

    /**
     * Hash algorithm used in TOTP generation. SHA1 is the current accepted
     * standard per RFC 6238. Only consider changing this to another hashing
     * function when working with authenticators that deviate from this
     * standard.
     *
     * <p>Valid values: [SHA1, SHA256, SHA512]
     *
     * @return zimbraTwoFactorAuthHashAlgorithm, or "SHA1" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1825)
    public String getTwoFactorAuthHashAlgorithmAsString() {
        return getAttr(Provisioning.A_zimbraTwoFactorAuthHashAlgorithm, "SHA1", true);
    }

    /**
     * Hash algorithm used in TOTP generation. SHA1 is the current accepted
     * standard per RFC 6238. Only consider changing this to another hashing
     * function when working with authenticators that deviate from this
     * standard.
     *
     * <p>Valid values: [SHA1, SHA256, SHA512]
     *
     * @param zimbraTwoFactorAuthHashAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1825)
    public void setTwoFactorAuthHashAlgorithm(ZAttrProvisioning.TwoFactorAuthHashAlgorithm zimbraTwoFactorAuthHashAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthHashAlgorithm, zimbraTwoFactorAuthHashAlgorithm.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hash algorithm used in TOTP generation. SHA1 is the current accepted
     * standard per RFC 6238. Only consider changing this to another hashing
     * function when working with authenticators that deviate from this
     * standard.
     *
     * <p>Valid values: [SHA1, SHA256, SHA512]
     *
     * @param zimbraTwoFactorAuthHashAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1825)
    public Map<String,Object> setTwoFactorAuthHashAlgorithm(ZAttrProvisioning.TwoFactorAuthHashAlgorithm zimbraTwoFactorAuthHashAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthHashAlgorithm, zimbraTwoFactorAuthHashAlgorithm.toString());
        return attrs;
    }

    /**
     * Hash algorithm used in TOTP generation. SHA1 is the current accepted
     * standard per RFC 6238. Only consider changing this to another hashing
     * function when working with authenticators that deviate from this
     * standard.
     *
     * <p>Valid values: [SHA1, SHA256, SHA512]
     *
     * @param zimbraTwoFactorAuthHashAlgorithm new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1825)
    public void setTwoFactorAuthHashAlgorithmAsString(String zimbraTwoFactorAuthHashAlgorithm) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthHashAlgorithm, zimbraTwoFactorAuthHashAlgorithm);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hash algorithm used in TOTP generation. SHA1 is the current accepted
     * standard per RFC 6238. Only consider changing this to another hashing
     * function when working with authenticators that deviate from this
     * standard.
     *
     * <p>Valid values: [SHA1, SHA256, SHA512]
     *
     * @param zimbraTwoFactorAuthHashAlgorithm new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1825)
    public Map<String,Object> setTwoFactorAuthHashAlgorithmAsString(String zimbraTwoFactorAuthHashAlgorithm, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthHashAlgorithm, zimbraTwoFactorAuthHashAlgorithm);
        return attrs;
    }

    /**
     * Hash algorithm used in TOTP generation. SHA1 is the current accepted
     * standard per RFC 6238. Only consider changing this to another hashing
     * function when working with authenticators that deviate from this
     * standard.
     *
     * <p>Valid values: [SHA1, SHA256, SHA512]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1825)
    public void unsetTwoFactorAuthHashAlgorithm() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthHashAlgorithm, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Hash algorithm used in TOTP generation. SHA1 is the current accepted
     * standard per RFC 6238. Only consider changing this to another hashing
     * function when working with authenticators that deviate from this
     * standard.
     *
     * <p>Valid values: [SHA1, SHA256, SHA512]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1825)
    public Map<String,Object> unsetTwoFactorAuthHashAlgorithm(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthHashAlgorithm, "");
        return attrs;
    }

    /**
     * scratch code encoding
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @return zimbraTwoFactorAuthScratchCodeEncoding, or ZAttrProvisioning.TwoFactorAuthScratchCodeEncoding.BASE32 if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1831)
    public ZAttrProvisioning.TwoFactorAuthScratchCodeEncoding getTwoFactorAuthScratchCodeEncoding() {
        try { String v = getAttr(Provisioning.A_zimbraTwoFactorAuthScratchCodeEncoding, true, true); return v == null ? ZAttrProvisioning.TwoFactorAuthScratchCodeEncoding.BASE32 : ZAttrProvisioning.TwoFactorAuthScratchCodeEncoding.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.TwoFactorAuthScratchCodeEncoding.BASE32; }
    }

    /**
     * scratch code encoding
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @return zimbraTwoFactorAuthScratchCodeEncoding, or "BASE32" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1831)
    public String getTwoFactorAuthScratchCodeEncodingAsString() {
        return getAttr(Provisioning.A_zimbraTwoFactorAuthScratchCodeEncoding, "BASE32", true);
    }

    /**
     * scratch code encoding
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param zimbraTwoFactorAuthScratchCodeEncoding new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1831)
    public void setTwoFactorAuthScratchCodeEncoding(ZAttrProvisioning.TwoFactorAuthScratchCodeEncoding zimbraTwoFactorAuthScratchCodeEncoding) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodeEncoding, zimbraTwoFactorAuthScratchCodeEncoding.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * scratch code encoding
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param zimbraTwoFactorAuthScratchCodeEncoding new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1831)
    public Map<String,Object> setTwoFactorAuthScratchCodeEncoding(ZAttrProvisioning.TwoFactorAuthScratchCodeEncoding zimbraTwoFactorAuthScratchCodeEncoding, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodeEncoding, zimbraTwoFactorAuthScratchCodeEncoding.toString());
        return attrs;
    }

    /**
     * scratch code encoding
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param zimbraTwoFactorAuthScratchCodeEncoding new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1831)
    public void setTwoFactorAuthScratchCodeEncodingAsString(String zimbraTwoFactorAuthScratchCodeEncoding) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodeEncoding, zimbraTwoFactorAuthScratchCodeEncoding);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * scratch code encoding
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param zimbraTwoFactorAuthScratchCodeEncoding new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1831)
    public Map<String,Object> setTwoFactorAuthScratchCodeEncodingAsString(String zimbraTwoFactorAuthScratchCodeEncoding, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodeEncoding, zimbraTwoFactorAuthScratchCodeEncoding);
        return attrs;
    }

    /**
     * scratch code encoding
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1831)
    public void unsetTwoFactorAuthScratchCodeEncoding() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodeEncoding, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * scratch code encoding
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1831)
    public Map<String,Object> unsetTwoFactorAuthScratchCodeEncoding(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthScratchCodeEncoding, "");
        return attrs;
    }

    /**
     * Shared secret encoding. Keep at BASE32 for compatability with common
     * TOTP clients.
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @return zimbraTwoFactorAuthSecretEncoding, or ZAttrProvisioning.TwoFactorAuthSecretEncoding.BASE32 if unset and/or has invalid value
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1826)
    public ZAttrProvisioning.TwoFactorAuthSecretEncoding getTwoFactorAuthSecretEncoding() {
        try { String v = getAttr(Provisioning.A_zimbraTwoFactorAuthSecretEncoding, true, true); return v == null ? ZAttrProvisioning.TwoFactorAuthSecretEncoding.BASE32 : ZAttrProvisioning.TwoFactorAuthSecretEncoding.fromString(v); } catch(com.zimbra.common.service.ServiceException e) { return ZAttrProvisioning.TwoFactorAuthSecretEncoding.BASE32; }
    }

    /**
     * Shared secret encoding. Keep at BASE32 for compatability with common
     * TOTP clients.
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @return zimbraTwoFactorAuthSecretEncoding, or "BASE32" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1826)
    public String getTwoFactorAuthSecretEncodingAsString() {
        return getAttr(Provisioning.A_zimbraTwoFactorAuthSecretEncoding, "BASE32", true);
    }

    /**
     * Shared secret encoding. Keep at BASE32 for compatability with common
     * TOTP clients.
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param zimbraTwoFactorAuthSecretEncoding new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1826)
    public void setTwoFactorAuthSecretEncoding(ZAttrProvisioning.TwoFactorAuthSecretEncoding zimbraTwoFactorAuthSecretEncoding) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretEncoding, zimbraTwoFactorAuthSecretEncoding.toString());
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared secret encoding. Keep at BASE32 for compatability with common
     * TOTP clients.
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param zimbraTwoFactorAuthSecretEncoding new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1826)
    public Map<String,Object> setTwoFactorAuthSecretEncoding(ZAttrProvisioning.TwoFactorAuthSecretEncoding zimbraTwoFactorAuthSecretEncoding, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretEncoding, zimbraTwoFactorAuthSecretEncoding.toString());
        return attrs;
    }

    /**
     * Shared secret encoding. Keep at BASE32 for compatability with common
     * TOTP clients.
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param zimbraTwoFactorAuthSecretEncoding new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1826)
    public void setTwoFactorAuthSecretEncodingAsString(String zimbraTwoFactorAuthSecretEncoding) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretEncoding, zimbraTwoFactorAuthSecretEncoding);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared secret encoding. Keep at BASE32 for compatability with common
     * TOTP clients.
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param zimbraTwoFactorAuthSecretEncoding new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1826)
    public Map<String,Object> setTwoFactorAuthSecretEncodingAsString(String zimbraTwoFactorAuthSecretEncoding, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretEncoding, zimbraTwoFactorAuthSecretEncoding);
        return attrs;
    }

    /**
     * Shared secret encoding. Keep at BASE32 for compatability with common
     * TOTP clients.
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1826)
    public void unsetTwoFactorAuthSecretEncoding() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretEncoding, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared secret encoding. Keep at BASE32 for compatability with common
     * TOTP clients.
     *
     * <p>Valid values: [BASE32, BASE64]
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1826)
    public Map<String,Object> unsetTwoFactorAuthSecretEncoding(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretEncoding, "");
        return attrs;
    }

    /**
     * length of shared secret
     *
     * @return zimbraTwoFactorAuthSecretLength, or 16 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1824)
    public int getTwoFactorAuthSecretLength() {
        return getIntAttr(Provisioning.A_zimbraTwoFactorAuthSecretLength, 16, true);
    }

    /**
     * length of shared secret
     *
     * @param zimbraTwoFactorAuthSecretLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1824)
    public void setTwoFactorAuthSecretLength(int zimbraTwoFactorAuthSecretLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretLength, Integer.toString(zimbraTwoFactorAuthSecretLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of shared secret
     *
     * @param zimbraTwoFactorAuthSecretLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1824)
    public Map<String,Object> setTwoFactorAuthSecretLength(int zimbraTwoFactorAuthSecretLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretLength, Integer.toString(zimbraTwoFactorAuthSecretLength));
        return attrs;
    }

    /**
     * length of shared secret
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1824)
    public void unsetTwoFactorAuthSecretLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of shared secret
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1824)
    public Map<String,Object> unsetTwoFactorAuthSecretLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthSecretLength, "");
        return attrs;
    }

    /**
     * trusted device token secret key
     *
     * @return zimbraTwoFactorAuthTrustedDeviceTokenKey, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public String[] getTwoFactorAuthTrustedDeviceTokenKey() {
        return getMultiAttr(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, true, true);
    }

    /**
     * trusted device token secret key
     *
     * @param zimbraTwoFactorAuthTrustedDeviceTokenKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public void setTwoFactorAuthTrustedDeviceTokenKey(String[] zimbraTwoFactorAuthTrustedDeviceTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, zimbraTwoFactorAuthTrustedDeviceTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * trusted device token secret key
     *
     * @param zimbraTwoFactorAuthTrustedDeviceTokenKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public Map<String,Object> setTwoFactorAuthTrustedDeviceTokenKey(String[] zimbraTwoFactorAuthTrustedDeviceTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, zimbraTwoFactorAuthTrustedDeviceTokenKey);
        return attrs;
    }

    /**
     * trusted device token secret key
     *
     * @param zimbraTwoFactorAuthTrustedDeviceTokenKey new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public void addTwoFactorAuthTrustedDeviceTokenKey(String zimbraTwoFactorAuthTrustedDeviceTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, zimbraTwoFactorAuthTrustedDeviceTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * trusted device token secret key
     *
     * @param zimbraTwoFactorAuthTrustedDeviceTokenKey new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public Map<String,Object> addTwoFactorAuthTrustedDeviceTokenKey(String zimbraTwoFactorAuthTrustedDeviceTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, zimbraTwoFactorAuthTrustedDeviceTokenKey);
        return attrs;
    }

    /**
     * trusted device token secret key
     *
     * @param zimbraTwoFactorAuthTrustedDeviceTokenKey existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public void removeTwoFactorAuthTrustedDeviceTokenKey(String zimbraTwoFactorAuthTrustedDeviceTokenKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, zimbraTwoFactorAuthTrustedDeviceTokenKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * trusted device token secret key
     *
     * @param zimbraTwoFactorAuthTrustedDeviceTokenKey existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public Map<String,Object> removeTwoFactorAuthTrustedDeviceTokenKey(String zimbraTwoFactorAuthTrustedDeviceTokenKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, zimbraTwoFactorAuthTrustedDeviceTokenKey);
        return attrs;
    }

    /**
     * trusted device token secret key
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public void unsetTwoFactorAuthTrustedDeviceTokenKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * trusted device token secret key
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1964)
    public Map<String,Object> unsetTwoFactorAuthTrustedDeviceTokenKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorAuthTrustedDeviceTokenKey, "");
        return attrs;
    }

    /**
     * Length of TOTP code required for two-factor authentication. Keep at 6
     * for compatability with common TOTP clients.
     *
     * @return zimbraTwoFactorCodeLength, or 6 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1828)
    public int getTwoFactorCodeLength() {
        return getIntAttr(Provisioning.A_zimbraTwoFactorCodeLength, 6, true);
    }

    /**
     * Length of TOTP code required for two-factor authentication. Keep at 6
     * for compatability with common TOTP clients.
     *
     * @param zimbraTwoFactorCodeLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1828)
    public void setTwoFactorCodeLength(int zimbraTwoFactorCodeLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorCodeLength, Integer.toString(zimbraTwoFactorCodeLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Length of TOTP code required for two-factor authentication. Keep at 6
     * for compatability with common TOTP clients.
     *
     * @param zimbraTwoFactorCodeLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1828)
    public Map<String,Object> setTwoFactorCodeLength(int zimbraTwoFactorCodeLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorCodeLength, Integer.toString(zimbraTwoFactorCodeLength));
        return attrs;
    }

    /**
     * Length of TOTP code required for two-factor authentication. Keep at 6
     * for compatability with common TOTP clients.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1828)
    public void unsetTwoFactorCodeLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorCodeLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Length of TOTP code required for two-factor authentication. Keep at 6
     * for compatability with common TOTP clients.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1828)
    public Map<String,Object> unsetTwoFactorCodeLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorCodeLength, "");
        return attrs;
    }

    /**
     * length of scratch codes
     *
     * @return zimbraTwoFactorScratchCodeLength, or 8 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1827)
    public int getTwoFactorScratchCodeLength() {
        return getIntAttr(Provisioning.A_zimbraTwoFactorScratchCodeLength, 8, true);
    }

    /**
     * length of scratch codes
     *
     * @param zimbraTwoFactorScratchCodeLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1827)
    public void setTwoFactorScratchCodeLength(int zimbraTwoFactorScratchCodeLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorScratchCodeLength, Integer.toString(zimbraTwoFactorScratchCodeLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of scratch codes
     *
     * @param zimbraTwoFactorScratchCodeLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1827)
    public Map<String,Object> setTwoFactorScratchCodeLength(int zimbraTwoFactorScratchCodeLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorScratchCodeLength, Integer.toString(zimbraTwoFactorScratchCodeLength));
        return attrs;
    }

    /**
     * length of scratch codes
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1827)
    public void unsetTwoFactorScratchCodeLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorScratchCodeLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of scratch codes
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1827)
    public Map<String,Object> unsetTwoFactorScratchCodeLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorScratchCodeLength, "");
        return attrs;
    }

    /**
     * length of time that a TOTP code is valid for. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getTwoFactorTimeWindowLengthAsString to access value as a string.
     *
     * @see #getTwoFactorTimeWindowLengthAsString()
     *
     * @return zimbraTwoFactorTimeWindowLength in millseconds, or 30000 (30s)  if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1829)
    public long getTwoFactorTimeWindowLength() {
        return getTimeInterval(Provisioning.A_zimbraTwoFactorTimeWindowLength, 30000L, true);
    }

    /**
     * length of time that a TOTP code is valid for. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraTwoFactorTimeWindowLength, or "30s" if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1829)
    public String getTwoFactorTimeWindowLengthAsString() {
        return getAttr(Provisioning.A_zimbraTwoFactorTimeWindowLength, "30s", true);
    }

    /**
     * length of time that a TOTP code is valid for. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraTwoFactorTimeWindowLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1829)
    public void setTwoFactorTimeWindowLength(String zimbraTwoFactorTimeWindowLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorTimeWindowLength, zimbraTwoFactorTimeWindowLength);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of time that a TOTP code is valid for. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraTwoFactorTimeWindowLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1829)
    public Map<String,Object> setTwoFactorTimeWindowLength(String zimbraTwoFactorTimeWindowLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorTimeWindowLength, zimbraTwoFactorTimeWindowLength);
        return attrs;
    }

    /**
     * length of time that a TOTP code is valid for. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1829)
    public void unsetTwoFactorTimeWindowLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorTimeWindowLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * length of time that a TOTP code is valid for. Must be in valid
     * duration format: {digits}{time-unit}. digits: 0-9, time-unit:
     * [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days, ms -
     * milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1829)
    public Map<String,Object> unsetTwoFactorTimeWindowLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorTimeWindowLength, "");
        return attrs;
    }

    /**
     * Determines the number of windows to check when trying to validate a
     * TOTP code (NOW-n through NOW+n). This number should typically be
     * small, but a minimum value of 1 is usually necessary to account for
     * network latency and clock drift. See also:
     * zimbraTwoFactorTimeWindowLength and
     * https://tools.ietf.org/html/rfc6238#section-5.2
     *
     * @return zimbraTwoFactorTimeWindowOffset, or 1 if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1830)
    public int getTwoFactorTimeWindowOffset() {
        return getIntAttr(Provisioning.A_zimbraTwoFactorTimeWindowOffset, 1, true);
    }

    /**
     * Determines the number of windows to check when trying to validate a
     * TOTP code (NOW-n through NOW+n). This number should typically be
     * small, but a minimum value of 1 is usually necessary to account for
     * network latency and clock drift. See also:
     * zimbraTwoFactorTimeWindowLength and
     * https://tools.ietf.org/html/rfc6238#section-5.2
     *
     * @param zimbraTwoFactorTimeWindowOffset new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1830)
    public void setTwoFactorTimeWindowOffset(int zimbraTwoFactorTimeWindowOffset) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorTimeWindowOffset, Integer.toString(zimbraTwoFactorTimeWindowOffset));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Determines the number of windows to check when trying to validate a
     * TOTP code (NOW-n through NOW+n). This number should typically be
     * small, but a minimum value of 1 is usually necessary to account for
     * network latency and clock drift. See also:
     * zimbraTwoFactorTimeWindowLength and
     * https://tools.ietf.org/html/rfc6238#section-5.2
     *
     * @param zimbraTwoFactorTimeWindowOffset new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1830)
    public Map<String,Object> setTwoFactorTimeWindowOffset(int zimbraTwoFactorTimeWindowOffset, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorTimeWindowOffset, Integer.toString(zimbraTwoFactorTimeWindowOffset));
        return attrs;
    }

    /**
     * Determines the number of windows to check when trying to validate a
     * TOTP code (NOW-n through NOW+n). This number should typically be
     * small, but a minimum value of 1 is usually necessary to account for
     * network latency and clock drift. See also:
     * zimbraTwoFactorTimeWindowLength and
     * https://tools.ietf.org/html/rfc6238#section-5.2
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1830)
    public void unsetTwoFactorTimeWindowOffset() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorTimeWindowOffset, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Determines the number of windows to check when trying to validate a
     * TOTP code (NOW-n through NOW+n). This number should typically be
     * small, but a minimum value of 1 is usually necessary to account for
     * network latency and clock drift. See also:
     * zimbraTwoFactorTimeWindowLength and
     * https://tools.ietf.org/html/rfc6238#section-5.2
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=1830)
    public Map<String,Object> unsetTwoFactorTimeWindowOffset(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraTwoFactorTimeWindowOffset, "");
        return attrs;
    }

    /**
     * Designated UC provider of the system
     *
     * @return zimbraUCProviderEnabled, or null if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1410)
    public String getUCProviderEnabled() {
        return getAttr(Provisioning.A_zimbraUCProviderEnabled, null, true);
    }

    /**
     * Designated UC provider of the system
     *
     * @param zimbraUCProviderEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1410)
    public void setUCProviderEnabled(String zimbraUCProviderEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCProviderEnabled, zimbraUCProviderEnabled);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Designated UC provider of the system
     *
     * @param zimbraUCProviderEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1410)
    public Map<String,Object> setUCProviderEnabled(String zimbraUCProviderEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCProviderEnabled, zimbraUCProviderEnabled);
        return attrs;
    }

    /**
     * Designated UC provider of the system
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1410)
    public void unsetUCProviderEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCProviderEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Designated UC provider of the system
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1410)
    public Map<String,Object> unsetUCProviderEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraUCProviderEnabled, "");
        return attrs;
    }

    /**
     * Time interval after which Zimbra version check detects a new version.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * <p>Use getVersionCheckIntervalAsString to access value as a string.
     *
     * @see #getVersionCheckIntervalAsString()
     *
     * @return zimbraVersionCheckInterval in millseconds, or 86400000 (1d)  if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1059)
    public long getVersionCheckInterval() {
        return getTimeInterval(Provisioning.A_zimbraVersionCheckInterval, 86400000L, true);
    }

    /**
     * Time interval after which Zimbra version check detects a new version.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @return zimbraVersionCheckInterval, or "1d" if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1059)
    public String getVersionCheckIntervalAsString() {
        return getAttr(Provisioning.A_zimbraVersionCheckInterval, "1d", true);
    }

    /**
     * Time interval after which Zimbra version check detects a new version.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraVersionCheckInterval new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1059)
    public void setVersionCheckInterval(String zimbraVersionCheckInterval) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckInterval, zimbraVersionCheckInterval);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which Zimbra version check detects a new version.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param zimbraVersionCheckInterval new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1059)
    public Map<String,Object> setVersionCheckInterval(String zimbraVersionCheckInterval, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckInterval, zimbraVersionCheckInterval);
        return attrs;
    }

    /**
     * Time interval after which Zimbra version check detects a new version.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1059)
    public void unsetVersionCheckInterval() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckInterval, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Time interval after which Zimbra version check detects a new version.
     * Must be in valid duration format: {digits}{time-unit}. digits: 0-9,
     * time-unit: [hmsd]|ms. h - hours, m - minutes, s - seconds, d - days,
     * ms - milliseconds. If time unit is not specified, the default is
     * s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1059)
    public Map<String,Object> unsetVersionCheckInterval(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckInterval, "");
        return attrs;
    }

    /**
     * time Zimbra version was last checked
     *
     * <p>Use getVersionCheckLastAttemptAsString to access value as a string.
     *
     * @see #getVersionCheckLastAttemptAsString()
     *
     * @return zimbraVersionCheckLastAttempt as Date, null if unset or unable to parse
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1056)
    public Date getVersionCheckLastAttempt() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraVersionCheckLastAttempt, null, true);
    }

    /**
     * time Zimbra version was last checked
     *
     * @return zimbraVersionCheckLastAttempt, or null if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1056)
    public String getVersionCheckLastAttemptAsString() {
        return getAttr(Provisioning.A_zimbraVersionCheckLastAttempt, null, true);
    }

    /**
     * time Zimbra version was last checked
     *
     * @param zimbraVersionCheckLastAttempt new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1056)
    public void setVersionCheckLastAttempt(Date zimbraVersionCheckLastAttempt) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastAttempt, zimbraVersionCheckLastAttempt==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraVersionCheckLastAttempt));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time Zimbra version was last checked
     *
     * @param zimbraVersionCheckLastAttempt new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1056)
    public Map<String,Object> setVersionCheckLastAttempt(Date zimbraVersionCheckLastAttempt, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastAttempt, zimbraVersionCheckLastAttempt==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraVersionCheckLastAttempt));
        return attrs;
    }

    /**
     * time Zimbra version was last checked
     *
     * @param zimbraVersionCheckLastAttempt new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1056)
    public void setVersionCheckLastAttemptAsString(String zimbraVersionCheckLastAttempt) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastAttempt, zimbraVersionCheckLastAttempt);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time Zimbra version was last checked
     *
     * @param zimbraVersionCheckLastAttempt new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1056)
    public Map<String,Object> setVersionCheckLastAttemptAsString(String zimbraVersionCheckLastAttempt, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastAttempt, zimbraVersionCheckLastAttempt);
        return attrs;
    }

    /**
     * time Zimbra version was last checked
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1056)
    public void unsetVersionCheckLastAttempt() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastAttempt, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time Zimbra version was last checked
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1056)
    public Map<String,Object> unsetVersionCheckLastAttempt(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastAttempt, "");
        return attrs;
    }

    /**
     * last response of last Zimbra version check. This will be a short XML
     * that will contain information about available updates.
     *
     * @return zimbraVersionCheckLastResponse, or null if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1058)
    public String getVersionCheckLastResponse() {
        return getAttr(Provisioning.A_zimbraVersionCheckLastResponse, null, true);
    }

    /**
     * last response of last Zimbra version check. This will be a short XML
     * that will contain information about available updates.
     *
     * @param zimbraVersionCheckLastResponse new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1058)
    public void setVersionCheckLastResponse(String zimbraVersionCheckLastResponse) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastResponse, zimbraVersionCheckLastResponse);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * last response of last Zimbra version check. This will be a short XML
     * that will contain information about available updates.
     *
     * @param zimbraVersionCheckLastResponse new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1058)
    public Map<String,Object> setVersionCheckLastResponse(String zimbraVersionCheckLastResponse, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastResponse, zimbraVersionCheckLastResponse);
        return attrs;
    }

    /**
     * last response of last Zimbra version check. This will be a short XML
     * that will contain information about available updates.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1058)
    public void unsetVersionCheckLastResponse() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastResponse, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * last response of last Zimbra version check. This will be a short XML
     * that will contain information about available updates.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1058)
    public Map<String,Object> unsetVersionCheckLastResponse(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastResponse, "");
        return attrs;
    }

    /**
     * time Zimbra version was last checked successfully
     *
     * <p>Use getVersionCheckLastSuccessAsString to access value as a string.
     *
     * @see #getVersionCheckLastSuccessAsString()
     *
     * @return zimbraVersionCheckLastSuccess as Date, null if unset or unable to parse
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1057)
    public Date getVersionCheckLastSuccess() {
        return getGeneralizedTimeAttr(Provisioning.A_zimbraVersionCheckLastSuccess, null, true);
    }

    /**
     * time Zimbra version was last checked successfully
     *
     * @return zimbraVersionCheckLastSuccess, or null if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1057)
    public String getVersionCheckLastSuccessAsString() {
        return getAttr(Provisioning.A_zimbraVersionCheckLastSuccess, null, true);
    }

    /**
     * time Zimbra version was last checked successfully
     *
     * @param zimbraVersionCheckLastSuccess new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1057)
    public void setVersionCheckLastSuccess(Date zimbraVersionCheckLastSuccess) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastSuccess, zimbraVersionCheckLastSuccess==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraVersionCheckLastSuccess));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time Zimbra version was last checked successfully
     *
     * @param zimbraVersionCheckLastSuccess new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1057)
    public Map<String,Object> setVersionCheckLastSuccess(Date zimbraVersionCheckLastSuccess, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastSuccess, zimbraVersionCheckLastSuccess==null ? "" : LdapDateUtil.toGeneralizedTime(zimbraVersionCheckLastSuccess));
        return attrs;
    }

    /**
     * time Zimbra version was last checked successfully
     *
     * @param zimbraVersionCheckLastSuccess new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1057)
    public void setVersionCheckLastSuccessAsString(String zimbraVersionCheckLastSuccess) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastSuccess, zimbraVersionCheckLastSuccess);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time Zimbra version was last checked successfully
     *
     * @param zimbraVersionCheckLastSuccess new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1057)
    public Map<String,Object> setVersionCheckLastSuccessAsString(String zimbraVersionCheckLastSuccess, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastSuccess, zimbraVersionCheckLastSuccess);
        return attrs;
    }

    /**
     * time Zimbra version was last checked successfully
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1057)
    public void unsetVersionCheckLastSuccess() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastSuccess, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * time Zimbra version was last checked successfully
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1057)
    public Map<String,Object> unsetVersionCheckLastSuccess(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckLastSuccess, "");
        return attrs;
    }

    /**
     * template used to construct the body of an Zimbra version check
     * notification message
     *
     * @return zimbraVersionCheckNotificationBody, or "${BEGIN_PREFIX}The following updates were found:${NEWLINE}${NEWLINE}${END_PREFIX}${BEGIN_UPDATE}${UPDATE_COUNTER}.  ${IS_CRITICAL}.  Version: ${UPDATE_VERSION}, URL: ${UPDATE_URL}${NEWLINE}${NEWLINE}${END_UPDATE}${BEGIN_SIGNATURE}Zimbra Updater${NEWLINE}${END_SIGNATURE}" if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1066)
    public String getVersionCheckNotificationBody() {
        return getAttr(Provisioning.A_zimbraVersionCheckNotificationBody, "${BEGIN_PREFIX}The following updates were found:${NEWLINE}${NEWLINE}${END_PREFIX}${BEGIN_UPDATE}${UPDATE_COUNTER}.  ${IS_CRITICAL}.  Version: ${UPDATE_VERSION}, URL: ${UPDATE_URL}${NEWLINE}${NEWLINE}${END_UPDATE}${BEGIN_SIGNATURE}Zimbra Updater${NEWLINE}${END_SIGNATURE}", true);
    }

    /**
     * template used to construct the body of an Zimbra version check
     * notification message
     *
     * @param zimbraVersionCheckNotificationBody new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1066)
    public void setVersionCheckNotificationBody(String zimbraVersionCheckNotificationBody) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationBody, zimbraVersionCheckNotificationBody);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template used to construct the body of an Zimbra version check
     * notification message
     *
     * @param zimbraVersionCheckNotificationBody new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1066)
    public Map<String,Object> setVersionCheckNotificationBody(String zimbraVersionCheckNotificationBody, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationBody, zimbraVersionCheckNotificationBody);
        return attrs;
    }

    /**
     * template used to construct the body of an Zimbra version check
     * notification message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1066)
    public void unsetVersionCheckNotificationBody() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationBody, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template used to construct the body of an Zimbra version check
     * notification message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1066)
    public Map<String,Object> unsetVersionCheckNotificationBody(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationBody, "");
        return attrs;
    }

    /**
     * email address to send mail to for the Zimbra version check
     * notification message
     *
     * @return zimbraVersionCheckNotificationEmail, or null if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1063)
    public String getVersionCheckNotificationEmail() {
        return getAttr(Provisioning.A_zimbraVersionCheckNotificationEmail, null, true);
    }

    /**
     * email address to send mail to for the Zimbra version check
     * notification message
     *
     * @param zimbraVersionCheckNotificationEmail new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1063)
    public void setVersionCheckNotificationEmail(String zimbraVersionCheckNotificationEmail) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationEmail, zimbraVersionCheckNotificationEmail);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email address to send mail to for the Zimbra version check
     * notification message
     *
     * @param zimbraVersionCheckNotificationEmail new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1063)
    public Map<String,Object> setVersionCheckNotificationEmail(String zimbraVersionCheckNotificationEmail, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationEmail, zimbraVersionCheckNotificationEmail);
        return attrs;
    }

    /**
     * email address to send mail to for the Zimbra version check
     * notification message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1063)
    public void unsetVersionCheckNotificationEmail() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationEmail, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * email address to send mail to for the Zimbra version check
     * notification message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1063)
    public Map<String,Object> unsetVersionCheckNotificationEmail(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationEmail, "");
        return attrs;
    }

    /**
     * from address for the Zimbra version check notification message
     *
     * @return zimbraVersionCheckNotificationEmailFrom, or null if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1064)
    public String getVersionCheckNotificationEmailFrom() {
        return getAttr(Provisioning.A_zimbraVersionCheckNotificationEmailFrom, null, true);
    }

    /**
     * from address for the Zimbra version check notification message
     *
     * @param zimbraVersionCheckNotificationEmailFrom new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1064)
    public void setVersionCheckNotificationEmailFrom(String zimbraVersionCheckNotificationEmailFrom) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationEmailFrom, zimbraVersionCheckNotificationEmailFrom);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * from address for the Zimbra version check notification message
     *
     * @param zimbraVersionCheckNotificationEmailFrom new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1064)
    public Map<String,Object> setVersionCheckNotificationEmailFrom(String zimbraVersionCheckNotificationEmailFrom, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationEmailFrom, zimbraVersionCheckNotificationEmailFrom);
        return attrs;
    }

    /**
     * from address for the Zimbra version check notification message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1064)
    public void unsetVersionCheckNotificationEmailFrom() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationEmailFrom, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * from address for the Zimbra version check notification message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1064)
    public Map<String,Object> unsetVersionCheckNotificationEmailFrom(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationEmailFrom, "");
        return attrs;
    }

    /**
     * template used to construct the subject of an Zimbra version check
     * notification message
     *
     * @return zimbraVersionCheckNotificationSubject, or "${IS_CRITICAL} updates are available for your Zimbra server" if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1065)
    public String getVersionCheckNotificationSubject() {
        return getAttr(Provisioning.A_zimbraVersionCheckNotificationSubject, "${IS_CRITICAL} updates are available for your Zimbra server", true);
    }

    /**
     * template used to construct the subject of an Zimbra version check
     * notification message
     *
     * @param zimbraVersionCheckNotificationSubject new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1065)
    public void setVersionCheckNotificationSubject(String zimbraVersionCheckNotificationSubject) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationSubject, zimbraVersionCheckNotificationSubject);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template used to construct the subject of an Zimbra version check
     * notification message
     *
     * @param zimbraVersionCheckNotificationSubject new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1065)
    public Map<String,Object> setVersionCheckNotificationSubject(String zimbraVersionCheckNotificationSubject, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationSubject, zimbraVersionCheckNotificationSubject);
        return attrs;
    }

    /**
     * template used to construct the subject of an Zimbra version check
     * notification message
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1065)
    public void unsetVersionCheckNotificationSubject() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationSubject, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * template used to construct the subject of an Zimbra version check
     * notification message
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1065)
    public Map<String,Object> unsetVersionCheckNotificationSubject(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckNotificationSubject, "");
        return attrs;
    }

    /**
     * whether to send a notification message if Zimbra version check detects
     * a new version
     *
     * @return zimbraVersionCheckSendNotifications, or true if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1062)
    public boolean isVersionCheckSendNotifications() {
        return getBooleanAttr(Provisioning.A_zimbraVersionCheckSendNotifications, true, true);
    }

    /**
     * whether to send a notification message if Zimbra version check detects
     * a new version
     *
     * @param zimbraVersionCheckSendNotifications new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1062)
    public void setVersionCheckSendNotifications(boolean zimbraVersionCheckSendNotifications) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckSendNotifications, zimbraVersionCheckSendNotifications ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to send a notification message if Zimbra version check detects
     * a new version
     *
     * @param zimbraVersionCheckSendNotifications new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1062)
    public Map<String,Object> setVersionCheckSendNotifications(boolean zimbraVersionCheckSendNotifications, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckSendNotifications, zimbraVersionCheckSendNotifications ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether to send a notification message if Zimbra version check detects
     * a new version
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1062)
    public void unsetVersionCheckSendNotifications() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckSendNotifications, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether to send a notification message if Zimbra version check detects
     * a new version
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1062)
    public Map<String,Object> unsetVersionCheckSendNotifications(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckSendNotifications, "");
        return attrs;
    }

    /**
     * zimbraId of the server that should perform the Zimbra version checks
     *
     * @return zimbraVersionCheckServer, or null if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1060)
    public String getVersionCheckServer() {
        return getAttr(Provisioning.A_zimbraVersionCheckServer, null, true);
    }

    /**
     * zimbraId of the server that should perform the Zimbra version checks
     *
     * @param zimbraVersionCheckServer new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1060)
    public void setVersionCheckServer(String zimbraVersionCheckServer) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckServer, zimbraVersionCheckServer);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimbraId of the server that should perform the Zimbra version checks
     *
     * @param zimbraVersionCheckServer new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1060)
    public Map<String,Object> setVersionCheckServer(String zimbraVersionCheckServer, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckServer, zimbraVersionCheckServer);
        return attrs;
    }

    /**
     * zimbraId of the server that should perform the Zimbra version checks
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1060)
    public void unsetVersionCheckServer() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckServer, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * zimbraId of the server that should perform the Zimbra version checks
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1060)
    public Map<String,Object> unsetVersionCheckServer(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckServer, "");
        return attrs;
    }

    /**
     * URL of the Zimbra version check script
     *
     * @return zimbraVersionCheckURL, or "https://www.zimbra.com/aus/universal/update.php" if unset
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1061)
    public String getVersionCheckURL() {
        return getAttr(Provisioning.A_zimbraVersionCheckURL, "https://www.zimbra.com/aus/universal/update.php", true);
    }

    /**
     * URL of the Zimbra version check script
     *
     * @param zimbraVersionCheckURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1061)
    public void setVersionCheckURL(String zimbraVersionCheckURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckURL, zimbraVersionCheckURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the Zimbra version check script
     *
     * @param zimbraVersionCheckURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1061)
    public Map<String,Object> setVersionCheckURL(String zimbraVersionCheckURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckURL, zimbraVersionCheckURL);
        return attrs;
    }

    /**
     * URL of the Zimbra version check script
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1061)
    public void unsetVersionCheckURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * URL of the Zimbra version check script
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 6.0.2
     */
    @ZAttr(id=1061)
    public Map<String,Object> unsetVersionCheckURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVersionCheckURL, "");
        return attrs;
    }

    /**
     * Whether to block archive files that are password protected or
     * encrypted
     *
     * @return zimbraVirusBlockEncryptedArchive, or true if unset
     */
    @ZAttr(id=205)
    public boolean isVirusBlockEncryptedArchive() {
        return getBooleanAttr(Provisioning.A_zimbraVirusBlockEncryptedArchive, true, true);
    }

    /**
     * Whether to block archive files that are password protected or
     * encrypted
     *
     * @param zimbraVirusBlockEncryptedArchive new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=205)
    public void setVirusBlockEncryptedArchive(boolean zimbraVirusBlockEncryptedArchive) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusBlockEncryptedArchive, zimbraVirusBlockEncryptedArchive ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to block archive files that are password protected or
     * encrypted
     *
     * @param zimbraVirusBlockEncryptedArchive new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=205)
    public Map<String,Object> setVirusBlockEncryptedArchive(boolean zimbraVirusBlockEncryptedArchive, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusBlockEncryptedArchive, zimbraVirusBlockEncryptedArchive ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to block archive files that are password protected or
     * encrypted
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=205)
    public void unsetVirusBlockEncryptedArchive() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusBlockEncryptedArchive, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to block archive files that are password protected or
     * encrypted
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=205)
    public Map<String,Object> unsetVirusBlockEncryptedArchive(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusBlockEncryptedArchive, "");
        return attrs;
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable virus checking
     *
     * @return zimbraVirusCheckEnabled, or false if unset
     */
    @ZAttr(id=206)
    public boolean isVirusCheckEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraVirusCheckEnabled, false, true);
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable virus checking
     *
     * @param zimbraVirusCheckEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=206)
    public void setVirusCheckEnabled(boolean zimbraVirusCheckEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusCheckEnabled, zimbraVirusCheckEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable virus checking
     *
     * @param zimbraVirusCheckEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=206)
    public Map<String,Object> setVirusCheckEnabled(boolean zimbraVirusCheckEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusCheckEnabled, zimbraVirusCheckEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable virus checking
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=206)
    public void unsetVirusCheckEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusCheckEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 4.5. Deprecated in favor of zimbraServiceEnabled.
     * Orig desc: Whether to enable virus checking
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=206)
    public Map<String,Object> unsetVirusCheckEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusCheckEnabled, "");
        return attrs;
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * <p>Use getVirusDefinitionsUpdateFrequencyAsString to access value as a string.
     *
     * @see #getVirusDefinitionsUpdateFrequencyAsString()
     *
     * @return zimbraVirusDefinitionsUpdateFrequency in millseconds, or 7200000 (2h)  if unset
     */
    @ZAttr(id=191)
    public long getVirusDefinitionsUpdateFrequency() {
        return getTimeInterval(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, 7200000L, true);
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @return zimbraVirusDefinitionsUpdateFrequency, or "2h" if unset
     */
    @ZAttr(id=191)
    public String getVirusDefinitionsUpdateFrequencyAsString() {
        return getAttr(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, "2h", true);
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraVirusDefinitionsUpdateFrequency new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=191)
    public void setVirusDefinitionsUpdateFrequency(String zimbraVirusDefinitionsUpdateFrequency) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, zimbraVirusDefinitionsUpdateFrequency);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param zimbraVirusDefinitionsUpdateFrequency new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=191)
    public Map<String,Object> setVirusDefinitionsUpdateFrequency(String zimbraVirusDefinitionsUpdateFrequency, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, zimbraVirusDefinitionsUpdateFrequency);
        return attrs;
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=191)
    public void unsetVirusDefinitionsUpdateFrequency() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * how often the virus definitions are updated. Must be in valid duration
     * format: {digits}{time-unit}. digits: 0-9, time-unit: [hmsd]|ms. h -
     * hours, m - minutes, s - seconds, d - days, ms - milliseconds. If time
     * unit is not specified, the default is s(seconds).
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=191)
    public Map<String,Object> unsetVirusDefinitionsUpdateFrequency(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusDefinitionsUpdateFrequency, "");
        return attrs;
    }

    /**
     * Whether to email admin on virus detection
     *
     * @return zimbraVirusWarnAdmin, or true if unset
     */
    @ZAttr(id=207)
    public boolean isVirusWarnAdmin() {
        return getBooleanAttr(Provisioning.A_zimbraVirusWarnAdmin, true, true);
    }

    /**
     * Whether to email admin on virus detection
     *
     * @param zimbraVirusWarnAdmin new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=207)
    public void setVirusWarnAdmin(boolean zimbraVirusWarnAdmin) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusWarnAdmin, zimbraVirusWarnAdmin ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to email admin on virus detection
     *
     * @param zimbraVirusWarnAdmin new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=207)
    public Map<String,Object> setVirusWarnAdmin(boolean zimbraVirusWarnAdmin, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusWarnAdmin, zimbraVirusWarnAdmin ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to email admin on virus detection
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=207)
    public void unsetVirusWarnAdmin() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusWarnAdmin, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to email admin on virus detection
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=207)
    public Map<String,Object> unsetVirusWarnAdmin(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusWarnAdmin, "");
        return attrs;
    }

    /**
     * Whether to email recipient on virus detection
     *
     * @return zimbraVirusWarnRecipient, or true if unset
     */
    @ZAttr(id=208)
    public boolean isVirusWarnRecipient() {
        return getBooleanAttr(Provisioning.A_zimbraVirusWarnRecipient, true, true);
    }

    /**
     * Whether to email recipient on virus detection
     *
     * @param zimbraVirusWarnRecipient new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=208)
    public void setVirusWarnRecipient(boolean zimbraVirusWarnRecipient) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusWarnRecipient, zimbraVirusWarnRecipient ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to email recipient on virus detection
     *
     * @param zimbraVirusWarnRecipient new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=208)
    public Map<String,Object> setVirusWarnRecipient(boolean zimbraVirusWarnRecipient, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusWarnRecipient, zimbraVirusWarnRecipient ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to email recipient on virus detection
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=208)
    public void unsetVirusWarnRecipient() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusWarnRecipient, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to email recipient on virus detection
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=208)
    public Map<String,Object> unsetVirusWarnRecipient(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraVirusWarnRecipient, "");
        return attrs;
    }

    /**
     * link for admin users in web client
     *
     * @return zimbraWebClientAdminReference, or null if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=701)
    public String getWebClientAdminReference() {
        return getAttr(Provisioning.A_zimbraWebClientAdminReference, null, true);
    }

    /**
     * link for admin users in web client
     *
     * @param zimbraWebClientAdminReference new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=701)
    public void setWebClientAdminReference(String zimbraWebClientAdminReference) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientAdminReference, zimbraWebClientAdminReference);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * link for admin users in web client
     *
     * @param zimbraWebClientAdminReference new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=701)
    public Map<String,Object> setWebClientAdminReference(String zimbraWebClientAdminReference, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientAdminReference, zimbraWebClientAdminReference);
        return attrs;
    }

    /**
     * link for admin users in web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=701)
    public void unsetWebClientAdminReference() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientAdminReference, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * link for admin users in web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=701)
    public Map<String,Object> unsetWebClientAdminReference(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientAdminReference, "");
        return attrs;
    }

    /**
     * login URL for web client to send the user to upon failed login, auth
     * expired, or no/invalid auth
     *
     * @return zimbraWebClientLoginURL, or null if unset
     */
    @ZAttr(id=506)
    public String getWebClientLoginURL() {
        return getAttr(Provisioning.A_zimbraWebClientLoginURL, null, true);
    }

    /**
     * login URL for web client to send the user to upon failed login, auth
     * expired, or no/invalid auth
     *
     * @param zimbraWebClientLoginURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=506)
    public void setWebClientLoginURL(String zimbraWebClientLoginURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURL, zimbraWebClientLoginURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * login URL for web client to send the user to upon failed login, auth
     * expired, or no/invalid auth
     *
     * @param zimbraWebClientLoginURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=506)
    public Map<String,Object> setWebClientLoginURL(String zimbraWebClientLoginURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURL, zimbraWebClientLoginURL);
        return attrs;
    }

    /**
     * login URL for web client to send the user to upon failed login, auth
     * expired, or no/invalid auth
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=506)
    public void unsetWebClientLoginURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * login URL for web client to send the user to upon failed login, auth
     * expired, or no/invalid auth
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=506)
    public Map<String,Object> unsetWebClientLoginURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURL, "");
        return attrs;
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @return zimbraWebClientLoginURLAllowedIP, or empty array if unset
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public String[] getWebClientLoginURLAllowedIP() {
        return getMultiAttr(Provisioning.A_zimbraWebClientLoginURLAllowedIP, true, true);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLoginURLAllowedIP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public void setWebClientLoginURLAllowedIP(String[] zimbraWebClientLoginURLAllowedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURLAllowedIP, zimbraWebClientLoginURLAllowedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLoginURLAllowedIP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public Map<String,Object> setWebClientLoginURLAllowedIP(String[] zimbraWebClientLoginURLAllowedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURLAllowedIP, zimbraWebClientLoginURLAllowedIP);
        return attrs;
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLoginURLAllowedIP new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public void addWebClientLoginURLAllowedIP(String zimbraWebClientLoginURLAllowedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientLoginURLAllowedIP, zimbraWebClientLoginURLAllowedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLoginURLAllowedIP new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public Map<String,Object> addWebClientLoginURLAllowedIP(String zimbraWebClientLoginURLAllowedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientLoginURLAllowedIP, zimbraWebClientLoginURLAllowedIP);
        return attrs;
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLoginURLAllowedIP existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public void removeWebClientLoginURLAllowedIP(String zimbraWebClientLoginURLAllowedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientLoginURLAllowedIP, zimbraWebClientLoginURLAllowedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLoginURLAllowedIP existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public Map<String,Object> removeWebClientLoginURLAllowedIP(String zimbraWebClientLoginURLAllowedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientLoginURLAllowedIP, zimbraWebClientLoginURLAllowedIP);
        return attrs;
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public void unsetWebClientLoginURLAllowedIP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURLAllowedIP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLoginURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1352)
    public Map<String,Object> unsetWebClientLoginURLAllowedIP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURLAllowedIP, "");
        return attrs;
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @return zimbraWebClientLoginURLAllowedUA, or empty array if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public String[] getWebClientLoginURLAllowedUA() {
        return getMultiAttr(Provisioning.A_zimbraWebClientLoginURLAllowedUA, true, true);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLoginURLAllowedUA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public void setWebClientLoginURLAllowedUA(String[] zimbraWebClientLoginURLAllowedUA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURLAllowedUA, zimbraWebClientLoginURLAllowedUA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLoginURLAllowedUA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public Map<String,Object> setWebClientLoginURLAllowedUA(String[] zimbraWebClientLoginURLAllowedUA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURLAllowedUA, zimbraWebClientLoginURLAllowedUA);
        return attrs;
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLoginURLAllowedUA new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public void addWebClientLoginURLAllowedUA(String zimbraWebClientLoginURLAllowedUA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientLoginURLAllowedUA, zimbraWebClientLoginURLAllowedUA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLoginURLAllowedUA new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public Map<String,Object> addWebClientLoginURLAllowedUA(String zimbraWebClientLoginURLAllowedUA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientLoginURLAllowedUA, zimbraWebClientLoginURLAllowedUA);
        return attrs;
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLoginURLAllowedUA existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public void removeWebClientLoginURLAllowedUA(String zimbraWebClientLoginURLAllowedUA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientLoginURLAllowedUA, zimbraWebClientLoginURLAllowedUA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLoginURLAllowedUA existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public Map<String,Object> removeWebClientLoginURLAllowedUA(String zimbraWebClientLoginURLAllowedUA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientLoginURLAllowedUA, zimbraWebClientLoginURLAllowedUA);
        return attrs;
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public void unsetWebClientLoginURLAllowedUA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURLAllowedUA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLoginURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1141)
    public Map<String,Object> unsetWebClientLoginURLAllowedUA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLoginURLAllowedUA, "");
        return attrs;
    }

    /**
     * logout URL for web client to send the user to upon explicit logging
     * out
     *
     * @return zimbraWebClientLogoutURL, or null if unset
     */
    @ZAttr(id=507)
    public String getWebClientLogoutURL() {
        return getAttr(Provisioning.A_zimbraWebClientLogoutURL, null, true);
    }

    /**
     * logout URL for web client to send the user to upon explicit logging
     * out
     *
     * @param zimbraWebClientLogoutURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=507)
    public void setWebClientLogoutURL(String zimbraWebClientLogoutURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURL, zimbraWebClientLogoutURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * logout URL for web client to send the user to upon explicit logging
     * out
     *
     * @param zimbraWebClientLogoutURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=507)
    public Map<String,Object> setWebClientLogoutURL(String zimbraWebClientLogoutURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURL, zimbraWebClientLogoutURL);
        return attrs;
    }

    /**
     * logout URL for web client to send the user to upon explicit logging
     * out
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=507)
    public void unsetWebClientLogoutURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * logout URL for web client to send the user to upon explicit logging
     * out
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=507)
    public Map<String,Object> unsetWebClientLogoutURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURL, "");
        return attrs;
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @return zimbraWebClientLogoutURLAllowedIP, or empty array if unset
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public String[] getWebClientLogoutURLAllowedIP() {
        return getMultiAttr(Provisioning.A_zimbraWebClientLogoutURLAllowedIP, true, true);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLogoutURLAllowedIP new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public void setWebClientLogoutURLAllowedIP(String[] zimbraWebClientLogoutURLAllowedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURLAllowedIP, zimbraWebClientLogoutURLAllowedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLogoutURLAllowedIP new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public Map<String,Object> setWebClientLogoutURLAllowedIP(String[] zimbraWebClientLogoutURLAllowedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURLAllowedIP, zimbraWebClientLogoutURLAllowedIP);
        return attrs;
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLogoutURLAllowedIP new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public void addWebClientLogoutURLAllowedIP(String zimbraWebClientLogoutURLAllowedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientLogoutURLAllowedIP, zimbraWebClientLogoutURLAllowedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLogoutURLAllowedIP new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public Map<String,Object> addWebClientLogoutURLAllowedIP(String zimbraWebClientLogoutURLAllowedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientLogoutURLAllowedIP, zimbraWebClientLogoutURLAllowedIP);
        return attrs;
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLogoutURLAllowedIP existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public void removeWebClientLogoutURLAllowedIP(String zimbraWebClientLogoutURLAllowedIP) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientLogoutURLAllowedIP, zimbraWebClientLogoutURLAllowedIP);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param zimbraWebClientLogoutURLAllowedIP existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public Map<String,Object> removeWebClientLogoutURLAllowedIP(String zimbraWebClientLogoutURLAllowedIP, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientLogoutURLAllowedIP, zimbraWebClientLogoutURLAllowedIP);
        return attrs;
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public void unsetWebClientLogoutURLAllowedIP() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURLAllowedIP, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex for allowed client IP addresses for honoring
     * zimbraWebClientLogoutURL. If not set, all IP addresses are allowed. If
     * multiple values are set, an IP address is allowed as long as it
     * matches any one of the values.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.5
     */
    @ZAttr(id=1353)
    public Map<String,Object> unsetWebClientLogoutURLAllowedIP(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURLAllowedIP, "");
        return attrs;
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @return zimbraWebClientLogoutURLAllowedUA, or empty array if unset
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public String[] getWebClientLogoutURLAllowedUA() {
        return getMultiAttr(Provisioning.A_zimbraWebClientLogoutURLAllowedUA, true, true);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLogoutURLAllowedUA new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public void setWebClientLogoutURLAllowedUA(String[] zimbraWebClientLogoutURLAllowedUA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURLAllowedUA, zimbraWebClientLogoutURLAllowedUA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLogoutURLAllowedUA new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public Map<String,Object> setWebClientLogoutURLAllowedUA(String[] zimbraWebClientLogoutURLAllowedUA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURLAllowedUA, zimbraWebClientLogoutURLAllowedUA);
        return attrs;
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLogoutURLAllowedUA new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public void addWebClientLogoutURLAllowedUA(String zimbraWebClientLogoutURLAllowedUA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientLogoutURLAllowedUA, zimbraWebClientLogoutURLAllowedUA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLogoutURLAllowedUA new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public Map<String,Object> addWebClientLogoutURLAllowedUA(String zimbraWebClientLogoutURLAllowedUA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientLogoutURLAllowedUA, zimbraWebClientLogoutURLAllowedUA);
        return attrs;
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLogoutURLAllowedUA existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public void removeWebClientLogoutURLAllowedUA(String zimbraWebClientLogoutURLAllowedUA) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientLogoutURLAllowedUA, zimbraWebClientLogoutURLAllowedUA);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param zimbraWebClientLogoutURLAllowedUA existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public Map<String,Object> removeWebClientLogoutURLAllowedUA(String zimbraWebClientLogoutURLAllowedUA, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientLogoutURLAllowedUA, zimbraWebClientLogoutURLAllowedUA);
        return attrs;
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public void unsetWebClientLogoutURLAllowedUA() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURLAllowedUA, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * regex to be matched for allowed user agents for honoring
     * zimbraWebClientLogoutURL. If not set, all UAs are allowed. If multiple
     * values are set, an UA is allowed as long as it matches any one of the
     * values. e.g. &quot;.*Windows NT.*Firefox/3.*&quot; will match firefox
     * 3 or later browsers on Windows. &quot;.*MSIE.*Windows NT.*&quot; will
     * match IE browsers on Windows.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.0.0
     */
    @ZAttr(id=1142)
    public Map<String,Object> unsetWebClientLogoutURLAllowedUA(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientLogoutURLAllowedUA, "");
        return attrs;
    }

    /**
     * max input buffer length for web client
     *
     * @return zimbraWebClientMaxInputBufferLength, or 1024 if unset
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1339)
    public int getWebClientMaxInputBufferLength() {
        return getIntAttr(Provisioning.A_zimbraWebClientMaxInputBufferLength, 1024, true);
    }

    /**
     * max input buffer length for web client
     *
     * @param zimbraWebClientMaxInputBufferLength new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1339)
    public void setWebClientMaxInputBufferLength(int zimbraWebClientMaxInputBufferLength) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientMaxInputBufferLength, Integer.toString(zimbraWebClientMaxInputBufferLength));
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max input buffer length for web client
     *
     * @param zimbraWebClientMaxInputBufferLength new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1339)
    public Map<String,Object> setWebClientMaxInputBufferLength(int zimbraWebClientMaxInputBufferLength, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientMaxInputBufferLength, Integer.toString(zimbraWebClientMaxInputBufferLength));
        return attrs;
    }

    /**
     * max input buffer length for web client
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1339)
    public void unsetWebClientMaxInputBufferLength() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientMaxInputBufferLength, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * max input buffer length for web client
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.0.0
     */
    @ZAttr(id=1339)
    public Map<String,Object> unsetWebClientMaxInputBufferLength(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientMaxInputBufferLength, "");
        return attrs;
    }

    /**
     * Whether the Stay Signed In checkbox should be disabled on the login
     * screen
     *
     * @return zimbraWebClientStaySignedInDisabled, or false if unset
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1687)
    public boolean isWebClientStaySignedInDisabled() {
        return getBooleanAttr(Provisioning.A_zimbraWebClientStaySignedInDisabled, false, true);
    }

    /**
     * Whether the Stay Signed In checkbox should be disabled on the login
     * screen
     *
     * @param zimbraWebClientStaySignedInDisabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1687)
    public void setWebClientStaySignedInDisabled(boolean zimbraWebClientStaySignedInDisabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientStaySignedInDisabled, zimbraWebClientStaySignedInDisabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the Stay Signed In checkbox should be disabled on the login
     * screen
     *
     * @param zimbraWebClientStaySignedInDisabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1687)
    public Map<String,Object> setWebClientStaySignedInDisabled(boolean zimbraWebClientStaySignedInDisabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientStaySignedInDisabled, zimbraWebClientStaySignedInDisabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether the Stay Signed In checkbox should be disabled on the login
     * screen
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1687)
    public void unsetWebClientStaySignedInDisabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientStaySignedInDisabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether the Stay Signed In checkbox should be disabled on the login
     * screen
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0
     */
    @ZAttr(id=1687)
    public Map<String,Object> unsetWebClientStaySignedInDisabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientStaySignedInDisabled, "");
        return attrs;
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @return zimbraWebClientSupportedHelps, or empty array if unset
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public String[] getWebClientSupportedHelps() {
        String[] value = getMultiAttr(Provisioning.A_zimbraWebClientSupportedHelps, true, true); return value.length > 0 ? value : new String[] {"productHelp","onlineHelp","newFeatures"};
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @param zimbraWebClientSupportedHelps new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public void setWebClientSupportedHelps(String[] zimbraWebClientSupportedHelps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientSupportedHelps, zimbraWebClientSupportedHelps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @param zimbraWebClientSupportedHelps new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public Map<String,Object> setWebClientSupportedHelps(String[] zimbraWebClientSupportedHelps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientSupportedHelps, zimbraWebClientSupportedHelps);
        return attrs;
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @param zimbraWebClientSupportedHelps new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public void addWebClientSupportedHelps(String zimbraWebClientSupportedHelps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientSupportedHelps, zimbraWebClientSupportedHelps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @param zimbraWebClientSupportedHelps new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public Map<String,Object> addWebClientSupportedHelps(String zimbraWebClientSupportedHelps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraWebClientSupportedHelps, zimbraWebClientSupportedHelps);
        return attrs;
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @param zimbraWebClientSupportedHelps existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public void removeWebClientSupportedHelps(String zimbraWebClientSupportedHelps) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientSupportedHelps, zimbraWebClientSupportedHelps);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @param zimbraWebClientSupportedHelps existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public Map<String,Object> removeWebClientSupportedHelps(String zimbraWebClientSupportedHelps, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraWebClientSupportedHelps, zimbraWebClientSupportedHelps);
        return attrs;
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public void unsetWebClientSupportedHelps() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientSupportedHelps, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Specify which help file&#039;s link should be displayed on the
     * pull-down menu in the Ajax Web client. The value is case-sensitive.
     * When &quot;productHelp&quot; is specified, &quot;Product Help&quot;
     * menu item will available and link to the default help files stored in
     * the same mail server (http://[service
     * URL]/help/[locale]/advanced/zimbra_user_help.htm) or URL specified in
     * skin or ZmMsg properties file (&quot;helpURI&quot;). When
     * &quot;onlineHelp&quot; is specified, &quot;Help Central Online&quot;
     * menu item will be available to link to http://help.zimbra.com/. When
     * &quot;newFeatures&quot; is specified, &quot;New Features&quot; menu
     * item will be available to link to
     * http://www.zimbra.com/products/whats_new.html.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.7.0,9.0.0
     */
    @ZAttr(id=2012)
    public Map<String,Object> unsetWebClientSupportedHelps(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientSupportedHelps, "");
        return attrs;
    }

    /**
     * weclient URL to directly connect when making service to JS calls from
     * mail server in split mode
     *
     * @return zimbraWebClientURL, or null if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public String getWebClientURL() {
        return getAttr(Provisioning.A_zimbraWebClientURL, null, true);
    }

    /**
     * weclient URL to directly connect when making service to JS calls from
     * mail server in split mode
     *
     * @param zimbraWebClientURL new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public void setWebClientURL(String zimbraWebClientURL) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientURL, zimbraWebClientURL);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * weclient URL to directly connect when making service to JS calls from
     * mail server in split mode
     *
     * @param zimbraWebClientURL new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public Map<String,Object> setWebClientURL(String zimbraWebClientURL, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientURL, zimbraWebClientURL);
        return attrs;
    }

    /**
     * weclient URL to directly connect when making service to JS calls from
     * mail server in split mode
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public void unsetWebClientURL() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientURL, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * weclient URL to directly connect when making service to JS calls from
     * mail server in split mode
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1445)
    public Map<String,Object> unsetWebClientURL(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebClientURL, "");
        return attrs;
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @return zimbraWebGzipEnabled, or true if unset
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public boolean isWebGzipEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraWebGzipEnabled, true, true);
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @param zimbraWebGzipEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public void setWebGzipEnabled(boolean zimbraWebGzipEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebGzipEnabled, zimbraWebGzipEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @param zimbraWebGzipEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public Map<String,Object> setWebGzipEnabled(boolean zimbraWebGzipEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebGzipEnabled, zimbraWebGzipEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public void unsetWebGzipEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebGzipEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether or not to gzip static web content. Defaults to true.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.2.5
     */
    @ZAttr(id=1468)
    public Map<String,Object> unsetWebGzipEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraWebGzipEnabled, "");
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra no longer includes an XMPP server.
     * Orig desc: Enable XMPP support for IM
     *
     * @return zimbraXMPPEnabled, or true if unset
     */
    @ZAttr(id=397)
    public boolean isXMPPEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraXMPPEnabled, true, true);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra no longer includes an XMPP server.
     * Orig desc: Enable XMPP support for IM
     *
     * @param zimbraXMPPEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=397)
    public void setXMPPEnabled(boolean zimbraXMPPEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPEnabled, zimbraXMPPEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra no longer includes an XMPP server.
     * Orig desc: Enable XMPP support for IM
     *
     * @param zimbraXMPPEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=397)
    public Map<String,Object> setXMPPEnabled(boolean zimbraXMPPEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPEnabled, zimbraXMPPEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Deprecated since: 8.7.0. Zimbra no longer includes an XMPP server.
     * Orig desc: Enable XMPP support for IM
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     */
    @ZAttr(id=397)
    public void unsetXMPPEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Deprecated since: 8.7.0. Zimbra no longer includes an XMPP server.
     * Orig desc: Enable XMPP support for IM
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     */
    @ZAttr(id=397)
    public Map<String,Object> unsetXMPPEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPEnabled, "");
        return attrs;
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @return zimbraXMPPServerDialbackKey, or empty array if unset
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public String[] getXMPPServerDialbackKey() {
        return getMultiAttr(Provisioning.A_zimbraXMPPServerDialbackKey, true, true);
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @param zimbraXMPPServerDialbackKey new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public void setXMPPServerDialbackKey(String[] zimbraXMPPServerDialbackKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPServerDialbackKey, zimbraXMPPServerDialbackKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @param zimbraXMPPServerDialbackKey new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public Map<String,Object> setXMPPServerDialbackKey(String[] zimbraXMPPServerDialbackKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPServerDialbackKey, zimbraXMPPServerDialbackKey);
        return attrs;
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @param zimbraXMPPServerDialbackKey new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public void addXMPPServerDialbackKey(String zimbraXMPPServerDialbackKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraXMPPServerDialbackKey, zimbraXMPPServerDialbackKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @param zimbraXMPPServerDialbackKey new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public Map<String,Object> addXMPPServerDialbackKey(String zimbraXMPPServerDialbackKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraXMPPServerDialbackKey, zimbraXMPPServerDialbackKey);
        return attrs;
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @param zimbraXMPPServerDialbackKey existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public void removeXMPPServerDialbackKey(String zimbraXMPPServerDialbackKey) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraXMPPServerDialbackKey, zimbraXMPPServerDialbackKey);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @param zimbraXMPPServerDialbackKey existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public Map<String,Object> removeXMPPServerDialbackKey(String zimbraXMPPServerDialbackKey, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraXMPPServerDialbackKey, zimbraXMPPServerDialbackKey);
        return attrs;
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public void unsetXMPPServerDialbackKey() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPServerDialbackKey, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Shared Secret for XMPP Server Dialback Protocol
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.9
     */
    @ZAttr(id=695)
    public Map<String,Object> unsetXMPPServerDialbackKey(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraXMPPServerDialbackKey, "");
        return attrs;
    }

    /**
     * whether zimlets that send sensitive data are disabled in
     * &quot;mixed&quot; zimbraMailMode
     *
     * @return zimbraZimletDataSensitiveInMixedModeDisabled, or true if unset
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1269)
    public boolean isZimletDataSensitiveInMixedModeDisabled() {
        return getBooleanAttr(Provisioning.A_zimbraZimletDataSensitiveInMixedModeDisabled, true, true);
    }

    /**
     * whether zimlets that send sensitive data are disabled in
     * &quot;mixed&quot; zimbraMailMode
     *
     * @param zimbraZimletDataSensitiveInMixedModeDisabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1269)
    public void setZimletDataSensitiveInMixedModeDisabled(boolean zimbraZimletDataSensitiveInMixedModeDisabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDataSensitiveInMixedModeDisabled, zimbraZimletDataSensitiveInMixedModeDisabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether zimlets that send sensitive data are disabled in
     * &quot;mixed&quot; zimbraMailMode
     *
     * @param zimbraZimletDataSensitiveInMixedModeDisabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1269)
    public Map<String,Object> setZimletDataSensitiveInMixedModeDisabled(boolean zimbraZimletDataSensitiveInMixedModeDisabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDataSensitiveInMixedModeDisabled, zimbraZimletDataSensitiveInMixedModeDisabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * whether zimlets that send sensitive data are disabled in
     * &quot;mixed&quot; zimbraMailMode
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1269)
    public void unsetZimletDataSensitiveInMixedModeDisabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDataSensitiveInMixedModeDisabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * whether zimlets that send sensitive data are disabled in
     * &quot;mixed&quot; zimbraMailMode
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 7.1.3
     */
    @ZAttr(id=1269)
    public Map<String,Object> unsetZimletDataSensitiveInMixedModeDisabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDataSensitiveInMixedModeDisabled, "");
        return attrs;
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @return zimbraZimletDomainAvailableZimlets, or empty array if unset
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public String[] getZimletDomainAvailableZimlets() {
        return getMultiAttr(Provisioning.A_zimbraZimletDomainAvailableZimlets, true, true);
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @param zimbraZimletDomainAvailableZimlets new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public void setZimletDomainAvailableZimlets(String[] zimbraZimletDomainAvailableZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDomainAvailableZimlets, zimbraZimletDomainAvailableZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @param zimbraZimletDomainAvailableZimlets new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public Map<String,Object> setZimletDomainAvailableZimlets(String[] zimbraZimletDomainAvailableZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDomainAvailableZimlets, zimbraZimletDomainAvailableZimlets);
        return attrs;
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @param zimbraZimletDomainAvailableZimlets new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public void addZimletDomainAvailableZimlets(String zimbraZimletDomainAvailableZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZimletDomainAvailableZimlets, zimbraZimletDomainAvailableZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @param zimbraZimletDomainAvailableZimlets new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public Map<String,Object> addZimletDomainAvailableZimlets(String zimbraZimletDomainAvailableZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZimletDomainAvailableZimlets, zimbraZimletDomainAvailableZimlets);
        return attrs;
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @param zimbraZimletDomainAvailableZimlets existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public void removeZimletDomainAvailableZimlets(String zimbraZimletDomainAvailableZimlets) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZimletDomainAvailableZimlets, zimbraZimletDomainAvailableZimlets);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @param zimbraZimletDomainAvailableZimlets existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public Map<String,Object> removeZimletDomainAvailableZimlets(String zimbraZimletDomainAvailableZimlets, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZimletDomainAvailableZimlets, zimbraZimletDomainAvailableZimlets);
        return attrs;
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public void unsetZimletDomainAvailableZimlets() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDomainAvailableZimlets, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * List of Zimlets available to this domain. Zimlets available to
     * accounts in the domain is the union of account/cos attribute
     * zimbraZimletAvailableZimlets and this attribute. See
     * zimbraZimletAvailableZimlets for value format.
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 5.0.10
     */
    @ZAttr(id=710)
    public Map<String,Object> unsetZimletDomainAvailableZimlets(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletDomainAvailableZimlets, "");
        return attrs;
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @return zimbraZimletJspEnabled, or false if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public boolean isZimletJspEnabled() {
        return getBooleanAttr(Provisioning.A_zimbraZimletJspEnabled, false, true);
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @param zimbraZimletJspEnabled new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public void setZimletJspEnabled(boolean zimbraZimletJspEnabled) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletJspEnabled, zimbraZimletJspEnabled ? TRUE : FALSE);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @param zimbraZimletJspEnabled new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public Map<String,Object> setZimletJspEnabled(boolean zimbraZimletJspEnabled, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletJspEnabled, zimbraZimletJspEnabled ? TRUE : FALSE);
        return attrs;
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public void unsetZimletJspEnabled() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletJspEnabled, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * Whether to enable JSP compilation for Zimlets (i.e. for /zimlet
     * webapp)
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1575)
    public Map<String,Object> unsetZimletJspEnabled(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZimletJspEnabled, "");
        return attrs;
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @return zimbraZookeeperClientServerList, or empty array if unset
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public String[] getZookeeperClientServerList() {
        return getMultiAttr(Provisioning.A_zimbraZookeeperClientServerList, true, true);
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @param zimbraZookeeperClientServerList new value
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public void setZookeeperClientServerList(String[] zimbraZookeeperClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @param zimbraZookeeperClientServerList new value
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public Map<String,Object> setZookeeperClientServerList(String[] zimbraZookeeperClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        return attrs;
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @param zimbraZookeeperClientServerList new to add to existing values
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public void addZookeeperClientServerList(String zimbraZookeeperClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @param zimbraZookeeperClientServerList new to add to existing values
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public Map<String,Object> addZookeeperClientServerList(String zimbraZookeeperClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "+" + Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        return attrs;
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @param zimbraZookeeperClientServerList existing value to remove
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public void removeZookeeperClientServerList(String zimbraZookeeperClientServerList) throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @param zimbraZookeeperClientServerList existing value to remove
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public Map<String,Object> removeZookeeperClientServerList(String zimbraZookeeperClientServerList, Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        StringUtil.addToMultiMap(attrs, "-" + Provisioning.A_zimbraZookeeperClientServerList, zimbraZookeeperClientServerList);
        return attrs;
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @throws com.zimbra.common.service.ServiceException if error during update
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public void unsetZookeeperClientServerList() throws com.zimbra.common.service.ServiceException {
        HashMap<String,Object> attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZookeeperClientServerList, "");
        getProvisioning().modifyAttrs(this, attrs);
    }

    /**
     * list of host:port for zookeeper servers; set to empty value to disable
     * the use of zookeeper
     *
     * @param attrs existing map to populate, or null to create a new map
     * @return populated map to pass into Provisioning.modifyAttrs
     *
     * @since ZCS 8.5.0
     */
    @ZAttr(id=1447)
    public Map<String,Object> unsetZookeeperClientServerList(Map<String,Object> attrs) {
        if (attrs == null) attrs = new HashMap<String,Object>();
        attrs.put(Provisioning.A_zimbraZookeeperClientServerList, "");
        return attrs;
    }

    ///// END-AUTO-GEN-REPLACE

}
